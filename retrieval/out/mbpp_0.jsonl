{"task_id": "mbpp_11", "code": "def remove_Occ(s,ch): \r\n    for i in range(len(s)): \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    for i in range(len(s) - 1,-1,-1):  \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    return s ", "test_list": ["assert remove_Occ(\"hello\",\"l\") == \"heo\"", "assert remove_Occ(\"abcda\",\"a\") == \"bcd\"", "assert remove_Occ(\"PHP\",\"P\") == \"H\""], "context": "Write a python function to remove first and last occurrence of a given character from the string.", "function_name": "def remove_Occ(s,ch):", "gold_generation": "for i in range(len(s)): \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    for i in range(len(s) - 1,-1,-1):  \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    return s", "ctxs": [{"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.7248153"}, {"id": "24398", "text": "Function: python.library.string\nSnippet: characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", "score": "0.70066774"}, {"id": "41747", "text": "Function: numpy.reference.generated.numpy.char.replace\nSnippet: numpy.char.replace char.replace(a, old, new, count=None)[source] For each element in a, return a copy of the string with all occurrences of substring old replaced by new. Calls str.replace element-wise. Parameters aarray-like of str or unicode old, newstr or unicode countint, optional If the optional argument count is given, only the first count occurrences are replaced. Returns outndarray Output array of str or unicode, depending on input type See also str.replace", "score": "0.6954029"}, {"id": "24376", "text": "Function: python.library.stdtypes#str.rstrip\nSnippet: str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty'", "score": "0.6951784"}, {"id": "25746", "text": "Function: python.library.stdtypes\nSnippet: Return -1 on failure. str.rindex(sub[, start[, end]]) Like rfind() but raises ValueError when the substring sub is not found. str.rjust(width[, fillchar]) Return the string right justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.rpartition(sep) Split the string at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself. str.rsplit(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any whitespace string is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below. str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty' str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3'] str.splitlines([keepends]) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. This", "score": "0.6904047"}]}
{"task_id": "mbpp_12", "code": "def sort_matrix(M):\r\n    result = sorted(M, key=sum)\r\n    return result", "test_list": ["assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]", "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]", "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"], "context": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "function_name": "def sort_matrix(M):", "gold_generation": "result = sorted(M, key=sum)\r\n    return result", "ctxs": [{"id": "42377", "text": "Function: numpy.reference.generated.numpy.matrix.argsort\nSnippet: numpy.matrix.argsort method matrix.argsort(axis=- 1, kind=None, order=None) Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.7097007"}, {"id": "42427", "text": "Function: numpy.reference.generated.numpy.matrix.sort\nSnippet: numpy.matrix.sort method matrix.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.6951961"}, {"id": "42938", "text": "Function: numpy.reference.generated.numpy.lexsort\nSnippet: numpy.lexsort numpy.lexsort(keys, axis=- 1) Perform an indirect stable sort using a sequence of keys. Given multiple sorting keys, which can be interpreted as columns in a spreadsheet, lexsort returns an array of integer indices that describes the sort order by multiple columns. The last key in the sequence is used for the primary sort order, the second-to-last key for the secondary sort order, and so on. The keys argument must be a sequence of objects that can be converted to arrays of the same shape. If a 2D array is provided for the keys argument, its rows are interpreted as the sorting keys and sorting is according to the last row, second last row etc. Parameters keys(k, N) array or tuple containing k (N,)-shaped sequences The k different “columns” to be sorted. The last column (or row if keys is a 2D array) is the primary sort key. axisint, optional Axis to be indirectly sorted. By default, sort over the last axis. Returns indices(N,) ndarray of ints Array of indices that sort the keys along the specified axis. See also argsort Indirect sort. ndarray.sort In-place sort. sort Return a sorted copy of an array. Examples Sort names: first by surname, then by name. >>> surnames = ('Hertz', 'Galilei', 'Hertz') >>> first_names = ('Heinrich', 'Galileo', 'Gustav') >>> ind = np.lexsort((first_names, surnames)) >>> ind array([1, 2, 0]) >>> [surnames[i] + \", \" + first_names[i] for i in ind] ['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich'] Sort two columns of numbers: >>> a = [1,5,1,4,3,4,4] # First column >>> b = [9,4,0,4,0,2,1] # Second column >>> ind = np.lexsort((b,a)) # Sort by a, then by b >>> ind array([2, 0, 4, 6, 5, 3, 1]) >>> [(a[i],b[i]) for i in ind] [(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)] Note that sorting is first according to the elements of a. Secondary sorting is according to the elements of b. A normal argsort would have yielded: >>> [(a[i],b[i]) for i in np.argsort(a)] [(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)] Structured arrays are sorted lexically by argsort: >>> x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)], ... dtype=np.dtype([('x', int), ('y', int)])) >>> np.argsort(x) # or np.argsort(x, order=('x', 'y')) array([2, 0, 4, 6, 5, 3, 1])", "score": "0.6756567"}, {"id": "42341", "text": "Function: numpy.reference.generated.numpy.ma.sort\nSnippet: numpy.ma.sort ma.sort(a, axis=- 1, kind=None, order=None, endwith=True, fill_value=None)[source] Return a sorted copy of the masked array. Equivalent to creating a copy of the array and applying the MaskedArray sort() method. Refer to MaskedArray.sort for the full documentation See also MaskedArray.sort equivalent method", "score": "0.67469895"}, {"id": "42414", "text": "Function: numpy.reference.generated.numpy.matrix.partition\nSnippet: numpy.matrix.partition method matrix.partition(kth, axis=- 1, kind='introselect', order=None) Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array. All elements smaller than the kth element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined. New in version 1.8.0. Parameters kthint or sequence of ints Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. Deprecated since version 1.22.0: Passing booleans as index is deprecated. axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘introselect’}, optional Selection algorithm. Default is ‘introselect’. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.partition Return a parititioned copy of an array. argpartition Indirect partition. sort Full sort. Notes See np.partition for notes on the different algorithms. Examples >>> a = np.array([3, 4, 2, 1]) >>> a.partition(3) >>> a array([2, 1, 3, 4]) >>> a.partition((1, 3)) >>> a array([1, 2, 3, 4])", "score": "0.6690877"}]}
{"task_id": "mbpp_13", "code": "from collections import Counter\r\ndef count_common(words):\r\n  word_counts = Counter(words)\r\n  top_four = word_counts.most_common(4)\r\n  return (top_four)\r\n", "test_list": ["assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]", "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]", "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"], "context": "Write a function to count the most common words in a dictionary.", "function_name": "from collections import Counter\r\ndef count_common(words):", "gold_generation": "word_counts = Counter(words)\r\n  top_four = word_counts.most_common(4)\r\n  return (top_four)", "ctxs": [{"id": "18610", "text": "Function: python.library.collections\nSnippet: 'black'}, {'elephant': 'blue'}, {'lion': 'yellow'}) >>> d['lion'] = 'orange' # update an existing key two levels down >>> d['snake'] = 'red' # new keys get added to the topmost dict >>> del d['elephant'] # remove an existing key one level down >>> d # display result DeepChainMap({'zebra': 'black', 'snake': 'red'}, {}, {'lion': 'orange'}) Counter objects A counter tool is provided to support convenient and rapid tallies. For example: >>> # Tally occurrences of words in a list >>> cnt = Counter() >>> for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']: ... cnt[word] += 1 >>> cnt Counter({'blue': 3, 'red': 2, 'green': 1}) >>> # Find the ten most common words in Hamlet >>> import re >>> words = re.findall(r'\\w+', open('hamlet.txt').read().lower()) >>> Counter(words).most_common(10) [('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631), ('you', 554), ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)] class collections.Counter([iterable-or-mapping]) A Counter is a dict subclass for counting hashable objects. It is a collection where elements are stored as dictionary keys and their counts are stored as dictionary values. Counts are allowed to be any integer value including zero or negative counts. The Counter class is similar to bags or multisets in other languages. Elements are counted from an iterable or initialized from another mapping (or counter): >>> c = Counter() # a new, empty counter >>> c = Counter('gallahad') # a new counter from an iterable >>> c = Counter({'red': 4, 'blue': 2}) # a new counter from a mapping >>> c = Counter(cats=4, dogs=8) # a new counter from keyword args Counter objects have a dictionary interface except that they return a zero count for missing items instead of raising a KeyError: >>> c = Counter(['eggs', 'ham']) >>> c['bacon'] # count of a missing element is zero 0 Setting a count to zero does not remove an element from a counter. Use del to remove it entirely: >>> c['sausage'] = 0 # counter entry with a zero count >>> del c['sausage'] # del actually removes the entry New in version 3.1. Changed in version 3.7: As a dict subclass, Counter Inherited the capability to remember insertion order. Math operations on Counter objects also preserve order. Results are ordered according to when an element is first encountered in the left operand and then by the order encountered in the right operand. Counter objects support three methods beyond those available for all dictionaries: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b'] most_common([n]) Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered in the order first encountered: >>> Counter('abracadabra').most_common(3) [('a', 5), ('b', 2), ('r', 2)] subtract([iterable-or-mapping])", "score": "0.73042774"}, {"id": "18655", "text": "Function: python.library.collections#collections.Counter.most_common\nSnippet: most_common([n]) Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered in the order first encountered: >>> Counter('abracadabra').most_common(3) [('a', 5), ('b', 2), ('r', 2)]", "score": "0.71360576"}, {"id": "18615", "text": "Function: python.library.collections\nSnippet: 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)] >>> d = defaultdict(list) >>> for k, v in s: ... d[k].append(v) ... >>> sorted(d.items()) [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])] When each key is encountered for the first time, it is not already in the mapping; so an entry is automatically created using the default_factory function which returns an empty list. The list.append() operation then attaches the value to the new list. When keys are encountered again, the look-up proceeds normally (returning the list for that key) and the list.append() operation adds another value to the list. This technique is simpler and faster than an equivalent technique using dict.setdefault(): >>> d = {} >>> for k, v in s: ... d.setdefault(k, []).append(v) ... >>> sorted(d.items()) [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])] Setting the default_factory to int makes the defaultdict useful for counting (like a bag or multiset in other languages): >>> s = 'mississippi' >>> d = defaultdict(int) >>> for k in s: ... d[k] += 1 ... >>> sorted(d.items()) [('i', 4), ('m', 1), ('p', 2), ('s', 4)] When a letter is first encountered, it is missing from the mapping, so the default_factory function calls int() to supply a default count of zero. The increment operation then builds up the count for each letter. The function int() which always returns zero is just a special case of constant functions. A faster and more flexible way to create constant functions is to use a lambda function which can supply any constant value (not just zero): >>> def constant_factory(value): ... return lambda: value >>> d = defaultdict(constant_factory('<missing>')) >>> d.update(name='John', action='ran') >>> '%(name)s %(action)s to %(object)s' % d 'John ran to <missing>' Setting the default_factory to set makes the defaultdict useful for building a dictionary of sets: >>> s = [('red', 1), ('blue', 2), ('red', 3), ('blue', 4), ('red', 1), ('blue', 4)] >>> d = defaultdict(set) >>> for k, v in s: ... d[k].add(v) ... >>> sorted(d.items()) [('blue', {2, 4}), ('red', {1, 3})] namedtuple() Factory Function for Tuples with Named Fields Named tuples assign meaning to each position in a tuple and allow for more readable, self-documenting code. They can be used wherever regular tuples are used, and they add the ability to access fields by name instead of position index. collections.namedtuple(typename, field_names, *, rename=False, defaults=None, module=None) Returns a new tuple subclass named typename. The new subclass is used to create tuple-like objects that have fields accessible by attribute lookup as well as being indexable and iterable. Instances of the subclass also have a helpful docstring (with typename and field_names) and a helpful __repr__() method which lists the tuple contents in a name=value format. The field_names are a sequence of strings such as ['x', 'y']. Alternatively, field_names can be a single string with each fieldname separated by whitespace and/or commas, for example 'x y' or 'x, y'. Any valid Python identifier may be used for a fieldname except for names starting with an underscore. Valid identifiers consist of letters,", "score": "0.68006104"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.6716431"}, {"id": "19634", "text": "Function: python.library.difflib#difflib.get_close_matches\nSnippet: difflib.get_close_matches(word, possibilities, n=3, cutoff=0.6) Return a list of the best “good enough” matches. word is a sequence for which close matches are desired (typically a string), and possibilities is a list of sequences against which to match word (typically a list of strings). Optional argument n (default 3) is the maximum number of close matches to return; n must be greater than 0. Optional argument cutoff (default 0.6) is a float in the range [0, 1]. Possibilities that don’t score at least that similar to word are ignored. The best (no more than n) matches among the possibilities are returned in a list, sorted by similarity score, most similar first. >>> get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy']) ['apple', 'ape'] >>> import keyword >>> get_close_matches('wheel', keyword.kwlist) ['while'] >>> get_close_matches('pineapple', keyword.kwlist) [] >>> get_close_matches('accept', keyword.kwlist) ['except']", "score": "0.66835684"}]}
{"task_id": "mbpp_14", "code": "def find_Volume(l,b,h) : \r\n    return ((l * b * h) / 2) ", "test_list": ["assert find_Volume(10,8,6) == 240", "assert find_Volume(3,2,2) == 6", "assert find_Volume(1,2,1) == 1"], "context": "Write a python function to find the volume of a triangular prism.", "function_name": "def find_Volume(l,b,h) :", "gold_generation": "return ((l * b * h) / 2)", "ctxs": [{"id": "33496", "text": "Function: matplotlib._as_gen.matplotlib.quiver.quiver\nSnippet: generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y direction components of the arrow vectors.\\n\\n They must have the same number of elements, matching the number of arrow\\n locations. *U* and *V* may be masked. Only locations unmasked in\\n *U*, *V*, and *C* will be drawn.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the arrow colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *color* instead. The size of *C* must match the number of arrow\\n locations.\\n\\nunits : {'width', 'height', 'dots', 'inches', 'x', 'y', 'xy'}, default: 'width'\\n The arrow dimensions (except for *length*) are measured in multiples of\\n this unit.\\n\\n The following values are supported:\\n\\n - 'width', 'height': The width or height of the axis.\\n - 'dots', 'inches': Pixels or inches based on the figure dpi.\\n - 'x', 'y', 'xy': *X*, *Y* or :math:`\\\\sqrt{X^2 + Y^2}` in data units.\\n\\n The arrows scale differently depending on the units. For\\n 'x' or 'y', the arrows get larger as one zooms in; for other\\n units, the arrow size is independent of the zoom state. For\\n 'width or 'height', the arrow size increases with the width and\\n height of the axes, respectively, when the window is resized;\\n for 'dots' or 'inches', resizing does not change the arrows.\\n\\nangles : {'uv', 'xy'} or array-like, default: 'uv'\\n Method for determining the angle of the arrows.\\n\\n - 'uv': The arrow axis aspect ratio is 1 so that\\n if *U* == *V* the orientation of the arrow on the plot is 45 degrees\\n counter-clockwise from the horizontal axis (positive to the right).\\n\\n Use this if the arrows symbolize a quantity that is not based on\\n *X*, *Y* data coordinates.\\n\\n - 'xy': Arrows point from (x, y) to (x+u, y+v).\\n Use this for plotting a gradient field, for example.\\n\\n - Alternatively, arbitrary angles may be specified explicitly as an array\\n of values in degrees, counter-clockwise from the horizontal axis.\\n\\n In this case *U*, *V* is only used to determine the length of the\\n arrows.\\n\\n Note: inverting a data axis will correspondingly invert the\\n arrows only with ``angles='xy'``.\\n\\nscale : float, optional\\n Number of data units per arrow length unit, e.g., m/s per plot width; a\\n smaller scale parameter makes the arrow longer. Default is *None*.\\n\\n If *None*, a simple autoscaling algorithm is used, based on the average\\n vector length and the number of vectors. The arrow length unit is given by\\n the *scale_units* parameter.\\n\\nscale_units : {'width', 'height', 'dots', 'inches', 'x', 'y', 'xy'}, optional\\n If the *scale* kwarg is *None*, the arrow length unit. Default is *None*.\\n\\n e.g. *scale_units* is 'inches', *scale* is 2.0, and ``(u, v) = (1, 0)``,\\n then the", "score": "0.68782544"}, {"id": "33502", "text": "Function: matplotlib._as_gen.matplotlib.quiver.quiver#matplotlib.quiver.Quiver.quiver_doc\nSnippet: symbolize a quantity that is not based on\\n *X*, *Y* data coordinates.\\n\\n - 'xy': Arrows point from (x, y) to (x+u, y+v).\\n Use this for plotting a gradient field, for example.\\n\\n - Alternatively, arbitrary angles may be specified explicitly as an array\\n of values in degrees, counter-clockwise from the horizontal axis.\\n\\n In this case *U*, *V* is only used to determine the length of the\\n arrows.\\n\\n Note: inverting a data axis will correspondingly invert the\\n arrows only with ``angles='xy'``.\\n\\nscale : float, optional\\n Number of data units per arrow length unit, e.g., m/s per plot width; a\\n smaller scale parameter makes the arrow longer. Default is *None*.\\n\\n If *None*, a simple autoscaling algorithm is used, based on the average\\n vector length and the number of vectors. The arrow length unit is given by\\n the *scale_units* parameter.\\n\\nscale_units : {'width', 'height', 'dots', 'inches', 'x', 'y', 'xy'}, optional\\n If the *scale* kwarg is *None*, the arrow length unit. Default is *None*.\\n\\n e.g. *scale_units* is 'inches', *scale* is 2.0, and ``(u, v) = (1, 0)``,\\n then the vector will be 0.5 inches long.\\n\\n If *scale_units* is 'width' or 'height', then the vector will be half the\\n width/height of the axes.\\n\\n If *scale_units* is 'x' then the vector will be 0.5 x-axis\\n units. To plot vectors in the x-y plane, with u and v having\\n the same units as x and y, use\\n ``angles='xy', scale_units='xy', scale=1``.\\n\\nwidth : float, optional\\n Shaft width in arrow units; default depends on choice of units,\\n above, and number of vectors; a typical starting value is about\\n 0.005 times the width of the plot.\\n\\nheadwidth : float, default: 3\\n Head width as multiple of shaft width.\\n\\nheadlength : float, default: 5\\n Head length as multiple of shaft width.\\n\\nheadaxislength : float, default: 4.5\\n Head length at shaft intersection.\\n\\nminshaft : float, default: 1\\n Length below which arrow scales, in units of head length. Do not\\n set this to less than 1, or small arrows will look terrible!\\n\\nminlength : float, default: 1\\n Minimum length as a multiple of shaft width; if an arrow length\\n is less than this, plot a dot (hexagon) of this diameter instead.\\n\\npivot : {'tail', 'mid', 'middle', 'tip'}, default: 'tail'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The arrow\\n rotates about this point.\\n\\n 'mid' is a synonym for 'middle'.\\n\\ncolor : color or color sequence, optional\\n Explicit color(s) for the arrows. If *C* has been set, *color* has no\\n effect.\\n\\n This is a synonym for the `.PolyCollection` *facecolor* parameter.\\n\\nOther Parameters\\n----------------\\ndata : indexable object, optional\\n DATA_PARAMETER_PLACEHOLDER\\n\\n**kwargs : `~matplotlib.collections.PolyCollection` properties, optional\\n All other keyword arguments are passed on to `.PolyCollection`:\\n\\n \\n .. table::\\n :class: property-table\\n\\n ================================================================================================= =====================================================================================================\\n Property Description \\n ================================================================================================= =====================================================================================================\\n :meth:`agg_filter <matplotlib.artist.Artist.set_agg_filter>` a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array\\n :meth:`alpha <matplotlib.collections.Collection.set_alpha>` array-like or scalar or None \\n :meth:`animated <matplotlib.artist.Artist.set_animated>` bool \\n :meth:`antialiased <matplotlib.collections.Collection.set_antialiased>` or aa or antialiaseds bool or list of bools \\n :meth:`array <matplotlib.cm.ScalarMappable.set_array>` array-like or None \\n :meth:`capstyle <matplotlib.collections.Collection.set_capstyle>` `.CapStyle` or {'butt',", "score": "0.68700707"}, {"id": "34305", "text": "Function: matplotlib.tri_api\nSnippet: matplotlib.tri Unstructured triangular grid functions. classmatplotlib.tri.Triangulation(x, y, triangles=None, mask=None)[source] An unstructured triangular grid consisting of npoints points and ntri triangles. The triangles can either be specified by the user or automatically generated using a Delaunay triangulation. Parameters x, y(npoints,) array-like Coordinates of grid points. triangles(ntri, 3) array-like of int, optional For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If not specified, the Delaunay triangulation is calculated. mask(ntri,) array-like of bool, optional Which triangles are masked out. Notes For a Triangulation to be valid it must not have duplicate points, triangles formed from colinear points, or overlapping triangles. Attributes triangles(ntri, 3) array of int For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If you want to take the mask into account, use get_masked_triangles instead. mask(ntri, 3) array of bool Masked out triangles. is_delaunaybool Whether the Triangulation is a calculated Delaunay triangulation (where triangles was not specified) or not. calculate_plane_coefficients(z)[source] Calculate plane equation coefficients for all unmasked triangles from the point (x, y) coordinates and specified z-array of shape (npoints). The returned array has shape (npoints, 3) and allows z-value at (x, y) position in triangle tri to be calculated using z = array[tri, 0] * x + array[tri, 1] * y + array[tri, 2]. propertyedges Return integer array of shape (nedges, 2) containing all edges of non-masked triangles. Each row defines an edge by it's start point index and end point index. Each edge appears only once, i.e. for an edge between points i and j, there will only be either (i, j) or (j, i). get_cpp_triangulation()[source] Return the underlying C++ Triangulation object, creating it if necessary. staticget_from_args_and_kwargs(*args, **kwargs)[source] Return a Triangulation object from the args and kwargs, and the remaining args and kwargs with the consumed values removed. There are two alternatives: either the first argument is a Triangulation object, in which case it is returned, or the args and kwargs are sufficient to create a new Triangulation to return. In the latter case, see Triangulation.__init__ for the possible args and kwargs. get_masked_triangles()[source] Return an array of triangles that are not masked. get_trifinder()[source] Return the default matplotlib.tri.TriFinder of this triangulation, creating it if necessary. This allows the same TriFinder object to be easily shared. propertyneighbors Return integer array of shape (ntri, 3) containing neighbor triangles. For each triangle, the indices of the three triangles that share the same edges, or -1 if there is no such neighboring triangle. neighbors[i, j] is the triangle that is the neighbor to the edge from point index triangles[i, j] to point index triangles[i, (j+1)%3]. set_mask(mask)[source] Set or clear the mask array. Parameters maskNone or bool array of length ntri classmatplotlib.tri.TriContourSet(ax, *args, **kwargs)[source] Bases: matplotlib.contour.ContourSet Create and store a set of contour lines or filled regions for a triangular grid. This class is typically not instantiated directly by the user but by tricontour and tricontourf. Attributes axAxes The Axes object in which the", "score": "0.6838472"}, {"id": "8193", "text": "Function: torch.generated.torch.triangular_solve#torch.triangular_solve\nSnippet: torch.triangular_solve(input, A, upper=True, transpose=False, unitriangular=False) -> (Tensor, Tensor) Solves a system of equations with a triangular coefficient matrix AA and multiple right-hand sides bb . In particular, solves AX=bAX = b and assumes AA is upper-triangular with the default keyword arguments. torch.triangular_solve(b, A) can take in 2D inputs b, A or inputs that are batches of 2D matrices. If the inputs are batches, then returns batched outputs X Supports real-valued and complex-valued inputs. Parameters input (Tensor) – multiple right-hand sides of size (∗,m,k)(*, m, k) where ∗* is zero of more batch dimensions (bb ) A (Tensor) – the input triangular coefficient matrix of size (∗,m,m)(*, m, m) where ∗* is zero or more batch dimensions upper (bool, optional) – whether to solve the upper-triangular system of equations (default) or the lower-triangular system of equations. Default: True. transpose (bool, optional) – whether AA should be transposed before being sent into the solver. Default: False. unitriangular (bool, optional) – whether AA is unit triangular. If True, the diagonal elements of AA are assumed to be 1 and not referenced from AA . Default: False. Returns A namedtuple (solution, cloned_coefficient) where cloned_coefficient is a clone of AA and solution is the solution XX to AX=bAX = b (or whatever variant of the system of equations, depending on the keyword arguments.) Examples: >>> A = torch.randn(2, 2).triu() >>> A tensor([[ 1.1527, -1.0753], [ 0.0000, 0.7986]]) >>> b = torch.randn(2, 3) >>> b tensor([[-0.0210, 2.3513, -1.5492], [ 1.5429, 0.7403, -1.0243]]) >>> torch.triangular_solve(b, A) torch.return_types.triangular_solve( solution=tensor([[ 1.7841, 2.9046, -2.5405], [ 1.9320, 0.9270, -1.2826]]), cloned_coefficient=tensor([[ 1.1527, -1.0753], [ 0.0000, 0.7986]]))", "score": "0.6830932"}, {"id": "34316", "text": "Function: matplotlib.tri_api#matplotlib.tri.TriAnalyzer\nSnippet: classmatplotlib.tri.TriAnalyzer(triangulation)[source] Define basic tools for triangular mesh analysis and improvement. A TriAnalyzer encapsulates a Triangulation object and provides basic tools for mesh analysis and mesh improvement. Parameters triangulationTriangulation The encapsulated triangulation to analyze. Attributes scale_factors Factors to rescale the triangulation into a unit square. circle_ratios(rescale=True)[source] Return a measure of the triangulation triangles flatness. The ratio of the incircle radius over the circumcircle radius is a widely used indicator of a triangle flatness. It is always <= 0.5 and == 0.5 only for equilateral triangles. Circle ratios below 0.01 denote very flat triangles. To avoid unduly low values due to a difference of scale between the 2 axis, the triangular mesh can first be rescaled to fit inside a unit square with scale_factors (Only if rescale is True, which is its default value). Parameters rescalebool, default: True If True, internally rescale (based on scale_factors), so that the (unmasked) triangles fit exactly inside a unit square mesh. Returns masked array Ratio of the incircle radius over the circumcircle radius, for each 'rescaled' triangle of the encapsulated triangulation. Values corresponding to masked triangles are masked out. get_flat_tri_mask(min_circle_ratio=0.01, rescale=True)[source] Eliminate excessively flat border triangles from the triangulation. Returns a mask new_mask which allows to clean the encapsulated triangulation from its border-located flat triangles (according to their circle_ratios()). This mask is meant to be subsequently applied to the triangulation using Triangulation.set_mask. new_mask is an extension of the initial triangulation mask in the sense that an initially masked triangle will remain masked. The new_mask array is computed recursively; at each step flat triangles are removed only if they share a side with the current mesh border. Thus no new holes in the triangulated domain will be created. Parameters min_circle_ratiofloat, default: 0.01 Border triangles with incircle/circumcircle radii ratio r/R will be removed if r/R < min_circle_ratio. rescalebool, default: True If True, first, internally rescale (based on scale_factors) so that the (unmasked) triangles fit exactly inside a unit square mesh. This rescaling accounts for the difference of scale which might exist between the 2 axis. Returns array of bool Mask to apply to encapsulated triangulation. All the initially masked triangles remain masked in the new_mask. Notes The rationale behind this function is that a Delaunay triangulation - of an unstructured set of points - sometimes contains almost flat triangles at its border, leading to artifacts in plots (especially for high-resolution contouring). Masked with computed new_mask, the encapsulated triangulation would contain no more unmasked border triangles with a circle ratio below min_circle_ratio, thus improving the mesh quality for subsequent plots or interpolation. propertyscale_factors Factors to rescale the triangulation into a unit square. Returns (float, float) Scaling factors (kx, ky) so that the triangulation [triangulation.x * kx, triangulation.y * ky] fits exactly inside a unit square.", "score": "0.6824151"}]}
{"task_id": "mbpp_15", "code": "import re\r\ndef split_lowerstring(text):\r\n return (re.findall('[a-z][^a-z]*', text))", "test_list": ["assert split_lowerstring(\"AbCd\")==['bC','d']", "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']", "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"], "context": "Write a function to split a string at lowercase letters.", "function_name": "import re\r\ndef split_lowerstring(text):", "gold_generation": "return (re.findall('[a-z][^a-z]*', text))", "ctxs": [{"id": "24400", "text": "Function: python.library.string#string.ascii_lowercase\nSnippet: string.ascii_lowercase The lowercase letters 'abcdefghijklmnopqrstuvwxyz'. This value is not locale-dependent and will not change.", "score": "0.73114634"}, {"id": "24364", "text": "Function: python.library.stdtypes#str.lower\nSnippet: str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard.", "score": "0.70779216"}, {"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.7061664"}, {"id": "16533", "text": "Function: pandas.reference.series\nSnippet: of strings in the Series/Index. Series.str.rpartition([sep, expand]) Split the string at the last occurrence of sep. Series.str.rstrip([to_strip]) Remove trailing characters. Series.str.slice([start, stop, step]) Slice substrings from each element in the Series or Index. Series.str.slice_replace([start, stop, repl]) Replace a positional slice of a string with another value. Series.str.split([pat, n, expand, regex]) Split strings around given separator/delimiter. Series.str.rsplit([pat, n, expand]) Split strings around given separator/delimiter. Series.str.startswith(pat[, na]) Test if the start of each string element matches a pattern. Series.str.strip([to_strip]) Remove leading and trailing characters. Series.str.swapcase() Convert strings in the Series/Index to be swapcased. Series.str.title() Convert strings in the Series/Index to titlecase. Series.str.translate(table) Map all characters in the string through the given mapping table. Series.str.upper() Convert strings in the Series/Index to uppercase. Series.str.wrap(width, **kwargs) Wrap strings in Series/Index at specified line width. Series.str.zfill(width) Pad strings in the Series/Index by prepending '0' characters. Series.str.isalnum() Check whether all characters in each string are alphanumeric. Series.str.isalpha() Check whether all characters in each string are alphabetic. Series.str.isdigit() Check whether all characters in each string are digits. Series.str.isspace() Check whether all characters in each string are whitespace. Series.str.islower() Check whether all characters in each string are lowercase. Series.str.isupper() Check whether all characters in each string are uppercase. Series.str.istitle() Check whether all characters in each string are titlecase. Series.str.isnumeric() Check whether all characters in each string are numeric. Series.str.isdecimal() Check whether all characters in each string are decimal. Series.str.get_dummies([sep]) Return DataFrame of dummy/indicator variables for Series. Categorical accessor Categorical-dtype specific methods and attributes are available under the Series.cat accessor. Series.cat.categories The categories of this categorical. Series.cat.ordered Whether the categories have an ordered relationship. Series.cat.codes Return Series of codes as well as the index. Series.cat.rename_categories(*args, **kwargs) Rename categories. Series.cat.reorder_categories(*args, **kwargs) Reorder categories as specified in new_categories. Series.cat.add_categories(*args, **kwargs) Add new categories. Series.cat.remove_categories(*args, **kwargs) Remove the specified categories. Series.cat.remove_unused_categories(*args, ...) Remove categories which are not used. Series.cat.set_categories(*args, **kwargs) Set the categories to the specified new_categories. Series.cat.as_ordered(*args, **kwargs) Set the Categorical to be ordered. Series.cat.as_unordered(*args, **kwargs) Set the Categorical to be unordered. Sparse accessor Sparse-dtype specific methods and attributes are provided under the Series.sparse accessor. Series.sparse.npoints The number of non- fill_value points. Series.sparse.density The percent of non- fill_value points, as decimal. Series.sparse.fill_value Elements in data that are fill_value are not stored. Series.sparse.sp_values An ndarray containing the non- fill_value values. Series.sparse.from_coo(A[, dense_index]) Create a Series with sparse values from a scipy.sparse.coo_matrix. Series.sparse.to_coo([row_levels, ...]) Create a scipy.sparse.coo_matrix from a Series with MultiIndex. Flags Flags refer to attributes of the pandas object. Properties of the dataset (like the date is was recorded, the URL it was accessed from, etc.) should be stored in Series.attrs. Flags(obj, *, allows_duplicate_labels) Flags that apply to pandas objects. Metadata Series.attrs is a dictionary for storing global metadata for this Series. Warning Series.attrs is considered experimental and may change without warning. Series.attrs Dictionary of global attributes of this dataset. Plotting Series.plot is both a callable method and a namespace attribute for specific plotting methods of the form Series.plot.<kind>. Series.plot([kind, ax, figsize, ....]) Series plotting accessor and method Series.plot.area([x, y]) Draw a", "score": "0.7003498"}, {"id": "25742", "text": "Function: python.library.stdtypes\nSnippet: Strings also support two styles of string formatting, one providing a large degree of flexibility and customization (see str.format(), Format String Syntax and Custom String Formatting) and the other based on C printf style formatting that handles a narrower range of types and is slightly harder to use correctly, but is often faster for the cases it can handle (printf-style String Formatting). The Text Processing Services section of the standard library covers a number of other modules that provide various text related utilities (including regular expression support in the re module). str.capitalize() Return a copy of the string with its first character capitalized and the rest lowercased. Changed in version 3.8: The first character is now put into titlecase rather than uppercase. This means that characters like digraphs will only have their first letter capitalized, instead of the full character. str.casefold() Return a casefolded copy of the string. Casefolded strings may be used for caseless matching. Casefolding is similar to lowercasing but more aggressive because it is intended to remove all case distinctions in a string. For example, the German lowercase letter 'ß' is equivalent to \"ss\". Since it is already lowercase, lower() would do nothing to 'ß'; casefold() converts it to \"ss\". The casefolding algorithm is described in section 3.13 of the Unicode Standard. New in version 3.3. str.center(width[, fillchar]) Return centered in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. str.encode(encoding=\"utf-8\", errors=\"strict\") Return an encoded version of the string as a bytes object. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other possible values are 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and any other name registered via codecs.register_error(), see section Error Handlers. For a list of possible encodings, see section Standard Encodings. By default, the errors argument is not checked for best performances, but only used at the first encoding error. Enable the Python Development Mode, or use a debug build to check errors. Changed in version 3.1: Support for keyword arguments added. Changed in version 3.9: The errors is now checked in development mode and in debug mode. str.endswith(suffix[, start[, end]]) Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. str.expandtabs(tabsize=8) Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. Tab positions occur every tabsize characters (default is 8, giving tab positions at columns 0, 8, 16 and so", "score": "0.6996551"}]}
{"task_id": "mbpp_16", "code": "import re\r\ndef text_lowercase_underscore(text):\r\n        patterns = '^[a-z]+_[a-z]+$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')", "test_list": ["assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')", "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')", "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"], "context": "Write a function to find sequences of lowercase letters joined with an underscore.", "function_name": "import re\r\ndef text_lowercase_underscore(text):", "gold_generation": "patterns = '^[a-z]+_[a-z]+$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')", "ctxs": [{"id": "16533", "text": "Function: pandas.reference.series\nSnippet: of strings in the Series/Index. Series.str.rpartition([sep, expand]) Split the string at the last occurrence of sep. Series.str.rstrip([to_strip]) Remove trailing characters. Series.str.slice([start, stop, step]) Slice substrings from each element in the Series or Index. Series.str.slice_replace([start, stop, repl]) Replace a positional slice of a string with another value. Series.str.split([pat, n, expand, regex]) Split strings around given separator/delimiter. Series.str.rsplit([pat, n, expand]) Split strings around given separator/delimiter. Series.str.startswith(pat[, na]) Test if the start of each string element matches a pattern. Series.str.strip([to_strip]) Remove leading and trailing characters. Series.str.swapcase() Convert strings in the Series/Index to be swapcased. Series.str.title() Convert strings in the Series/Index to titlecase. Series.str.translate(table) Map all characters in the string through the given mapping table. Series.str.upper() Convert strings in the Series/Index to uppercase. Series.str.wrap(width, **kwargs) Wrap strings in Series/Index at specified line width. Series.str.zfill(width) Pad strings in the Series/Index by prepending '0' characters. Series.str.isalnum() Check whether all characters in each string are alphanumeric. Series.str.isalpha() Check whether all characters in each string are alphabetic. Series.str.isdigit() Check whether all characters in each string are digits. Series.str.isspace() Check whether all characters in each string are whitespace. Series.str.islower() Check whether all characters in each string are lowercase. Series.str.isupper() Check whether all characters in each string are uppercase. Series.str.istitle() Check whether all characters in each string are titlecase. Series.str.isnumeric() Check whether all characters in each string are numeric. Series.str.isdecimal() Check whether all characters in each string are decimal. Series.str.get_dummies([sep]) Return DataFrame of dummy/indicator variables for Series. Categorical accessor Categorical-dtype specific methods and attributes are available under the Series.cat accessor. Series.cat.categories The categories of this categorical. Series.cat.ordered Whether the categories have an ordered relationship. Series.cat.codes Return Series of codes as well as the index. Series.cat.rename_categories(*args, **kwargs) Rename categories. Series.cat.reorder_categories(*args, **kwargs) Reorder categories as specified in new_categories. Series.cat.add_categories(*args, **kwargs) Add new categories. Series.cat.remove_categories(*args, **kwargs) Remove the specified categories. Series.cat.remove_unused_categories(*args, ...) Remove categories which are not used. Series.cat.set_categories(*args, **kwargs) Set the categories to the specified new_categories. Series.cat.as_ordered(*args, **kwargs) Set the Categorical to be ordered. Series.cat.as_unordered(*args, **kwargs) Set the Categorical to be unordered. Sparse accessor Sparse-dtype specific methods and attributes are provided under the Series.sparse accessor. Series.sparse.npoints The number of non- fill_value points. Series.sparse.density The percent of non- fill_value points, as decimal. Series.sparse.fill_value Elements in data that are fill_value are not stored. Series.sparse.sp_values An ndarray containing the non- fill_value values. Series.sparse.from_coo(A[, dense_index]) Create a Series with sparse values from a scipy.sparse.coo_matrix. Series.sparse.to_coo([row_levels, ...]) Create a scipy.sparse.coo_matrix from a Series with MultiIndex. Flags Flags refer to attributes of the pandas object. Properties of the dataset (like the date is was recorded, the URL it was accessed from, etc.) should be stored in Series.attrs. Flags(obj, *, allows_duplicate_labels) Flags that apply to pandas objects. Metadata Series.attrs is a dictionary for storing global metadata for this Series. Warning Series.attrs is considered experimental and may change without warning. Series.attrs Dictionary of global attributes of this dataset. Plotting Series.plot is both a callable method and a namespace attribute for specific plotting methods of the form Series.plot.<kind>. Series.plot([kind, ax, figsize, ....]) Series plotting accessor and method Series.plot.area([x, y]) Draw a", "score": "0.6957855"}, {"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.686237"}, {"id": "24364", "text": "Function: python.library.stdtypes#str.lower\nSnippet: str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard.", "score": "0.68487334"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.68331546"}, {"id": "25742", "text": "Function: python.library.stdtypes\nSnippet: Strings also support two styles of string formatting, one providing a large degree of flexibility and customization (see str.format(), Format String Syntax and Custom String Formatting) and the other based on C printf style formatting that handles a narrower range of types and is slightly harder to use correctly, but is often faster for the cases it can handle (printf-style String Formatting). The Text Processing Services section of the standard library covers a number of other modules that provide various text related utilities (including regular expression support in the re module). str.capitalize() Return a copy of the string with its first character capitalized and the rest lowercased. Changed in version 3.8: The first character is now put into titlecase rather than uppercase. This means that characters like digraphs will only have their first letter capitalized, instead of the full character. str.casefold() Return a casefolded copy of the string. Casefolded strings may be used for caseless matching. Casefolding is similar to lowercasing but more aggressive because it is intended to remove all case distinctions in a string. For example, the German lowercase letter 'ß' is equivalent to \"ss\". Since it is already lowercase, lower() would do nothing to 'ß'; casefold() converts it to \"ss\". The casefolding algorithm is described in section 3.13 of the Unicode Standard. New in version 3.3. str.center(width[, fillchar]) Return centered in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. str.encode(encoding=\"utf-8\", errors=\"strict\") Return an encoded version of the string as a bytes object. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other possible values are 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and any other name registered via codecs.register_error(), see section Error Handlers. For a list of possible encodings, see section Standard Encodings. By default, the errors argument is not checked for best performances, but only used at the first encoding error. Enable the Python Development Mode, or use a debug build to check errors. Changed in version 3.1: Support for keyword arguments added. Changed in version 3.9: The errors is now checked in development mode and in debug mode. str.endswith(suffix[, start[, end]]) Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. str.expandtabs(tabsize=8) Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. Tab positions occur every tabsize characters (default is 8, giving tab positions at columns 0, 8, 16 and so", "score": "0.6825408"}]}
{"task_id": "mbpp_17", "code": "def square_perimeter(a):\r\n  perimeter=4*a\r\n  return perimeter", "test_list": ["assert square_perimeter(10)==40", "assert square_perimeter(5)==20", "assert square_perimeter(4)==16"], "context": "Write a function to find the perimeter of a square.", "function_name": "def square_perimeter(a):", "gold_generation": "perimeter=4*a\r\n  return perimeter", "ctxs": [{"id": "36357", "text": "Function: django.ref.contrib.gis.functions#django.contrib.gis.db.models.functions.Perimeter\nSnippet: class Perimeter(expression, **extra)", "score": "0.70107317"}, {"id": "21777", "text": "Function: python.library.math\nSnippet: Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers. math.sqrt(x) Return the square root of x. Trigonometric functions math.acos(x) Return the arc cosine of x, in radians. The result is between 0 and pi. math.asin(x) Return the arc sine of x, in radians. The result is between -pi/2 and pi/2. math.atan(x) Return the arc tangent of x, in radians. The result is between -pi/2 and pi/2. math.atan2(y, x) Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4. math.cos(x) Return the cosine of x radians. math.dist(p, q) Return the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Roughly equivalent to: sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q))) New in version 3.8. math.hypot(*coordinates) Return the Euclidean norm, sqrt(sum(x**2 for x in coordinates)). This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point (x, y), this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, sqrt(x*x + y*y). Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. math.sin(x) Return the sine of x radians. math.tan(x) Return the tangent of x radians. Angular conversion math.degrees(x) Convert angle x from radians to degrees. math.radians(x) Convert angle x from degrees to radians. Hyperbolic functions Hyperbolic functions are analogs of trigonometric functions that are based on hyperbolas instead of circles. math.acosh(x) Return the inverse hyperbolic cosine of x. math.asinh(x) Return the inverse hyperbolic sine of x. math.atanh(x) Return the inverse hyperbolic tangent of x. math.cosh(x) Return the hyperbolic cosine of x. math.sinh(x) Return the hyperbolic sine of x. math.tanh(x) Return the hyperbolic tangent of x. Special functions math.erf(x) Return the error function at x. The erf() function can be used to compute traditional statistical functions such as the cumulative standard normal distribution: def phi(x): 'Cumulative distribution function for the standard normal distribution' return (1.0 + erf(x / sqrt(2.0))) / 2.0 New in version 3.2. math.erfc(x) Return the complementary error function at x. The complementary error function is defined as 1.0 - erf(x). It is used for large values of x where a subtraction from one would cause a loss of significance. New in version 3.2. math.gamma(x) Return the Gamma function at x. New in version 3.2. math.lgamma(x) Return the natural logarithm of the absolute value of the Gamma function at x. New in version 3.2. Constants math.pi The mathematical constant π =", "score": "0.6479097"}, {"id": "16654", "text": "Function: skimage.api.skimage.draw#skimage.draw.rectangle_perimeter\nSnippet: skimage.draw.rectangle_perimeter(start, end=None, extent=None, shape=None, clip=False) [source] Generate coordinates of pixels that are exactly around a rectangle. Parameters starttuple Origin point of the inner rectangle, e.g., (row, column). endtuple End point of the inner rectangle (row, column). For a 2D matrix, the slice defined by inner the rectangle is [start:(end+1)]. Either end or extent must be specified. extenttuple The extent (size) of the inner rectangle. E.g., (num_rows, num_cols). Either end or extent must be specified. Negative extents are permitted. See rectangle to better understand how they behave. shapetuple, optional Image shape used to determine the maximum bounds of the output coordinates. This is useful for clipping perimeters that exceed the image size. By default, no clipping is done. Must be at least length 2. Only the first two values are used to determine the extent of the input image. clipbool, optional Whether to clip the perimeter to the provided shape. If this is set to True, the drawn figure will always be a closed polygon with all edges visible. Returns coordsarray of int, shape (2, Npoints) The coordinates of all pixels in the rectangle. Examples >>> import numpy as np >>> from skimage.draw import rectangle_perimeter >>> img = np.zeros((5, 6), dtype=np.uint8) >>> start = (2, 3) >>> end = (3, 4) >>> rr, cc = rectangle_perimeter(start, end=end, shape=img.shape) >>> img[rr, cc] = 1 >>> img array([[0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1]], dtype=uint8) >>> img = np.zeros((5, 5), dtype=np.uint8) >>> r, c = rectangle_perimeter(start, (10, 10), shape=img.shape, clip=True) >>> img[r, c] = 1 >>> img array([[0, 0, 0, 0, 0], [0, 0, 1, 1, 1], [0, 0, 1, 0, 1], [0, 0, 1, 0, 1], [0, 0, 1, 1, 1]], dtype=uint8)", "score": "0.63835585"}, {"id": "13502", "text": "Function: pygame.ref.math#pygame.math.Vector2.length_squared\nSnippet: length_squared() returns the squared Euclidean length of the vector. length_squared() -> float calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length_squared() == vec.x**2 + vec.y**2. This is faster than vec.length() because it avoids the square root.", "score": "0.63696694"}, {"id": "8112", "text": "Function: torch.tensors#torch.Tensor.square\nSnippet: square() → Tensor See torch.square()", "score": "0.63596416"}]}
{"task_id": "mbpp_18", "code": "NO_OF_CHARS = 256\r\ndef str_to_list(string): \r\n\ttemp = [] \r\n\tfor x in string: \r\n\t\ttemp.append(x) \r\n\treturn temp \r\ndef lst_to_string(List): \r\n\treturn ''.join(List) \r\ndef get_char_count_array(string): \r\n\tcount = [0] * NO_OF_CHARS \r\n\tfor i in string: \r\n\t\tcount[ord(i)] += 1\r\n\treturn count \r\ndef remove_dirty_chars(string, second_string): \r\n\tcount = get_char_count_array(second_string) \r\n\tip_ind = 0\r\n\tres_ind = 0\r\n\ttemp = '' \r\n\tstr_list = str_to_list(string) \r\n\twhile ip_ind != len(str_list): \r\n\t\ttemp = str_list[ip_ind] \r\n\t\tif count[ord(temp)] == 0: \r\n\t\t\tstr_list[res_ind] = str_list[ip_ind] \r\n\t\t\tres_ind += 1\r\n\t\tip_ind+=1\r\n\treturn lst_to_string(str_list[0:res_ind]) ", "test_list": ["assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'", "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'", "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "], "context": "Write a function to remove characters from the first string which are present in the second string.", "function_name": "NO_OF_CHARS = 256\r\ndef str_to_list(string):", "gold_generation": "temp = [] \r\n\tfor x in string: \r\n\t\ttemp.append(x) \r\n\treturn temp \r\ndef lst_to_string(List): \r\n\treturn ''.join(List) \r\ndef get_char_count_array(string): \r\n\tcount = [0] * NO_OF_CHARS \r\n\tfor i in string: \r\n\t\tcount[ord(i)] += 1\r\n\treturn count \r\ndef remove_dirty_chars(string, second_string): \r\n\tcount = get_char_count_array(second_string) \r\n\tip_ind = 0\r\n\tres_ind = 0\r\n\ttemp = '' \r\n\tstr_list = str_to_list(string) \r\n\twhile ip_ind != len(str_list): \r\n\t\ttemp = str_list[ip_ind] \r\n\t\tif count[ord(temp)] == 0: \r\n\t\t\tstr_list[res_ind] = str_list[ip_ind] \r\n\t\t\tres_ind += 1\r\n\t\tip_ind+=1\r\n\treturn lst_to_string(str_list[0:res_ind])", "ctxs": [{"id": "41823", "text": "Function: numpy.reference.generated.numpy.chararray.strip\nSnippet: numpy.chararray.strip method chararray.strip(chars=None)[source] For each element in self, return a copy with the leading and trailing characters removed. See also char.strip", "score": "0.69341284"}, {"id": "41702", "text": "Function: numpy.reference.generated.numpy.char.chararray.strip\nSnippet: numpy.char.chararray.strip method char.chararray.strip(chars=None)[source] For each element in self, return a copy with the leading and trailing characters removed. See also char.strip", "score": "0.6922374"}, {"id": "24398", "text": "Function: python.library.string\nSnippet: characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", "score": "0.68622863"}, {"id": "24376", "text": "Function: python.library.stdtypes#str.rstrip\nSnippet: str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty'", "score": "0.6844448"}, {"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.68151313"}]}
{"task_id": "mbpp_19", "code": "def test_duplicate(arraynums):\r\n    nums_set = set(arraynums)    \r\n    return len(arraynums) != len(nums_set)     ", "test_list": ["assert test_duplicate(([1,2,3,4,5]))==False", "assert test_duplicate(([1,2,3,4, 4]))==True", "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"], "context": "Write a function to find whether a given array of integers contains any duplicate element.", "function_name": "def test_duplicate(arraynums):", "gold_generation": "nums_set = set(arraynums)    \r\n    return len(arraynums) != len(nums_set)", "ctxs": [{"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.7485917"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.68425155"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.68234056"}, {"id": "14702", "text": "Function: pandas.reference.api.pandas.index.has_duplicates\nSnippet: pandas.Index.has_duplicates propertyIndex.has_duplicates Check if the Index has duplicate values. Returns bool Whether or not the Index has duplicate values. Examples >>> idx = pd.Index([1, 5, 7, 7]) >>> idx.has_duplicates True >>> idx = pd.Index([1, 5, 7]) >>> idx.has_duplicates False >>> idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\", ... \"Watermelon\"]).astype(\"category\") >>> idx.has_duplicates True >>> idx = pd.Index([\"Orange\", \"Apple\", ... \"Watermelon\"]).astype(\"category\") >>> idx.has_duplicates False", "score": "0.6788043"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.6764115"}]}
{"task_id": "mbpp_20", "code": "def is_woodall(x): \r\n\tif (x % 2 == 0): \r\n\t\treturn False\r\n\tif (x == 1): \r\n\t\treturn True\r\n\tx = x + 1 \r\n\tp = 0\r\n\twhile (x % 2 == 0): \r\n\t\tx = x/2\r\n\t\tp = p + 1\r\n\t\tif (p == x): \r\n\t\t\treturn True\r\n\treturn False", "test_list": ["assert is_woodall(383) == True", "assert is_woodall(254) == False", "assert is_woodall(200) == False"], "context": "Write a function to check if the given number is woodball or not.", "function_name": "def is_woodall(x):", "gold_generation": "if (x % 2 == 0): \r\n\t\treturn False\r\n\tif (x == 1): \r\n\t\treturn True\r\n\tx = x + 1 \r\n\tp = 0\r\n\twhile (x % 2 == 0): \r\n\t\tx = x/2\r\n\t\tp = p + 1\r\n\t\tif (p == x): \r\n\t\t\treturn True\r\n\treturn False", "ctxs": [{"id": "14026", "text": "Function: pandas.reference.api.pandas.api.types.is_number\nSnippet: pandas.api.types.is_number pandas.api.types.is_number(obj)[source] Check if the object is a number. Returns True when the object is a number, and False if is not. Parameters obj:any type The object to check if is a number. Returns is_number:bool Whether obj is a number or not. See also api.types.is_integer Checks a subgroup of numbers. Examples >>> from pandas.api.types import is_number >>> is_number(1) True >>> is_number(7.15) True Booleans are valid because they are int subclass. >>> is_number(False) True >>> is_number(\"foo\") False >>> is_number(\"5\") False", "score": "0.6682615"}, {"id": "19477", "text": "Function: python.library.decimal#decimal.Context.is_normal\nSnippet: is_normal(x) Returns True if x is a normal number; otherwise returns False.", "score": "0.6663408"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.66352177"}, {"id": "21811", "text": "Function: python.library.math#math.isnan\nSnippet: math.isnan(x) Return True if x is a NaN (not a number), and False otherwise.", "score": "0.66068935"}, {"id": "19479", "text": "Function: python.library.decimal#decimal.Context.is_signed\nSnippet: is_signed(x) Returns True if x is negative; otherwise returns False.", "score": "0.65264297"}]}
{"task_id": "mbpp_21", "code": "def multiples_of_num(m,n): \r\n    multiples_of_num= list(range(n,(m+1)*n, n)) \r\n    return list(multiples_of_num)", "test_list": ["assert multiples_of_num(4,3)== [3,6,9,12]", "assert multiples_of_num(2,5)== [5,10]", "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"], "context": "Write a function to find m number of multiples of n.", "function_name": "def multiples_of_num(m,n):", "gold_generation": "multiples_of_num= list(range(n,(m+1)*n, n)) \r\n    return list(multiples_of_num)", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.67494273"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6605464"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.654325"}, {"id": "21813", "text": "Function: python.library.math#math.lcm\nSnippet: math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9.", "score": "0.64066446"}, {"id": "16117", "text": "Function: pandas.reference.api.pandas.tseries.offsets.micro.n\nSnippet: pandas.tseries.offsets.Micro.n Micro.n", "score": "0.64016736"}]}
{"task_id": "mbpp_22", "code": "def find_first_duplicate(nums):\r\n    num_set = set()\r\n    no_duplicate = -1\r\n\r\n    for i in range(len(nums)):\r\n\r\n        if nums[i] in num_set:\r\n            return nums[i]\r\n        else:\r\n            num_set.add(nums[i])\r\n\r\n    return no_duplicate", "test_list": ["assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4", "assert find_first_duplicate([1, 2, 3, 4])==-1", "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"], "context": "Write a function to find the first duplicate element in a given array of integers.", "function_name": "def find_first_duplicate(nums):", "gold_generation": "num_set = set()\r\n    no_duplicate = -1\r\n\r\n    for i in range(len(nums)):\r\n\r\n        if nums[i] in num_set:\r\n            return nums[i]\r\n        else:\r\n            num_set.add(nums[i])\r\n\r\n    return no_duplicate", "ctxs": [{"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.7361721"}, {"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.728411"}, {"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.6941106"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.6586559"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6567061"}]}
{"task_id": "mbpp_23", "code": "def maximum_Sum(list1): \r\n    maxi = -100000\r\n    for x in list1: \r\n        sum = 0 \r\n        for y in x: \r\n            sum+= y      \r\n        maxi = max(sum,maxi)     \r\n    return maxi ", "test_list": ["assert maximum_Sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33", "assert maximum_Sum([[0,1,1],[1,1,2],[3,2,1]]) == 6", "assert maximum_Sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"], "context": "Write a python function to find the maximum sum of elements of list in a list of lists.", "function_name": "def maximum_Sum(list1):", "gold_generation": "maxi = -100000\r\n    for x in list1: \r\n        sum = 0 \r\n        for y in x: \r\n            sum+= y      \r\n        maxi = max(sum,maxi)     \r\n    return maxi", "ctxs": [{"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.66741395"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.661973"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.65904325"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.65878487"}, {"id": "43857", "text": "Function: numpy.reference.generated.numpy.recarray.max\nSnippet: numpy.recarray.max method recarray.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the maximum along a given axis. Refer to numpy.amax for full documentation. See also numpy.amax equivalent function", "score": "0.65417194"}]}
{"task_id": "mbpp_24", "code": "def binary_to_decimal(binary): \r\n    binary1 = binary \r\n    decimal, i, n = 0, 0, 0\r\n    while(binary != 0): \r\n        dec = binary % 10\r\n        decimal = decimal + dec * pow(2, i) \r\n        binary = binary//10\r\n        i += 1\r\n    return (decimal)", "test_list": ["assert binary_to_decimal(100) == 4", "assert binary_to_decimal(1011) == 11", "assert binary_to_decimal(1101101) == 109"], "context": "Write a function to convert the given binary number to its decimal equivalent.", "function_name": "def binary_to_decimal(binary):", "gold_generation": "binary1 = binary \r\n    decimal, i, n = 0, 0, 0\r\n    while(binary != 0): \r\n        dec = binary % 10\r\n        decimal = decimal + dec * pow(2, i) \r\n        binary = binary//10\r\n        i += 1\r\n    return (decimal)", "ctxs": [{"id": "19516", "text": "Function: python.library.decimal#decimal.Decimal\nSnippet: class decimal.Decimal(value=\"0\", context=None) Construct a new Decimal object based from value. value can be an integer, string, tuple, float, or another Decimal object. If no value is given, returns Decimal('0'). If value is a string, it should conform to the decimal numeric string syntax after leading and trailing whitespace characters, as well as underscores throughout, are removed: sign ::= '+' | '-' digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' indicator ::= 'e' | 'E' digits ::= digit [digit]... decimal-part ::= digits '.' [digits] | ['.'] digits exponent-part ::= indicator [sign] digits infinity ::= 'Infinity' | 'Inf' nan ::= 'NaN' [digits] | 'sNaN' [digits] numeric-value ::= decimal-part [exponent-part] | infinity numeric-string ::= [sign] numeric-value | [sign] nan Other Unicode decimal digits are also permitted where digit appears above. These include decimal digits from various other alphabets (for example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits '\\uff10' through '\\uff19'. If value is a tuple, it should have three components, a sign (0 for positive or 1 for negative), a tuple of digits, and an integer exponent. For example, Decimal((0, (1, 4, 1, 4), -3)) returns Decimal('1.414'). If value is a float, the binary floating point value is losslessly converted to its exact decimal equivalent. This conversion can often require 53 or more digits of precision. For example, Decimal(float('1.1')) converts to Decimal('1.100000000000000088817841970012523233890533447265625'). The context precision does not affect how many digits are stored. That is determined exclusively by the number of digits in value. For example, Decimal('3.00000') records all five zeros even if the context precision is only three. The purpose of the context argument is determining what to do if value is a malformed string. If the context traps InvalidOperation, an exception is raised; otherwise, the constructor returns a new Decimal with the value of NaN. Once constructed, Decimal objects are immutable. Changed in version 3.2: The argument to the constructor is now permitted to be a float instance. Changed in version 3.3: float arguments raise an exception if the FloatOperation trap is set. By default the trap is off. Changed in version 3.6: Underscores are allowed for grouping, as with integral and floating-point literals in code. Decimal floating point objects share many properties with the other built-in numeric types such as float and int. All of the usual math operations and special methods apply. Likewise, decimal objects can be copied, pickled, printed, used as dictionary keys, used as set elements, compared, sorted, and coerced to another type (such as float or int). There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator % is applied to Decimal objects, the sign of the result is the sign of the dividend rather than the sign of the divisor: >>> (-7) % 4 1 >>> Decimal(-7) % Decimal(4) Decimal('-3') The integer division operator // behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather", "score": "0.7525537"}, {"id": "19499", "text": "Function: python.library.decimal#decimal.Context.normalize\nSnippet: normalize(x) Reduces x to its simplest form.", "score": "0.7502239"}, {"id": "19430", "text": "Function: python.library.decimal\nSnippet: operand with the sign set to be the same as the sign of the second operand. For example: >>> Decimal('2.3').copy_sign(Decimal('-1.5')) Decimal('-2.3') This operation is unaffected by context and is quiet: no flags are changed and no rounding is performed. As an exception, the C version may raise InvalidOperation if the second operand cannot be converted exactly. exp(context=None) Return the value of the (natural) exponential function e**x at the given number. The result is correctly rounded using the ROUND_HALF_EVEN rounding mode. >>> Decimal(1).exp() Decimal('2.718281828459045235360287471') >>> Decimal(321).exp() Decimal('2.561702493119680037517373933E+139') from_float(f) Classmethod that converts a float to a decimal number, exactly. Note Decimal.from_float(0.1) is not the same as Decimal(‘0.1’). Since 0.1 is not exactly representable in binary floating point, the value is stored as the nearest representable value which is 0x1.999999999999ap-4. That equivalent value in decimal is 0.1000000000000000055511151231257827021181583404541015625. Note From Python 3.2 onwards, a Decimal instance can also be constructed directly from a float. >>> Decimal.from_float(0.1) Decimal('0.1000000000000000055511151231257827021181583404541015625') >>> Decimal.from_float(float('nan')) Decimal('NaN') >>> Decimal.from_float(float('inf')) Decimal('Infinity') >>> Decimal.from_float(float('-inf')) Decimal('-Infinity') New in version 3.1. fma(other, third, context=None) Fused multiply-add. Return self*other+third with no rounding of the intermediate product self*other. >>> Decimal(2).fma(3, 5) Decimal('11') is_canonical() Return True if the argument is canonical and False otherwise. Currently, a Decimal instance is always canonical, so this operation always returns True. is_finite() Return True if the argument is a finite number, and False if the argument is an infinity or a NaN. is_infinite() Return True if the argument is either positive or negative infinity and False otherwise. is_nan() Return True if the argument is a (quiet or signaling) NaN and False otherwise. is_normal(context=None) Return True if the argument is a normal finite number. Return False if the argument is zero, subnormal, infinite or a NaN. is_qnan() Return True if the argument is a quiet NaN, and False otherwise. is_signed() Return True if the argument has a negative sign and False otherwise. Note that zeros and NaNs can both carry signs. is_snan() Return True if the argument is a signaling NaN and False otherwise. is_subnormal(context=None) Return True if the argument is subnormal, and False otherwise. is_zero() Return True if the argument is a (positive or negative) zero and False otherwise. ln(context=None) Return the natural (base e) logarithm of the operand. The result is correctly rounded using the ROUND_HALF_EVEN rounding mode. log10(context=None) Return the base ten logarithm of the operand. The result is correctly rounded using the ROUND_HALF_EVEN rounding mode. logb(context=None) For a nonzero number, return the adjusted exponent of its operand as a Decimal instance. If the operand is a zero then Decimal('-Infinity') is returned and the DivisionByZero flag is raised. If the operand is an infinity then Decimal('Infinity') is returned. logical_and(other, context=None) logical_and() is a logical operation which takes two logical operands (see Logical operands). The result is the digit-wise and of the two operands. logical_invert(context=None) logical_invert() is a logical operation. The result is the digit-wise inversion of the operand. logical_or(other, context=None) logical_or() is a logical operation which takes two logical operands (see Logical operands). The result is the digit-wise or of", "score": "0.7423283"}, {"id": "19442", "text": "Function: python.library.decimal\nSnippet: In developing fixed-point applications, it is convenient to define functions to handle the quantize() step: >>> def mul(x, y, fp=TWOPLACES): ... return (x * y).quantize(fp) >>> def div(x, y, fp=TWOPLACES): ... return (x / y).quantize(fp) >>> mul(a, b) # Automatically preserve fixed-point Decimal('325.62') >>> div(b, a) Decimal('0.03') Q. There are many ways to express the same value. The numbers 200, 200.000, 2E2, and 02E+4 all have the same value at various precisions. Is there a way to transform them to a single recognizable canonical value? A. The normalize() method maps all equivalent values to a single representative: >>> values = map(Decimal, '200 200.000 2E2 .02E+4'.split()) >>> [v.normalize() for v in values] [Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2')] Q. Some decimal values always print with exponential notation. Is there a way to get a non-exponential representation? A. For some values, exponential notation is the only way to express the number of significant places in the coefficient. For example, expressing 5.0E+3 as 5000 keeps the value constant but cannot show the original’s two-place significance. If an application does not care about tracking significance, it is easy to remove the exponent and trailing zeroes, losing significance, but keeping the value unchanged: >>> def remove_exponent(d): ... return d.quantize(Decimal(1)) if d == d.to_integral() else d.normalize() >>> remove_exponent(Decimal('5E+3')) Decimal('5000') Q. Is there a way to convert a regular float to a Decimal? A. Yes, any binary floating point number can be exactly expressed as a Decimal though an exact conversion may take more precision than intuition would suggest: >>> Decimal(math.pi) Decimal('3.141592653589793115997963468544185161590576171875') Q. Within a complex calculation, how can I make sure that I haven’t gotten a spurious result because of insufficient precision or rounding anomalies. A. The decimal module makes it easy to test results. A best practice is to re-run calculations using greater precision and with various rounding modes. Widely differing results indicate insufficient precision, rounding mode issues, ill-conditioned inputs, or a numerically unstable algorithm. Q. I noticed that context precision is applied to the results of operations but not to the inputs. Is there anything to watch out for when mixing values of different precisions? A. Yes. The principle is that all values are considered to be exact and so is the arithmetic on those values. Only the results are rounded. The advantage for inputs is that “what you type is what you get”. A disadvantage is that the results can look odd if you forget that the inputs haven’t been rounded: >>> getcontext().prec = 3 >>> Decimal('3.104') + Decimal('2.104') Decimal('5.21') >>> Decimal('3.104') + Decimal('0.000') + Decimal('2.104') Decimal('5.20') The solution is either to increase precision or to force rounding of inputs using the unary plus operation: >>> getcontext().prec = 3 >>> +Decimal('1.23456789') # unary plus triggers rounding Decimal('1.23') Alternatively, inputs can be rounded upon creation using the Context.create_decimal() method: >>> Context(prec=5, rounding=ROUND_DOWN).create_decimal('1.2345678') Decimal('1.2345') Q. Is the CPython implementation fast for large numbers? A. Yes. In the CPython and PyPy3 implementations, the C/CFFI versions of the decimal module integrate the high speed libmpdec library for arbitrary precision", "score": "0.7418275"}, {"id": "19536", "text": "Function: python.library.decimal#decimal.Decimal.from_float\nSnippet: from_float(f) Classmethod that converts a float to a decimal number, exactly. Note Decimal.from_float(0.1) is not the same as Decimal(‘0.1’). Since 0.1 is not exactly representable in binary floating point, the value is stored as the nearest representable value which is 0x1.999999999999ap-4. That equivalent value in decimal is 0.1000000000000000055511151231257827021181583404541015625. Note From Python 3.2 onwards, a Decimal instance can also be constructed directly from a float. >>> Decimal.from_float(0.1) Decimal('0.1000000000000000055511151231257827021181583404541015625') >>> Decimal.from_float(float('nan')) Decimal('NaN') >>> Decimal.from_float(float('inf')) Decimal('Infinity') >>> Decimal.from_float(float('-inf')) Decimal('-Infinity') New in version 3.1.", "score": "0.73797417"}]}
{"task_id": "mbpp_25", "code": "def find_Product(arr,n): \r\n    arr.sort() \r\n    prod = 1\r\n    for i in range(0,n,1): \r\n        if (arr[i - 1] != arr[i]): \r\n            prod = prod * arr[i] \r\n    return prod; ", "test_list": ["assert find_Product([1,1,2,3],4) == 6", "assert find_Product([1,2,3,1,1],5) == 6", "assert find_Product([1,1,4,5,6],5) == 120"], "context": "Write a python function to find the product of non-repeated elements in a given array.", "function_name": "def find_Product(arr,n):", "gold_generation": "arr.sort() \r\n    prod = 1\r\n    for i in range(0,n,1): \r\n        if (arr[i - 1] != arr[i]): \r\n            prod = prod * arr[i] \r\n    return prod;", "ctxs": [{"id": "43865", "text": "Function: numpy.reference.generated.numpy.recarray.prod\nSnippet: numpy.recarray.prod method recarray.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True) Return the product of the array elements over the given axis Refer to numpy.prod for full documentation. See also numpy.prod equivalent function", "score": "0.73025686"}, {"id": "43843", "text": "Function: numpy.reference.generated.numpy.recarray.cumprod\nSnippet: numpy.recarray.cumprod method recarray.cumprod(axis=None, dtype=None, out=None) Return the cumulative product of the elements along the given axis. Refer to numpy.cumprod for full documentation. See also numpy.cumprod equivalent function", "score": "0.71544796"}, {"id": "42551", "text": "Function: numpy.reference.generated.numpy.ndarray.prod\nSnippet: numpy.ndarray.prod method ndarray.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True) Return the product of the array elements over the given axis Refer to numpy.prod for full documentation. See also numpy.prod equivalent function", "score": "0.71528167"}, {"id": "21311", "text": "Function: python.library.itertools#itertools.product\nSnippet: itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs.", "score": "0.706409"}, {"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.7034321"}]}
{"task_id": "mbpp_26", "code": "def check_k_elements(test_list, K):\r\n  res = True\r\n  for tup in test_list:\r\n    for ele in tup:\r\n      if ele != K:\r\n        res = False\r\n  return (res) ", "test_list": ["assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True", "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True", "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"], "context": "Write a function to check if the given tuple list has all k elements.", "function_name": "def check_k_elements(test_list, K):", "gold_generation": "res = True\r\n  for tup in test_list:\r\n    for ele in tup:\r\n      if ele != K:\r\n        res = False\r\n  return (res)", "ctxs": [{"id": "17577", "text": "Function: python.library.functions#all\nSnippet: all(iterable) Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to: def all(iterable): for element in iterable: if not element: return False return True", "score": "0.7114464"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6851249"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.67849076"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6726688"}, {"id": "17578", "text": "Function: python.library.functions#any\nSnippet: any(iterable) Return True if any element of the iterable is true. If the iterable is empty, return False. Equivalent to: def any(iterable): for element in iterable: if element: return True return False", "score": "0.668327"}]}
{"task_id": "mbpp_27", "code": "import re  \r\ndef remove(list): \r\n    pattern = '[0-9]'\r\n    list = [re.sub(pattern, '', i) for i in list] \r\n    return list", "test_list": ["assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']", "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']", "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"], "context": "Write a python function to remove all digits from a list of strings.", "function_name": "import re  \r\ndef remove(list):", "gold_generation": "pattern = '[0-9]'\r\n    list = [re.sub(pattern, '', i) for i in list] \r\n    return list", "ctxs": [{"id": "24403", "text": "Function: python.library.string#string.digits\nSnippet: string.digits The string '0123456789'.", "score": "0.7119862"}, {"id": "25756", "text": "Function: python.library.stdtypes\nSnippet: binary sequence of byte values to remove may be any bytes-like object. See removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> b'Monty Python'.rstrip(b' Python') b'M' >>> b'Monty Python'.removesuffix(b' Python') b'Monty' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3'] bytes.strip([chars]) bytearray.strip([chars]) Return a copy of the sequence with specified leading and trailing bytes removed. The chars argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters. If omitted or None, the chars argument defaults to removing ASCII whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> b' spacious '.strip() b'spacious' >>> b'www.example.com'.strip(b'cmowz.') b'example' The binary sequence of byte values to remove may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.capitalize() bytearray.capitalize() Return a copy of the sequence with each byte interpreted as an ASCII character, and the first byte capitalized and the rest", "score": "0.6939624"}, {"id": "24415", "text": "Function: python.library.string#string.octdigits\nSnippet: string.octdigits The string '01234567'.", "score": "0.67955935"}, {"id": "24376", "text": "Function: python.library.stdtypes#str.rstrip\nSnippet: str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty'", "score": "0.67614806"}, {"id": "24414", "text": "Function: python.library.string#string.hexdigits\nSnippet: string.hexdigits The string '0123456789abcdefABCDEF'.", "score": "0.67513263"}]}
{"task_id": "mbpp_28", "code": "def binomial_Coeff(n,k): \r\n    if k > n : \r\n       return 0\r\n    if k==0 or k ==n : \r\n        return 1 \r\n    return binomial_Coeff(n-1,k-1) + binomial_Coeff(n-1,k) ", "test_list": ["assert binomial_Coeff(5,2) == 10", "assert binomial_Coeff(4,3) == 4", "assert binomial_Coeff(3,2) == 3"], "context": "Write a python function to find binomial co-efficient.", "function_name": "def binomial_Coeff(n,k):", "gold_generation": "if k > n : \r\n       return 0\r\n    if k==0 or k ==n : \r\n        return 1 \r\n    return binomial_Coeff(n-1,k-1) + binomial_Coeff(n-1,k)", "ctxs": [{"id": "24303", "text": "Function: python.library.statistics\nSnippet: 2.5).samples(n, seed=3652260728) >>> Y = NormalDist(15, 1.75).samples(n, seed=4582495471) >>> Z = NormalDist(50, 1.25).samples(n, seed=6582483453) >>> quantiles(map(model, X, Y, Z)) [1.4591308524824727, 1.8035946855390597, 2.175091447274739] Normal distributions can be used to approximate Binomial distributions when the sample size is large and when the probability of a successful trial is near 50%. For example, an open source conference has 750 attendees and two rooms with a 500 person capacity. There is a talk about Python and another about Ruby. In previous conferences, 65% of the attendees preferred to listen to Python talks. Assuming the population preferences haven’t changed, what is the probability that the Python room will stay within its capacity limits? >>> n = 750 # Sample size >>> p = 0.65 # Preference for Python >>> q = 1.0 - p # Preference for Ruby >>> k = 500 # Room capacity >>> # Approximation using the cumulative normal distribution >>> from math import sqrt >>> round(NormalDist(mu=n*p, sigma=sqrt(n*p*q)).cdf(k + 0.5), 4) 0.8402 >>> # Solution using the cumulative binomial distribution >>> from math import comb, fsum >>> round(fsum(comb(n, r) * p**r * q**(n-r) for r in range(k+1)), 4) 0.8402 >>> # Approximation using a simulation >>> from random import seed, choices >>> seed(8675309) >>> def trial(): ... return choices(('Python', 'Ruby'), (p, q), k=n).count('Python') >>> mean(trial() <= k for i in range(10_000)) 0.8398 Normal distributions commonly arise in machine learning problems. Wikipedia has a nice example of a Naive Bayesian Classifier. The challenge is to predict a person’s gender from measurements of normally distributed features including height, weight, and foot size. We’re given a training dataset with measurements for eight people. The measurements are assumed to be normally distributed, so we summarize the data with NormalDist: >>> height_male = NormalDist.from_samples([6, 5.92, 5.58, 5.92]) >>> height_female = NormalDist.from_samples([5, 5.5, 5.42, 5.75]) >>> weight_male = NormalDist.from_samples([180, 190, 170, 165]) >>> weight_female = NormalDist.from_samples([100, 150, 130, 150]) >>> foot_size_male = NormalDist.from_samples([12, 11, 12, 10]) >>> foot_size_female = NormalDist.from_samples([6, 8, 7, 9]) Next, we encounter a new person whose feature measurements are known but whose gender is unknown: >>> ht = 6.0 # height >>> wt = 130 # weight >>> fs = 8 # foot size Starting with a 50% prior probability of being male or female, we compute the posterior as the prior times the product of likelihoods for the feature measurements given the gender: >>> prior_male = 0.5 >>> prior_female = 0.5 >>> posterior_male = (prior_male * height_male.pdf(ht) * ... weight_male.pdf(wt) * foot_size_male.pdf(fs)) >>> posterior_female = (prior_female * height_female.pdf(ht) * ... weight_female.pdf(wt) * foot_size_female.pdf(fs)) The final prediction goes to the largest posterior. This is known as the maximum a posteriori or MAP: >>> 'male' if posterior_male > posterior_female else 'female' 'female'", "score": "0.6789272"}, {"id": "43752", "text": "Function: numpy.reference.random.generated.numpy.random.randomstate.binomial\nSnippet: numpy.random.RandomState.binomial method random.RandomState.binomial(n, p, size=None) Draw samples from a binomial distribution. Samples are drawn from a binomial distribution with specified parameters, n trials and p probability of success where n an integer >= 0 and p is in the interval [0,1]. (n may be input as a float, but it is truncated to an integer in use) Note New code should use the binomial method of a default_rng() instance instead; please see the Quick Start. Parameters nint or array_like of ints Parameter of the distribution, >= 0. Floats are also accepted, but they will be truncated to integers. pfloat or array_like of floats Parameter of the distribution, >= 0 and <=1. sizeint or tuple of ints, optional Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn. Returns outndarray or scalar Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials. See also scipy.stats.binom probability density function, distribution or cumulative density function, etc. Generator.binomial which should be used for new code. Notes The probability density for the binomial distribution is \\[P(N) = \\binom{n}{N}p^N(1-p)^{n-N},\\] where \\(n\\) is the number of trials, \\(p\\) is the probability of success, and \\(N\\) is the number of successes. When estimating the standard error of a proportion in a population by using a random sample, the normal distribution works well unless the product p*n <=5, where p = population proportion estimate, and n = number of samples, in which case the binomial distribution is used instead. For example, a sample of 15 people shows 4 who are left handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4, so the binomial distribution should be used in this case. References 1 Dalgaard, Peter, “Introductory Statistics with R”, Springer-Verlag, 2002. 2 Glantz, Stanton A. “Primer of Biostatistics.”, McGraw-Hill, Fifth Edition, 2002. 3 Lentner, Marvin, “Elementary Applied Statistics”, Bogden and Quigley, 1972. 4 Weisstein, Eric W. “Binomial Distribution.” From MathWorld–A Wolfram Web Resource. http://mathworld.wolfram.com/BinomialDistribution.html 5 Wikipedia, “Binomial distribution”, https://en.wikipedia.org/wiki/Binomial_distribution Examples Draw samples from the distribution: >>> n, p = 10, .5 # number of trials, probability of each trial >>> s = np.random.binomial(n, p, 1000) # result of flipping a coin 10 times, tested 1000 times. A real world example. A company drills 9 wild-cat oil exploration wells, each with an estimated probability of success of 0.1. All nine wells fail. What is the probability of that happening? Let’s do 20,000 trials of the model, and count the number that generate zero positive results. >>> sum(np.random.binomial(9, 0.1, 20000) == 0)/20000. # answer = 0.38885, or 38%.", "score": "0.6788852"}, {"id": "43644", "text": "Function: numpy.reference.random.generated.numpy.random.binomial\nSnippet: numpy.random.binomial random.binomial(n, p, size=None) Draw samples from a binomial distribution. Samples are drawn from a binomial distribution with specified parameters, n trials and p probability of success where n an integer >= 0 and p is in the interval [0,1]. (n may be input as a float, but it is truncated to an integer in use) Note New code should use the binomial method of a default_rng() instance instead; please see the Quick Start. Parameters nint or array_like of ints Parameter of the distribution, >= 0. Floats are also accepted, but they will be truncated to integers. pfloat or array_like of floats Parameter of the distribution, >= 0 and <=1. sizeint or tuple of ints, optional Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn. Returns outndarray or scalar Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials. See also scipy.stats.binom probability density function, distribution or cumulative density function, etc. Generator.binomial which should be used for new code. Notes The probability density for the binomial distribution is \\[P(N) = \\binom{n}{N}p^N(1-p)^{n-N},\\] where \\(n\\) is the number of trials, \\(p\\) is the probability of success, and \\(N\\) is the number of successes. When estimating the standard error of a proportion in a population by using a random sample, the normal distribution works well unless the product p*n <=5, where p = population proportion estimate, and n = number of samples, in which case the binomial distribution is used instead. For example, a sample of 15 people shows 4 who are left handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4, so the binomial distribution should be used in this case. References 1 Dalgaard, Peter, “Introductory Statistics with R”, Springer-Verlag, 2002. 2 Glantz, Stanton A. “Primer of Biostatistics.”, McGraw-Hill, Fifth Edition, 2002. 3 Lentner, Marvin, “Elementary Applied Statistics”, Bogden and Quigley, 1972. 4 Weisstein, Eric W. “Binomial Distribution.” From MathWorld–A Wolfram Web Resource. http://mathworld.wolfram.com/BinomialDistribution.html 5 Wikipedia, “Binomial distribution”, https://en.wikipedia.org/wiki/Binomial_distribution Examples Draw samples from the distribution: >>> n, p = 10, .5 # number of trials, probability of each trial >>> s = np.random.binomial(n, p, 1000) # result of flipping a coin 10 times, tested 1000 times. A real world example. A company drills 9 wild-cat oil exploration wells, each with an estimated probability of success of 0.1. All nine wells fail. What is the probability of that happening? Let’s do 20,000 trials of the model, and count the number that generate zero positive results. >>> sum(np.random.binomial(9, 0.1, 20000) == 0)/20000. # answer = 0.38885, or 38%.", "score": "0.6671103"}, {"id": "43655", "text": "Function: numpy.reference.random.generated.numpy.random.generator.binomial\nSnippet: numpy.random.Generator.binomial method random.Generator.binomial(n, p, size=None) Draw samples from a binomial distribution. Samples are drawn from a binomial distribution with specified parameters, n trials and p probability of success where n an integer >= 0 and p is in the interval [0,1]. (n may be input as a float, but it is truncated to an integer in use) Parameters nint or array_like of ints Parameter of the distribution, >= 0. Floats are also accepted, but they will be truncated to integers. pfloat or array_like of floats Parameter of the distribution, >= 0 and <=1. sizeint or tuple of ints, optional Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn. Returns outndarray or scalar Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials. See also scipy.stats.binom probability density function, distribution or cumulative density function, etc. Notes The probability density for the binomial distribution is \\[P(N) = \\binom{n}{N}p^N(1-p)^{n-N},\\] where \\(n\\) is the number of trials, \\(p\\) is the probability of success, and \\(N\\) is the number of successes. When estimating the standard error of a proportion in a population by using a random sample, the normal distribution works well unless the product p*n <=5, where p = population proportion estimate, and n = number of samples, in which case the binomial distribution is used instead. For example, a sample of 15 people shows 4 who are left handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4, so the binomial distribution should be used in this case. References 1 Dalgaard, Peter, “Introductory Statistics with R”, Springer-Verlag, 2002. 2 Glantz, Stanton A. “Primer of Biostatistics.”, McGraw-Hill, Fifth Edition, 2002. 3 Lentner, Marvin, “Elementary Applied Statistics”, Bogden and Quigley, 1972. 4 Weisstein, Eric W. “Binomial Distribution.” From MathWorld–A Wolfram Web Resource. http://mathworld.wolfram.com/BinomialDistribution.html 5 Wikipedia, “Binomial distribution”, https://en.wikipedia.org/wiki/Binomial_distribution Examples Draw samples from the distribution: >>> rng = np.random.default_rng() >>> n, p = 10, .5 # number of trials, probability of each trial >>> s = rng.binomial(n, p, 1000) # result of flipping a coin 10 times, tested 1000 times. A real world example. A company drills 9 wild-cat oil exploration wells, each with an estimated probability of success of 0.1. All nine wells fail. What is the probability of that happening? Let’s do 20,000 trials of the model, and count the number that generate zero positive results. >>> sum(rng.binomial(9, 0.1, 20000) == 0)/20000. # answer = 0.38885, or 39%.", "score": "0.6631209"}, {"id": "21787", "text": "Function: python.library.math#math.comb\nSnippet: math.comb(n, k) Return the number of ways to choose k items from n items without repetition and without order. Evaluates to n! / (k! * (n - k)!) when k <= n and evaluates to zero when k > n. Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of the expression (1 + x) ** n. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6619936"}]}
{"task_id": "mbpp_29", "code": "def get_Odd_Occurrence(arr,arr_size):   \r\n    for i in range(0,arr_size): \r\n        count = 0\r\n        for j in range(0,arr_size): \r\n            if arr[i] == arr[j]: \r\n                count+=1     \r\n        if (count % 2 != 0): \r\n            return arr[i]     \r\n    return -1", "test_list": ["assert get_Odd_Occurrence([1,2,3,1,2,3,1],7) == 1", "assert get_Odd_Occurrence([1,2,3,2,3,1,3],7) == 3", "assert get_Odd_Occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"], "context": "Write a python function to find the element occurring odd number of times.", "function_name": "def get_Odd_Occurrence(arr,arr_size):", "gold_generation": "for i in range(0,arr_size): \r\n        count = 0\r\n        for j in range(0,arr_size): \r\n            if arr[i] == arr[j]: \r\n                count+=1     \r\n        if (count % 2 != 0): \r\n            return arr[i]     \r\n    return -1", "ctxs": [{"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6954361"}, {"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.6946722"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6930802"}, {"id": "22306", "text": "Function: python.library.operator#operator.countOf\nSnippet: operator.countOf(a, b) Return the number of occurrences of b in a.", "score": "0.68554497"}, {"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.6804766"}]}
{"task_id": "mbpp_30", "code": "def check_Equality(s): \r\n    return (ord(s[0]) == ord(s[len(s) - 1])); \r\ndef count_Substring_With_Equal_Ends(s): \r\n    result = 0; \r\n    n = len(s); \r\n    for i in range(n): \r\n        for j in range(1,n-i+1):  \r\n            if (check_Equality(s[i:i+j])): \r\n                result+=1; \r\n    return result; ", "test_list": ["assert count_Substring_With_Equal_Ends(\"abc\") == 3", "assert count_Substring_With_Equal_Ends(\"abcda\") == 6", "assert count_Substring_With_Equal_Ends(\"ab\") == 2"], "context": "Write a python function to count all the substrings starting and ending with same characters.", "function_name": "def check_Equality(s):", "gold_generation": "return (ord(s[0]) == ord(s[len(s) - 1])); \r\ndef count_Substring_With_Equal_Ends(s): \r\n    result = 0; \r\n    n = len(s); \r\n    for i in range(n): \r\n        for j in range(1,n-i+1):  \r\n            if (check_Equality(s[i:i+j])): \r\n                result+=1; \r\n    return result;", "ctxs": [{"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.7611417"}, {"id": "41718", "text": "Function: numpy.reference.generated.numpy.char.count\nSnippet: numpy.char.count char.count(a, sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. Calls str.count element-wise. Parameters aarray_like of str or unicode substr or unicode The substring to search for. start, endint, optional Optional arguments start and end are interpreted as slice notation to specify the range in which to count. Returns outndarray Output array of ints. See also str.count Examples >>> c = np.array(['aAaAaA', ' aA ', 'abBABba']) >>> c array(['aAaAaA', ' aA ', 'abBABba'], dtype='<U7') >>> np.char.count(c, 'A') array([3, 1, 1]) >>> np.char.count(c, 'aA') array([3, 1, 0]) >>> np.char.count(c, 'A', start=1, end=4) array([2, 1, 1]) >>> np.char.count(c, 'A', start=1, end=3) array([1, 0, 0])", "score": "0.73983866"}, {"id": "41643", "text": "Function: numpy.reference.generated.numpy.char.chararray.count\nSnippet: numpy.char.chararray.count method char.chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.730834"}, {"id": "41768", "text": "Function: numpy.reference.generated.numpy.chararray.count\nSnippet: numpy.chararray.count method chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.72672296"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.72119856"}]}
{"task_id": "mbpp_31", "code": "def func(nums, k):\r\n    import collections\r\n    d = collections.defaultdict(int)\r\n    for row in nums:\r\n        for i in row:\r\n            d[i] += 1\r\n    temp = []\r\n    import heapq\r\n    for key, v in d.items():\r\n        if len(temp) < k:\r\n            temp.append((v, key))\r\n            if len(temp) == k:\r\n                heapq.heapify(temp)\r\n        else:\r\n            if v > temp[0][0]:\r\n                heapq.heappop(temp)\r\n                heapq.heappush(temp, (v, key))\r\n    result = []\r\n    while temp:\r\n        v, key = heapq.heappop(temp)\r\n        result.append(key)\r\n    return result", "test_list": ["assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]", "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]", "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"], "context": "Write a function to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.", "function_name": "def func(nums, k):", "gold_generation": "import collections\r\n    d = collections.defaultdict(int)\r\n    for row in nums:\r\n        for i in row:\r\n            d[i] += 1\r\n    temp = []\r\n    import heapq\r\n    for key, v in d.items():\r\n        if len(temp) < k:\r\n            temp.append((v, key))\r\n            if len(temp) == k:\r\n                heapq.heapify(temp)\r\n        else:\r\n            if v > temp[0][0]:\r\n                heapq.heappop(temp)\r\n                heapq.heappush(temp, (v, key))\r\n    result = []\r\n    while temp:\r\n        v, key = heapq.heappop(temp)\r\n        result.append(key)\r\n    return result", "ctxs": [{"id": "20477", "text": "Function: python.library.heapq\nSnippet: heapq — Heap queue algorithm Source code: Lib/heapq.py This module provides an implementation of the heap queue algorithm, also known as the priority queue algorithm. Heaps are binary trees for which every parent node has a value less than or equal to any of its children. This implementation uses arrays for which heap[k] <= heap[2*k+1] and heap[k] <= heap[2*k+2] for all k, counting elements from zero. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that its smallest element is always the root, heap[0]. The API below differs from textbook heap algorithms in two aspects: (a) We use zero-based indexing. This makes the relationship between the index for a node and the indexes for its children slightly less obvious, but is more suitable since Python uses zero-based indexing. (b) Our pop method returns the smallest item, not the largest (called a “min heap” in textbooks; a “max heap” is more common in texts because of its suitability for in-place sorting). These two make it possible to view the heap as a regular Python list without surprises: heap[0] is the smallest item, and heap.sort() maintains the heap invariant! To create a heap, use a list initialized to [], or you can transform a populated list into a heap via function heapify(). The following functions are provided: heapq.heappush(heap, item) Push the value item onto the heap, maintaining the heap invariant. heapq.heappop(heap) Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0]. heapq.heappushpop(heap, item) Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop(). heapq.heapify(x) Transform list x into a heap, in-place, in linear time. heapq.heapreplace(heap, item) Pop and return the smallest item from the heap, and also push the new item. The heap size doesn’t change. If the heap is empty, IndexError is raised. This one step operation is more efficient than a heappop() followed by heappush() and can be more appropriate when using a fixed-size heap. The pop/push combination always returns an element from the heap and replaces it with item. The value returned may be larger than the item added. If that isn’t desired, consider using heappushpop() instead. Its push/pop combination returns the smaller of the two values, leaving the larger value on the heap. The module also offers three general purpose functions based on heaps. heapq.merge(*iterables, key=None, reverse=False) Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an iterator over the sorted values. Similar to sorted(itertools.chain(*iterables)) but returns an iterable, does not pull the data into memory all at once, and assumes that each of the input streams is already sorted (smallest to largest). Has two optional arguments which must be specified as keyword arguments. key specifies a", "score": "0.74881697"}, {"id": "20488", "text": "Function: python.library.heapq#heapq.nlargest\nSnippet: heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n].", "score": "0.708125"}, {"id": "20478", "text": "Function: python.library.heapq\nSnippet: key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters. heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n]. heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n]. The latter two functions perform best for smaller values of n. For larger values, it is more efficient to use the sorted() function. Also, when n==1, it is more efficient to use the built-in min() and max() functions. If repeated usage of these functions is required, consider turning the iterable into an actual heap. Basic Examples A heapsort can be implemented by pushing all values onto a heap and then popping off the smallest values one at a time: >>> def heapsort(iterable): ... h = [] ... for value in iterable: ... heappush(h, value) ... return [heappop(h) for i in range(len(h))] ... >>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] This is similar to sorted(iterable), but unlike sorted(), this implementation is not stable. Heap elements can be tuples. This is useful for assigning comparison values (such as task priorities) alongside the main record being tracked: >>> h = [] >>> heappush(h, (5, 'write code')) >>> heappush(h, (7, 'release product')) >>> heappush(h, (1, 'write spec')) >>> heappush(h, (3, 'create tests')) >>> heappop(h) (1, 'write spec') Priority Queue Implementation Notes A priority queue is common use for a heap, and it presents several implementation challenges: Sort stability: how do you get two tasks with equal priorities to be returned in the order they were originally added? Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order. If the priority of a task changes, how do you move it to a new position in the heap? Or if a pending task needs to be deleted, how do you find it and remove it from the queue? A solution to the first two challenges is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were", "score": "0.7036049"}, {"id": "20479", "text": "Function: python.library.heapq\nSnippet: added. And since no two entry counts are the same, the tuple comparison will never attempt to directly compare two tasks. Another solution to the problem of non-comparable tasks is to create a wrapper class that ignores the task item and only compares the priority field: from dataclasses import dataclass, field from typing import Any @dataclass(order=True) class PrioritizedItem: priority: int item: Any=field(compare=False) The remaining challenges revolve around finding a pending task and making changes to its priority or removing it entirely. Finding a task can be done with a dictionary pointing to an entry in the queue. Removing the entry or changing its priority is more difficult because it would break the heap structure invariants. So, a possible solution is to mark the entry as removed and add a new entry with the revised priority: pq = [] # list of entries arranged in a heap entry_finder = {} # mapping of tasks to entries REMOVED = '<removed-task>' # placeholder for a removed task counter = itertools.count() # unique sequence count def add_task(task, priority=0): 'Add a new task or update the priority of an existing task' if task in entry_finder: remove_task(task) count = next(counter) entry = [priority, count, task] entry_finder[task] = entry heappush(pq, entry) def remove_task(task): 'Mark an existing task as REMOVED. Raise KeyError if not found.' entry = entry_finder.pop(task) entry[-1] = REMOVED def pop_task(): 'Remove and return the lowest priority task. Raise KeyError if empty.' while pq: priority, count, task = heappop(pq) if task is not REMOVED: del entry_finder[task] return task raise KeyError('pop from an empty priority queue') Theory Heaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for all k, counting elements from 0. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that a[0] is always its smallest element. The strange invariant above is meant to be an efficient memory representation for a tournament. The numbers below are k, not a[k]: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 In the tree above, each cell k is topping 2*k+1 and 2*k+2. In a usual binary tournament we see in sports, each cell is the winner over the two cells it tops, and we can trace the winner down the tree to see all opponents s/he had. However, in many computer applications of such tournaments, we do not need to trace the history of a winner. To be more memory efficient, when a winner is promoted, we try to replace it by something else at a lower level, and the rule becomes that a cell and the two cells it tops contain three different items, but the top cell “wins” over the two topped cells. If this heap invariant is protected at all time, index 0 is clearly the overall winner. The simplest algorithmic way to remove it and find the “next”", "score": "0.7021401"}, {"id": "20480", "text": "Function: python.library.heapq\nSnippet: winner is to move some loser (let’s say cell 30 in the diagram above) into the 0 position, and then percolate this new 0 down the tree, exchanging values, until the invariant is re-established. This is clearly logarithmic on the total number of items in the tree. By iterating over all items, you get an O(n log n) sort. A nice feature of this sort is that you can efficiently insert new items while the sort is going on, provided that the inserted items are not “better” than the last 0’th element you extracted. This is especially useful in simulation contexts, where the tree holds all incoming events, and the “win” condition means the smallest scheduled time. When an event schedules other events for execution, they are scheduled into the future, so they can easily go into the heap. So, a heap is a good structure for implementing schedulers (this is what I used for my MIDI sequencer :-). Various structures for implementing schedulers have been extensively studied, and heaps are good for this, as they are reasonably speedy, the speed is almost constant, and the worst case is not much different than the average case. However, there are other representations which are more efficient overall, yet the worst cases might be terrible. Heaps are also very useful in big disk sorts. You most probably all know that a big sort implies producing “runs” (which are pre-sorted sequences, whose size is usually related to the amount of CPU memory), followed by a merging passes for these runs, which merging is often very cleverly organised 1. It is very important that the initial sort produces the longest runs possible. Tournaments are a good way to achieve that. If, using all the memory available to hold a tournament, you replace and percolate items that happen to fit the current run, you’ll produce runs which are twice the size of the memory for random input, and much better for input fuzzily ordered. Moreover, if you output the 0’th item on disk and get an input which may not fit in the current tournament (because the value “wins” over the last output value), it cannot fit in the heap, so the size of the heap decreases. The freed memory could be cleverly reused immediately for progressively building a second heap, which grows at exactly the same rate the first heap is melting. When the first heap completely vanishes, you switch heaps and start a new run. Clever and quite effective! In a word, heaps are useful memory structures to know. I use them in a few applications, and I think it is good to keep a ‘heap’ module around. :-) Footnotes 1 The disk balancing algorithms which are current, nowadays, are more annoying than clever, and this is a consequence of the seeking capabilities of the disks. On devices which cannot seek, like big tape drives, the story was quite different, and one had to be very clever to ensure (far in advance) that", "score": "0.69086766"}]}
{"task_id": "mbpp_32", "code": "import math \r\ndef max_Prime_Factors (n): \r\n    maxPrime = -1 \r\n    while n%2 == 0: \r\n        maxPrime = 2\r\n        n >>= 1    \r\n    for i in range(3,int(math.sqrt(n))+1,2): \r\n        while n % i == 0: \r\n            maxPrime = i \r\n            n = n / i \r\n    if n > 2: \r\n        maxPrime = n  \r\n    return int(maxPrime)", "test_list": ["assert max_Prime_Factors(15) == 5", "assert max_Prime_Factors(6) == 3", "assert max_Prime_Factors(2) == 2"], "context": "Write a python function to find the largest prime factor of a given number.", "function_name": "import math \r\ndef max_Prime_Factors (n):", "gold_generation": "maxPrime = -1 \r\n    while n%2 == 0: \r\n        maxPrime = 2\r\n        n >>= 1    \r\n    for i in range(3,int(math.sqrt(n))+1,2): \r\n        while n % i == 0: \r\n            maxPrime = i \r\n            n = n / i \r\n    if n > 2: \r\n        maxPrime = n  \r\n    return int(maxPrime)", "ctxs": [{"id": "19587", "text": "Function: python.library.decimal#decimal.MAX_PREC\nSnippet: decimal.MAX_PREC", "score": "0.65994734"}, {"id": "21805", "text": "Function: python.library.math#math.gcd\nSnippet: math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported.", "score": "0.6535566"}, {"id": "20457", "text": "Function: python.library.hashlib#hashlib.blake2b.MAX_KEY_SIZE\nSnippet: blake2b.MAX_KEY_SIZE", "score": "0.6484354"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6439864"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.6435582"}]}
{"task_id": "mbpp_33", "code": "def decimal_To_Binary(N): \r\n    B_Number = 0\r\n    cnt = 0\r\n    while (N != 0): \r\n        rem = N % 2\r\n        c = pow(10,cnt)  \r\n        B_Number += rem*c  \r\n        N //= 2 \r\n        cnt += 1\r\n    return B_Number  ", "test_list": ["assert decimal_To_Binary(10) == 1010", "assert decimal_To_Binary(1) == 1", "assert decimal_To_Binary(20) == 10100"], "context": "Write a python function to convert a decimal number to binary number.", "function_name": "def decimal_To_Binary(N):", "gold_generation": "B_Number = 0\r\n    cnt = 0\r\n    while (N != 0): \r\n        rem = N % 2\r\n        c = pow(10,cnt)  \r\n        B_Number += rem*c  \r\n        N //= 2 \r\n        cnt += 1\r\n    return B_Number", "ctxs": [{"id": "18215", "text": "Function: python.library.functions#bin\nSnippet: bin(x) Convert an integer number to a binary string prefixed with “0b”. The result is a valid Python expression. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> bin(3) '0b11' >>> bin(-10) '-0b1010' If prefix “0b” is desired or not, you can use either of the following ways. >>> format(14, '#b'), format(14, 'b') ('0b1110', '1110') >>> f'{14:#b}', f'{14:b}' ('0b1110', '1110') See also format() for more information.", "score": "0.7630241"}, {"id": "19516", "text": "Function: python.library.decimal#decimal.Decimal\nSnippet: class decimal.Decimal(value=\"0\", context=None) Construct a new Decimal object based from value. value can be an integer, string, tuple, float, or another Decimal object. If no value is given, returns Decimal('0'). If value is a string, it should conform to the decimal numeric string syntax after leading and trailing whitespace characters, as well as underscores throughout, are removed: sign ::= '+' | '-' digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' indicator ::= 'e' | 'E' digits ::= digit [digit]... decimal-part ::= digits '.' [digits] | ['.'] digits exponent-part ::= indicator [sign] digits infinity ::= 'Infinity' | 'Inf' nan ::= 'NaN' [digits] | 'sNaN' [digits] numeric-value ::= decimal-part [exponent-part] | infinity numeric-string ::= [sign] numeric-value | [sign] nan Other Unicode decimal digits are also permitted where digit appears above. These include decimal digits from various other alphabets (for example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits '\\uff10' through '\\uff19'. If value is a tuple, it should have three components, a sign (0 for positive or 1 for negative), a tuple of digits, and an integer exponent. For example, Decimal((0, (1, 4, 1, 4), -3)) returns Decimal('1.414'). If value is a float, the binary floating point value is losslessly converted to its exact decimal equivalent. This conversion can often require 53 or more digits of precision. For example, Decimal(float('1.1')) converts to Decimal('1.100000000000000088817841970012523233890533447265625'). The context precision does not affect how many digits are stored. That is determined exclusively by the number of digits in value. For example, Decimal('3.00000') records all five zeros even if the context precision is only three. The purpose of the context argument is determining what to do if value is a malformed string. If the context traps InvalidOperation, an exception is raised; otherwise, the constructor returns a new Decimal with the value of NaN. Once constructed, Decimal objects are immutable. Changed in version 3.2: The argument to the constructor is now permitted to be a float instance. Changed in version 3.3: float arguments raise an exception if the FloatOperation trap is set. By default the trap is off. Changed in version 3.6: Underscores are allowed for grouping, as with integral and floating-point literals in code. Decimal floating point objects share many properties with the other built-in numeric types such as float and int. All of the usual math operations and special methods apply. Likewise, decimal objects can be copied, pickled, printed, used as dictionary keys, used as set elements, compared, sorted, and coerced to another type (such as float or int). There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator % is applied to Decimal objects, the sign of the result is the sign of the dividend rather than the sign of the divisor: >>> (-7) % 4 1 >>> Decimal(-7) % Decimal(4) Decimal('-3') The integer division operator // behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather", "score": "0.7600186"}, {"id": "19536", "text": "Function: python.library.decimal#decimal.Decimal.from_float\nSnippet: from_float(f) Classmethod that converts a float to a decimal number, exactly. Note Decimal.from_float(0.1) is not the same as Decimal(‘0.1’). Since 0.1 is not exactly representable in binary floating point, the value is stored as the nearest representable value which is 0x1.999999999999ap-4. That equivalent value in decimal is 0.1000000000000000055511151231257827021181583404541015625. Note From Python 3.2 onwards, a Decimal instance can also be constructed directly from a float. >>> Decimal.from_float(0.1) Decimal('0.1000000000000000055511151231257827021181583404541015625') >>> Decimal.from_float(float('nan')) Decimal('NaN') >>> Decimal.from_float(float('inf')) Decimal('Infinity') >>> Decimal.from_float(float('-inf')) Decimal('-Infinity') New in version 3.1.", "score": "0.7469224"}, {"id": "19499", "text": "Function: python.library.decimal#decimal.Context.normalize\nSnippet: normalize(x) Reduces x to its simplest form.", "score": "0.7439907"}, {"id": "19442", "text": "Function: python.library.decimal\nSnippet: In developing fixed-point applications, it is convenient to define functions to handle the quantize() step: >>> def mul(x, y, fp=TWOPLACES): ... return (x * y).quantize(fp) >>> def div(x, y, fp=TWOPLACES): ... return (x / y).quantize(fp) >>> mul(a, b) # Automatically preserve fixed-point Decimal('325.62') >>> div(b, a) Decimal('0.03') Q. There are many ways to express the same value. The numbers 200, 200.000, 2E2, and 02E+4 all have the same value at various precisions. Is there a way to transform them to a single recognizable canonical value? A. The normalize() method maps all equivalent values to a single representative: >>> values = map(Decimal, '200 200.000 2E2 .02E+4'.split()) >>> [v.normalize() for v in values] [Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2')] Q. Some decimal values always print with exponential notation. Is there a way to get a non-exponential representation? A. For some values, exponential notation is the only way to express the number of significant places in the coefficient. For example, expressing 5.0E+3 as 5000 keeps the value constant but cannot show the original’s two-place significance. If an application does not care about tracking significance, it is easy to remove the exponent and trailing zeroes, losing significance, but keeping the value unchanged: >>> def remove_exponent(d): ... return d.quantize(Decimal(1)) if d == d.to_integral() else d.normalize() >>> remove_exponent(Decimal('5E+3')) Decimal('5000') Q. Is there a way to convert a regular float to a Decimal? A. Yes, any binary floating point number can be exactly expressed as a Decimal though an exact conversion may take more precision than intuition would suggest: >>> Decimal(math.pi) Decimal('3.141592653589793115997963468544185161590576171875') Q. Within a complex calculation, how can I make sure that I haven’t gotten a spurious result because of insufficient precision or rounding anomalies. A. The decimal module makes it easy to test results. A best practice is to re-run calculations using greater precision and with various rounding modes. Widely differing results indicate insufficient precision, rounding mode issues, ill-conditioned inputs, or a numerically unstable algorithm. Q. I noticed that context precision is applied to the results of operations but not to the inputs. Is there anything to watch out for when mixing values of different precisions? A. Yes. The principle is that all values are considered to be exact and so is the arithmetic on those values. Only the results are rounded. The advantage for inputs is that “what you type is what you get”. A disadvantage is that the results can look odd if you forget that the inputs haven’t been rounded: >>> getcontext().prec = 3 >>> Decimal('3.104') + Decimal('2.104') Decimal('5.21') >>> Decimal('3.104') + Decimal('0.000') + Decimal('2.104') Decimal('5.20') The solution is either to increase precision or to force rounding of inputs using the unary plus operation: >>> getcontext().prec = 3 >>> +Decimal('1.23456789') # unary plus triggers rounding Decimal('1.23') Alternatively, inputs can be rounded upon creation using the Context.create_decimal() method: >>> Context(prec=5, rounding=ROUND_DOWN).create_decimal('1.2345678') Decimal('1.2345') Q. Is the CPython implementation fast for large numbers? A. Yes. In the CPython and PyPy3 implementations, the C/CFFI versions of the decimal module integrate the high speed libmpdec library for arbitrary precision", "score": "0.7423688"}]}
{"task_id": "mbpp_34", "code": "def find_missing(ar,N): \r\n    l = 0\r\n    r = N - 1\r\n    while (l <= r):  \r\n        mid = (l + r) / 2\r\n        mid= int (mid) \r\n        if (ar[mid] != mid + 1 and ar[mid - 1] == mid): \r\n            return (mid + 1)  \r\n        elif (ar[mid] != mid + 1): \r\n            r = mid - 1 \r\n        else: \r\n            l = mid + 1\r\n    return (-1) ", "test_list": ["assert find_missing([1,2,3,5],4) == 4", "assert find_missing([1,3,4,5],4) == 2", "assert find_missing([1,2,3,5,6,7],5) == 4"], "context": "Write a python function to find the missing number in a sorted array.", "function_name": "def find_missing(ar,N):", "gold_generation": "l = 0\r\n    r = N - 1\r\n    while (l <= r):  \r\n        mid = (l + r) / 2\r\n        mid= int (mid) \r\n        if (ar[mid] != mid + 1 and ar[mid - 1] == mid): \r\n            return (mid + 1)  \r\n        elif (ar[mid] != mid + 1): \r\n            r = mid - 1 \r\n        else: \r\n            l = mid + 1\r\n    return (-1)", "ctxs": [{"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.68675756"}, {"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.6812921"}, {"id": "18241", "text": "Function: python.library.bisect\nSnippet: bisect — Array bisection algorithm Source code: Lib/bisect.py This module provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach. The module is called bisect because it uses a basic bisection algorithm to do its work. The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!). The following functions are provided: bisect.bisect_left(a, x, lo=0, hi=len(a)) Locate the insertion point for x in a to maintain sorted order. The parameters lo and hi may be used to specify a subset of the list which should be considered; by default the entire list is used. If x is already present in a, the insertion point will be before (to the left of) any existing entries. The return value is suitable for use as the first parameter to list.insert() assuming that a is already sorted. The returned insertion point i partitions the array a into two halves so that all(val < x for val in a[lo:i]) for the left side and all(val >= x for val in a[i:hi]) for the right side. bisect.bisect_right(a, x, lo=0, hi=len(a)) bisect.bisect(a, x, lo=0, hi=len(a)) Similar to bisect_left(), but returns an insertion point which comes after (to the right of) any existing entries of x in a. The returned insertion point i partitions the array a into two halves so that all(val <= x for val in a[lo:i]) for the left side and all(val > x for val in a[i:hi]) for the right side. bisect.insort_left(a, x, lo=0, hi=len(a)) Insert x in a in sorted order. This is equivalent to a.insert(bisect.bisect_left(a, x, lo, hi), x) assuming that a is already sorted. Keep in mind that the O(log n) search is dominated by the slow O(n) insertion step. bisect.insort_right(a, x, lo=0, hi=len(a)) bisect.insort(a, x, lo=0, hi=len(a)) Similar to insort_left(), but inserting x in a after any existing entries of x. See also SortedCollection recipe that uses bisect to build a full-featured collection class with straight-forward search methods and support for a key-function. The keys are precomputed to save unnecessary calls to the key function during searches. Searching Sorted Lists The above bisect() functions are useful for finding insertion points but can be tricky or awkward to use for common searching tasks. The following five functions show how to transform them into the standard lookups for sorted lists: def index(a, x): 'Locate the leftmost value exactly equal to x' i = bisect_left(a, x) if i != len(a) and a[i] == x: return i raise ValueError def find_lt(a, x): 'Find rightmost value less than x' i = bisect_left(a, x) if i: return a[i-1] raise ValueError def find_le(a, x): 'Find rightmost value less than or equal to x' i = bisect_right(a, x) if i: return a[i-1] raise ValueError def find_gt(a, x): 'Find leftmost value greater than x' i = bisect_right(a, x) if i != len(a): return", "score": "0.67933637"}, {"id": "43173", "text": "Function: numpy.reference.generated.numpy.searchsorted\nSnippet: numpy.searchsorted numpy.searchsorted(a, v, side='left', sorter=None)[source] Find indices where elements should be inserted to maintain order. Find the indices into a sorted array a such that, if the corresponding elements in v were inserted before the indices, the order of a would be preserved. Assuming that a is sorted: side returned index i satisfies left a[i-1] < v <= a[i] right a[i-1] <= v < a[i] Parameters a1-D array_like Input array. If sorter is None, then it must be sorted in ascending order, otherwise sorter must be an array of indices that sort it. varray_like Values to insert into a. side{‘left’, ‘right’}, optional If ‘left’, the index of the first suitable location found is given. If ‘right’, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of a). sorter1-D array_like, optional Optional array of integer indices that sort array a into ascending order. They are typically the result of argsort. New in version 1.7.0. Returns indicesint or array of ints Array of insertion points with the same shape as v, or an integer if v is a scalar. See also sort Return a sorted copy of an array. histogram Produce histogram from 1-D data. Notes Binary search is used to find the required insertion points. As of NumPy 1.4.0 searchsorted works with real/complex arrays containing nan values. The enhanced sort order is documented in sort. This function uses the same algorithm as the builtin python bisect.bisect_left (side='left') and bisect.bisect_right (side='right') functions, which is also vectorized in the v argument. Examples >>> np.searchsorted([1,2,3,4,5], 3) 2 >>> np.searchsorted([1,2,3,4,5], 3, side='right') 3 >>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3]) array([0, 5, 1, 2])", "score": "0.67885125"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.67770326"}]}
{"task_id": "mbpp_35", "code": "def find_rect_num(n):\r\n  return n*(n + 1) ", "test_list": ["assert find_rect_num(4) == 20", "assert find_rect_num(5) == 30", "assert find_rect_num(6) == 42"], "context": "Write a function to find the n-th rectangular number.", "function_name": "def find_rect_num(n):", "gold_generation": "return n*(n + 1)", "ctxs": [{"id": "43079", "text": "Function: numpy.reference.generated.numpy.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.6764736"}, {"id": "21812", "text": "Function: python.library.math#math.isqrt\nSnippet: math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8.", "score": "0.6671672"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.66589546"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.66094947"}, {"id": "14447", "text": "Function: pandas.reference.api.pandas.dataframe.radd\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.65622616"}]}
{"task_id": "mbpp_36", "code": "def find_Nth_Digit(p,q,N) :  \r\n    while (N > 0) : \r\n        N -= 1;  \r\n        p *= 10;  \r\n        res = p // q;  \r\n        p %= q;  \r\n    return res;  ", "test_list": ["assert find_Nth_Digit(1,2,1) == 5", "assert find_Nth_Digit(3,5,1) == 6", "assert find_Nth_Digit(5,6,5) == 3"], "context": "Write a python function to find the nth digit in the proper fraction of two given numbers.", "function_name": "def find_Nth_Digit(p,q,N) :", "gold_generation": "while (N > 0) : \r\n        N -= 1;  \r\n        p *= 10;  \r\n        res = p // q;  \r\n        p %= q;  \r\n    return res;", "ctxs": [{"id": "20203", "text": "Function: python.library.fractions#fractions.Fraction\nSnippet: a given floating-point number: >>> from fractions import Fraction >>> Fraction('3.1415926535897932').limit_denominator(1000) Fraction(355, 113) or for recovering a rational number that’s represented as a float: >>> from math import pi, cos >>> Fraction(cos(pi/3)) Fraction(4503599627370497, 9007199254740992) >>> Fraction(cos(pi/3)).limit_denominator() Fraction(1, 2) >>> Fraction(1.1).limit_denominator() Fraction(11, 10) __floor__() Returns the greatest int <= self. This method can also be accessed through the math.floor() function: >>> from math import floor >>> floor(Fraction(355, 113)) 3 __ceil__() Returns the least int >= self. This method can also be accessed through the math.ceil() function. __round__() __round__(ndigits) The first version returns the nearest int to self, rounding half to even. The second version rounds self to the nearest multiple of Fraction(1, 10**ndigits) (logically, if ndigits is negative), again rounding half toward even. This method can also be accessed through the round() function.", "score": "0.70160556"}, {"id": "19506", "text": "Function: python.library.decimal#decimal.Context.remainder_near\nSnippet: remainder_near(x, y) Returns x - y * n, where n is the integer nearest the exact value of x / y (if the result is 0 then its sign will be the sign of x).", "score": "0.7015513"}, {"id": "20201", "text": "Function: python.library.fractions\nSnippet: can also construct a Fraction instance directly from a decimal.Decimal instance. limit_denominator(max_denominator=1000000) Finds and returns the closest Fraction to self that has denominator at most max_denominator. This method is useful for finding rational approximations to a given floating-point number: >>> from fractions import Fraction >>> Fraction('3.1415926535897932').limit_denominator(1000) Fraction(355, 113) or for recovering a rational number that’s represented as a float: >>> from math import pi, cos >>> Fraction(cos(pi/3)) Fraction(4503599627370497, 9007199254740992) >>> Fraction(cos(pi/3)).limit_denominator() Fraction(1, 2) >>> Fraction(1.1).limit_denominator() Fraction(11, 10) __floor__() Returns the greatest int <= self. This method can also be accessed through the math.floor() function: >>> from math import floor >>> floor(Fraction(355, 113)) 3 __ceil__() Returns the least int >= self. This method can also be accessed through the math.ceil() function. __round__() __round__(ndigits) The first version returns the nearest int to self, rounding half to even. The second version rounds self to the nearest multiple of Fraction(1, 10**ndigits) (logically, if ndigits is negative), again rounding half toward even. This method can also be accessed through the round() function. See also Module numbers The abstract base classes making up the numeric tower.", "score": "0.69911087"}, {"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.69712716"}, {"id": "19565", "text": "Function: python.library.decimal#decimal.Decimal.remainder_near\nSnippet: remainder_near(other, context=None) Return the remainder from dividing self by other. This differs from self % other in that the sign of the remainder is chosen so as to minimize its absolute value. More precisely, the return value is self - n * other where n is the integer nearest to the exact value of self / other, and if two integers are equally near then the even one is chosen. If the result is zero then its sign will be the sign of self. >>> Decimal(18).remainder_near(Decimal(10)) Decimal('-2') >>> Decimal(25).remainder_near(Decimal(10)) Decimal('5') >>> Decimal(35).remainder_near(Decimal(10)) Decimal('-5')", "score": "0.69533664"}]}
{"task_id": "mbpp_37", "code": "def sort_mixed_list(mixed_list):\r\n    int_part = sorted([i for i in mixed_list if type(i) is int])\r\n    str_part = sorted([i for i in mixed_list if type(i) is str])\r\n    return int_part + str_part", "test_list": ["assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"], "context": "Write a function to sort a given mixed list of integers and strings.", "function_name": "def sort_mixed_list(mixed_list):", "gold_generation": "int_part = sorted([i for i in mixed_list if type(i) is int])\r\n    str_part = sorted([i for i in mixed_list if type(i) is str])\r\n    return int_part + str_part", "ctxs": [{"id": "41639", "text": "Function: numpy.reference.generated.numpy.char.chararray.argsort\nSnippet: numpy.char.chararray.argsort method char.chararray.argsort(axis=- 1, kind=None, order=None)[source] Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.70913076"}, {"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.70612335"}, {"id": "41764", "text": "Function: numpy.reference.generated.numpy.chararray.argsort\nSnippet: numpy.chararray.argsort method chararray.argsort(axis=- 1, kind=None, order=None)[source] Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.7026528"}, {"id": "41696", "text": "Function: numpy.reference.generated.numpy.char.chararray.sort\nSnippet: numpy.char.chararray.sort method char.chararray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.6995138"}, {"id": "43832", "text": "Function: numpy.reference.generated.numpy.recarray.argsort\nSnippet: numpy.recarray.argsort method recarray.argsort(axis=- 1, kind=None, order=None) Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.6993106"}]}
{"task_id": "mbpp_38", "code": "def div_even_odd(list1):\r\n    first_even = next((el for el in list1 if el%2==0),-1)\r\n    first_odd = next((el for el in list1 if el%2!=0),-1)\r\n    return (first_even/first_odd)", "test_list": ["assert div_even_odd([1,3,5,7,4,1,6,8])==4", "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2", "assert div_even_odd([1,5,7,9,10])==10"], "context": "Write a function to find the division of first even and odd number of a given list.", "function_name": "def div_even_odd(list1):", "gold_generation": "first_even = next((el for el in list1 if el%2==0),-1)\r\n    first_odd = next((el for el in list1 if el%2!=0),-1)\r\n    return (first_even/first_odd)", "ctxs": [{"id": "19597", "text": "Function: python.library.decimal#decimal.ROUND_HALF_EVEN\nSnippet: decimal.ROUND_HALF_EVEN Round to nearest with ties going to nearest even integer.", "score": "0.66660136"}, {"id": "42840", "text": "Function: numpy.reference.generated.numpy.floor_divide\nSnippet: numpy.floor_divide numpy.floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'floor_divide'> Return the largest integer smaller or equal to the division of the inputs. It is equivalent to the Python // operator and pairs with the Python % (remainder), function so that a = a % b + b * (a // b) up to roundoff. Parameters x1array_like Numerator. x2array_like Denominator. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray y = floor(x1/x2) This is a scalar if both x1 and x2 are scalars. See also remainder Remainder complementary to floor_divide. divmod Simultaneous floor division and remainder. divide Standard division. floor Round a number to the nearest integer toward minus infinity. ceil Round a number to the nearest integer toward infinity. Examples >>> np.floor_divide(7,3) 2 >>> np.floor_divide([1., 2., 3., 4.], 2.5) array([ 0., 0., 1., 1.]) The // operator can be used as a shorthand for np.floor_divide on ndarrays. >>> x1 = np.array([1., 2., 3., 4.]) >>> x1 // 2.5 array([0., 0., 1., 1.])", "score": "0.6594044"}, {"id": "14326", "text": "Function: pandas.reference.api.pandas.dataframe.divide\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6514351"}, {"id": "42794", "text": "Function: numpy.reference.generated.numpy.divide\nSnippet: numpy.divide numpy.divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'true_divide'> Returns a true division of the inputs, element-wise. Unlike ‘floor division’, true division adjusts the output type to present the best answer, regardless of input types. Parameters x1array_like Dividend array. x2array_like Divisor array. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar This is a scalar if both x1 and x2 are scalars. Notes In Python, // is the floor division operator and / the true division operator. The true_divide(x1, x2) function is equivalent to true division in Python. Examples >>> x = np.arange(5) >>> np.true_divide(x, 4) array([ 0. , 0.25, 0.5 , 0.75, 1. ]) >>> x/4 array([ 0. , 0.25, 0.5 , 0.75, 1. ]) >>> x//4 array([0, 0, 0, 0, 1]) The / operator can be used as a shorthand for np.true_divide on ndarrays. >>> x = np.arange(5) >>> x / 4 array([0. , 0.25, 0.5 , 0.75, 1. ])", "score": "0.6497649"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.64841866"}]}
{"task_id": "mbpp_39", "code": "import heapq\r\nfrom collections import Counter\r\ndef rearange_string(S):\r\n    ctr = Counter(S)\r\n    heap = [(-value, key) for key, value in ctr.items()]\r\n    heapq.heapify(heap)\r\n    if (-heap[0][0]) * 2 > len(S) + 1: \r\n        return \"\"\r\n    ans = []\r\n    while len(heap) >= 2:\r\n        nct1, char1 = heapq.heappop(heap)\r\n        nct2, char2 = heapq.heappop(heap)\r\n        ans.extend([char1, char2])\r\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\r\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\r\n    return \"\".join(ans) + (heap[0][1] if heap else \"\")", "test_list": ["assert rearange_string(\"aab\")==('aba')", "assert rearange_string(\"aabb\")==('abab')", "assert rearange_string(\"abccdd\")==('cdabcd')"], "context": "Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.", "function_name": "import heapq\r\nfrom collections import Counter\r\ndef rearange_string(S):", "gold_generation": "ctr = Counter(S)\r\n    heap = [(-value, key) for key, value in ctr.items()]\r\n    heapq.heapify(heap)\r\n    if (-heap[0][0]) * 2 > len(S) + 1: \r\n        return \"\"\r\n    ans = []\r\n    while len(heap) >= 2:\r\n        nct1, char1 = heapq.heappop(heap)\r\n        nct2, char2 = heapq.heappop(heap)\r\n        ans.extend([char1, char2])\r\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\r\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\r\n    return \"\".join(ans) + (heap[0][1] if heap else \"\")", "ctxs": [{"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6940024"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6898136"}, {"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.6873677"}, {"id": "41704", "text": "Function: numpy.reference.generated.numpy.char.chararray.swapcase\nSnippet: numpy.char.chararray.swapcase method char.chararray.swapcase()[source] For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. See also char.swapcase", "score": "0.6768226"}, {"id": "16533", "text": "Function: pandas.reference.series\nSnippet: of strings in the Series/Index. Series.str.rpartition([sep, expand]) Split the string at the last occurrence of sep. Series.str.rstrip([to_strip]) Remove trailing characters. Series.str.slice([start, stop, step]) Slice substrings from each element in the Series or Index. Series.str.slice_replace([start, stop, repl]) Replace a positional slice of a string with another value. Series.str.split([pat, n, expand, regex]) Split strings around given separator/delimiter. Series.str.rsplit([pat, n, expand]) Split strings around given separator/delimiter. Series.str.startswith(pat[, na]) Test if the start of each string element matches a pattern. Series.str.strip([to_strip]) Remove leading and trailing characters. Series.str.swapcase() Convert strings in the Series/Index to be swapcased. Series.str.title() Convert strings in the Series/Index to titlecase. Series.str.translate(table) Map all characters in the string through the given mapping table. Series.str.upper() Convert strings in the Series/Index to uppercase. Series.str.wrap(width, **kwargs) Wrap strings in Series/Index at specified line width. Series.str.zfill(width) Pad strings in the Series/Index by prepending '0' characters. Series.str.isalnum() Check whether all characters in each string are alphanumeric. Series.str.isalpha() Check whether all characters in each string are alphabetic. Series.str.isdigit() Check whether all characters in each string are digits. Series.str.isspace() Check whether all characters in each string are whitespace. Series.str.islower() Check whether all characters in each string are lowercase. Series.str.isupper() Check whether all characters in each string are uppercase. Series.str.istitle() Check whether all characters in each string are titlecase. Series.str.isnumeric() Check whether all characters in each string are numeric. Series.str.isdecimal() Check whether all characters in each string are decimal. Series.str.get_dummies([sep]) Return DataFrame of dummy/indicator variables for Series. Categorical accessor Categorical-dtype specific methods and attributes are available under the Series.cat accessor. Series.cat.categories The categories of this categorical. Series.cat.ordered Whether the categories have an ordered relationship. Series.cat.codes Return Series of codes as well as the index. Series.cat.rename_categories(*args, **kwargs) Rename categories. Series.cat.reorder_categories(*args, **kwargs) Reorder categories as specified in new_categories. Series.cat.add_categories(*args, **kwargs) Add new categories. Series.cat.remove_categories(*args, **kwargs) Remove the specified categories. Series.cat.remove_unused_categories(*args, ...) Remove categories which are not used. Series.cat.set_categories(*args, **kwargs) Set the categories to the specified new_categories. Series.cat.as_ordered(*args, **kwargs) Set the Categorical to be ordered. Series.cat.as_unordered(*args, **kwargs) Set the Categorical to be unordered. Sparse accessor Sparse-dtype specific methods and attributes are provided under the Series.sparse accessor. Series.sparse.npoints The number of non- fill_value points. Series.sparse.density The percent of non- fill_value points, as decimal. Series.sparse.fill_value Elements in data that are fill_value are not stored. Series.sparse.sp_values An ndarray containing the non- fill_value values. Series.sparse.from_coo(A[, dense_index]) Create a Series with sparse values from a scipy.sparse.coo_matrix. Series.sparse.to_coo([row_levels, ...]) Create a scipy.sparse.coo_matrix from a Series with MultiIndex. Flags Flags refer to attributes of the pandas object. Properties of the dataset (like the date is was recorded, the URL it was accessed from, etc.) should be stored in Series.attrs. Flags(obj, *, allows_duplicate_labels) Flags that apply to pandas objects. Metadata Series.attrs is a dictionary for storing global metadata for this Series. Warning Series.attrs is considered experimental and may change without warning. Series.attrs Dictionary of global attributes of this dataset. Plotting Series.plot is both a callable method and a namespace attribute for specific plotting methods of the form Series.plot.<kind>. Series.plot([kind, ax, figsize, ....]) Series plotting accessor and method Series.plot.area([x, y]) Draw a", "score": "0.67508364"}]}
{"task_id": "mbpp_40", "code": "from collections import Counter\r\nfrom itertools import chain\r\ndef freq_element(nums):\r\n  result = Counter(chain.from_iterable(nums))\r\n  return result", "test_list": ["assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})", "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})", "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"], "context": "Write a function to find frequency of the elements in a given list of lists using collections module.", "function_name": "from collections import Counter\r\nfrom itertools import chain\r\ndef freq_element(nums):", "gold_generation": "result = Counter(chain.from_iterable(nums))\r\n  return result", "ctxs": [{"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.71254253"}, {"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.6920731"}, {"id": "14927", "text": "Function: pandas.reference.api.pandas.period.freq\nSnippet: pandas.Period.freq Period.freq", "score": "0.6900423"}, {"id": "18655", "text": "Function: python.library.collections#collections.Counter.most_common\nSnippet: most_common([n]) Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered in the order first encountered: >>> Counter('abracadabra').most_common(3) [('a', 5), ('b', 2), ('r', 2)]", "score": "0.6856785"}, {"id": "18614", "text": "Function: python.library.collections\nSnippet: 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0 # http://en.wikipedia.org/wiki/Moving_average it = iter(iterable) d = deque(itertools.islice(it, n-1)) d.appendleft(0) s = sum(d) for elem in it: s += elem - d.popleft() d.append(elem) yield s / n A round-robin scheduler can be implemented with input iterators stored in a deque. Values are yielded from the active iterator in position zero. If that iterator is exhausted, it can be removed with popleft(); otherwise, it can be cycled back to the end with the rotate() method: def roundrobin(*iterables): \"roundrobin('ABC', 'D', 'EF') --> A D E B F C\" iterators = deque(map(iter, iterables)) while iterators: try: while True: yield next(iterators[0]) iterators.rotate(-1) except StopIteration: # Remove an exhausted iterator. iterators.popleft() The rotate() method provides a way to implement deque slicing and deletion. For example, a pure Python implementation of del d[n] relies on the rotate() method to position elements to be popped: def delete_nth(d, n): d.rotate(-n) d.popleft() d.rotate(n) To implement deque slicing, use a similar approach applying rotate() to bring a target element to the left side of the deque. Remove old entries with popleft(), add new entries with extend(), and then reverse the rotation. With minor variations on that approach, it is easy to implement Forth style stack manipulations such as dup, drop, swap, over, pick, rot, and roll. defaultdict objects class collections.defaultdict([default_factory[, ...]]) Returns a new dictionary-like object. defaultdict is a subclass of the built-in dict class. It overrides one method and adds one writable instance variable. The remaining functionality is the same as for the dict class and is not documented here. The first argument provides the initial value for the default_factory attribute; it defaults to None. All remaining arguments are treated the same as if they were passed to the dict constructor, including keyword arguments. defaultdict objects support the following method in addition to the standard dict operations: __missing__(key) If the default_factory attribute is None, this raises a KeyError exception with the key as argument. If default_factory is not None, it is called without arguments to provide a default value for the given key, this value is inserted in the dictionary for the key, and returned. If calling default_factory raises an exception this exception is propagated unchanged. This method is called by the __getitem__() method of the dict class when the requested key is not found; whatever it returns or raises is then returned or raised by __getitem__(). Note that __missing__() is not called for any operations besides __getitem__(). This means that get() will, like normal dictionaries, return None as a default rather than using default_factory. defaultdict objects support the following instance variable: default_factory This attribute is used by the __missing__() method; it is initialized from the first argument to the constructor, if present, or to None, if absent. Changed in version 3.9: Added merge (|) and update (|=) operators, specified in PEP 584. defaultdict Examples Using list as the default_factory, it is easy to group a sequence of key-value pairs into a dictionary of lists: >>> s = [('yellow',", "score": "0.6784226"}]}
{"task_id": "mbpp_41", "code": "def filter_evennumbers(nums):\r\n even_nums = list(filter(lambda x: x%2 == 0, nums))\r\n return even_nums", "test_list": ["assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]", "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]", "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"], "context": "Write a function to filter even numbers using lambda function.", "function_name": "def filter_evennumbers(nums):", "gold_generation": "even_nums = list(filter(lambda x: x%2 == 0, nums))\r\n return even_nums", "ctxs": [{"id": "21296", "text": "Function: python.library.itertools\nSnippet: D E B F C\" # Recipe credited to George Sakkis num_active = len(iterables) nexts = cycle(iter(it).__next__ for it in iterables) while num_active: try: for next in nexts: yield next() except StopIteration: # Remove the iterator we just exhausted from the cycle. num_active -= 1 nexts = cycle(islice(nexts, num_active)) def partition(pred, iterable): \"Use a predicate to partition entries into false entries and true entries\" # partition(is_odd, range(10)) --> 0 2 4 6 8 and 1 3 5 7 9 t1, t2 = tee(iterable) return filterfalse(pred, t1), filter(pred, t2) def powerset(iterable): \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\" s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s)+1)) def unique_everseen(iterable, key=None): \"List unique elements, preserving order. Remember all elements ever seen.\" # unique_everseen('AAAABBBCCDAABBB') --> A B C D # unique_everseen('ABBCcAD', str.lower) --> A B C D seen = set() seen_add = seen.add if key is None: for element in filterfalse(seen.__contains__, iterable): seen_add(element) yield element else: for element in iterable: k = key(element) if k not in seen: seen_add(k) yield element def unique_justseen(iterable, key=None): \"List unique elements, preserving order. Remember only the element just seen.\" # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B # unique_justseen('ABBCcAD', str.lower) --> A B C A D return map(next, map(operator.itemgetter(1), groupby(iterable, key))) def iter_except(func, exception, first=None): \"\"\" Call a function repeatedly until an exception is raised. Converts a call-until-exception interface to an iterator interface. Like builtins.iter(func, sentinel) but uses an exception instead of a sentinel to end the loop. Examples: iter_except(functools.partial(heappop, h), IndexError) # priority queue iterator iter_except(d.popitem, KeyError) # non-blocking dict iterator iter_except(d.popleft, IndexError) # non-blocking deque iterator iter_except(q.get_nowait, Queue.Empty) # loop over a producer Queue iter_except(s.pop, KeyError) # non-blocking set iterator \"\"\" try: if first is not None: yield first() # For database APIs needing an initial cast to db.first() while True: yield func() except exception: pass def first_true(iterable, default=False, pred=None): \"\"\"Returns the first true value in the iterable. If no true value is found, returns *default* If *pred* is not None, returns the first item for which pred(item) is true. \"\"\" # first_true([a,b,c], x) --> a or b or c or x # first_true([a,b], x, f) --> a if f(a) else b if f(b) else x return next(filter(pred, iterable), default) def random_product(*args, repeat=1): \"Random selection from itertools.product(*args, **kwds)\" pools = [tuple(pool) for pool in args] * repeat return tuple(map(random.choice, pools)) def random_permutation(iterable, r=None): \"Random selection from itertools.permutations(iterable, r)\" pool = tuple(iterable) r = len(pool) if r is None else r return tuple(random.sample(pool, r)) def random_combination(iterable, r): \"Random selection from itertools.combinations(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.sample(range(n), r)) return tuple(pool[i] for i in indices) def random_combination_with_replacement(iterable, r): \"Random selection from itertools.combinations_with_replacement(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.choices(range(n), k=r)) return tuple(pool[i] for i in indices) def nth_combination(iterable, r, index): \"Equivalent to list(combinations(iterable, r))[index]\" pool = tuple(iterable) n = len(pool) if r < 0 or r > n: raise ValueError c = 1 k = min(r, n-r) for i in range(1, k+1): c = c", "score": "0.66267633"}, {"id": "19597", "text": "Function: python.library.decimal#decimal.ROUND_HALF_EVEN\nSnippet: decimal.ROUND_HALF_EVEN Round to nearest with ties going to nearest even integer.", "score": "0.66081685"}, {"id": "20282", "text": "Function: python.library.functions\nSnippet: local dictionary, respectively, which may be useful to pass around for use as the second and third argument to exec(). Note The default locals act as described for function locals() below: modifications to the default locals dictionary should not be attempted. Pass an explicit locals dictionary if you need to see effects of the code on locals after function exec() returns. filter(function, iterable) Construct an iterator from those elements of iterable for which function returns true. iterable may be either a sequence, a container which supports iteration, or an iterator. If function is None, the identity function is assumed, that is, all elements of iterable that are false are removed. Note that filter(function, iterable) is equivalent to the generator expression (item for item in iterable if function(item)) if function is not None and (item for item in iterable if item) if function is None. See itertools.filterfalse() for the complementary function that returns elements of iterable for which function returns false. class float([x]) Return a floating point number constructed from a number or string x. If the argument is a string, it should contain a decimal number, optionally preceded by a sign, and optionally embedded in whitespace. The optional sign may be '+' or '-'; a '+' sign has no effect on the value produced. The argument may also be a string representing a NaN (not-a-number), or a positive or negative infinity. More precisely, the input must conform to the following grammar after leading and trailing whitespace characters are removed: sign ::= \"+\" | \"-\" infinity ::= \"Infinity\" | \"inf\" nan ::= \"nan\" numeric_value ::= floatnumber | infinity | nan numeric_string ::= [sign] numeric_value Here floatnumber is the form of a Python floating-point literal, described in Floating point literals. Case is not significant, so, for example, “inf”, “Inf”, “INFINITY” and “iNfINity” are all acceptable spellings for positive infinity. Otherwise, if the argument is an integer or a floating point number, a floating point number with the same value (within Python’s floating point precision) is returned. If the argument is outside the range of a Python float, an OverflowError will be raised. For a general Python object x, float(x) delegates to x.__float__(). If __float__() is not defined then it falls back to __index__(). If no argument is given, 0.0 is returned. Examples: >>> float('+1.23') 1.23 >>> float(' -12345\\n') -12345.0 >>> float('1e-003') 0.001 >>> float('+1E6') 1000000.0 >>> float('-Infinity') -inf The float type is described in Numeric Types — int, float, complex. Changed in version 3.6: Grouping digits with underscores as in code literals is allowed. Changed in version 3.7: x is now a positional-only parameter. Changed in version 3.8: Falls back to __index__() if __float__() is not defined. format(value[, format_spec]) Convert a value to a “formatted” representation, as controlled by format_spec. The interpretation of format_spec will depend on the type of the value argument, however there is a standard formatting syntax that is used by most built-in types: Format Specification Mini-Language. The default format_spec is an empty string which usually gives the same", "score": "0.65927124"}, {"id": "23266", "text": "Function: python.library.random\nSnippet: distribution. Conditions on the parameters are alpha > 0 and beta > 0. Returned values range between 0 and 1. random.expovariate(lambd) Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called “lambda”, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. random.gammavariate(alpha, beta) Gamma distribution. (Not the gamma function!) Conditions on the parameters are alpha > 0 and beta > 0. The probability distribution function is: x ** (alpha - 1) * math.exp(-x / beta) pdf(x) = -------------------------------------- math.gamma(alpha) * beta ** alpha random.gauss(mu, sigma) Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the normalvariate() function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe normalvariate() function instead. random.lognormvariate(mu, sigma) Log normal distribution. If you take the natural logarithm of this distribution, you’ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. random.normalvariate(mu, sigma) Normal distribution. mu is the mean, and sigma is the standard deviation. random.vonmisesvariate(mu, kappa) mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. random.paretovariate(alpha) Pareto distribution. alpha is the shape parameter. random.weibullvariate(alpha, beta) Weibull distribution. alpha is the scale parameter and beta is the shape parameter. Alternative Generator class random.Random([seed]) Class that implements the default pseudo-random number generator used by the random module. Deprecated since version 3.9: In the future, the seed must be one of the following types: NoneType, int, float, str, bytes, or bytearray. class random.SystemRandom([seed]) Class that uses the os.urandom() function for generating random numbers from sources provided by the operating system. Not available on all systems. Does not rely on software state, and sequences are not reproducible. Accordingly, the seed() method has no effect and is ignored. The getstate() and setstate() methods raise NotImplementedError if called. Notes on Reproducibility Sometimes it is useful to be able to reproduce the sequences given by a pseudo-random number generator. By re-using a seed value, the same sequence should be reproducible from run to run as long as multiple threads are not running. Most of the random module’s algorithms and seeding functions are subject to change across Python versions, but two aspects are guaranteed not to change: If a new seeding method is added, then a backward compatible seeder will be offered. The generator’s random() method will continue to produce", "score": "0.65525496"}, {"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.65395063"}]}
{"task_id": "mbpp_42", "code": "def find_Sum(arr,n): \r\n    return sum([x for x in arr if arr.count(x) > 1])", "test_list": ["assert find_Sum([1,2,3,1,1,4,5,6],8) == 3", "assert find_Sum([1,2,3,1,1],5) == 3", "assert find_Sum([1,1,2],3) == 2"], "context": "Write a python function to find the sum of repeated elements in a given array.", "function_name": "def find_Sum(arr,n):", "gold_generation": "return sum([x for x in arr if arr.count(x) > 1])", "ctxs": [{"id": "43844", "text": "Function: numpy.reference.generated.numpy.recarray.cumsum\nSnippet: numpy.recarray.cumsum method recarray.cumsum(axis=None, dtype=None, out=None) Return the cumulative sum of the elements along the given axis. Refer to numpy.cumsum for full documentation. See also numpy.cumsum equivalent function", "score": "0.7364092"}, {"id": "43881", "text": "Function: numpy.reference.generated.numpy.recarray.sum\nSnippet: numpy.recarray.sum method recarray.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True) Return the sum of the array elements over the given axis. Refer to numpy.sum for full documentation. See also numpy.sum equivalent function", "score": "0.72856146"}, {"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.7201872"}, {"id": "43869", "text": "Function: numpy.reference.generated.numpy.recarray.repeat\nSnippet: numpy.recarray.repeat method recarray.repeat(repeats, axis=None) Repeat elements of an array. Refer to numpy.repeat for full documentation. See also numpy.repeat equivalent function", "score": "0.7148521"}, {"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.70918095"}]}
{"task_id": "mbpp_43", "code": "import re\r\ndef text_match(text):\r\n  patterns = '^[a-z]+_[a-z]+$'\r\n  if re.search(patterns,  text):\r\n    return ('Found a match!')\r\n  else:\r\n    return ('Not matched!')", "test_list": ["assert text_match(\"aab_cbbbc\") == 'Found a match!'", "assert text_match(\"aab_Abbbc\") == 'Not matched!'", "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"], "context": "Write a function to find sequences of lowercase letters joined with an underscore using regex.", "function_name": "import re\r\ndef text_match(text):", "gold_generation": "patterns = '^[a-z]+_[a-z]+$'\r\n  if re.search(patterns,  text):\r\n    return ('Found a match!')\r\n  else:\r\n    return ('Not matched!')", "ctxs": [{"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.70682883"}, {"id": "23304", "text": "Function: python.library.re\nSnippet: Similar to positive lookbehind assertions, the contained pattern must only match strings of some fixed length. Patterns which start with negative lookbehind assertions may match at the beginning of the string being searched. (?(id/name)yes-pattern|no-pattern) Will try to match with yes-pattern if the group with given id or name exists, and with no-pattern if it doesn’t. no-pattern is optional and can be omitted. For example, (<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$) is a poor email matching pattern, which will match with '<user@host.com>' as well as 'user@host.com', but not with '<user@host.com' nor 'user@host.com>'. The special sequences consist of '\\' and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, \\$ matches the character '$'. \\number Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, (.+) \\1 matches 'the the' or '55 55', but not 'thethe' (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the '[' and ']' of a character class, all numeric escapes are treated as characters. \\A Matches only at the start of the string. \\b Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of word characters. Note that formally, \\b is defined as the boundary between a \\w and a \\W character (or vice versa), or between \\w and the beginning/end of the string. This means that r'\\bfoo\\b' matches 'foo', 'foo.', '(foo)', 'bar foo baz' but not 'foobar' or 'foo3'. By default Unicode alphanumerics are the ones used in Unicode patterns, but this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. Inside a character range, \\b represents the backspace character, for compatibility with Python’s string literals. \\B Matches the empty string, but only when it is not at the beginning or end of a word. This means that r'py\\B' matches 'python', 'py3', 'py2', but not 'py', 'py.', or 'py!'. \\B is just the opposite of \\b, so word characters in Unicode patterns are Unicode alphanumerics or the underscore, although this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. \\d For Unicode (str) patterns: Matches any Unicode decimal digit (that is, any character in Unicode character category [Nd]). This includes [0-9], and also many other digit characters. If the ASCII flag is used only [0-9] is matched. For 8-bit (bytes) patterns: Matches any decimal digit; this is equivalent to [0-9]. \\D Matches any character which is not a decimal digit. This is the opposite of \\d. If the", "score": "0.69746256"}, {"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.69677246"}, {"id": "23300", "text": "Function: python.library.re\nSnippet: For further information and a gentler presentation, consult the Regular Expression HOWTO. Regular expressions can contain both special and ordinary characters. Most ordinary characters, like 'A', 'a', or '0', are the simplest regular expressions; they simply match themselves. You can concatenate ordinary characters, so last matches the string 'last'. (In the rest of this section, we’ll write RE’s in this special style, usually without quotes, and strings to be matched 'in single quotes'.) Some characters, like '|' or '(', are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. Repetition qualifiers (*, +, ?, {m,n}, etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix ?, and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression (?:a{6})* matches any multiple of six 'a' characters. The special characters are: . (Dot.) In the default mode, this matches any character except a newline. If the DOTALL flag has been specified, this matches any character including a newline. ^ (Caret.) Matches the start of the string, and in MULTILINE mode also matches immediately after each newline. $ Matches the end of the string or just before the newline at the end of the string, and in MULTILINE mode also matches before a newline. foo matches both ‘foo’ and ‘foobar’, while the regular expression foo$ matches only ‘foo’. More interestingly, searching for foo.$ in 'foo1\\nfoo2\\n' matches ‘foo2’ normally, but ‘foo1’ in MULTILINE mode; searching for a single $ in 'foo\\n' will find two (empty) matches: one just before the newline, and one at the end of the string. * Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. ab* will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s. + Causes the resulting RE to match 1 or more repetitions of the preceding RE. ab+ will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’. ? Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. ab? will match either ‘a’ or ‘ab’. *?, +?, ?? The '*', '+', and '?' qualifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE <.*> is matched against '<a> b <c>', it will match the entire string, and not just '<a>'. Adding ? after the qualifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using the RE <.*?> will match only '<a>'. {m} Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, a{6} will match exactly six 'a' characters, but not five. {m,n} Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many", "score": "0.69315743"}, {"id": "23369", "text": "Function: python.library.re#re.sub\nSnippet: re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern are replaced only when not adjacent to a previous empty match, so sub('x*', '-', 'abxd') returns '-a-b--d-'. In string-type repl arguments, in addition to the character escapes and backreferences described above, \\g<name> will use the substring matched by the group named name, as defined by the (?P<name>...) syntax. \\g<number> uses the corresponding group number; \\g<2> is therefore equivalent to \\2, but isn’t ambiguous in a replacement such as \\g<2>0. \\20 would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character '0'. The backreference \\g<0> substitutes in the entire substring matched by the RE. Changed in version 3.1: Added the optional flags argument. Changed in version 3.5: Unmatched groups are replaced with an empty string. Changed in version 3.6: Unknown escapes in pattern consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Unknown escapes in repl consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Empty matches for the pattern are replaced when adjacent to a previous non-empty match.", "score": "0.68967295"}]}
{"task_id": "mbpp_44", "code": "import re\r\ndef text_match_string(text):\r\n        patterns = '^\\w+'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return 'Not matched!'", "test_list": ["assert text_match_string(\" python\")==('Not matched!')", "assert text_match_string(\"python\")==('Found a match!')", "assert text_match_string(\"  lang\")==('Not matched!')"], "context": "Write a function that matches a word at the beginning of a string.", "function_name": "import re\r\ndef text_match_string(text):", "gold_generation": "patterns = '^\\w+'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return 'Not matched!'", "ctxs": [{"id": "23310", "text": "Function: python.library.re\nSnippet: for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\" Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). Pattern.fullmatch(string[, pos[, endpos]]) If the whole string matches this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o[gh]\") >>> pattern.fullmatch(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.fullmatch(\"ogre\") # No match as not the full string matches. >>> pattern.fullmatch(\"doggie\", 1, 3) # Matches within given limits. <re.Match object; span=(1, 3), match='og'> New in version 3.4. Pattern.split(string, maxsplit=0) Identical to the split() function, using the compiled pattern. Pattern.findall(string[, pos[, endpos]]) Similar to the findall() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.finditer(string[, pos[, endpos]]) Similar to the finditer() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.sub(repl, string, count=0) Identical to the sub() function, using the compiled pattern. Pattern.subn(repl, string, count=0) Identical to the subn() function, using the compiled pattern. Pattern.flags The regex", "score": "0.70497686"}, {"id": "23359", "text": "Function: python.library.re#re.Pattern.match\nSnippet: Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()).", "score": "0.7044808"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.69982517"}, {"id": "23337", "text": "Function: python.library.re#re.match\nSnippet: re.match(pattern, string, flags=0) If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. Note that even in MULTILINE mode, re.match() will only match at the beginning of the string and not at the beginning of each line. If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()).", "score": "0.69571877"}, {"id": "23307", "text": "Function: python.library.re\nSnippet: '^' matches only at the beginning of the string, and '$' only at the end of the string and immediately before the newline (if any) at the end of the string. Corresponds to the inline flag (?m). re.S re.DOTALL Make the '.' special character match any character at all, including a newline; without this flag, '.' will match anything except a newline. Corresponds to the inline flag (?s). re.X re.VERBOSE This flag allows you to write regular expressions that look nicer and are more readable by allowing you to visually separate logical sections of the pattern and add comments. Whitespace within the pattern is ignored, except when in a character class, or when preceded by an unescaped backslash, or within tokens like *?, (?: or (?P<...>. When a line contains a # that is not in a character class and is not preceded by an unescaped backslash, all characters from the leftmost such # through the end of the line are ignored. This means that the two following regular expression objects that match a decimal number are functionally equal: a = re.compile(r\"\"\"\\d + # the integral part \\. # the decimal point \\d * # some fractional digits\"\"\", re.X) b = re.compile(r\"\\d+\\.\\d*\") Corresponds to the inline flag (?x). re.search(pattern, string, flags=0) Scan through string looking for the first location where the regular expression pattern produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. re.match(pattern, string, flags=0) If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. Note that even in MULTILINE mode, re.match() will only match at the beginning of the string and not at the beginning of each line. If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). re.fullmatch(pattern, string, flags=0) If the whole string matches the regular expression pattern, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. New in version 3.4. re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string,", "score": "0.6948942"}]}
{"task_id": "mbpp_45", "code": "def find_gcd(x, y): \r\n\twhile(y): \r\n\t\tx, y = y, x % y \r\n\treturn x \r\ndef get_gcd(l):\r\n  num1 = l[0]\r\n  num2 = l[1]\r\n  gcd = find_gcd(num1, num2)\r\n  for i in range(2, len(l)):\r\n    gcd = find_gcd(gcd, l[i])\r\n  return gcd", "test_list": ["assert get_gcd([2, 4, 6, 8, 16]) == 2", "assert get_gcd([1, 2, 3]) == 1", "assert get_gcd([2, 4, 6, 8]) == 2 "], "context": "Write a function to find the gcd of the given array elements.", "function_name": "def find_gcd(x, y):", "gold_generation": "while(y): \r\n\t\tx, y = y, x % y \r\n\treturn x \r\ndef get_gcd(l):\r\n  num1 = l[0]\r\n  num2 = l[1]\r\n  gcd = find_gcd(num1, num2)\r\n  for i in range(2, len(l)):\r\n    gcd = find_gcd(gcd, l[i])\r\n  return gcd", "ctxs": [{"id": "42857", "text": "Function: numpy.reference.generated.numpy.gcd\nSnippet: numpy.gcd numpy.gcd(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'gcd'> Returns the greatest common divisor of |x1| and |x2| Parameters x1, x2array_like, int Arrays of values. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). Returns yndarray or scalar The greatest common divisor of the absolute value of the inputs This is a scalar if both x1 and x2 are scalars. See also lcm The lowest common multiple Examples >>> np.gcd(12, 20) 4 >>> np.gcd.reduce([15, 25, 35]) 5 >>> np.gcd(np.arange(6), 20) array([20, 1, 2, 1, 4, 5])", "score": "0.7417505"}, {"id": "21805", "text": "Function: python.library.math#math.gcd\nSnippet: math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported.", "score": "0.7395041"}, {"id": "6576", "text": "Function: torch.generated.torch.gcd#torch.gcd\nSnippet: torch.gcd(input, other, *, out=None) → Tensor Computes the element-wise greatest common divisor (GCD) of input and other. Both input and other must have integer types. Note This defines gcd(0,0)=0gcd(0, 0) = 0 . Parameters input (Tensor) – the input tensor. other (Tensor) – the second input tensor Keyword Arguments out (Tensor, optional) – the output tensor. Example: >>> a = torch.tensor([5, 10, 15]) >>> b = torch.tensor([3, 4, 5]) >>> torch.gcd(a, b) tensor([1, 2, 5]) >>> c = torch.tensor([3]) >>> torch.gcd(a, c) tensor([1, 1, 3])", "score": "0.73029006"}, {"id": "7862", "text": "Function: torch.tensors#torch.Tensor.gcd_\nSnippet: gcd_(other) → Tensor In-place version of gcd()", "score": "0.69167614"}, {"id": "7861", "text": "Function: torch.tensors#torch.Tensor.gcd\nSnippet: gcd(other) → Tensor See torch.gcd()", "score": "0.6812818"}]}
{"task_id": "mbpp_46", "code": "def test_distinct(data):\r\n  if len(data) == len(set(data)):\r\n    return True\r\n  else:\r\n    return False;", "test_list": ["assert test_distinct([1,5,7,9]) == True", "assert test_distinct([2,4,5,5,7,9]) == False", "assert test_distinct([1,2,3]) == True"], "context": "Write a python function to determine whether all the numbers are different from each other are not.", "function_name": "def test_distinct(data):", "gold_generation": "if len(data) == len(set(data)):\r\n    return True\r\n  else:\r\n    return False;", "ctxs": [{"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6946129"}, {"id": "19682", "text": "Function: python.library.dis#dis.hascompare\nSnippet: dis.hascompare Sequence of bytecodes of Boolean operations.", "score": "0.68285453"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.68119055"}, {"id": "19651", "text": "Function: python.library.difflib#difflib.SequenceMatcher.ratio\nSnippet: ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5", "score": "0.67884386"}, {"id": "19477", "text": "Function: python.library.decimal#decimal.Context.is_normal\nSnippet: is_normal(x) Returns True if x is a normal number; otherwise returns False.", "score": "0.6781644"}]}
{"task_id": "mbpp_47", "code": "def compute_Last_Digit(A,B): \r\n    variable = 1\r\n    if (A == B): \r\n        return 1\r\n    elif ((B - A) >= 5):  \r\n        return 0\r\n    else:   \r\n        for i in range(A + 1,B + 1): \r\n            variable = (variable * (i % 10)) % 10\r\n        return variable % 10", "test_list": ["assert compute_Last_Digit(2,4) == 2", "assert compute_Last_Digit(6,8) == 6", "assert compute_Last_Digit(1,2) == 2"], "context": "Write a python function to find the last digit when factorial of a divides factorial of b.", "function_name": "def compute_Last_Digit(A,B):", "gold_generation": "variable = 1\r\n    if (A == B): \r\n        return 1\r\n    elif ((B - A) >= 5):  \r\n        return 0\r\n    else:   \r\n        for i in range(A + 1,B + 1): \r\n            variable = (variable * (i % 10)) % 10\r\n        return variable % 10", "ctxs": [{"id": "21799", "text": "Function: python.library.math#math.factorial\nSnippet: math.factorial(x) Return x factorial as an integer. Raises ValueError if x is not integral or is negative. Deprecated since version 3.9: Accepting floats with integral values (like 5.0) is deprecated.", "score": "0.70807284"}, {"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.69210255"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.678408"}, {"id": "22396", "text": "Function: python.library.operator#operator.__sub__\nSnippet: operator.sub(a, b) operator.__sub__(a, b) Return a - b.", "score": "0.67495275"}, {"id": "42840", "text": "Function: numpy.reference.generated.numpy.floor_divide\nSnippet: numpy.floor_divide numpy.floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'floor_divide'> Return the largest integer smaller or equal to the division of the inputs. It is equivalent to the Python // operator and pairs with the Python % (remainder), function so that a = a % b + b * (a // b) up to roundoff. Parameters x1array_like Numerator. x2array_like Denominator. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray y = floor(x1/x2) This is a scalar if both x1 and x2 are scalars. See also remainder Remainder complementary to floor_divide. divmod Simultaneous floor division and remainder. divide Standard division. floor Round a number to the nearest integer toward minus infinity. ceil Round a number to the nearest integer toward infinity. Examples >>> np.floor_divide(7,3) 2 >>> np.floor_divide([1., 2., 3., 4.], 2.5) array([ 0., 0., 1., 1.]) The // operator can be used as a shorthand for np.floor_divide on ndarrays. >>> x1 = np.array([1., 2., 3., 4.]) >>> x1 // 2.5 array([0., 0., 1., 1.])", "score": "0.66448224"}]}
{"task_id": "mbpp_48", "code": "def odd_bit_set_number(n):\r\n    count = 0;res = 0;temp = n\r\n    while temp > 0:\r\n        if count % 2 == 0:\r\n            res |= (1 << count)\r\n        count += 1\r\n        temp >>= 1\r\n    return (n | res)", "test_list": ["assert odd_bit_set_number(10) == 15", "assert odd_bit_set_number(20) == 21", "assert odd_bit_set_number(30) == 31"], "context": "Write a python function to set all odd bits of a given number.", "function_name": "def odd_bit_set_number(n):", "gold_generation": "count = 0;res = 0;temp = n\r\n    while temp > 0:\r\n        if count % 2 == 0:\r\n            res |= (1 << count)\r\n        count += 1\r\n        temp >>= 1\r\n    return (n | res)", "ctxs": [{"id": "7760", "text": "Function: torch.tensors#torch.Tensor.bitwise_xor_\nSnippet: bitwise_xor_() → Tensor In-place version of bitwise_xor()", "score": "0.6915565"}, {"id": "7759", "text": "Function: torch.tensors#torch.Tensor.bitwise_xor\nSnippet: bitwise_xor() → Tensor See torch.bitwise_xor()", "score": "0.68114364"}, {"id": "19487", "text": "Function: python.library.decimal#decimal.Context.logical_invert\nSnippet: logical_invert(x) Invert all the digits in x.", "score": "0.67749405"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.67749333"}, {"id": "7758", "text": "Function: torch.tensors#torch.Tensor.bitwise_or_\nSnippet: bitwise_or_() → Tensor In-place version of bitwise_or()", "score": "0.6754968"}]}
{"task_id": "mbpp_49", "code": "def specified_element(nums, N):\r\n    result = [i[N] for i in nums]\r\n    return result\r\n    ", "test_list": ["assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]", "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]", "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"], "context": "Write a function to extract every first or specified element from a given two-dimensional list.", "function_name": "def specified_element(nums, N):", "gold_generation": "result = [i[N] for i in nums]\r\n    return result", "ctxs": [{"id": "20295", "text": "Function: python.library.functions\nSnippet: aggregates elements from each of the iterables. Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator. Equivalent to: def zip(*iterables): # zip('ABCD', 'xy') --> Ax By sentinel = object() iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using zip(*[iter(s)]*n). This repeats the same iterator n times so that each output tuple has the result of n calls to the iterator. This has the effect of dividing the input into n-length chunks. zip() should only be used with unequal length inputs when you don’t care about trailing, unmatched values from the longer iterables. If those values are important, use itertools.zip_longest() instead. zip() in conjunction with the * operator can be used to unzip a list: >>> x = [1, 2, 3] >>> y = [4, 5, 6] >>> zipped = zip(x, y) >>> list(zipped) [(1, 4), (2, 5), (3, 6)] >>> x2, y2 = zip(*zip(x, y)) >>> x == list(x2) and y == list(y2) True __import__(name, globals=None, locals=None, fromlist=(), level=0) Note This is an advanced function that is not needed in everyday Python programming, unlike importlib.import_module(). This function is invoked by the import statement. It can be replaced (by importing the builtins module and assigning to builtins.__import__) in order to change semantics of the import statement, but doing so is strongly discouraged as it is usually simpler to use import hooks (see PEP 302) to attain the same goals and does not cause issues with code which assumes the default import implementation is in use. Direct use of __import__() is also discouraged in favor of importlib.import_module(). The function imports the module name, potentially using the given globals and locals to determine how to interpret the name in a package context. The fromlist gives the names of objects or submodules that should be imported from the module given by name. The standard implementation does not use its locals argument at all, and uses its globals only to determine the package context of the import statement. level specifies whether to use absolute or relative imports. 0 (the default) means only perform absolute imports. Positive values for level indicate the number of parent directories to search relative to the directory of the module calling __import__() (see PEP 328 for the details). When the name variable is of the form package.module, normally, the top-level package (the name up till the first dot) is returned, not the module named by name. However, when a non-empty fromlist argument is given, the module named by name is returned. For example, the statement import spam results", "score": "0.65062624"}, {"id": "41706", "text": "Function: numpy.reference.generated.numpy.char.chararray.take\nSnippet: numpy.char.chararray.take method char.chararray.take(indices, axis=None, out=None, mode='raise') Return an array formed from the elements of a at the given indices. Refer to numpy.take for full documentation. See also numpy.take equivalent function", "score": "0.64951855"}, {"id": "21309", "text": "Function: python.library.itertools#itertools.islice\nSnippet: itertools.islice(iterable, stop) itertools.islice(iterable, start, stop[, step]) Make an iterator that returns selected elements from the iterable. If start is non-zero, then elements from the iterable are skipped until start is reached. Afterward, elements are returned consecutively unless step is set higher than one which results in items being skipped. If stop is None, then iteration continues until the iterator is exhausted, if at all; otherwise, it stops at the specified position. Unlike regular slicing, islice() does not support negative values for start, stop, or step. Can be used to extract related fields from data where the internal structure has been flattened (for example, a multi-line report may list a name field on every third line). Roughly equivalent to: def islice(iterable, *args): # islice('ABCDEFG', 2) --> A B # islice('ABCDEFG', 2, 4) --> C D # islice('ABCDEFG', 2, None) --> C D E F G # islice('ABCDEFG', 0, None, 2) --> A C E G s = slice(*args) start, stop, step = s.start or 0, s.stop or sys.maxsize, s.step or 1 it = iter(range(start, stop, step)) try: nexti = next(it) except StopIteration: # Consume *iterable* up to the *start* position. for i, element in zip(range(start), iterable): pass return try: for i, element in enumerate(iterable): if i == nexti: yield element nexti = next(it) except StopIteration: # Consume to *stop*. for i, element in zip(range(i + 1, stop), iterable): pass If start is None, then iteration starts at zero. If step is None, then the step defaults to one.", "score": "0.6488346"}, {"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.648813"}, {"id": "21296", "text": "Function: python.library.itertools\nSnippet: D E B F C\" # Recipe credited to George Sakkis num_active = len(iterables) nexts = cycle(iter(it).__next__ for it in iterables) while num_active: try: for next in nexts: yield next() except StopIteration: # Remove the iterator we just exhausted from the cycle. num_active -= 1 nexts = cycle(islice(nexts, num_active)) def partition(pred, iterable): \"Use a predicate to partition entries into false entries and true entries\" # partition(is_odd, range(10)) --> 0 2 4 6 8 and 1 3 5 7 9 t1, t2 = tee(iterable) return filterfalse(pred, t1), filter(pred, t2) def powerset(iterable): \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\" s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s)+1)) def unique_everseen(iterable, key=None): \"List unique elements, preserving order. Remember all elements ever seen.\" # unique_everseen('AAAABBBCCDAABBB') --> A B C D # unique_everseen('ABBCcAD', str.lower) --> A B C D seen = set() seen_add = seen.add if key is None: for element in filterfalse(seen.__contains__, iterable): seen_add(element) yield element else: for element in iterable: k = key(element) if k not in seen: seen_add(k) yield element def unique_justseen(iterable, key=None): \"List unique elements, preserving order. Remember only the element just seen.\" # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B # unique_justseen('ABBCcAD', str.lower) --> A B C A D return map(next, map(operator.itemgetter(1), groupby(iterable, key))) def iter_except(func, exception, first=None): \"\"\" Call a function repeatedly until an exception is raised. Converts a call-until-exception interface to an iterator interface. Like builtins.iter(func, sentinel) but uses an exception instead of a sentinel to end the loop. Examples: iter_except(functools.partial(heappop, h), IndexError) # priority queue iterator iter_except(d.popitem, KeyError) # non-blocking dict iterator iter_except(d.popleft, IndexError) # non-blocking deque iterator iter_except(q.get_nowait, Queue.Empty) # loop over a producer Queue iter_except(s.pop, KeyError) # non-blocking set iterator \"\"\" try: if first is not None: yield first() # For database APIs needing an initial cast to db.first() while True: yield func() except exception: pass def first_true(iterable, default=False, pred=None): \"\"\"Returns the first true value in the iterable. If no true value is found, returns *default* If *pred* is not None, returns the first item for which pred(item) is true. \"\"\" # first_true([a,b,c], x) --> a or b or c or x # first_true([a,b], x, f) --> a if f(a) else b if f(b) else x return next(filter(pred, iterable), default) def random_product(*args, repeat=1): \"Random selection from itertools.product(*args, **kwds)\" pools = [tuple(pool) for pool in args] * repeat return tuple(map(random.choice, pools)) def random_permutation(iterable, r=None): \"Random selection from itertools.permutations(iterable, r)\" pool = tuple(iterable) r = len(pool) if r is None else r return tuple(random.sample(pool, r)) def random_combination(iterable, r): \"Random selection from itertools.combinations(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.sample(range(n), r)) return tuple(pool[i] for i in indices) def random_combination_with_replacement(iterable, r): \"Random selection from itertools.combinations_with_replacement(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.choices(range(n), k=r)) return tuple(pool[i] for i in indices) def nth_combination(iterable, r, index): \"Equivalent to list(combinations(iterable, r))[index]\" pool = tuple(iterable) n = len(pool) if r < 0 or r > n: raise ValueError c = 1 k = min(r, n-r) for i in range(1, k+1): c = c", "score": "0.6483783"}]}
{"task_id": "mbpp_50", "code": "def min_length_list(input_list):\r\n    min_length = min(len(x) for x in input_list )  \r\n    min_list = min(input_list, key = lambda i: len(i))\r\n    return(min_length, min_list)", "test_list": ["assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])", "assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])", "assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])"], "context": "Write a function to find the list with minimum length using lambda function.", "function_name": "def min_length_list(input_list):", "gold_generation": "min_length = min(len(x) for x in input_list )  \r\n    min_list = min(input_list, key = lambda i: len(i))\r\n    return(min_length, min_list)", "ctxs": [{"id": "21889", "text": "Function: python.library.functions#min\nSnippet: min(iterable, *[, key, default]) min(arg1, arg2, *args[, key]) Return the smallest item in an iterable or the smallest of two or more arguments. If one positional argument is provided, it should be an iterable. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.68071395"}, {"id": "21919", "text": "Function: python.library.mmap#mmap.mmap.find\nSnippet: find(sub[, start[, end]]) Returns the lowest index in the object where the subsequence sub is found, such that sub is contained in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. Returns -1 on failure. Changed in version 3.5: Writable bytes-like object is now accepted.", "score": "0.6751342"}, {"id": "11234", "text": "Function: sklearn.modules.generated.sklearn.linear_model.lassolars\nSnippet: smaller. If this is a list of array-like, the length of the outer list is n_targets. active_list of length n_alphas or list of such lists Indices of active variables at the end of the path. If this is a list of list, the length of the outer list is n_targets. coef_path_array-like of shape (n_features, n_alphas + 1) or list of such arrays If a list is passed it’s expected to be one of n_targets such arrays. The varying values of the coefficients along the path. It is not present if the fit_path parameter is False. If this is a list of array-like, the length of the outer list is n_targets. coef_array-like of shape (n_features,) or (n_targets, n_features) Parameter vector (w in the formulation formula). intercept_float or array-like of shape (n_targets,) Independent term in decision function. n_iter_array-like or int The number of iterations taken by lars_path to find the grid of alphas for each target. See also lars_path lasso_path Lasso LassoCV LassoLarsCV LassoLarsIC sklearn.decomposition.sparse_encode Examples >>> from sklearn import linear_model >>> reg = linear_model.LassoLars(alpha=0.01) >>> reg.fit([[-1, 1], [0, 0], [1, 1]], [-1, 0, -1]) LassoLars(alpha=0.01) >>> print(reg.coef_) [ 0. -0.963257...] Methods fit(X, y[, Xy]) Fit the model using X, y as training data. get_params([deep]) Get parameters for this estimator. predict(X) Predict using the linear model. score(X, y[, sample_weight]) Return the coefficient of determination \\(R^2\\) of the prediction. set_params(**params) Set the parameters of this estimator. fit(X, y, Xy=None) [source] Fit the model using X, y as training data. Parameters Xarray-like of shape (n_samples, n_features) Training data. yarray-like of shape (n_samples,) or (n_samples, n_targets) Target values. Xyarray-like of shape (n_samples,) or (n_samples, n_targets), default=None Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed. Returns selfobject returns an instance of self. get_params(deep=True) [source] Get parameters for this estimator. Parameters deepbool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns paramsdict Parameter names mapped to their values. predict(X) [source] Predict using the linear model. Parameters Xarray-like or sparse matrix, shape (n_samples, n_features) Samples. Returns Carray, shape (n_samples,) Returns predicted values. score(X, y, sample_weight=None) [source] Return the coefficient of determination \\(R^2\\) of the prediction. The coefficient \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares ((y_true - y_pred) ** 2).sum() and \\(v\\) is the total sum of squares ((y_true - y_true.mean()) ** 2).sum(). The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of y, disregarding the input features, would get a \\(R^2\\) score of 0.0. Parameters Xarray-like of shape (n_samples, n_features) Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape (n_samples, n_samples_fitted), where n_samples_fitted is the number of samples used in the fitting for the estimator. yarray-like of shape (n_samples,) or (n_samples, n_outputs) True values for X. sample_weightarray-like of shape (n_samples,), default=None Sample", "score": "0.6621562"}, {"id": "41654", "text": "Function: numpy.reference.generated.numpy.char.chararray.find\nSnippet: numpy.char.chararray.find method char.chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.656145"}, {"id": "41778", "text": "Function: numpy.reference.generated.numpy.chararray.find\nSnippet: numpy.chararray.find method chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.6532539"}]}
{"task_id": "mbpp_51", "code": "def check_equilateral(x,y,z):\r\n  if x == y == z:\r\n\t   return True\r\n  else:\r\n     return False", "test_list": ["assert check_equilateral(6,8,12)==False ", "assert check_equilateral(6,6,12)==False", "assert check_equilateral(6,6,6)==True"], "context": "Write a function to print check if the triangle is equilateral or not.", "function_name": "def check_equilateral(x,y,z):", "gold_generation": "if x == y == z:\r\n\t   return True\r\n  else:\r\n     return False", "ctxs": [{"id": "14480", "text": "Function: pandas.reference.api.pandas.dataframe.rtruediv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6776817"}, {"id": "14324", "text": "Function: pandas.reference.api.pandas.dataframe.div\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6731684"}, {"id": "42538", "text": "Function: numpy.user.quickstart\nSnippet: 1.25, 1.5 , 1.75, 2. ]) >>> x = np.linspace(0, 2 * pi, 100) # useful to evaluate function at lots of points >>> f = np.sin(x) See also array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange, linspace, numpy.random.Generator.rand, numpy.random.Generator.randn, fromfunction, fromfile Printing Arrays When you print an array, NumPy displays it in a similar way to nested lists, but with the following layout: the last axis is printed from left to right, the second-to-last is printed from top to bottom, the rest are also printed from top to bottom, with each slice separated from the next by an empty line. One-dimensional arrays are then printed as rows, bidimensionals as matrices and tridimensionals as lists of matrices. >>> a = np.arange(6) # 1d array >>> print(a) [0 1 2 3 4 5] >>> >>> b = np.arange(12).reshape(4, 3) # 2d array >>> print(b) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] >>> >>> c = np.arange(24).reshape(2, 3, 4) # 3d array >>> print(c) [[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]] See below to get more details on reshape. If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners: >>> print(np.arange(10000)) [ 0 1 2 ... 9997 9998 9999] >>> >>> print(np.arange(10000).reshape(100, 100)) [[ 0 1 2 ... 97 98 99] [ 100 101 102 ... 197 198 199] [ 200 201 202 ... 297 298 299] ... [9700 9701 9702 ... 9797 9798 9799] [9800 9801 9802 ... 9897 9898 9899] [9900 9901 9902 ... 9997 9998 9999]] To disable this behaviour and force NumPy to print the entire array, you can change the printing options using set_printoptions. >>> np.set_printoptions(threshold=sys.maxsize) # sys module should be imported Basic Operations Arithmetic operators on arrays apply elementwise. A new array is created and filled with the result. >>> a = np.array([20, 30, 40, 50]) >>> b = np.arange(4) >>> b array([0, 1, 2, 3]) >>> c = a - b >>> c array([20, 29, 38, 47]) >>> b**2 array([0, 1, 4, 9]) >>> 10 * np.sin(a) array([ 9.12945251, -9.88031624, 7.4511316 , -2.62374854]) >>> a < 35 array([ True, True, False, False]) Unlike in many matrix languages, the product operator * operates elementwise in NumPy arrays. The matrix product can be performed using the @ operator (in python >=3.5) or the dot function or method: >>> A = np.array([[1, 1], ... [0, 1]]) >>> B = np.array([[2, 0], ... [3, 4]]) >>> A * B # elementwise product array([[2, 0], [0, 4]]) >>> A @ B # matrix product array([[5, 4], [3, 4]]) >>> A.dot(B) # another matrix product array([[5, 4], [3, 4]]) Some operations, such as += and *=, act in place to modify an existing array rather than create a new one. >>> rg = np.random.default_rng(1) # create instance of default", "score": "0.67102057"}, {"id": "14476", "text": "Function: pandas.reference.api.pandas.dataframe.rpow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6688257"}, {"id": "14549", "text": "Function: pandas.reference.api.pandas.dataframe.truediv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.66814774"}]}
{"task_id": "mbpp_52", "code": "def parallelogram_area(b,h):\r\n  area=b*h\r\n  return area", "test_list": ["assert parallelogram_area(10,20)==200", "assert parallelogram_area(15,20)==300", "assert parallelogram_area(8,9)==72"], "context": "Write a function to caluclate area of a parallelogram.", "function_name": "def parallelogram_area(b,h):", "gold_generation": "area=b*h\r\n  return area", "ctxs": [{"id": "36509", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.OGRGeometry.area\nSnippet: area", "score": "0.65191084"}, {"id": "15250", "text": "Function: pandas.reference.api.pandas.series.plot.area\nSnippet: pandas.Series.plot.area Series.plot.area(x=None, y=None, **kwargs)[source] Draw a stacked area plot. An area plot displays quantitative data visually. This function wraps the matplotlib area function. Parameters x:label or position, optional Coordinates for the X axis. By default uses the index. y:label or position, optional Column to plot. By default uses all columns. stacked:bool, default True Area plots are stacked by default. Set to False to create a unstacked plot. **kwargs Additional keyword arguments are documented in DataFrame.plot(). Returns matplotlib.axes.Axes or numpy.ndarray Area plot, or array of area plots if subplots is True. See also DataFrame.plot Make plots of DataFrame using matplotlib / pylab. Examples Draw an area plot based on basic business metrics: >>> df = pd.DataFrame({ ... 'sales': [3, 2, 3, 9, 10, 6], ... 'signups': [5, 5, 6, 12, 14, 13], ... 'visits': [20, 42, 28, 62, 81, 50], ... }, index=pd.date_range(start='2018/01/01', end='2018/07/01', ... freq='M')) >>> ax = df.plot.area() Area plots are stacked by default. To produce an unstacked plot, pass stacked=False: >>> ax = df.plot.area(stacked=False) Draw an area plot for a single column: >>> ax = df.plot.area(y='sales') Draw with a different x: >>> df = pd.DataFrame({ ... 'sales': [3, 2, 3], ... 'visits': [20, 42, 28], ... 'day': [1, 2, 3], ... }) >>> ax = df.plot.area(x='day')", "score": "0.6448547"}, {"id": "32684", "text": "Function: matplotlib.offsetbox_api#matplotlib.offsetbox.TextArea\nSnippet: area as a string. set_transform(t)[source] set_transform is ignored.", "score": "0.6410357"}, {"id": "14427", "text": "Function: pandas.reference.api.pandas.dataframe.plot.area\nSnippet: pandas.DataFrame.plot.area DataFrame.plot.area(x=None, y=None, **kwargs)[source] Draw a stacked area plot. An area plot displays quantitative data visually. This function wraps the matplotlib area function. Parameters x:label or position, optional Coordinates for the X axis. By default uses the index. y:label or position, optional Column to plot. By default uses all columns. stacked:bool, default True Area plots are stacked by default. Set to False to create a unstacked plot. **kwargs Additional keyword arguments are documented in DataFrame.plot(). Returns matplotlib.axes.Axes or numpy.ndarray Area plot, or array of area plots if subplots is True. See also DataFrame.plot Make plots of DataFrame using matplotlib / pylab. Examples Draw an area plot based on basic business metrics: >>> df = pd.DataFrame({ ... 'sales': [3, 2, 3, 9, 10, 6], ... 'signups': [5, 5, 6, 12, 14, 13], ... 'visits': [20, 42, 28, 62, 81, 50], ... }, index=pd.date_range(start='2018/01/01', end='2018/07/01', ... freq='M')) >>> ax = df.plot.area() Area plots are stacked by default. To produce an unstacked plot, pass stacked=False: >>> ax = df.plot.area(stacked=False) Draw an area plot for a single column: >>> ax = df.plot.area(y='sales') Draw with a different x: >>> df = pd.DataFrame({ ... 'sales': [3, 2, 3], ... 'visits': [20, 42, 28], ... 'day': [1, 2, 3], ... }) >>> ax = df.plot.area(x='day')", "score": "0.6367217"}, {"id": "33502", "text": "Function: matplotlib._as_gen.matplotlib.quiver.quiver#matplotlib.quiver.Quiver.quiver_doc\nSnippet: symbolize a quantity that is not based on\\n *X*, *Y* data coordinates.\\n\\n - 'xy': Arrows point from (x, y) to (x+u, y+v).\\n Use this for plotting a gradient field, for example.\\n\\n - Alternatively, arbitrary angles may be specified explicitly as an array\\n of values in degrees, counter-clockwise from the horizontal axis.\\n\\n In this case *U*, *V* is only used to determine the length of the\\n arrows.\\n\\n Note: inverting a data axis will correspondingly invert the\\n arrows only with ``angles='xy'``.\\n\\nscale : float, optional\\n Number of data units per arrow length unit, e.g., m/s per plot width; a\\n smaller scale parameter makes the arrow longer. Default is *None*.\\n\\n If *None*, a simple autoscaling algorithm is used, based on the average\\n vector length and the number of vectors. The arrow length unit is given by\\n the *scale_units* parameter.\\n\\nscale_units : {'width', 'height', 'dots', 'inches', 'x', 'y', 'xy'}, optional\\n If the *scale* kwarg is *None*, the arrow length unit. Default is *None*.\\n\\n e.g. *scale_units* is 'inches', *scale* is 2.0, and ``(u, v) = (1, 0)``,\\n then the vector will be 0.5 inches long.\\n\\n If *scale_units* is 'width' or 'height', then the vector will be half the\\n width/height of the axes.\\n\\n If *scale_units* is 'x' then the vector will be 0.5 x-axis\\n units. To plot vectors in the x-y plane, with u and v having\\n the same units as x and y, use\\n ``angles='xy', scale_units='xy', scale=1``.\\n\\nwidth : float, optional\\n Shaft width in arrow units; default depends on choice of units,\\n above, and number of vectors; a typical starting value is about\\n 0.005 times the width of the plot.\\n\\nheadwidth : float, default: 3\\n Head width as multiple of shaft width.\\n\\nheadlength : float, default: 5\\n Head length as multiple of shaft width.\\n\\nheadaxislength : float, default: 4.5\\n Head length at shaft intersection.\\n\\nminshaft : float, default: 1\\n Length below which arrow scales, in units of head length. Do not\\n set this to less than 1, or small arrows will look terrible!\\n\\nminlength : float, default: 1\\n Minimum length as a multiple of shaft width; if an arrow length\\n is less than this, plot a dot (hexagon) of this diameter instead.\\n\\npivot : {'tail', 'mid', 'middle', 'tip'}, default: 'tail'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The arrow\\n rotates about this point.\\n\\n 'mid' is a synonym for 'middle'.\\n\\ncolor : color or color sequence, optional\\n Explicit color(s) for the arrows. If *C* has been set, *color* has no\\n effect.\\n\\n This is a synonym for the `.PolyCollection` *facecolor* parameter.\\n\\nOther Parameters\\n----------------\\ndata : indexable object, optional\\n DATA_PARAMETER_PLACEHOLDER\\n\\n**kwargs : `~matplotlib.collections.PolyCollection` properties, optional\\n All other keyword arguments are passed on to `.PolyCollection`:\\n\\n \\n .. table::\\n :class: property-table\\n\\n ================================================================================================= =====================================================================================================\\n Property Description \\n ================================================================================================= =====================================================================================================\\n :meth:`agg_filter <matplotlib.artist.Artist.set_agg_filter>` a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array\\n :meth:`alpha <matplotlib.collections.Collection.set_alpha>` array-like or scalar or None \\n :meth:`animated <matplotlib.artist.Artist.set_animated>` bool \\n :meth:`antialiased <matplotlib.collections.Collection.set_antialiased>` or aa or antialiaseds bool or list of bools \\n :meth:`array <matplotlib.cm.ScalarMappable.set_array>` array-like or None \\n :meth:`capstyle <matplotlib.collections.Collection.set_capstyle>` `.CapStyle` or {'butt',", "score": "0.62703735"}]}
{"task_id": "mbpp_53", "code": "def check_Equality(str):\r\n  if (str[0] == str[-1]):  \r\n    return (\"Equal\") \r\n  else:  \r\n    return (\"Not Equal\") ", "test_list": ["assert check_Equality(\"abcda\") == \"Equal\"", "assert check_Equality(\"ab\") == \"Not Equal\"", "assert check_Equality(\"mad\") == \"Not Equal\""], "context": "Write a python function to check whether the first and last characters of a given string are equal or not.", "function_name": "def check_Equality(str):", "gold_generation": "if (str[0] == str[-1]):  \r\n    return (\"Equal\") \r\n  else:  \r\n    return (\"Not Equal\")", "ctxs": [{"id": "24361", "text": "Function: python.library.stdtypes#str.isupper\nSnippet: str.isupper() Return True if all cased characters 4 in the string are uppercase and there is at least one cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False", "score": "0.7230288"}, {"id": "24356", "text": "Function: python.library.stdtypes#str.islower\nSnippet: str.islower() Return True if all cased characters 4 in the string are lowercase and there is at least one cased character, False otherwise.", "score": "0.7221587"}, {"id": "41722", "text": "Function: numpy.reference.generated.numpy.char.equal\nSnippet: numpy.char.equal char.equal(x1, x2)[source] Return (x1 == x2) element-wise. Unlike numpy.equal, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray. Parameters x1, x2array_like of str or unicode Input arrays of the same shape. Returns outndarray Output array of bools. See also not_equal, greater_equal, less_equal, greater, less", "score": "0.71653855"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.7159929"}, {"id": "24344", "text": "Function: python.library.stdtypes#str.endswith\nSnippet: str.endswith(suffix[, start[, end]]) Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position.", "score": "0.7141585"}]}
{"task_id": "mbpp_54", "code": "def counting_sort(my_list):\r\n    max_value = 0\r\n    for i in range(len(my_list)):\r\n        if my_list[i] > max_value:\r\n            max_value = my_list[i]\r\n    buckets = [0] * (max_value + 1)\r\n    for i in my_list:\r\n        buckets[i] += 1\r\n    i = 0\r\n    for j in range(max_value + 1):\r\n         for a in range(buckets[j]):\r\n             my_list[i] = j\r\n             i += 1\r\n    return my_list", "test_list": ["assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]", "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]", "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"], "context": "Write a function to sort the given array by using counting sort.", "function_name": "def counting_sort(my_list):", "gold_generation": "max_value = 0\r\n    for i in range(len(my_list)):\r\n        if my_list[i] > max_value:\r\n            max_value = my_list[i]\r\n    buckets = [0] * (max_value + 1)\r\n    for i in my_list:\r\n        buckets[i] += 1\r\n    i = 0\r\n    for j in range(max_value + 1):\r\n         for a in range(buckets[j]):\r\n             my_list[i] = j\r\n             i += 1\r\n    return my_list", "ctxs": [{"id": "43832", "text": "Function: numpy.reference.generated.numpy.recarray.argsort\nSnippet: numpy.recarray.argsort method recarray.argsort(axis=- 1, kind=None, order=None) Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.70037913"}, {"id": "42341", "text": "Function: numpy.reference.generated.numpy.ma.sort\nSnippet: numpy.ma.sort ma.sort(a, axis=- 1, kind=None, order=None, endwith=True, fill_value=None)[source] Return a sorted copy of the masked array. Equivalent to creating a copy of the array and applying the MaskedArray sort() method. Refer to MaskedArray.sort for the full documentation See also MaskedArray.sort equivalent method", "score": "0.696532"}, {"id": "42504", "text": "Function: numpy.reference.generated.numpy.ndarray.argsort\nSnippet: numpy.ndarray.argsort method ndarray.argsort(axis=- 1, kind=None, order=None) Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.69149244"}, {"id": "41639", "text": "Function: numpy.reference.generated.numpy.char.chararray.argsort\nSnippet: numpy.char.chararray.argsort method char.chararray.argsort(axis=- 1, kind=None, order=None)[source] Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.6859437"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6832826"}]}
{"task_id": "mbpp_55", "code": "import math\r\ndef tn_gp(a,n,r):\r\n  tn = a * (math.pow(r, n - 1))\r\n  return tn", "test_list": ["assert tn_gp(1,5,2)==16", "assert tn_gp(1,5,4)==256", "assert tn_gp(2,6,3)==486"], "context": "Write a function to find t-nth term of geometric series.", "function_name": "import math\r\ndef tn_gp(a,n,r):", "gold_generation": "tn = a * (math.pow(r, n - 1))\r\n  return tn", "ctxs": [{"id": "16375", "text": "Function: pandas.reference.api.pandas.tseries.offsets.semimonthend.n\nSnippet: pandas.tseries.offsets.SemiMonthEnd.n SemiMonthEnd.n", "score": "0.6613022"}, {"id": "18485", "text": "Function: python.library.cmath#cmath.tan\nSnippet: cmath.tan(x) Return the tangent of x.", "score": "0.65173364"}, {"id": "15608", "text": "Function: pandas.reference.api.pandas.tseries.offsets.bquarterend.n\nSnippet: pandas.tseries.offsets.BQuarterEnd.n BQuarterEnd.n", "score": "0.64581054"}, {"id": "15382", "text": "Function: pandas.reference.api.pandas.series.t\nSnippet: pandas.Series.T propertySeries.T Return the transpose, which is by definition self.", "score": "0.6440987"}, {"id": "16349", "text": "Function: pandas.reference.api.pandas.tseries.offsets.semimonthbegin.n\nSnippet: pandas.tseries.offsets.SemiMonthBegin.n SemiMonthBegin.n", "score": "0.64357734"}]}
{"task_id": "mbpp_56", "code": "def rev(num):    \r\n    rev_num = 0\r\n    while (num > 0):  \r\n        rev_num = (rev_num * 10 + num % 10) \r\n        num = num // 10  \r\n    return rev_num  \r\ndef check(n):    \r\n    return (2 * rev(n) == n + 1)  ", "test_list": ["assert check(70) == False", "assert check(23) == False", "assert check(73) == True"], "context": "Write a python function to check if a given number is one less than twice its reverse.", "function_name": "def rev(num):", "gold_generation": "rev_num = 0\r\n    while (num > 0):  \r\n        rev_num = (rev_num * 10 + num % 10) \r\n        num = num // 10  \r\n    return rev_num  \r\ndef check(n):    \r\n    return (2 * rev(n) == n + 1)", "ctxs": [{"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.69974107"}, {"id": "21810", "text": "Function: python.library.math#math.isinf\nSnippet: math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise.", "score": "0.69387686"}, {"id": "21822", "text": "Function: python.library.math#math.nextafter\nSnippet: math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9.", "score": "0.6933691"}, {"id": "17643", "text": "Function: python.library.array#array.array.reverse\nSnippet: array.reverse() Reverse the order of the items in the array.", "score": "0.69090855"}, {"id": "19462", "text": "Function: python.library.decimal#decimal.Context.copy_negate\nSnippet: copy_negate(x) Returns a copy of x with the sign inverted.", "score": "0.68264633"}]}
{"task_id": "mbpp_57", "code": "def find_Max_Num(arr,n) : \r\n    arr.sort(reverse = True) \r\n    num = arr[0] \r\n    for i in range(1,n) : \r\n        num = num * 10 + arr[i] \r\n    return num ", "test_list": ["assert find_Max_Num([1,2,3],3) == 321", "assert find_Max_Num([4,5,6,1],4) == 6541", "assert find_Max_Num([1,2,3,9],4) == 9321"], "context": "Write a python function to find the largest number that can be formed with the given digits.", "function_name": "def find_Max_Num(arr,n) :", "gold_generation": "arr.sort(reverse = True) \r\n    num = arr[0] \r\n    for i in range(1,n) : \r\n        num = num * 10 + arr[i] \r\n    return num", "ctxs": [{"id": "24403", "text": "Function: python.library.string#string.digits\nSnippet: string.digits The string '0123456789'.", "score": "0.6739005"}, {"id": "19496", "text": "Function: python.library.decimal#decimal.Context.next_minus\nSnippet: next_minus(x) Returns the largest representable number smaller than x.", "score": "0.67066586"}, {"id": "19490", "text": "Function: python.library.decimal#decimal.Context.max\nSnippet: max(x, y) Compares two values numerically and returns the maximum.", "score": "0.66555643"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.66515577"}, {"id": "19558", "text": "Function: python.library.decimal#decimal.Decimal.next_minus\nSnippet: next_minus(context=None) Return the largest number representable in the given context (or in the current thread’s context if no context is given) that is smaller than the given operand.", "score": "0.6604797"}]}
{"task_id": "mbpp_58", "code": "def opposite_Signs(x,y): \r\n    return ((x ^ y) < 0); ", "test_list": ["assert opposite_Signs(1,-2) == True", "assert opposite_Signs(3,2) == False", "assert opposite_Signs(-10,-10) == False"], "context": "Write a python function to check whether the given two integers have opposite sign or not.", "function_name": "def opposite_Signs(x,y):", "gold_generation": "return ((x ^ y) < 0);", "ctxs": [{"id": "19479", "text": "Function: python.library.decimal#decimal.Context.is_signed\nSnippet: is_signed(x) Returns True if x is negative; otherwise returns False.", "score": "0.7139454"}, {"id": "19543", "text": "Function: python.library.decimal#decimal.Decimal.is_signed\nSnippet: is_signed() Return True if the argument has a negative sign and False otherwise. Note that zeros and NaNs can both carry signs.", "score": "0.71289843"}, {"id": "21810", "text": "Function: python.library.math#math.isinf\nSnippet: math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise.", "score": "0.7054821"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.7007619"}, {"id": "42910", "text": "Function: numpy.reference.generated.numpy.invert\nSnippet: numpy.invert numpy.invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'invert'> Compute bit-wise inversion, or bit-wise NOT, element-wise. Computes the bit-wise NOT of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator ~. For signed integer inputs, the two’s complement is returned. In a two’s-complement system negative numbers are represented by the two’s complement of the absolute value. This is the most common method of representing signed integers on computers [1]. A N-bit two’s-complement system can represent every integer in the range \\(-2^{N-1}\\) to \\(+2^{N-1}-1\\). Parameters xarray_like Only integer and boolean types are handled. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Result. This is a scalar if x is a scalar. See also bitwise_and, bitwise_or, bitwise_xor logical_not binary_repr Return the binary representation of the input number as a string. Notes bitwise_not is an alias for invert: >>> np.bitwise_not is np.invert True References 1 Wikipedia, “Two’s complement”, https://en.wikipedia.org/wiki/Two’s_complement Examples We’ve seen that 13 is represented by 00001101. The invert or bit-wise NOT of 13 is then: >>> x = np.invert(np.array(13, dtype=np.uint8)) >>> x 242 >>> np.binary_repr(x, width=8) '11110010' The result depends on the bit-width: >>> x = np.invert(np.array(13, dtype=np.uint16)) >>> x 65522 >>> np.binary_repr(x, width=16) '1111111111110010' When using signed integer types the result is the two’s complement of the result for the unsigned type: >>> np.invert(np.array([13], dtype=np.int8)) array([-14], dtype=int8) >>> np.binary_repr(-14, width=8) '11110010' Booleans are accepted as well: >>> np.invert(np.array([True, False])) array([False, True]) The ~ operator can be used as a shorthand for np.invert on ndarrays. >>> x1 = np.array([True, False]) >>> ~x1 array([False, True])", "score": "0.6996781"}]}
{"task_id": "mbpp_59", "code": "def is_octagonal(n): \r\n\treturn 3 * n * n - 2 * n ", "test_list": ["assert is_octagonal(5) == 65", "assert is_octagonal(10) == 280", "assert is_octagonal(15) == 645"], "context": "Write a function to find the nth octagonal number.", "function_name": "def is_octagonal(n):", "gold_generation": "return 3 * n * n - 2 * n", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.7110311"}, {"id": "15976", "text": "Function: pandas.reference.api.pandas.tseries.offsets.easter.n\nSnippet: pandas.tseries.offsets.Easter.n Easter.n", "score": "0.6877485"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6792592"}, {"id": "35797", "text": "Function: django.ref.models.database-functions#django.db.models.functions.NthValue\nSnippet: class NthValue(expression, nth=1, **extra)", "score": "0.671884"}, {"id": "15978", "text": "Function: pandas.reference.api.pandas.tseries.offsets.easter.nanos\nSnippet: pandas.tseries.offsets.Easter.nanos Easter.nanos", "score": "0.6707537"}]}
{"task_id": "mbpp_60", "code": "def max_len_sub( arr, n): \r\n\tmls=[] \r\n\tmax = 0\r\n\tfor i in range(n): \r\n\t\tmls.append(1) \r\n\tfor i in range(n): \r\n\t\tfor j in range(i): \r\n\t\t\tif (abs(arr[i] - arr[j]) <= 1 and mls[i] < mls[j] + 1): \r\n\t\t\t\tmls[i] = mls[j] + 1\r\n\tfor i in range(n): \r\n\t\tif (max < mls[i]): \r\n\t\t\tmax = mls[i] \r\n\treturn max", "test_list": ["assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5", "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4", "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"], "context": "Write a function to find the maximum length of the subsequence with difference between adjacent elements for the given array.", "function_name": "def max_len_sub( arr, n):", "gold_generation": "mls=[] \r\n\tmax = 0\r\n\tfor i in range(n): \r\n\t\tmls.append(1) \r\n\tfor i in range(n): \r\n\t\tfor j in range(i): \r\n\t\t\tif (abs(arr[i] - arr[j]) <= 1 and mls[i] < mls[j] + 1): \r\n\t\t\t\tmls[i] = mls[j] + 1\r\n\tfor i in range(n): \r\n\t\tif (max < mls[i]): \r\n\t\t\tmax = mls[i] \r\n\treturn max", "ctxs": [{"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.70772105"}, {"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.7066606"}, {"id": "18944", "text": "Function: python.library.ctypes#ctypes.Array._length_\nSnippet: _length_ A positive integer specifying the number of elements in the array. Out-of-range subscripts result in an IndexError. Will be returned by len().", "score": "0.698814"}, {"id": "18285", "text": "Function: python.library.stdtypes#bytearray.rfind\nSnippet: bytes.rfind(sub[, start[, end]]) bytearray.rfind(sub[, start[, end]]) Return the highest index in the sequence where the subsequence sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.6967607"}, {"id": "18291", "text": "Function: python.library.stdtypes#bytearray.split\nSnippet: bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3']", "score": "0.69468933"}]}
{"task_id": "mbpp_61", "code": "from collections import defaultdict\r\ndef count_Substrings(s,n):\r\n    count,sum = 0,0\r\n    mp = defaultdict(lambda : 0)\r\n    mp[0] += 1\r\n    for i in range(n):\r\n        sum += ord(s[i]) - ord('0')\r\n        count += mp[sum - (i + 1)]\r\n        mp[sum - (i + 1)] += 1\r\n    return count", "test_list": ["assert count_Substrings('112112',6) == 6", "assert count_Substrings('111',3) == 6", "assert count_Substrings('1101112',7) == 12"], "context": "Write a python function to count number of substrings with the sum of digits equal to their length.", "function_name": "from collections import defaultdict\r\ndef count_Substrings(s,n):", "gold_generation": "count,sum = 0,0\r\n    mp = defaultdict(lambda : 0)\r\n    mp[0] += 1\r\n    for i in range(n):\r\n        sum += ord(s[i]) - ord('0')\r\n        count += mp[sum - (i + 1)]\r\n        mp[sum - (i + 1)] += 1\r\n    return count", "ctxs": [{"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.7342552"}, {"id": "41718", "text": "Function: numpy.reference.generated.numpy.char.count\nSnippet: numpy.char.count char.count(a, sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. Calls str.count element-wise. Parameters aarray_like of str or unicode substr or unicode The substring to search for. start, endint, optional Optional arguments start and end are interpreted as slice notation to specify the range in which to count. Returns outndarray Output array of ints. See also str.count Examples >>> c = np.array(['aAaAaA', ' aA ', 'abBABba']) >>> c array(['aAaAaA', ' aA ', 'abBABba'], dtype='<U7') >>> np.char.count(c, 'A') array([3, 1, 1]) >>> np.char.count(c, 'aA') array([3, 1, 0]) >>> np.char.count(c, 'A', start=1, end=4) array([2, 1, 1]) >>> np.char.count(c, 'A', start=1, end=3) array([1, 0, 0])", "score": "0.71247333"}, {"id": "24403", "text": "Function: python.library.string#string.digits\nSnippet: string.digits The string '0123456789'.", "score": "0.700922"}, {"id": "41643", "text": "Function: numpy.reference.generated.numpy.char.chararray.count\nSnippet: numpy.char.chararray.count method char.chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.6940472"}, {"id": "21151", "text": "Function: python.library.io#io.TextIOBase.write\nSnippet: write(s) Write the string s to the stream and return the number of characters written.", "score": "0.6915368"}]}
{"task_id": "mbpp_62", "code": "def smallest_num(xs):\n  return min(xs)\n", "test_list": ["assert smallest_num([10, 20, 1, 45, 99]) == 1", "assert smallest_num([1, 2, 3]) == 1", "assert smallest_num([45, 46, 50, 60]) == 45"], "context": "Write a python function to find smallest number in a list.", "function_name": "def smallest_num(xs):", "gold_generation": "return min(xs)", "ctxs": [{"id": "19492", "text": "Function: python.library.decimal#decimal.Context.min\nSnippet: min(x, y) Compares two values numerically and returns the minimum.", "score": "0.7203155"}, {"id": "21889", "text": "Function: python.library.functions#min\nSnippet: min(iterable, *[, key, default]) min(arg1, arg2, *args[, key]) Return the smallest item in an iterable or the smallest of two or more arguments. If one positional argument is provided, it should be an iterable. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.72016"}, {"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.7181919"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.7172232"}, {"id": "24346", "text": "Function: python.library.stdtypes#str.find\nSnippet: str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True", "score": "0.6964342"}]}
{"task_id": "mbpp_63", "code": "def max_difference(test_list):\r\n  temp = [abs(b - a) for a, b in test_list]\r\n  res = max(temp)\r\n  return (res) ", "test_list": ["assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7", "assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15", "assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23"], "context": "Write a function to find the maximum difference between available pairs in the given tuple list.", "function_name": "def max_difference(test_list):", "gold_generation": "temp = [abs(b - a) for a, b in test_list]\r\n  res = max(temp)\r\n  return (res)", "ctxs": [{"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.68815213"}, {"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.6867948"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6785948"}, {"id": "19651", "text": "Function: python.library.difflib#difflib.SequenceMatcher.ratio\nSnippet: ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5", "score": "0.67543864"}, {"id": "43968", "text": "Function: numpy.reference.generated.numpy.testing.assert_array_max_ulp\nSnippet: numpy.testing.assert_array_max_ulp testing.assert_array_max_ulp(a, b, maxulp=1, dtype=None)[source] Check that all items of arrays differ in at most N Units in the Last Place. Parameters a, barray_like Input arrays to be compared. maxulpint, optional The maximum number of units in the last place that elements of a and b can differ. Default is 1. dtypedtype, optional Data-type to convert a and b to if given. Default is None. Returns retndarray Array containing number of representable floating point numbers between items in a and b. Raises AssertionError If one or more elements differ by more than maxulp. See also assert_array_almost_equal_nulp Compare two arrays relatively to their spacing. Notes For computing the ULP difference, this API does not differentiate between various representations of NAN (ULP difference between 0x7fc00000 and 0xffc00000 is zero). Examples >>> a = np.linspace(0., 1., 100) >>> res = np.testing.assert_array_max_ulp(a, np.arcsin(np.sin(a)))", "score": "0.6750131"}]}
{"task_id": "mbpp_64", "code": "def subject_marks(subjectmarks):\r\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\r\n subjectmarks.sort(key = lambda x: x[1])\r\n return subjectmarks", "test_list": ["assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]", "assert subject_marks([('Telugu',49),('Hindhi',54),('Social',33)])==([('Social',33),('Telugu',49),('Hindhi',54)])", "assert subject_marks([('Physics',96),('Chemistry',97),('Biology',45)])==([('Biology',45),('Physics',96),('Chemistry',97)])"], "context": "Write a function to sort a list of tuples using lambda.", "function_name": "def subject_marks(subjectmarks):", "gold_generation": "#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\r\n subjectmarks.sort(key = lambda x: x[1])\r\n return subjectmarks", "ctxs": [{"id": "25739", "text": "Function: python.library.stdtypes\nSnippet: a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort. Tuples Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a set or dict instance). class tuple([iterable]) Tuples may be constructed in a number of ways: Using a pair of parentheses to denote the empty tuple: () Using a trailing comma for a singleton tuple: a, or (a,) Separating items with commas: a, b, c or (a, b, c) Using the tuple() built-in: tuple() or tuple(iterable) The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, tuple('abc') returns ('a', 'b', 'c') and tuple( [1, 2, 3] ) returns (1, 2, 3). If no argument is given, the constructor creates a new empty tuple, (). Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, f(a, b, c) is a function call with three arguments, while f((a, b, c)) is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, collections.namedtuple() may be a more appropriate choice than a simple tuple object. Ranges The range type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops. class range(stop) class range(start, stop[, step]) The arguments to the range constructor must be integers (either built-in int or any object that implements the __index__ special method). If the step argument is omitted, it defaults to 1. If the start argument is", "score": "0.7169336"}, {"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.6946517"}, {"id": "21356", "text": "Function: python.library.stdtypes#list\nSnippet: class list([iterable]) Lists may be constructed in several ways: Using a pair of square brackets to denote the empty list: [] Using square brackets, separating items with commas: [a], [a, b, c] Using a list comprehension: [x for x in iterable] Using the type constructor: list() or list(iterable) The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to iterable[:]. For example, list('abc') returns ['a', 'b', 'c'] and list( (1, 2, 3) ) returns [1, 2, 3]. If no argument is given, the constructor creates a new empty list, []. Many other operations also produce lists, including the sorted() built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.6867633"}, {"id": "14754", "text": "Function: pandas.reference.api.pandas.index.sort\nSnippet: pandas.Index.sort finalIndex.sort(*args, **kwargs)[source] Use sort_values instead.", "score": "0.685814"}, {"id": "20478", "text": "Function: python.library.heapq\nSnippet: key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters. heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n]. heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n]. The latter two functions perform best for smaller values of n. For larger values, it is more efficient to use the sorted() function. Also, when n==1, it is more efficient to use the built-in min() and max() functions. If repeated usage of these functions is required, consider turning the iterable into an actual heap. Basic Examples A heapsort can be implemented by pushing all values onto a heap and then popping off the smallest values one at a time: >>> def heapsort(iterable): ... h = [] ... for value in iterable: ... heappush(h, value) ... return [heappop(h) for i in range(len(h))] ... >>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] This is similar to sorted(iterable), but unlike sorted(), this implementation is not stable. Heap elements can be tuples. This is useful for assigning comparison values (such as task priorities) alongside the main record being tracked: >>> h = [] >>> heappush(h, (5, 'write code')) >>> heappush(h, (7, 'release product')) >>> heappush(h, (1, 'write spec')) >>> heappush(h, (3, 'create tests')) >>> heappop(h) (1, 'write spec') Priority Queue Implementation Notes A priority queue is common use for a heap, and it presents several implementation challenges: Sort stability: how do you get two tasks with equal priorities to be returned in the order they were originally added? Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order. If the priority of a task changes, how do you move it to a new position in the heap? Or if a pending task needs to be deleted, how do you find it and remove it from the queue? A solution to the first two challenges is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were", "score": "0.6826621"}]}
{"task_id": "mbpp_65", "code": "def recursive_list_sum(data_list):\r\n\ttotal = 0\r\n\tfor element in data_list:\r\n\t\tif type(element) == type([]):\r\n\t\t\ttotal = total + recursive_list_sum(element)\r\n\t\telse:\r\n\t\t\ttotal = total + element\r\n\treturn total", "test_list": ["assert recursive_list_sum(([1, 2, [3,4],[5,6]]))==21", "assert recursive_list_sum(([7, 10, [15,14],[19,41]]))==106", "assert recursive_list_sum(([10, 20, [30,40],[50,60]]))==210"], "context": "Write a function of recursion list sum.", "function_name": "def recursive_list_sum(data_list):", "gold_generation": "total = 0\r\n\tfor element in data_list:\r\n\t\tif type(element) == type([]):\r\n\t\t\ttotal = total + recursive_list_sum(element)\r\n\t\telse:\r\n\t\t\ttotal = total + element\r\n\treturn total", "ctxs": [{"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.70429564"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.7036023"}, {"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.68431336"}, {"id": "43881", "text": "Function: numpy.reference.generated.numpy.recarray.sum\nSnippet: numpy.recarray.sum method recarray.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True) Return the sum of the array elements over the given axis. Refer to numpy.sum for full documentation. See also numpy.sum equivalent function", "score": "0.6780546"}, {"id": "42970", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.recursive_fill_fields\nSnippet: numpy.lib.recfunctions.recursive_fill_fields(input, output)[source] Fills fields from output with fields from input, with support for nested structures. Parameters inputndarray Input array. outputndarray Output array. Notes output should be at least the same size as input Examples >>> from numpy.lib import recfunctions as rfn >>> a = np.array([(1, 10.), (2, 20.)], dtype=[('A', np.int64), ('B', np.float64)]) >>> b = np.zeros((3,), dtype=a.dtype) >>> rfn.recursive_fill_fields(a, b) array([(1, 10.), (2, 20.), (0, 0.)], dtype=[('A', '<i8'), ('B', '<f8')])", "score": "0.66970384"}]}
{"task_id": "mbpp_66", "code": "def pos_count(list):\r\n  pos_count= 0\r\n  for num in list: \r\n    if num >= 0: \r\n      pos_count += 1\r\n  return pos_count ", "test_list": ["assert pos_count([1,-2,3,-4]) == 2", "assert pos_count([3,4,5,-1]) == 3", "assert pos_count([1,2,3,4]) == 4"], "context": "Write a python function to count positive numbers in a list.", "function_name": "def pos_count(list):", "gold_generation": "pos_count= 0\r\n  for num in list: \r\n    if num >= 0: \r\n      pos_count += 1\r\n  return pos_count", "ctxs": [{"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.67275614"}, {"id": "25740", "text": "Function: python.library.stdtypes\nSnippet: omitted, it defaults to 0. If step is zero, ValueError is raised. For a positive step, the contents of a range r are determined by the formula r[i] = start + step*i where i >= 0 and r[i] < stop. For a negative step, the contents of the range are still determined by the formula r[i] = start + step*i, but the constraints are i >= 0 and r[i] > stop. A range object will be empty if r[0] does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than sys.maxsize are permitted but some features (such as len()) may raise OverflowError. Range examples: >>> list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> list(range(0, 30, 5)) [0, 5, 10, 15, 20, 25] >>> list(range(0, 10, 3)) [0, 3, 6, 9] >>> list(range(0, -10, -1)) [0, -1, -2, -3, -4, -5, -6, -7, -8, -9] >>> list(range(0)) [] >>> list(range(1, 0)) [] Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). start The value of the start parameter (or 0 if the parameter was not supplied) stop The value of the stop parameter step The value of the step parameter (or 1 if the parameter was not supplied) The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and subranges as needed). Range objects implement the collections.abc.Sequence ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): >>> r = range(0, 20, 2) >>> r range(0, 20, 2) >>> 11 in r False >>> 10 in r True >>> r.index(10) 5 >>> r[5] 10 >>> r[:5] range(0, 10, 2) >>> r[-1] 18 Testing range objects for equality with == and != compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different start, stop and step attributes, for example range(0) == range(2, 1, 3) or range(0, 3, 2) == range(0, 4, 2).) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test int objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity). New in version 3.3: The", "score": "0.67243385"}, {"id": "21304", "text": "Function: python.library.itertools#itertools.count\nSnippet: itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments.", "score": "0.66599286"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6638503"}, {"id": "18944", "text": "Function: python.library.ctypes#ctypes.Array._length_\nSnippet: _length_ A positive integer specifying the number of elements in the array. Out-of-range subscripts result in an IndexError. Will be returned by len().", "score": "0.6576354"}]}
{"task_id": "mbpp_67", "code": "def bell_number(n):   \r\n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \r\n    bell[0][0] = 1\r\n    for i in range(1, n+1): \r\n        bell[i][0] = bell[i-1][i-1]  \r\n        for j in range(1, i+1): \r\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \r\n    return bell[n][0] ", "test_list": ["assert bell_number(2)==2", "assert bell_number(10)==115975", "assert bell_number(56)==6775685320645824322581483068371419745979053216268760300"], "context": "Write a function to find the number of ways to partition a set of bell numbers.", "function_name": "def bell_number(n):", "gold_generation": "bell = [[0 for i in range(n+1)] for j in range(n+1)] \r\n    bell[0][0] = 1\r\n    for i in range(1, n+1): \r\n        bell[i][0] = bell[i-1][i-1]  \r\n        for j in range(1, i+1): \r\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \r\n    return bell[n][0]", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.663653"}, {"id": "21296", "text": "Function: python.library.itertools\nSnippet: D E B F C\" # Recipe credited to George Sakkis num_active = len(iterables) nexts = cycle(iter(it).__next__ for it in iterables) while num_active: try: for next in nexts: yield next() except StopIteration: # Remove the iterator we just exhausted from the cycle. num_active -= 1 nexts = cycle(islice(nexts, num_active)) def partition(pred, iterable): \"Use a predicate to partition entries into false entries and true entries\" # partition(is_odd, range(10)) --> 0 2 4 6 8 and 1 3 5 7 9 t1, t2 = tee(iterable) return filterfalse(pred, t1), filter(pred, t2) def powerset(iterable): \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\" s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s)+1)) def unique_everseen(iterable, key=None): \"List unique elements, preserving order. Remember all elements ever seen.\" # unique_everseen('AAAABBBCCDAABBB') --> A B C D # unique_everseen('ABBCcAD', str.lower) --> A B C D seen = set() seen_add = seen.add if key is None: for element in filterfalse(seen.__contains__, iterable): seen_add(element) yield element else: for element in iterable: k = key(element) if k not in seen: seen_add(k) yield element def unique_justseen(iterable, key=None): \"List unique elements, preserving order. Remember only the element just seen.\" # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B # unique_justseen('ABBCcAD', str.lower) --> A B C A D return map(next, map(operator.itemgetter(1), groupby(iterable, key))) def iter_except(func, exception, first=None): \"\"\" Call a function repeatedly until an exception is raised. Converts a call-until-exception interface to an iterator interface. Like builtins.iter(func, sentinel) but uses an exception instead of a sentinel to end the loop. Examples: iter_except(functools.partial(heappop, h), IndexError) # priority queue iterator iter_except(d.popitem, KeyError) # non-blocking dict iterator iter_except(d.popleft, IndexError) # non-blocking deque iterator iter_except(q.get_nowait, Queue.Empty) # loop over a producer Queue iter_except(s.pop, KeyError) # non-blocking set iterator \"\"\" try: if first is not None: yield first() # For database APIs needing an initial cast to db.first() while True: yield func() except exception: pass def first_true(iterable, default=False, pred=None): \"\"\"Returns the first true value in the iterable. If no true value is found, returns *default* If *pred* is not None, returns the first item for which pred(item) is true. \"\"\" # first_true([a,b,c], x) --> a or b or c or x # first_true([a,b], x, f) --> a if f(a) else b if f(b) else x return next(filter(pred, iterable), default) def random_product(*args, repeat=1): \"Random selection from itertools.product(*args, **kwds)\" pools = [tuple(pool) for pool in args] * repeat return tuple(map(random.choice, pools)) def random_permutation(iterable, r=None): \"Random selection from itertools.permutations(iterable, r)\" pool = tuple(iterable) r = len(pool) if r is None else r return tuple(random.sample(pool, r)) def random_combination(iterable, r): \"Random selection from itertools.combinations(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.sample(range(n), r)) return tuple(pool[i] for i in indices) def random_combination_with_replacement(iterable, r): \"Random selection from itertools.combinations_with_replacement(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.choices(range(n), k=r)) return tuple(pool[i] for i in indices) def nth_combination(iterable, r, index): \"Equivalent to list(combinations(iterable, r))[index]\" pool = tuple(iterable) n = len(pool) if r < 0 or r > n: raise ValueError c = 1 k = min(r, n-r) for i in range(1, k+1): c = c", "score": "0.6492574"}, {"id": "43864", "text": "Function: numpy.reference.generated.numpy.recarray.partition\nSnippet: numpy.recarray.partition method recarray.partition(kth, axis=- 1, kind='introselect', order=None) Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array. All elements smaller than the kth element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined. New in version 1.8.0. Parameters kthint or sequence of ints Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. Deprecated since version 1.22.0: Passing booleans as index is deprecated. axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘introselect’}, optional Selection algorithm. Default is ‘introselect’. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.partition Return a parititioned copy of an array. argpartition Indirect partition. sort Full sort. Notes See np.partition for notes on the different algorithms. Examples >>> a = np.array([3, 4, 2, 1]) >>> a.partition(3) >>> a array([2, 1, 3, 4]) >>> a.partition((1, 3)) >>> a array([1, 2, 3, 4])", "score": "0.6435366"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6428455"}, {"id": "209", "text": "Function: tensorflow.compat.v1.data.fixedlengthrecorddataset\nSnippet: to determine the number of elements in the dataset (e.g. when the dataset source is a file). dataset = tf.data.Dataset.range(42) print(dataset.cardinality().numpy()) 42 dataset = dataset.repeat() cardinality = dataset.cardinality() print((cardinality == tf.data.INFINITE_CARDINALITY).numpy()) True dataset = dataset.filter(lambda x: True) cardinality = dataset.cardinality() print((cardinality == tf.data.UNKNOWN_CARDINALITY).numpy()) True Returns A scalar tf.int64 Tensor representing the cardinality of the dataset. If the cardinality is infinite or unknown, cardinality returns the named constants tf.data.INFINITE_CARDINALITY and tf.data.UNKNOWN_CARDINALITY respectively. concatenate View source concatenate( dataset ) Creates a Dataset by concatenating the given dataset with this dataset. a = tf.data.Dataset.range(1, 4) # ==> [ 1, 2, 3 ] b = tf.data.Dataset.range(4, 8) # ==> [ 4, 5, 6, 7 ] ds = a.concatenate(b) list(ds.as_numpy_iterator()) [1, 2, 3, 4, 5, 6, 7] # The input dataset and dataset to be concatenated should have the same # nested structures and output types. c = tf.data.Dataset.zip((a, b)) a.concatenate(c) Traceback (most recent call last): TypeError: Two datasets to concatenate have different types <dtype: 'int64'> and (tf.int64, tf.int64) d = tf.data.Dataset.from_tensor_slices([\"a\", \"b\", \"c\"]) a.concatenate(d) Traceback (most recent call last): TypeError: Two datasets to concatenate have different types <dtype: 'int64'> and <dtype: 'string'> Args dataset Dataset to be concatenated. Returns Dataset A Dataset. enumerate View source enumerate( start=0 ) Enumerates the elements of this dataset. It is similar to python's enumerate. dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3]) dataset = dataset.enumerate(start=5) for element in dataset.as_numpy_iterator(): print(element) (5, 1) (6, 2) (7, 3) # The nested structure of the input dataset determines the structure of # elements in the resulting dataset. dataset = tf.data.Dataset.from_tensor_slices([(7, 8), (9, 10)]) dataset = dataset.enumerate() for element in dataset.as_numpy_iterator(): print(element) (0, array([7, 8], dtype=int32)) (1, array([ 9, 10], dtype=int32)) Args start A tf.int64 scalar tf.Tensor, representing the start value for enumeration. Returns Dataset A Dataset. filter View source filter( predicate ) Filters this dataset according to predicate. dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3]) dataset = dataset.filter(lambda x: x < 3) list(dataset.as_numpy_iterator()) [1, 2] # `tf.math.equal(x, y)` is required for equality comparison def filter_fn(x): return tf.math.equal(x, 1) dataset = dataset.filter(filter_fn) list(dataset.as_numpy_iterator()) [1] Args predicate A function mapping a dataset element to a boolean. Returns Dataset The Dataset containing the elements of this dataset for which predicate is True. filter_with_legacy_function View source filter_with_legacy_function( predicate ) Filters this dataset according to predicate. (deprecated) Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use `tf.data.Dataset.filter() Note: This is an escape hatch for existing uses of filter that do not work with V2 functions. New uses are strongly discouraged and existing uses should migrate to filter as this method will be removed in V2. Args predicate A function mapping a nested structure of tensors (having shapes and types defined by self.output_shapes and self.output_types) to a scalar tf.bool tensor. Returns Dataset The Dataset containing the elements of this dataset for which predicate is True. flat_map View source flat_map( map_func ) Maps map_func across this dataset and flattens the result. Use flat_map if you want to make sure that the order of your dataset", "score": "0.6370853"}]}
{"task_id": "mbpp_68", "code": "def is_Monotonic(A): \r\n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\r\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) ", "test_list": ["assert is_Monotonic([6, 5, 4, 4]) == True", "assert is_Monotonic([1, 2, 2, 3]) == True", "assert is_Monotonic([1, 3, 2]) == False"], "context": "Write a python function to check whether the given array is monotonic or not.", "function_name": "def is_Monotonic(A):", "gold_generation": "return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\r\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1)))", "ctxs": [{"id": "15205", "text": "Function: pandas.reference.api.pandas.series.is_monotonic\nSnippet: pandas.Series.is_monotonic propertySeries.is_monotonic Return boolean if values in the object are monotonic_increasing. Returns bool", "score": "0.75147384"}, {"id": "15206", "text": "Function: pandas.reference.api.pandas.series.is_monotonic_decreasing\nSnippet: pandas.Series.is_monotonic_decreasing propertySeries.is_monotonic_decreasing Return boolean if values in the object are monotonic_decreasing. Returns bool", "score": "0.7386147"}, {"id": "14054", "text": "Function: pandas.reference.api.pandas.arrays.intervalarray.is_non_overlapping_monotonic\nSnippet: pandas.arrays.IntervalArray.is_non_overlapping_monotonic propertyIntervalArray.is_non_overlapping_monotonic Return True if the IntervalArray is non-overlapping (no Intervals share points) and is either monotonic increasing or monotonic decreasing, else False.", "score": "0.72802126"}, {"id": "14178", "text": "Function: pandas.reference.api.pandas.core.groupby.seriesgroupby.is_monotonic_decreasing\nSnippet: pandas.core.groupby.SeriesGroupBy.is_monotonic_decreasing propertySeriesGroupBy.is_monotonic_decreasing Return boolean if values in the object are monotonic_decreasing. Returns bool", "score": "0.7259624"}, {"id": "14718", "text": "Function: pandas.reference.api.pandas.index.is_monotonic_decreasing\nSnippet: pandas.Index.is_monotonic_decreasing propertyIndex.is_monotonic_decreasing Return if the index is monotonic decreasing (only equal or decreasing) values. Examples >>> Index([3, 2, 1]).is_monotonic_decreasing True >>> Index([3, 2, 2]).is_monotonic_decreasing True >>> Index([3, 1, 2]).is_monotonic_decreasing False", "score": "0.7188629"}]}
{"task_id": "mbpp_69", "code": "def is_sublist(l, s):\r\n\tsub_set = False\r\n\tif s == []:\r\n\t\tsub_set = True\r\n\telif s == l:\r\n\t\tsub_set = True\r\n\telif len(s) > len(l):\r\n\t\tsub_set = False\r\n\telse:\r\n\t\tfor i in range(len(l)):\r\n\t\t\tif l[i] == s[0]:\r\n\t\t\t\tn = 1\r\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\r\n\t\t\t\t\tn += 1\t\t\t\t\r\n\t\t\t\tif n == len(s):\r\n\t\t\t\t\tsub_set = True\r\n\treturn sub_set", "test_list": ["assert is_sublist([2,4,3,5,7],[3,7])==False", "assert is_sublist([2,4,3,5,7],[4,3])==True", "assert is_sublist([2,4,3,5,7],[1,6])==False"], "context": "Write a function to check whether a list contains the given sublist or not.", "function_name": "def is_sublist(l, s):", "gold_generation": "sub_set = False\r\n\tif s == []:\r\n\t\tsub_set = True\r\n\telif s == l:\r\n\t\tsub_set = True\r\n\telif len(s) > len(l):\r\n\t\tsub_set = False\r\n\telse:\r\n\t\tfor i in range(len(l)):\r\n\t\t\tif l[i] == s[0]:\r\n\t\t\t\tn = 1\r\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\r\n\t\t\t\t\tn += 1\t\t\t\t\r\n\t\t\t\tif n == len(s):\r\n\t\t\t\t\tsub_set = True\r\n\treturn sub_set", "ctxs": [{"id": "14049", "text": "Function: pandas.reference.api.pandas.arrays.intervalarray.contains\nSnippet: pandas.arrays.IntervalArray.contains IntervalArray.contains(other)[source] Check elementwise if the Intervals contain the value. Return a boolean mask whether the value is contained in the Intervals of the IntervalArray. New in version 0.25.0. Parameters other:scalar The value to check whether it is contained in the Intervals. Returns boolean array See also Interval.contains Check whether Interval object contains value. IntervalArray.overlaps Check if an Interval overlaps the values in the IntervalArray. Examples >>> intervals = pd.arrays.IntervalArray.from_tuples([(0, 1), (1, 3), (2, 4)]) >>> intervals <IntervalArray> [(0, 1], (1, 3], (2, 4]] Length: 3, dtype: interval[int64, right] >>> intervals.contains(0.5) array([ True, False, False])", "score": "0.69484645"}, {"id": "20225", "text": "Function: python.library.stdtypes#frozenset.issubset\nSnippet: issubset(other) set <= other Test whether every element in the set is in other.", "score": "0.68762666"}, {"id": "14799", "text": "Function: pandas.reference.api.pandas.intervalindex.contains\nSnippet: pandas.IntervalIndex.contains IntervalIndex.contains(*args, **kwargs)[source] Check elementwise if the Intervals contain the value. Return a boolean mask whether the value is contained in the Intervals of the IntervalArray. New in version 0.25.0. Parameters other:scalar The value to check whether it is contained in the Intervals. Returns boolean array See also Interval.contains Check whether Interval object contains value. IntervalArray.overlaps Check if an Interval overlaps the values in the IntervalArray. Examples >>> intervals = pd.arrays.IntervalArray.from_tuples([(0, 1), (1, 3), (2, 4)]) >>> intervals <IntervalArray> [(0, 1], (1, 3], (2, 4]] Length: 3, dtype: interval[int64, right] >>> intervals.contains(0.5) array([ True, False, False])", "score": "0.68336535"}, {"id": "30845", "text": "Function: matplotlib.collections_api#matplotlib.collections.RegularPolyCollection.contains\nSnippet: contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event.", "score": "0.67952347"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.677514"}]}
{"task_id": "mbpp_70", "code": "def find_equal_tuple(Input, k):\r\n  flag = 1\r\n  for tuple in Input:\r\n    if len(tuple) != k:\r\n      flag = 0\r\n      break\r\n  return flag\r\ndef get_equal(Input, k):\r\n  if find_equal_tuple(Input, k) == 1:\r\n    return (\"All tuples have same length\")\r\n  else:\r\n    return (\"All tuples do not have same length\")", "test_list": ["assert get_equal([(11, 22, 33), (44, 55, 66)], 3) == 'All tuples have same length'", "assert get_equal([(1, 2, 3), (4, 5, 6, 7)], 3) == 'All tuples do not have same length'", "assert get_equal([(1, 2), (3, 4)], 2) == 'All tuples have same length'"], "context": "Write a function to find whether all the given tuples have equal length or not.", "function_name": "def find_equal_tuple(Input, k):", "gold_generation": "flag = 1\r\n  for tuple in Input:\r\n    if len(tuple) != k:\r\n      flag = 0\r\n      break\r\n  return flag\r\ndef get_equal(Input, k):\r\n  if find_equal_tuple(Input, k) == 1:\r\n    return (\"All tuples have same length\")\r\n  else:\r\n    return (\"All tuples do not have same length\")", "ctxs": [{"id": "13018", "text": "Function: sklearn.modules.generated.sklearn.utils.check_consistent_length#sklearn.utils.check_consistent_length\nSnippet: sklearn.utils.check_consistent_length(*arrays) [source] Check that all arrays have consistent first dimensions. Checks whether all objects in arrays have the same shape or length. Parameters *arrayslist or tuple of input objects. Objects that will be checked for consistent length.", "score": "0.7339827"}, {"id": "12783", "text": "Function: sklearn.modules.generated.sklearn.utils.check_consistent_length\nSnippet: sklearn.utils.check_consistent_length sklearn.utils.check_consistent_length(*arrays) [source] Check that all arrays have consistent first dimensions. Checks whether all objects in arrays have the same shape or length. Parameters *arrayslist or tuple of input objects. Objects that will be checked for consistent length.", "score": "0.7306705"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.7013422"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6895115"}, {"id": "26103", "text": "Function: python.library.unittest#unittest.TestCase.assertTupleEqual\nSnippet: assertListEqual(first, second, msg=None) assertTupleEqual(first, second, msg=None) Tests that two lists or tuples are equal. If not, an error message is constructed that shows only the differences between the two. An error is also raised if either of the parameters are of the wrong type. These methods are used by default when comparing lists or tuples with assertEqual(). New in version 3.1.", "score": "0.6734708"}]}
{"task_id": "mbpp_71", "code": "def comb_sort(nums):\r\n    shrink_fact = 1.3\r\n    gaps = len(nums)\r\n    swapped = True\r\n    i = 0\r\n    while gaps > 1 or swapped:\r\n        gaps = int(float(gaps) / shrink_fact)\r\n        swapped = False\r\n        i = 0\r\n        while gaps + i < len(nums):\r\n            if nums[i] > nums[i+gaps]:\r\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\r\n                swapped = True\r\n            i += 1\r\n    return nums", "test_list": ["assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]", "assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]", "assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]"], "context": "Write a function to sort a list of elements using comb sort.", "function_name": "def comb_sort(nums):", "gold_generation": "shrink_fact = 1.3\r\n    gaps = len(nums)\r\n    swapped = True\r\n    i = 0\r\n    while gaps > 1 or swapped:\r\n        gaps = int(float(gaps) / shrink_fact)\r\n        swapped = False\r\n        i = 0\r\n        while gaps + i < len(nums):\r\n            if nums[i] > nums[i+gaps]:\r\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\r\n                swapped = True\r\n            i += 1\r\n    return nums", "ctxs": [{"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.70065725"}, {"id": "42341", "text": "Function: numpy.reference.generated.numpy.ma.sort\nSnippet: numpy.ma.sort ma.sort(a, axis=- 1, kind=None, order=None, endwith=True, fill_value=None)[source] Return a sorted copy of the masked array. Equivalent to creating a copy of the array and applying the MaskedArray sort() method. Refer to MaskedArray.sort for the full documentation See also MaskedArray.sort equivalent method", "score": "0.69190246"}, {"id": "23949", "text": "Function: python.library.functions#sorted\nSnippet: sorted(iterable, *, key=None, reverse=False) Return a new sorted list from the items in iterable. Has two optional arguments which must be specified as keyword arguments. key specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. Use functools.cmp_to_key() to convert an old-style cmp function to a key function. The built-in sorted() function is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO.", "score": "0.6802583"}, {"id": "21787", "text": "Function: python.library.math#math.comb\nSnippet: math.comb(n, k) Return the number of ways to choose k items from n items without repetition and without order. Evaluates to n! / (k! * (n - k)!) when k <= n and evaluates to zero when k > n. Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of the expression (1 + x) ** n. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6742324"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.67228276"}]}
{"task_id": "mbpp_72", "code": "def dif_Square(n): \r\n    if (n % 4 != 2): \r\n        return True\r\n    return False", "test_list": ["assert dif_Square(5) == True", "assert dif_Square(10) == False", "assert dif_Square(15) == True"], "context": "Write a python function to check whether the given number can be represented as difference of two squares or not.", "function_name": "def dif_Square(n):", "gold_generation": "if (n % 4 != 2): \r\n        return True\r\n    return False", "ctxs": [{"id": "14509", "text": "Function: pandas.reference.api.pandas.dataframe.subtract\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.71174085"}, {"id": "14324", "text": "Function: pandas.reference.api.pandas.dataframe.div\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6902254"}, {"id": "19512", "text": "Function: python.library.decimal#decimal.Context.subtract\nSnippet: subtract(x, y) Return the difference between x and y.", "score": "0.6886577"}, {"id": "43202", "text": "Function: numpy.reference.generated.numpy.square\nSnippet: numpy.square numpy.square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'square'> Return the element-wise square of the input. Parameters xarray_like Input data. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Element-wise x*x, of the same shape and dtype as x. This is a scalar if x is a scalar. See also numpy.linalg.matrix_power sqrt power Examples >>> np.square([-1j, 1]) array([-1.-0.j, 1.+0.j])", "score": "0.68444854"}, {"id": "21811", "text": "Function: python.library.math#math.isnan\nSnippet: math.isnan(x) Return True if x is a NaN (not a number), and False otherwise.", "score": "0.6844017"}]}
{"task_id": "mbpp_73", "code": "import re\r\ndef multiple_split(text):\r\n  return (re.split('; |, |\\*|\\n',text))", "test_list": ["assert multiple_split('Forces of the \\ndarkness*are coming into the play.') == ['Forces of the ', 'darkness', 'are coming into the play.']", "assert multiple_split('Mi Box runs on the \\n Latest android*which has google assistance and chromecast.') == ['Mi Box runs on the ', ' Latest android', 'which has google assistance and chromecast.']", "assert multiple_split('Certain services\\nare subjected to change*over the seperate subscriptions.') == ['Certain services', 'are subjected to change', 'over the seperate subscriptions.']"], "context": "Write a function to split the given string with multiple delimiters by using regex.", "function_name": "import re\r\ndef multiple_split(text):", "gold_generation": "return (re.split('; |, |\\*|\\n',text))", "ctxs": [{"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.7633375"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.7364252"}, {"id": "23362", "text": "Function: python.library.re#re.Pattern.split\nSnippet: Pattern.split(string, maxsplit=0) Identical to the split() function, using the compiled pattern.", "score": "0.7252238"}, {"id": "24377", "text": "Function: python.library.stdtypes#str.split\nSnippet: str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3']", "score": "0.72349817"}, {"id": "41754", "text": "Function: numpy.reference.generated.numpy.char.split\nSnippet: numpy.char.split char.split(a, sep=None, maxsplit=None)[source] For each element in a, return a list of the words in the string, using sep as the delimiter string. Calls str.split element-wise. Parameters aarray_like of str or unicode sepstr or unicode, optional If sep is not specified or None, any whitespace string is a separator. maxsplitint, optional If maxsplit is given, at most maxsplit splits are done. Returns outndarray Array of list objects See also str.split, rsplit", "score": "0.69807726"}]}
{"task_id": "mbpp_74", "code": "def is_samepatterns(colors, patterns):    \r\n    if len(colors) != len(patterns):\r\n        return False    \r\n    sdict = {}\r\n    pset = set()\r\n    sset = set()    \r\n    for i in range(len(patterns)):\r\n        pset.add(patterns[i])\r\n        sset.add(colors[i])\r\n        if patterns[i] not in sdict.keys():\r\n            sdict[patterns[i]] = []\r\n\r\n        keys = sdict[patterns[i]]\r\n        keys.append(colors[i])\r\n        sdict[patterns[i]] = keys\r\n\r\n    if len(pset) != len(sset):\r\n        return False   \r\n\r\n    for values in sdict.values():\r\n\r\n        for i in range(len(values) - 1):\r\n            if values[i] != values[i+1]:\r\n                return False\r\n\r\n    return True", "test_list": ["assert is_samepatterns([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True ", "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False ", "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False "], "context": "Write a function to check whether it follows the sequence given in the patterns array.", "function_name": "def is_samepatterns(colors, patterns):", "gold_generation": "if len(colors) != len(patterns):\r\n        return False    \r\n    sdict = {}\r\n    pset = set()\r\n    sset = set()    \r\n    for i in range(len(patterns)):\r\n        pset.add(patterns[i])\r\n        sset.add(colors[i])\r\n        if patterns[i] not in sdict.keys():\r\n            sdict[patterns[i]] = []\r\n\r\n        keys = sdict[patterns[i]]\r\n        keys.append(colors[i])\r\n        sdict[patterns[i]] = keys\r\n\r\n    if len(pset) != len(sset):\r\n        return False   \r\n\r\n    for values in sdict.values():\r\n\r\n        for i in range(len(values) - 1):\r\n            if values[i] != values[i+1]:\r\n                return False\r\n\r\n    return True", "ctxs": [{"id": "42785", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.is_sequence\nSnippet: numpy.distutils.misc_util.is_sequence(seq)[source]", "score": "0.7067505"}, {"id": "23326", "text": "Function: python.library.re#re.error.pattern\nSnippet: pattern The regular expression pattern.", "score": "0.68010986"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.67950654"}, {"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.677668"}, {"id": "23311", "text": "Function: python.library.re\nSnippet: matching flags. This is a combination of the flags given to compile(), any (?...) inline flags in the pattern, and implicit flags such as UNICODE if the pattern is a Unicode string. Pattern.groups The number of capturing groups in the pattern. Pattern.groupindex A dictionary mapping any symbolic group names defined by (?P<id>) to group numbers. The dictionary is empty if no symbolic groups were used in the pattern. Pattern.pattern The pattern string from which the pattern object was compiled. Changed in version 3.7: Added support of copy.copy() and copy.deepcopy(). Compiled regular expression objects are considered atomic. Match Objects Match objects always have a boolean value of True. Since match() and search() return None when there is no match, you can test whether there was a match with a simple if statement: match = re.search(pattern, string) if match: process(match) Match objects support the following methods and attributes: Match.expand(template) Return the string obtained by doing backslash substitution on the template string template, as done by the sub() method. Escapes such as \\n are converted to the appropriate characters, and numeric backreferences (\\1, \\2) and named backreferences (\\g<1>, \\g<name>) are replaced by the contents of the corresponding group. Changed in version 3.5: Unmatched groups are replaced with an empty string. Match.group([group1, ...]) Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an IndexError exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is None. If a group is contained in a part of the pattern that matched multiple times, the last match is returned. >>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\") >>> m.group(0) # The entire match 'Isaac Newton' >>> m.group(1) # The first parenthesized subgroup. 'Isaac' >>> m.group(2) # The second parenthesized subgroup. 'Newton' >>> m.group(1, 2) # Multiple arguments give us a tuple. ('Isaac', 'Newton') If the regular expression uses the (?P<name>...) syntax, the groupN arguments may also be strings identifying groups by their group name. If a string argument is not used as a group name in the pattern, an IndexError exception is raised. A moderately complicated example: >>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm Reynolds\") >>> m.group('first_name') 'Malcolm' >>> m.group('last_name') 'Reynolds' Named groups can also be referred to by their index: >>> m.group(1) 'Malcolm' >>> m.group(2) 'Reynolds' If a group matches multiple times, only the last match is accessible: >>> m = re.match(r\"(..)+\", \"a1b2c3\") # Matches 3 times. >>> m.group(1) # Returns only the last match. 'c3' Match.__getitem__(g) This is identical", "score": "0.67287034"}]}
{"task_id": "mbpp_75", "code": "def find_tuples(test_list, K):\r\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\r\n  return (str(res)) ", "test_list": ["assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == '[(6, 24, 12)]'", "assert find_tuples([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == '[(5, 25, 30)]'", "assert find_tuples([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == '[(8, 16, 4)]'"], "context": "Write a function to find tuples which have all elements divisible by k from the given list of tuples.", "function_name": "def find_tuples(test_list, K):", "gold_generation": "res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\r\n  return (str(res))", "ctxs": [{"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6664363"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6580284"}, {"id": "21296", "text": "Function: python.library.itertools\nSnippet: D E B F C\" # Recipe credited to George Sakkis num_active = len(iterables) nexts = cycle(iter(it).__next__ for it in iterables) while num_active: try: for next in nexts: yield next() except StopIteration: # Remove the iterator we just exhausted from the cycle. num_active -= 1 nexts = cycle(islice(nexts, num_active)) def partition(pred, iterable): \"Use a predicate to partition entries into false entries and true entries\" # partition(is_odd, range(10)) --> 0 2 4 6 8 and 1 3 5 7 9 t1, t2 = tee(iterable) return filterfalse(pred, t1), filter(pred, t2) def powerset(iterable): \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\" s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s)+1)) def unique_everseen(iterable, key=None): \"List unique elements, preserving order. Remember all elements ever seen.\" # unique_everseen('AAAABBBCCDAABBB') --> A B C D # unique_everseen('ABBCcAD', str.lower) --> A B C D seen = set() seen_add = seen.add if key is None: for element in filterfalse(seen.__contains__, iterable): seen_add(element) yield element else: for element in iterable: k = key(element) if k not in seen: seen_add(k) yield element def unique_justseen(iterable, key=None): \"List unique elements, preserving order. Remember only the element just seen.\" # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B # unique_justseen('ABBCcAD', str.lower) --> A B C A D return map(next, map(operator.itemgetter(1), groupby(iterable, key))) def iter_except(func, exception, first=None): \"\"\" Call a function repeatedly until an exception is raised. Converts a call-until-exception interface to an iterator interface. Like builtins.iter(func, sentinel) but uses an exception instead of a sentinel to end the loop. Examples: iter_except(functools.partial(heappop, h), IndexError) # priority queue iterator iter_except(d.popitem, KeyError) # non-blocking dict iterator iter_except(d.popleft, IndexError) # non-blocking deque iterator iter_except(q.get_nowait, Queue.Empty) # loop over a producer Queue iter_except(s.pop, KeyError) # non-blocking set iterator \"\"\" try: if first is not None: yield first() # For database APIs needing an initial cast to db.first() while True: yield func() except exception: pass def first_true(iterable, default=False, pred=None): \"\"\"Returns the first true value in the iterable. If no true value is found, returns *default* If *pred* is not None, returns the first item for which pred(item) is true. \"\"\" # first_true([a,b,c], x) --> a or b or c or x # first_true([a,b], x, f) --> a if f(a) else b if f(b) else x return next(filter(pred, iterable), default) def random_product(*args, repeat=1): \"Random selection from itertools.product(*args, **kwds)\" pools = [tuple(pool) for pool in args] * repeat return tuple(map(random.choice, pools)) def random_permutation(iterable, r=None): \"Random selection from itertools.permutations(iterable, r)\" pool = tuple(iterable) r = len(pool) if r is None else r return tuple(random.sample(pool, r)) def random_combination(iterable, r): \"Random selection from itertools.combinations(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.sample(range(n), r)) return tuple(pool[i] for i in indices) def random_combination_with_replacement(iterable, r): \"Random selection from itertools.combinations_with_replacement(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.choices(range(n), k=r)) return tuple(pool[i] for i in indices) def nth_combination(iterable, r, index): \"Equivalent to list(combinations(iterable, r))[index]\" pool = tuple(iterable) n = len(pool) if r < 0 or r > n: raise ValueError c = 1 k = min(r, n-r) for i in range(1, k+1): c = c", "score": "0.6542113"}, {"id": "21301", "text": "Function: python.library.itertools#itertools.combinations\nSnippet: itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6491321"}, {"id": "21302", "text": "Function: python.library.itertools#itertools.combinations_with_replacement\nSnippet: itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1.", "score": "0.64679456"}]}
{"task_id": "mbpp_76", "code": "def count_Squares(m,n):\r\n    if(n < m):\r\n        temp = m\r\n        m = n\r\n        n = temp\r\n    return ((m * (m + 1) * (2 * m + 1) / 6 + (n - m) * m * (m + 1) / 2))", "test_list": ["assert count_Squares(4,3) == 20", "assert count_Squares(2,2) == 5", "assert count_Squares(1,1) == 1"], "context": "Write a python function to count the number of squares in a rectangle.", "function_name": "def count_Squares(m,n):", "gold_generation": "if(n < m):\r\n        temp = m\r\n        m = n\r\n        n = temp\r\n    return ((m * (m + 1) * (2 * m + 1) / 6 + (n - m) * m * (m + 1) / 2))", "ctxs": [{"id": "14324", "text": "Function: pandas.reference.api.pandas.dataframe.div\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6810493"}, {"id": "43202", "text": "Function: numpy.reference.generated.numpy.square\nSnippet: numpy.square numpy.square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'square'> Return the element-wise square of the input. Parameters xarray_like Input data. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Element-wise x*x, of the same shape and dtype as x. This is a scalar if x is a scalar. See also numpy.linalg.matrix_power sqrt power Examples >>> np.square([-1j, 1]) array([-1.-0.j, 1.+0.j])", "score": "0.6762521"}, {"id": "14476", "text": "Function: pandas.reference.api.pandas.dataframe.rpow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6743764"}, {"id": "14507", "text": "Function: pandas.reference.api.pandas.dataframe.sub\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6743541"}, {"id": "14478", "text": "Function: pandas.reference.api.pandas.dataframe.rsub\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6736448"}]}
{"task_id": "mbpp_77", "code": "def is_Diff(n): \r\n    return (n % 11 == 0) ", "test_list": ["assert is_Diff (12345) == False", "assert is_Diff(1212112) == True", "assert is_Diff(1212) == False"], "context": "Write a python function to find the difference between sum of even and odd digits.", "function_name": "def is_Diff(n):", "gold_generation": "return (n % 11 == 0)", "ctxs": [{"id": "19512", "text": "Function: python.library.decimal#decimal.Context.subtract\nSnippet: subtract(x, y) Return the difference between x and y.", "score": "0.6853029"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.6755142"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.6740797"}, {"id": "19457", "text": "Function: python.library.decimal#decimal.Context.compare_total\nSnippet: compare_total(x, y) Compares two operands using their abstract representation.", "score": "0.67214036"}, {"id": "24415", "text": "Function: python.library.string#string.octdigits\nSnippet: string.octdigits The string '01234567'.", "score": "0.66874945"}]}
{"task_id": "mbpp_78", "code": "def count_With_Odd_SetBits(n): \r\n    if (n % 2 != 0): \r\n        return (n + 1) / 2\r\n    count = bin(n).count('1') \r\n    ans = n / 2\r\n    if (count % 2 != 0): \r\n        ans += 1\r\n    return ans ", "test_list": ["assert count_With_Odd_SetBits(5) == 3", "assert count_With_Odd_SetBits(10) == 5", "assert count_With_Odd_SetBits(15) == 8"], "context": "Write a python function to find number of integers with odd number of set bits.", "function_name": "def count_With_Odd_SetBits(n):", "gold_generation": "if (n % 2 != 0): \r\n        return (n + 1) / 2\r\n    count = bin(n).count('1') \r\n    ans = n / 2\r\n    if (count % 2 != 0): \r\n        ans += 1\r\n    return ans", "ctxs": [{"id": "25732", "text": "Function: python.library.stdtypes\nSnippet: there were an infinite number of sign bits. Additional Methods on Integer Types The int type implements the numbers.Integral abstract base class. In addition, it provides a few more methods: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1. int.to_bytes(length, byteorder, *, signed=False) Return an array of bytes representing an integer. >>> (1024).to_bytes(2, byteorder='big') b'\\x04\\x00' >>> (1024).to_bytes(10, byteorder='big') b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00' >>> (-1024).to_bytes(10, byteorder='big', signed=True) b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00' >>> x = 1000 >>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little') b'\\xe8\\x03' The integer is represented using length bytes. An OverflowError is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument determines whether two’s complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. The default value for signed is False. New in version 3.2. classmethod int.from_bytes(bytes, byteorder, *, signed=False) Return the integer represented by the given array of bytes. >>> int.from_bytes(b'\\x00\\x10', byteorder='big') 16 >>> int.from_bytes(b'\\x00\\x10', byteorder='little') 4096 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True) -1024 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False) 64512 >>> int.from_bytes([255, 0, 0], byteorder='big') 16711680 The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. New in version 3.2. int.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original integer and with a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. New in version 3.8. Additional Methods on Float The float type implements the numbers.Real abstract base class. float also has the following additional methods. float.as_integer_ratio() Return a pair of integers whose", "score": "0.71995026"}, {"id": "21071", "text": "Function: python.library.stdtypes#int.bit_length\nSnippet: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1.", "score": "0.7191921"}, {"id": "13465", "text": "Function: pygame.ref.mask#pygame.mask.Mask.count\nSnippet: count() Returns the number of set bits count() -> bits Returns: the number of set bits in the mask Return type: int", "score": "0.7051028"}, {"id": "23488", "text": "Function: python.library.secrets#secrets.randbits\nSnippet: secrets.randbits(k) Return an int with k random bits.", "score": "0.6958825"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.68008906"}]}
{"task_id": "mbpp_79", "code": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2!=0: \r\n            return True  \r\n        else:\r\n          return False", "test_list": ["assert word_len(\"Hadoop\") == False", "assert word_len(\"great\") == True", "assert word_len(\"structure\") == True"], "context": "Write a python function to check whether the length of the word is odd or not.", "function_name": "def word_len(s):", "gold_generation": "s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2!=0: \r\n            return True  \r\n        else:\r\n          return False", "ctxs": [{"id": "25020", "text": "Function: python.library.textwrap\nSnippet: \"'\", followed by a space. One problem with this is algorithm is that it is unable to detect the difference between “Dr.” in [...] Dr. Frankenstein's monster [...] and “Spot.” in [...] See Spot. See Spot run [...] fix_sentence_endings is false by default. Since the sentence detection algorithm relies on string.lowercase for the definition of “lowercase letter”, and a convention of using two spaces after a period to separate sentences on the same line, it is specific to English-language texts. break_long_words (default: True) If true, then words longer than width will be broken in order to ensure that no lines are longer than width. If it is false, long words will not be broken, and some lines may be longer than width. (Long words will be put on a line by themselves, in order to minimize the amount by which width is exceeded.) break_on_hyphens (default: True) If true, wrapping will occur preferably on whitespaces and right after hyphens in compound words, as it is customary in English. If false, only whitespaces will be considered as potentially good places for line breaks, but you need to set break_long_words to false if you want truly insecable words. Default behaviour in previous versions was to always allow breaking hyphenated words. max_lines (default: None) If not None, then the output will contain at most max_lines lines, with placeholder appearing at the end of the output. New in version 3.4. placeholder (default: ' [...]') String that will appear at the end of the output text if it has been truncated. New in version 3.4. TextWrapper also provides some public methods, analogous to the module-level convenience functions: wrap(text) Wraps the single paragraph in text (a string) so every line is at most width characters long. All wrapping options are taken from instance attributes of the TextWrapper instance. Returns a list of output lines, without final newlines. If the wrapped output has no content, the returned list is empty. fill(text) Wraps the single paragraph in text, and returns a single string containing the wrapped paragraph.", "score": "0.6755171"}, {"id": "18944", "text": "Function: python.library.ctypes#ctypes.Array._length_\nSnippet: _length_ A positive integer specifying the number of elements in the array. Out-of-range subscripts result in an IndexError. Will be returned by len().", "score": "0.67423135"}, {"id": "19070", "text": "Function: python.library.curses.ascii#curses.ascii.ispunct\nSnippet: curses.ascii.ispunct(c) Checks for any printable ASCII character which is not a space or an alphanumeric character.", "score": "0.6709722"}, {"id": "23301", "text": "Function: python.library.re\nSnippet: repetitions as possible. For example, a{3,5} will match from 3 to 5 'a' characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, a{4,}b will match 'aaaab' or a thousand 'a' characters followed by a 'b', but not 'aaab'. The comma may not be omitted or the modifier would be confused with the previously described form. {m,n}? Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous qualifier. For example, on the 6-character string 'aaaaaa', a{3,5} will match 5 'a' characters, while a{3,5}? will only match 3 characters. \\ Either escapes special characters (permitting you to match characters like '*', '?', and so forth), or signals a special sequence; special sequences are discussed below. If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions. [] Used to indicate a set of characters. In a set: Characters can be listed individually, e.g. [amk] will match 'a', 'm', or 'k'. Ranges of characters can be indicated by giving two characters and separating them by a '-', for example [a-z] will match any lowercase ASCII letter, [0-5][0-9] will match all the two-digits numbers from 00 to 59, and [0-9A-Fa-f] will match any hexadecimal digit. If - is escaped (e.g. [a\\-z]) or if it’s placed as the first or last character (e.g. [-a] or [a-]), it will match a literal '-'. Special characters lose their special meaning inside sets. For example, [(+*)] will match any of the literal characters '(', '+', '*', or ')'. Character classes such as \\w or \\S (defined below) are also accepted inside a set, although the characters they match depends on whether ASCII or LOCALE mode is in force. Characters that are not within a range can be matched by complementing the set. If the first character of the set is '^', all the characters that are not in the set will be matched. For example, [^5] will match any character except '5', and [^^] will match any character except '^'. ^ has no special meaning if it’s not the first character in the set. To match a literal ']' inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both [()[\\]{}] and []()[{}] will both match a parenthesis. Support of nested sets and set operations as in Unicode Technical Standard #18 might be added in the future. This would change the syntax, so to facilitate this change", "score": "0.66724396"}, {"id": "24344", "text": "Function: python.library.stdtypes#str.endswith\nSnippet: str.endswith(suffix[, start[, end]]) Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position.", "score": "0.6650001"}]}
{"task_id": "mbpp_80", "code": "def tetrahedral_number(n): \r\n\treturn (n * (n + 1) * (n + 2)) / 6", "test_list": ["assert tetrahedral_number(5) == 35.0", "assert tetrahedral_number(6) == 56.0", "assert tetrahedral_number(7) == 84.0"], "context": "Write a function to find the nth tetrahedral number.", "function_name": "def tetrahedral_number(n):", "gold_generation": "return (n * (n + 1) * (n + 2)) / 6", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.7221811"}, {"id": "35797", "text": "Function: django.ref.models.database-functions#django.db.models.functions.NthValue\nSnippet: class NthValue(expression, nth=1, **extra)", "score": "0.68855935"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.673282"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.66692185"}, {"id": "43231", "text": "Function: numpy.reference.generated.numpy.tri\nSnippet: numpy.tri numpy.tri(N, M=None, k=0, dtype=<class 'float'>, *, like=None)[source] An array with ones at and below the given diagonal and zeros elsewhere. Parameters Nint Number of rows in the array. Mint, optional Number of columns in the array. By default, M is taken equal to N. kint, optional The sub-diagonal at and below which the array is filled. k = 0 is the main diagonal, while k < 0 is below it, and k > 0 is above. The default is 0. dtypedtype, optional Data type of the returned array. The default is float. likearray_like Reference object to allow the creation of arrays which are not NumPy arrays. If an array-like passed in as like supports the __array_function__ protocol, the result will be defined by it. In this case, it ensures the creation of an array object compatible with that passed in via this argument. New in version 1.20.0. Returns trindarray of shape (N, M) Array with its lower triangle filled with ones and zero elsewhere; in other words T[i,j] == 1 for j <= i + k, 0 otherwise. Examples >>> np.tri(3, 5, 2, dtype=int) array([[1, 1, 1, 0, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 1]]) >>> np.tri(3, 5, -1) array([[0., 0., 0., 0., 0.], [1., 0., 0., 0., 0.], [1., 1., 0., 0., 0.]])", "score": "0.66653866"}]}
{"task_id": "mbpp_81", "code": "def zip_tuples(test_tup1, test_tup2):\r\n  res = []\r\n  for i, j in enumerate(test_tup1):\r\n    res.append((j, test_tup2[i % len(test_tup2)])) \r\n  return (res) ", "test_list": ["assert zip_tuples((7, 8, 4, 5, 9, 10),(1, 5, 6) ) == [(7, 1), (8, 5), (4, 6), (5, 1), (9, 5), (10, 6)]", "assert zip_tuples((8, 9, 5, 6, 10, 11),(2, 6, 7) ) == [(8, 2), (9, 6), (5, 7), (6, 2), (10, 6), (11, 7)]", "assert zip_tuples((9, 10, 6, 7, 11, 12),(3, 7, 8) ) == [(9, 3), (10, 7), (6, 8), (7, 3), (11, 7), (12, 8)]"], "context": "Write a function to zip the two given tuples.", "function_name": "def zip_tuples(test_tup1, test_tup2):", "gold_generation": "res = []\r\n  for i, j in enumerate(test_tup1):\r\n    res.append((j, test_tup2[i % len(test_tup2)])) \r\n  return (res)", "ctxs": [{"id": "27121", "text": "Function: python.library.functions#zip\nSnippet: zip(*iterables) Make an iterator that aggregates elements from each of the iterables. Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator. Equivalent to: def zip(*iterables): # zip('ABCD', 'xy') --> Ax By sentinel = object() iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using zip(*[iter(s)]*n). This repeats the same iterator n times so that each output tuple has the result of n calls to the iterator. This has the effect of dividing the input into n-length chunks. zip() should only be used with unequal length inputs when you don’t care about trailing, unmatched values from the longer iterables. If those values are important, use itertools.zip_longest() instead. zip() in conjunction with the * operator can be used to unzip a list: >>> x = [1, 2, 3] >>> y = [4, 5, 6] >>> zipped = zip(x, y) >>> list(zipped) [(1, 4), (2, 5), (3, 6)] >>> x2, y2 = zip(*zip(x, y)) >>> x == list(x2) and y == list(y2) True", "score": "0.7444568"}, {"id": "20295", "text": "Function: python.library.functions\nSnippet: aggregates elements from each of the iterables. Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator. Equivalent to: def zip(*iterables): # zip('ABCD', 'xy') --> Ax By sentinel = object() iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using zip(*[iter(s)]*n). This repeats the same iterator n times so that each output tuple has the result of n calls to the iterator. This has the effect of dividing the input into n-length chunks. zip() should only be used with unequal length inputs when you don’t care about trailing, unmatched values from the longer iterables. If those values are important, use itertools.zip_longest() instead. zip() in conjunction with the * operator can be used to unzip a list: >>> x = [1, 2, 3] >>> y = [4, 5, 6] >>> zipped = zip(x, y) >>> list(zipped) [(1, 4), (2, 5), (3, 6)] >>> x2, y2 = zip(*zip(x, y)) >>> x == list(x2) and y == list(y2) True __import__(name, globals=None, locals=None, fromlist=(), level=0) Note This is an advanced function that is not needed in everyday Python programming, unlike importlib.import_module(). This function is invoked by the import statement. It can be replaced (by importing the builtins module and assigning to builtins.__import__) in order to change semantics of the import statement, but doing so is strongly discouraged as it is usually simpler to use import hooks (see PEP 302) to attain the same goals and does not cause issues with code which assumes the default import implementation is in use. Direct use of __import__() is also discouraged in favor of importlib.import_module(). The function imports the module name, potentially using the given globals and locals to determine how to interpret the name in a package context. The fromlist gives the names of objects or submodules that should be imported from the module given by name. The standard implementation does not use its locals argument at all, and uses its globals only to determine the package context of the import statement. level specifies whether to use absolute or relative imports. 0 (the default) means only perform absolute imports. Positive values for level indicate the number of parent directories to search relative to the directory of the module calling __import__() (see PEP 328 for the details). When the name variable is of the form package.module, normally, the top-level package (the name up till the first dot) is returned, not the module named by name. However, when a non-empty fromlist argument is given, the module named by name is returned. For example, the statement import spam results", "score": "0.7151781"}, {"id": "21316", "text": "Function: python.library.itertools#itertools.zip_longest\nSnippet: itertools.zip_longest(*iterables, fillvalue=None) Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. Roughly equivalent to: def zip_longest(*args, fillvalue=None): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- iterators = [iter(it) for it in args] num_active = len(iterators) if not num_active: return while True: values = [] for i, it in enumerate(iterators): try: value = next(it) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values.append(value) yield tuple(values) If one of the iterables is potentially infinite, then the zip_longest() function should be wrapped with something that limits the number of calls (for example islice() or takewhile()). If not specified, fillvalue defaults to None.", "score": "0.6879743"}, {"id": "36422", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.Envelope.tuple\nSnippet: tuple", "score": "0.6877471"}, {"id": "27155", "text": "Function: python.library.zipfile#zipfile.ZipFile\nSnippet: New in version 3.8: The strict_timestamps keyword-only argument", "score": "0.68480706"}]}
{"task_id": "mbpp_82", "code": "import math\r\ndef volume_sphere(r):\r\n  volume=(4/3)*math.pi*r*r*r\r\n  return volume", "test_list": ["assert volume_sphere(10)==4188.790204786391", "assert volume_sphere(25)==65449.84694978735", "assert volume_sphere(20)==33510.32163829113"], "context": "Write a function to find the volume of a sphere.", "function_name": "import math\r\ndef volume_sphere(r):", "gold_generation": "volume=(4/3)*math.pi*r*r*r\r\n  return volume", "ctxs": [{"id": "36351", "text": "Function: django.ref.contrib.gis.functions#django.contrib.gis.db.models.functions.Length\nSnippet: class Length(expression, spheroid=True, **extra)", "score": "0.6359139"}, {"id": "13521", "text": "Function: pygame.ref.math#pygame.math.Vector3.as_spherical\nSnippet: as_spherical() returns a tuple with radial distance, inclination and azimuthal angle. as_spherical() -> (r, theta, phi) Returns a tuple (r, theta, phi) where r is the radial distance, theta is the inclination angle and phi is the azimuthal angle.", "score": "0.6319473"}, {"id": "42994", "text": "Function: numpy.reference.arrays.scalars#numpy.longcomplex\nSnippet: numpy.longcomplex[source] alias of numpy.clongdouble", "score": "0.6157975"}, {"id": "42696", "text": "Function: numpy.reference.arrays.scalars#numpy.clongfloat\nSnippet: numpy.clongfloat[source] alias of numpy.clongdouble", "score": "0.61461735"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.61413133"}]}
{"task_id": "mbpp_83", "code": "def get_Char(strr):  \r\n    summ = 0\r\n    for i in range(len(strr)): \r\n        summ += (ord(strr[i]) - ord('a') + 1)  \r\n    if (summ % 26 == 0): \r\n        return ord('z') \r\n    else: \r\n        summ = summ % 26\r\n        return chr(ord('a') + summ - 1)", "test_list": ["assert get_Char(\"abc\") == \"f\"", "assert get_Char(\"gfg\") == \"t\"", "assert get_Char(\"ab\") == \"c\""], "context": "Write a python function to find the character made by adding all the characters of the given string.", "function_name": "def get_Char(strr):", "gold_generation": "summ = 0\r\n    for i in range(len(strr)): \r\n        summ += (ord(strr[i]) - ord('a') + 1)  \r\n    if (summ % 26 == 0): \r\n        return ord('z') \r\n    else: \r\n        summ = summ % 26\r\n        return chr(ord('a') + summ - 1)", "ctxs": [{"id": "41634", "text": "Function: numpy.reference.generated.numpy.char.add\nSnippet: numpy.char.add char.add(x1, x2)[source] Return element-wise string concatenation for two arrays of str or unicode. Arrays x1 and x2 must have the same shape. Parameters x1array_like of str or unicode Input array. x2array_like of str or unicode Input array. Returns addndarray Output array of string_ or unicode_, depending on input types of the same shape as x1 and x2.", "score": "0.69642365"}, {"id": "41724", "text": "Function: numpy.reference.generated.numpy.char.find\nSnippet: numpy.char.find char.find(a, sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. Calls str.find element-wise. For each element, return the lowest index in the string where substring sub is found, such that sub is contained in the range [start, end]. Parameters aarray_like of str or unicode substr or unicode start, endint, optional Optional arguments start and end are interpreted as in slice notation. Returns outndarray or int Output array of ints. Returns -1 if sub is not found. See also str.find", "score": "0.69340384"}, {"id": "24414", "text": "Function: python.library.string#string.hexdigits\nSnippet: string.hexdigits The string '0123456789abcdefABCDEF'.", "score": "0.6788068"}, {"id": "41664", "text": "Function: numpy.reference.generated.numpy.char.chararray.isdigit\nSnippet: numpy.char.chararray.isdigit method char.chararray.isdigit()[source] Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. See also char.isdigit", "score": "0.677032"}, {"id": "41654", "text": "Function: numpy.reference.generated.numpy.char.chararray.find\nSnippet: numpy.char.chararray.find method char.chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.67615306"}]}
{"task_id": "mbpp_84", "code": "def sequence(n): \r\n\tif n == 1 or n == 2: \r\n\t\treturn 1\r\n\telse: \r\n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))", "test_list": ["assert sequence(10) == 6", "assert sequence(2) == 1", "assert sequence(3) == 2"], "context": "Write a function to find the n-th number in newman conway sequence.", "function_name": "def sequence(n):", "gold_generation": "if n == 1 or n == 2: \r\n\t\treturn 1\r\n\telse: \r\n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))", "ctxs": [{"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.67791426"}, {"id": "7524", "text": "Function: torch.generated.torch.polygamma#torch.polygamma\nSnippet: torch.polygamma(n, input, *, out=None) → Tensor Computes the nthn^{th} derivative of the digamma function on input. n≥0n \\geq 0 is called the order of the polygamma function. ψ(n)(x)=d(n)dx(n)ψ(x)\\psi^{(n)}(x) = \\frac{d^{(n)}}{dx^{(n)}} \\psi(x) Note This function is implemented only for nonnegative integers n≥0n \\geq 0 . Parameters n (int) – the order of the polygamma function input (Tensor) – the input tensor. Keyword Arguments out (Tensor, optional) – the output tensor. Example:: >>> a = torch.tensor([1, 0.5]) >>> torch.polygamma(1, a) tensor([1.64493, 4.9348]) >>> torch.polygamma(2, a) tensor([ -2.4041, -16.8288]) >>> torch.polygamma(3, a) tensor([ 6.4939, 97.4091]) >>> torch.polygamma(4, a) tensor([ -24.8863, -771.4742])", "score": "0.6569399"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6521798"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6448548"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.64292145"}]}
{"task_id": "mbpp_85", "code": "import math\r\ndef surfacearea_sphere(r):\r\n  surfacearea=4*math.pi*r*r\r\n  return surfacearea", "test_list": ["assert surfacearea_sphere(10)==1256.6370614359173", "assert surfacearea_sphere(15)==2827.4333882308138", "assert surfacearea_sphere(20)==5026.548245743669"], "context": "Write a function to find the surface area of a sphere.", "function_name": "import math\r\ndef surfacearea_sphere(r):", "gold_generation": "surfacearea=4*math.pi*r*r\r\n  return surfacearea", "ctxs": [{"id": "17024", "text": "Function: skimage.api.skimage.measure#skimage.measure.mesh_surface_area\nSnippet: skimage.measure.mesh_surface_area(verts, faces) [source] Compute surface area, given vertices & triangular faces Parameters verts(V, 3) array of floats Array containing (x, y, z) coordinates for V unique mesh vertices. faces(F, 3) array of ints List of length-3 lists of integers, referencing vertex coordinates as provided in verts Returns areafloat Surface area of mesh. Units now [coordinate units] ** 2. See also skimage.measure.marching_cubes skimage.measure.marching_cubes_classic Notes The arguments expected by this function are the first two outputs from skimage.measure.marching_cubes. For unit correct output, ensure correct spacing was passed to skimage.measure.marching_cubes. This algorithm works properly only if the faces provided are all triangles.", "score": "0.64865947"}, {"id": "13483", "text": "Function: pygame.ref.math\nSnippet: vector is the zero vector (i.e. has length 0 thus no direction) a ValueError is raised. reflect() returns a vector reflected of a given normal. reflect(Vector2) -> Vector2 Returns a new vector that points in the direction as if self would bounce of a surface characterized by the given surface normal. The length of the new vector is the same as self's. reflect_ip() reflect the vector of a given normal in place. reflect_ip(Vector2) -> None Changes the direction of self as if it would have been reflected of a surface with the given surface normal. distance_to() calculates the Euclidean distance to a given vector. distance_to(Vector2) -> float distance_squared_to() calculates the squared Euclidean distance to a given vector. distance_squared_to(Vector2) -> float lerp() returns a linear interpolation to the given vector. lerp(Vector2, float) -> Vector2 Returns a Vector which is a linear interpolation between self and the given Vector. The second parameter determines how far between self and other the result is going to be. It must be a value between 0 and 1 where 0 means self and 1 means other will be returned. slerp() returns a spherical interpolation to the given vector. slerp(Vector2, float) -> Vector2 Calculates the spherical interpolation from self to the given Vector. The second argument - often called t - must be in the range [-1, 1]. It parametrizes where - in between the two vectors - the result should be. If a negative value is given the interpolation will not take the complement of the shortest path. elementwise() The next operation will be performed elementwise. elementwise() -> VectorElementwiseProxy Applies the following operation to each element of the vector. rotate() rotates a vector by a given angle in degrees. rotate(angle) -> Vector2 Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in degrees. rotate_rad() rotates a vector by a given angle in radians. rotate_rad(angle) -> Vector2 Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in radians. New in pygame 2.0.0. rotate_ip() rotates the vector by a given angle in degrees in place. rotate_ip(angle) -> None Rotates the vector counterclockwise by the given angle in degrees. The length of the vector is not changed. rotate_ip_rad() rotates the vector by a given angle in radians in place. rotate_ip_rad(angle) -> None Rotates the vector counterclockwise by the given angle in radians. The length of the vector is not changed. New in pygame 2.0.0. angle_to() calculates the angle to a given vector in degrees. angle_to(Vector2) -> float Returns the angle between self and the given vector. as_polar() returns a tuple with radial distance and azimuthal angle. as_polar() -> (r, phi) Returns a tuple (r, phi) where r is the radial distance, and phi is the azimuthal angle. from_polar() Sets x and y from a polar coordinates tuple. from_polar((r, phi)) -> None Sets x and y from a tuple (r, phi) where r is the radial distance, and phi is the azimuthal", "score": "0.645112"}, {"id": "13521", "text": "Function: pygame.ref.math#pygame.math.Vector3.as_spherical\nSnippet: as_spherical() returns a tuple with radial distance, inclination and azimuthal angle. as_spherical() -> (r, theta, phi) Returns a tuple (r, theta, phi) where r is the radial distance, theta is the inclination angle and phi is the azimuthal angle.", "score": "0.6338062"}, {"id": "16631", "text": "Function: skimage.api.skimage.draw\nSnippet: ellipsoid_stats skimage.draw.ellipsoid_stats(a, b, c) [source] Calculates analytical surface area and volume for ellipsoid with semimajor axes aligned with grid dimensions of specified spacing. Parameters afloat Length of semimajor axis aligned with x-axis. bfloat Length of semimajor axis aligned with y-axis. cfloat Length of semimajor axis aligned with z-axis. Returns volfloat Calculated volume of ellipsoid. surffloat Calculated surface area of ellipsoid. line skimage.draw.line(r0, c0, r1, c1) [source] Generate line pixel coordinates. Parameters r0, c0int Starting position (row, column). r1, c1int End position (row, column). Returns rr, cc(N,) ndarray of int Indices of pixels that belong to the line. May be used to directly index into an array, e.g. img[rr, cc] = 1. Notes Anti-aliased line generator is available with line_aa. Examples >>> from skimage.draw import line >>> img = np.zeros((10, 10), dtype=np.uint8) >>> rr, cc = line(1, 1, 8, 8) >>> img[rr, cc] = 1 >>> img array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8) line_aa skimage.draw.line_aa(r0, c0, r1, c1) [source] Generate anti-aliased line pixel coordinates. Parameters r0, c0int Starting position (row, column). r1, c1int End position (row, column). Returns rr, cc, val(N,) ndarray (int, int, float) Indices of pixels (rr, cc) and intensity values (val). img[rr, cc] = val. References 1 A Rasterizing Algorithm for Drawing Curves, A. Zingl, 2012 http://members.chello.at/easyfilter/Bresenham.pdf Examples >>> from skimage.draw import line_aa >>> img = np.zeros((10, 10), dtype=np.uint8) >>> rr, cc, val = line_aa(1, 1, 8, 8) >>> img[rr, cc] = val * 255 >>> img array([[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [ 0, 255, 74, 0, 0, 0, 0, 0, 0, 0], [ 0, 74, 255, 74, 0, 0, 0, 0, 0, 0], [ 0, 0, 74, 255, 74, 0, 0, 0, 0, 0], [ 0, 0, 0, 74, 255, 74, 0, 0, 0, 0], [ 0, 0, 0, 0, 74, 255, 74, 0, 0, 0], [ 0, 0, 0, 0, 0, 74, 255, 74, 0, 0], [ 0, 0, 0, 0, 0, 0, 74, 255, 74, 0], [ 0, 0, 0, 0, 0, 0, 0, 74, 255, 0], [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8) line_nd skimage.draw.line_nd(start, stop, *, endpoint=False, integer=True) [source] Draw a single-pixel thick line in n dimensions. The line produced will be ndim-connected. That is, two subsequent pixels in the line will be either direct or diagonal neighbours in n dimensions. Parameters startarray-like, shape (N,) The start coordinates of the line. stoparray-like, shape (N,) The end coordinates", "score": "0.6268893"}, {"id": "33487", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: barbs_doc='\\nPlot a 2D field of barbs.\\n\\nCall signature::\\n\\n barbs([X, Y], U, V, [C], **kw)\\n\\nWhere *X*, *Y* define the barb locations, *U*, *V* define the barb\\ndirections, and *C* optionally sets the color.\\n\\nAll arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked\\n*X*, *Y* are not supported at present.\\n\\nBarbs are traditionally used in meteorology as a way to plot the speed\\nand direction of wind observations, but can technically be used to\\nplot any two dimensional vector quantity. As opposed to arrows, which\\ngive vector magnitude by the length of the arrow, the barbs give more\\nquantitative information about the vector magnitude by putting slanted\\nlines or a triangle for various increments in magnitude, as show\\nschematically below::\\n\\n : /\\\\ \\\\\\n : / \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : ------------------------------\\n\\nThe largest increment is given by a triangle (or \"flag\"). After those\\ncome full lines (barbs). The smallest increment is a half line. There\\nis only, of course, ever at most 1 half line. If the magnitude is\\nsmall and only needs a single half-line and no full lines or\\ntriangles, the half-line is offset from the end of the barb so that it\\ncan be easily distinguished from barbs with a single full line. The\\nmagnitude for the barb shown above would nominally be 65, using the\\nstandard increments of 50, 10, and 5.\\n\\nSee also https://en.wikipedia.org/wiki/Wind_barb.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the barb locations. See *pivot* for how the\\n barbs are drawn to the x, y positions.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y components of the barb shaft.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If", "score": "0.62605286"}]}
{"task_id": "mbpp_86", "code": "def centered_hexagonal_number(n):\r\n  return 3 * n * (n - 1) + 1", "test_list": ["assert centered_hexagonal_number(10) == 271", "assert centered_hexagonal_number(2) == 7", "assert centered_hexagonal_number(9) == 217"], "context": "Write a function to find nth centered hexagonal number.", "function_name": "def centered_hexagonal_number(n):", "gold_generation": "return 3 * n * (n - 1) + 1", "ctxs": [{"id": "27626", "text": "Function: matplotlib._as_gen.matplotlib.axes.axes.hexbin\nSnippet: matplotlib.axes.Axes.hexbin Axes.hexbin(x, y, C=None, gridsize=100, bins=None, xscale='linear', yscale='linear', extent=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, edgecolors='face', reduce_C_function=<function mean>, mincnt=None, marginals=False, *, data=None, **kwargs)[source] Make a 2D hexagonal binning plot of points x, y. If C is None, the value of the hexagon is determined by the number of points in the hexagon. Otherwise, C specifies values at the coordinate (x[i], y[i]). For each hexagon, these values are reduced using reduce_C_function. Parameters x, yarray-like The data positions. x and y must be of the same length. Carray-like, optional If given, these values are accumulated in the bins. Otherwise, every point has a value of 1. Must be of the same length as x and y. gridsizeint or (int, int), default: 100 If a single int, the number of hexagons in the x-direction. The number of hexagons in the y-direction is chosen such that the hexagons are approximately regular. Alternatively, if a tuple (nx, ny), the number of hexagons in the x-direction and the y-direction. bins'log' or int or sequence, default: None Discretization of the hexagon values. If None, no binning is applied; the color of each hexagon directly corresponds to its count value. If 'log', use a logarithmic scale for the colormap. Internally, \\(log_{10}(i+1)\\) is used to determine the hexagon color. This is equivalent to norm=LogNorm(). If an integer, divide the counts in the specified number of bins, and color the hexagons accordingly. If a sequence of values, the values of the lower bound of the bins to be used. xscale{'linear', 'log'}, default: 'linear' Use a linear or log10 scale on the horizontal axis. yscale{'linear', 'log'}, default: 'linear' Use a linear or log10 scale on the vertical axis. mincntint > 0, default: None If not None, only display cells with more than mincnt number of points in the cell. marginalsbool, default: False If marginals is True, plot the marginal density as colormapped rectangles along the bottom of the x-axis and left of the y-axis. extent4-tuple of float, default: None The limits of the bins (xmin, xmax, ymin, ymax). The default assigns the limits based on gridsize, x, y, xscale and yscale. If xscale or yscale is set to 'log', the limits are expected to be the exponent for a power of 10. E.g. for x-limits of 1 and 50 in 'linear' scale and y-limits of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3). Returns PolyCollection A PolyCollection defining the hexagonal bins. PolyCollection.get_offsets contains a Mx2 array containing the x, y positions of the M hexagon centers. PolyCollection.get_array contains the values of the M hexagons. If marginals is True, horizontal bar and vertical bar (both PolyCollections) will be attached to the return collection as attributes hbar and vbar. Other Parameters cmapstr or Colormap, default: rcParams[\"image.cmap\"] (default: 'viridis') The Colormap instance or registered colormap name used to map the bin values to colors. normNormalize, optional The Normalize instance scales the bin values to the canonical colormap range [0, 1] for mapping to colors. By default, the data range is mapped", "score": "0.69534326"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.69230163"}, {"id": "33344", "text": "Function: matplotlib._as_gen.matplotlib.pyplot.hexbin\nSnippet: matplotlib.pyplot.hexbin matplotlib.pyplot.hexbin(x, y, C=None, gridsize=100, bins=None, xscale='linear', yscale='linear', extent=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, edgecolors='face', reduce_C_function=<function mean>, mincnt=None, marginals=False, *, data=None, **kwargs)[source] Make a 2D hexagonal binning plot of points x, y. If C is None, the value of the hexagon is determined by the number of points in the hexagon. Otherwise, C specifies values at the coordinate (x[i], y[i]). For each hexagon, these values are reduced using reduce_C_function. Parameters x, yarray-like The data positions. x and y must be of the same length. Carray-like, optional If given, these values are accumulated in the bins. Otherwise, every point has a value of 1. Must be of the same length as x and y. gridsizeint or (int, int), default: 100 If a single int, the number of hexagons in the x-direction. The number of hexagons in the y-direction is chosen such that the hexagons are approximately regular. Alternatively, if a tuple (nx, ny), the number of hexagons in the x-direction and the y-direction. bins'log' or int or sequence, default: None Discretization of the hexagon values. If None, no binning is applied; the color of each hexagon directly corresponds to its count value. If 'log', use a logarithmic scale for the colormap. Internally, \\(log_{10}(i+1)\\) is used to determine the hexagon color. This is equivalent to norm=LogNorm(). If an integer, divide the counts in the specified number of bins, and color the hexagons accordingly. If a sequence of values, the values of the lower bound of the bins to be used. xscale{'linear', 'log'}, default: 'linear' Use a linear or log10 scale on the horizontal axis. yscale{'linear', 'log'}, default: 'linear' Use a linear or log10 scale on the vertical axis. mincntint > 0, default: None If not None, only display cells with more than mincnt number of points in the cell. marginalsbool, default: False If marginals is True, plot the marginal density as colormapped rectangles along the bottom of the x-axis and left of the y-axis. extent4-tuple of float, default: None The limits of the bins (xmin, xmax, ymin, ymax). The default assigns the limits based on gridsize, x, y, xscale and yscale. If xscale or yscale is set to 'log', the limits are expected to be the exponent for a power of 10. E.g. for x-limits of 1 and 50 in 'linear' scale and y-limits of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3). Returns PolyCollection A PolyCollection defining the hexagonal bins. PolyCollection.get_offsets contains a Mx2 array containing the x, y positions of the M hexagon centers. PolyCollection.get_array contains the values of the M hexagons. If marginals is True, horizontal bar and vertical bar (both PolyCollections) will be attached to the return collection as attributes hbar and vbar. Other Parameters cmapstr or Colormap, default: rcParams[\"image.cmap\"] (default: 'viridis') The Colormap instance or registered colormap name used to map the bin values to colors. normNormalize, optional The Normalize instance scales the bin values to the canonical colormap range [0, 1] for mapping to colors. By default, the data range is mapped", "score": "0.6895491"}, {"id": "14432", "text": "Function: pandas.reference.api.pandas.dataframe.plot.hexbin\nSnippet: pandas.DataFrame.plot.hexbin DataFrame.plot.hexbin(x, y, C=None, reduce_C_function=None, gridsize=None, **kwargs)[source] Generate a hexagonal binning plot. Generate a hexagonal binning plot of x versus y. If C is None (the default), this is a histogram of the number of occurrences of the observations at (x[i], y[i]). If C is specified, specifies values at given coordinates (x[i], y[i]). These values are accumulated for each hexagonal bin and then reduced according to reduce_C_function, having as default the NumPy’s mean function (numpy.mean()). (If C is specified, it must also be a 1-D sequence of the same length as x and y, or a column label.) Parameters x:int or str The column label or position for x points. y:int or str The column label or position for y points. C:int or str, optional The column label or position for the value of (x, y) point. reduce_C_function:callable, default np.mean Function of one argument that reduces all the values in a bin to a single number (e.g. np.mean, np.max, np.sum, np.std). gridsize:int or tuple of (int, int), default 100 The number of hexagons in the x-direction. The corresponding number of hexagons in the y-direction is chosen in a way that the hexagons are approximately regular. Alternatively, gridsize can be a tuple with two elements specifying the number of hexagons in the x-direction and the y-direction. **kwargs Additional keyword arguments are documented in DataFrame.plot(). Returns matplotlib.AxesSubplot The matplotlib Axes on which the hexbin is plotted. See also DataFrame.plot Make plots of a DataFrame. matplotlib.pyplot.hexbin Hexagonal binning plot using matplotlib, the matplotlib function that is used under the hood. Examples The following examples are generated with random data from a normal distribution. >>> n = 10000 >>> df = pd.DataFrame({'x': np.random.randn(n), ... 'y': np.random.randn(n)}) >>> ax = df.plot.hexbin(x='x', y='y', gridsize=20) The next example uses C and np.sum as reduce_C_function. Note that ‘observations’ values ranges from 1 to 5 but the result plot shows values up to more than 25. This is because of the reduce_C_function. >>> n = 500 >>> df = pd.DataFrame({ ... 'coord_x': np.random.uniform(-3, 3, size=n), ... 'coord_y': np.random.uniform(30, 50, size=n), ... 'observations': np.random.randint(1,5, size=n) ... }) >>> ax = df.plot.hexbin(x='coord_x', ... y='coord_y', ... C='observations', ... reduce_C_function=np.sum, ... gridsize=10, ... cmap=\"viridis\")", "score": "0.6788778"}, {"id": "14447", "text": "Function: pandas.reference.api.pandas.dataframe.radd\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.67515105"}]}
{"task_id": "mbpp_87", "code": "import collections as ct\r\ndef merge_dictionaries_three(dict1,dict2, dict3):\r\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\r\n    return merged_dict", "test_list": ["assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}", "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}", "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}"], "context": "Write a function to merge three dictionaries into a single expression.", "function_name": "import collections as ct\r\ndef merge_dictionaries_three(dict1,dict2, dict3):", "gold_generation": "merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\r\n    return merged_dict", "ctxs": [{"id": "8369", "text": "Function: werkzeug.datastructures.index#werkzeug.datastructures.CombinedMultiDict\nSnippet: class werkzeug.datastructures.CombinedMultiDict(dicts=None) A read only MultiDict that you can pass multiple MultiDict instances as sequence and it will combine the return values of all wrapped dicts: >>> from werkzeug.datastructures import CombinedMultiDict, MultiDict >>> post = MultiDict([('foo', 'bar')]) >>> get = MultiDict([('blub', 'blah')]) >>> combined = CombinedMultiDict([get, post]) >>> combined['foo'] 'bar' >>> combined['blub'] 'blah' This works for all read operations and will raise a TypeError for methods that usually change data which isn’t possible. From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions.", "score": "0.6584047"}, {"id": "20487", "text": "Function: python.library.heapq#heapq.merge\nSnippet: heapq.merge(*iterables, key=None, reverse=False) Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an iterator over the sorted values. Similar to sorted(itertools.chain(*iterables)) but returns an iterable, does not pull the data into memory all at once, and assumes that each of the input streams is already sorted (smallest to largest). Has two optional arguments which must be specified as keyword arguments. key specifies a key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters.", "score": "0.6541411"}, {"id": "42965", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.join_by\nSnippet: numpy.lib.recfunctions.join_by(key, r1, r2, jointype='inner', r1postfix='1', r2postfix='2', defaults=None, usemask=True, asrecarray=False)[source] Join arrays r1 and r2 on key key. The key should be either a string or a sequence of string corresponding to the fields used to join the array. An exception is raised if the key field cannot be found in the two input arrays. Neither r1 nor r2 should have any duplicates along key: the presence of duplicates will make the output quite unreliable. Note that duplicates are not looked for by the algorithm. Parameters key{string, sequence} A string or a sequence of strings corresponding to the fields used for comparison. r1, r2arrays Structured arrays. jointype{‘inner’, ‘outer’, ‘leftouter’}, optional If ‘inner’, returns the elements common to both r1 and r2. If ‘outer’, returns the common elements as well as the elements of r1 not in r2 and the elements of not in r2. If ‘leftouter’, returns the common elements and the elements of r1 not in r2. r1postfixstring, optional String appended to the names of the fields of r1 that are present in r2 but absent of the key. r2postfixstring, optional String appended to the names of the fields of r2 that are present in r1 but absent of the key. defaults{dictionary}, optional Dictionary mapping field names to the corresponding default values. usemask{True, False}, optional Whether to return a MaskedArray (or MaskedRecords is asrecarray==True) or a ndarray. asrecarray{False, True}, optional Whether to return a recarray (or MaskedRecords if usemask==True) or just a flexible-type ndarray. Notes The output is sorted along the key. A temporary array is formed by dropping the fields not in the key for the two arrays and concatenating the result. This array is then sorted, and the common entries selected. The output is constructed by filling the fields with the selected entries. Matching is not preserved if there are some duplicates…", "score": "0.65382487"}, {"id": "42953", "text": "Function: numpy.user.basics.rec\nSnippet: the two arrays and concatenating the result. This array is then sorted, and the common entries selected. The output is constructed by filling the fields with the selected entries. Matching is not preserved if there are some duplicates… numpy.lib.recfunctions.merge_arrays(seqarrays, fill_value=- 1, flatten=False, usemask=False, asrecarray=False)[source] Merge arrays field by field. Parameters seqarrayssequence of ndarrays Sequence of arrays fill_value{float}, optional Filling value used to pad missing data on the shorter arrays. flatten{False, True}, optional Whether to collapse nested fields. usemask{False, True}, optional Whether to return a masked array or not. asrecarray{False, True}, optional Whether to return a recarray (MaskedRecords) or not. Notes Without a mask, the missing value will be filled with something, depending on what its corresponding type: -1 for integers -1.0 for floating point numbers '-' for characters '-1' for strings True for boolean values XXX: I just obtained these values empirically Examples >>> from numpy.lib import recfunctions as rfn >>> rfn.merge_arrays((np.array([1, 2]), np.array([10., 20., 30.]))) array([( 1, 10.), ( 2, 20.), (-1, 30.)], dtype=[('f0', '<i8'), ('f1', '<f8')]) >>> rfn.merge_arrays((np.array([1, 2], dtype=np.int64), ... np.array([10., 20., 30.])), usemask=False) array([(1, 10.0), (2, 20.0), (-1, 30.0)], dtype=[('f0', '<i8'), ('f1', '<f8')]) >>> rfn.merge_arrays((np.array([1, 2]).view([('a', np.int64)]), ... np.array([10., 20., 30.])), ... usemask=False, asrecarray=True) rec.array([( 1, 10.), ( 2, 20.), (-1, 30.)], dtype=[('a', '<i8'), ('f1', '<f8')]) numpy.lib.recfunctions.rec_append_fields(base, names, data, dtypes=None)[source] Add new fields to an existing array. The names of the fields are given with the names arguments, the corresponding values with the data arguments. If a single field is appended, names, data and dtypes do not have to be lists but just values. Parameters basearray Input array to extend. namesstring, sequence String or sequence of strings corresponding to the names of the new fields. dataarray or sequence of arrays Array or sequence of arrays storing the fields to add to the base. dtypessequence of datatypes, optional Datatype or sequence of datatypes. If None, the datatypes are estimated from the data. Returns appended_arraynp.recarray See also append_fields numpy.lib.recfunctions.rec_drop_fields(base, drop_names)[source] Returns a new numpy.recarray with fields in drop_names dropped. numpy.lib.recfunctions.rec_join(key, r1, r2, jointype='inner', r1postfix='1', r2postfix='2', defaults=None)[source] Join arrays r1 and r2 on keys. Alternative to join_by, that always returns a np.recarray. See also join_by equivalent function numpy.lib.recfunctions.recursive_fill_fields(input, output)[source] Fills fields from output with fields from input, with support for nested structures. Parameters inputndarray Input array. outputndarray Output array. Notes output should be at least the same size as input Examples >>> from numpy.lib import recfunctions as rfn >>> a = np.array([(1, 10.), (2, 20.)], dtype=[('A', np.int64), ('B', np.float64)]) >>> b = np.zeros((3,), dtype=a.dtype) >>> rfn.recursive_fill_fields(a, b) array([(1, 10.), (2, 20.), (0, 0.)], dtype=[('A', '<i8'), ('B', '<f8')]) numpy.lib.recfunctions.rename_fields(base, namemapper)[source] Rename the fields from a flexible-datatype ndarray or recarray. Nested fields are supported. Parameters basendarray Input array whose fields must be modified. namemapperdictionary Dictionary mapping old field names to their new version. Examples >>> from numpy.lib import recfunctions as rfn >>> a = np.array([(1, (2, [3.0, 30.])), (4, (5, [6.0, 60.]))], ... dtype=[('a', int),('b', [('ba', float), ('bb', (float, 2))])]) >>> rfn.rename_fields(a, {'a':'A', 'bb':'BB'}) array([(1, (2., [ 3., 30.])), (4, (5.,", "score": "0.6510071"}, {"id": "17702", "text": "Function: python.library.ast#ast.Dict\nSnippet: class ast.Dict(keys, values) A dictionary. keys and values hold lists of nodes representing the keys and the values respectively, in matching order (what would be returned when calling dictionary.keys() and dictionary.values()). When doing dictionary unpacking using dictionary literals the expression to be expanded goes in the values list, with a None at the corresponding position in keys. >>> print(ast.dump(ast.parse('{\"a\":1, **d}', mode='eval'), indent=4)) Expression( body=Dict( keys=[ Constant(value='a'), None], values=[ Constant(value=1), Name(id='d', ctx=Load())]))", "score": "0.64873594"}]}
{"task_id": "mbpp_88", "code": "import collections\r\ndef freq_count(list1):\r\n  freq_count= collections.Counter(list1)\r\n  return freq_count", "test_list": ["assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1}) ", "assert freq_count([1,2,3,4,3,2,4,1,3,1,4])==({1:3, 2:2,3:3,4:3}) ", "assert freq_count([5,6,7,4,9,10,4,5,6,7,9,5])==({10:1,5:3,6:2,7:2,4:2,9:2}) "], "context": "Write a function to get the frequency of the elements in a list.", "function_name": "import collections\r\ndef freq_count(list1):", "gold_generation": "freq_count= collections.Counter(list1)\r\n  return freq_count", "ctxs": [{"id": "14927", "text": "Function: pandas.reference.api.pandas.period.freq\nSnippet: pandas.Period.freq Period.freq", "score": "0.7211416"}, {"id": "14928", "text": "Function: pandas.reference.api.pandas.period.freqstr\nSnippet: pandas.Period.freqstr Period.freqstr Return a string representation of the frequency.", "score": "0.7091912"}, {"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.7058868"}, {"id": "14958", "text": "Function: pandas.reference.api.pandas.periodindex.freq\nSnippet: pandas.PeriodIndex.freq propertyPeriodIndex.freq Return the frequency object if it is set, otherwise None.", "score": "0.70192486"}, {"id": "15446", "text": "Function: pandas.reference.api.pandas.timedelta.freq\nSnippet: pandas.Timedelta.freq Timedelta.freq", "score": "0.7007658"}]}
{"task_id": "mbpp_89", "code": "def closest_num(N):\r\n  return (N - 1)", "test_list": ["assert closest_num(11) == 10", "assert closest_num(7) == 6", "assert closest_num(12) == 11"], "context": "Write a function to find the closest smaller number than n.", "function_name": "def closest_num(N):", "gold_generation": "return (N - 1)", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.71601486"}, {"id": "19496", "text": "Function: python.library.decimal#decimal.Context.next_minus\nSnippet: next_minus(x) Returns the largest representable number smaller than x.", "score": "0.6932645"}, {"id": "19497", "text": "Function: python.library.decimal#decimal.Context.next_plus\nSnippet: next_plus(x) Returns the smallest representable number larger than x.", "score": "0.6916044"}, {"id": "19506", "text": "Function: python.library.decimal#decimal.Context.remainder_near\nSnippet: remainder_near(x, y) Returns x - y * n, where n is the integer nearest the exact value of x / y (if the result is 0 then its sign will be the sign of x).", "score": "0.67003286"}, {"id": "19492", "text": "Function: python.library.decimal#decimal.Context.min\nSnippet: min(x, y) Compares two values numerically and returns the minimum.", "score": "0.6692835"}]}
{"task_id": "mbpp_90", "code": "def len_log(list1):\r\n    max=len(list1[0])\r\n    for i in list1:\r\n        if len(i)>max:\r\n            max=len(i)\r\n    return max", "test_list": ["assert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7", "assert len_log([\"a\",\"ab\",\"abc\"]) == 3", "assert len_log([\"small\",\"big\",\"tall\"]) == 5"], "context": "Write a python function to find the length of the longest word.", "function_name": "def len_log(list1):", "gold_generation": "max=len(list1[0])\r\n    for i in list1:\r\n        if len(i)>max:\r\n            max=len(i)\r\n    return max", "ctxs": [{"id": "21316", "text": "Function: python.library.itertools#itertools.zip_longest\nSnippet: itertools.zip_longest(*iterables, fillvalue=None) Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. Roughly equivalent to: def zip_longest(*args, fillvalue=None): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- iterators = [iter(it) for it in args] num_active = len(iterators) if not num_active: return while True: values = [] for i, it in enumerate(iterators): try: value = next(it) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values.append(value) yield tuple(values) If one of the iterables is potentially infinite, then the zip_longest() function should be wrapped with something that limits the number of calls (for example islice() or takewhile()). If not specified, fillvalue defaults to None.", "score": "0.6870831"}, {"id": "19646", "text": "Function: python.library.difflib#difflib.SequenceMatcher.find_longest_match\nSnippet: find_longest_match(alo=0, ahi=None, blo=0, bhi=None) Find longest matching block in a[alo:ahi] and b[blo:bhi]. If isjunk was omitted or None, find_longest_match() returns (i, j, k) such that a[i:i+k] is equal to b[j:j+k], where alo <= i <= i+k <= ahi and blo <= j <= j+k <= bhi. For all (i', j', k') meeting those conditions, the additional conditions k >= k', i <= i', and if i == i', j <= j' are also met. In other words, of all maximal matching blocks, return one that starts earliest in a, and of all those maximal matching blocks that start earliest in a, return the one that starts earliest in b. >>> s = SequenceMatcher(None, \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=0, b=4, size=5) If isjunk was provided, first the longest matching block is determined as above, but with the additional restriction that no junk element appears in the block. Then that block is extended as far as possible by matching (only) junk elements on both sides. So the resulting block never matches on junk except as identical junk happens to be adjacent to an interesting match. Here’s the same example as before, but considering blanks to be junk. That prevents ' abcd' from matching the ' abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments.", "score": "0.6838904"}, {"id": "23418", "text": "Function: python.library.reprlib#reprlib.Repr.maxlong\nSnippet: Repr.maxlong Maximum number of characters in the representation for an integer. Digits are dropped from the middle. The default is 40.", "score": "0.67359734"}, {"id": "25027", "text": "Function: python.library.textwrap#textwrap.TextWrapper.break_long_words\nSnippet: break_long_words (default: True) If true, then words longer than width will be broken in order to ensure that no lines are longer than width. If it is false, long words will not be broken, and some lines may be longer than width. (Long words will be put on a line by themselves, in order to minimize the amount by which width is exceeded.)", "score": "0.67306197"}, {"id": "25020", "text": "Function: python.library.textwrap\nSnippet: \"'\", followed by a space. One problem with this is algorithm is that it is unable to detect the difference between “Dr.” in [...] Dr. Frankenstein's monster [...] and “Spot.” in [...] See Spot. See Spot run [...] fix_sentence_endings is false by default. Since the sentence detection algorithm relies on string.lowercase for the definition of “lowercase letter”, and a convention of using two spaces after a period to separate sentences on the same line, it is specific to English-language texts. break_long_words (default: True) If true, then words longer than width will be broken in order to ensure that no lines are longer than width. If it is false, long words will not be broken, and some lines may be longer than width. (Long words will be put on a line by themselves, in order to minimize the amount by which width is exceeded.) break_on_hyphens (default: True) If true, wrapping will occur preferably on whitespaces and right after hyphens in compound words, as it is customary in English. If false, only whitespaces will be considered as potentially good places for line breaks, but you need to set break_long_words to false if you want truly insecable words. Default behaviour in previous versions was to always allow breaking hyphenated words. max_lines (default: None) If not None, then the output will contain at most max_lines lines, with placeholder appearing at the end of the output. New in version 3.4. placeholder (default: ' [...]') String that will appear at the end of the output text if it has been truncated. New in version 3.4. TextWrapper also provides some public methods, analogous to the module-level convenience functions: wrap(text) Wraps the single paragraph in text (a string) so every line is at most width characters long. All wrapping options are taken from instance attributes of the TextWrapper instance. Returns a list of output lines, without final newlines. If the wrapped output has no content, the returned list is empty. fill(text) Wraps the single paragraph in text, and returns a single string containing the wrapped paragraph.", "score": "0.66638124"}]}
{"task_id": "mbpp_91", "code": "def find_substring(str1, sub_str):\r\n   if any(sub_str in s for s in str1):\r\n       return True\r\n   return False", "test_list": ["assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ack\")==True", "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"abc\")==False", "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ange\")==True"], "context": "Write a function to check if a substring is present in a given list of string values.", "function_name": "def find_substring(str1, sub_str):", "gold_generation": "if any(sub_str in s for s in str1):\r\n       return True\r\n   return False", "ctxs": [{"id": "24349", "text": "Function: python.library.stdtypes#str.index\nSnippet: str.index(sub[, start[, end]]) Like find(), but raise ValueError when the substring is not found.", "score": "0.73296416"}, {"id": "42786", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.is_string\nSnippet: numpy.distutils.misc_util.is_string(s)[source]", "score": "0.7223773"}, {"id": "24346", "text": "Function: python.library.stdtypes#str.find\nSnippet: str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True", "score": "0.7184288"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.7067007"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.70312285"}]}
{"task_id": "mbpp_92", "code": "def is_undulating(n): \r\n\tif (len(n) <= 2): \r\n\t\treturn False\r\n\tfor i in range(2, len(n)): \r\n\t\tif (n[i - 2] != n[i]): \r\n\t\t\treturn False\r\n\treturn True", "test_list": ["assert is_undulating(\"1212121\") == True", "assert is_undulating(\"1991\") == False", "assert is_undulating(\"121\") == True"], "context": "Write a function to check whether the given number is undulating or not.", "function_name": "def is_undulating(n):", "gold_generation": "if (len(n) <= 2): \r\n\t\treturn False\r\n\tfor i in range(2, len(n)): \r\n\t\tif (n[i - 2] != n[i]): \r\n\t\t\treturn False\r\n\treturn True", "ctxs": [{"id": "19477", "text": "Function: python.library.decimal#decimal.Context.is_normal\nSnippet: is_normal(x) Returns True if x is a normal number; otherwise returns False.", "score": "0.67082787"}, {"id": "21811", "text": "Function: python.library.math#math.isnan\nSnippet: math.isnan(x) Return True if x is a NaN (not a number), and False otherwise.", "score": "0.67035687"}, {"id": "21810", "text": "Function: python.library.math#math.isinf\nSnippet: math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise.", "score": "0.66497266"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.6576925"}, {"id": "21776", "text": "Function: python.library.math\nSnippet: (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9. Note that frexp() and modf() have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 2**52 necessarily has no fractional bits. Power and logarithmic functions math.exp(x) Return e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). math.expm1(x) Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision: >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.0000050000069649e-05 >>> expm1(1e-5) # result accurate to full precision 1.0000050000166668e-05 New in version 3.2. math.log(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). math.log1p(x) Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. math.log2(x) Return the base-2 logarithm of x. This is usually more accurate than log(x, 2). New in version 3.3. See also int.bit_length() returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. math.log10(x) Return the base-10 logarithm of x. This is usually more accurate than log(x, 10). math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", "score": "0.6561474"}]}
{"task_id": "mbpp_93", "code": "def power(a,b):\r\n\tif b==0:\r\n\t\treturn 1\r\n\telif a==0:\r\n\t\treturn 0\r\n\telif b==1:\r\n\t\treturn a\r\n\telse:\r\n\t\treturn a*power(a,b-1)", "test_list": ["assert power(3,4) == 81", "assert power(2,3) == 8", "assert power(5,5) == 3125"], "context": "Write a function to calculate the value of 'a' to the power 'b'.", "function_name": "def power(a,b):", "gold_generation": "if b==0:\r\n\t\treturn 1\r\n\telif a==0:\r\n\t\treturn 0\r\n\telif b==1:\r\n\t\treturn a\r\n\telse:\r\n\t\treturn a*power(a,b-1)", "ctxs": [{"id": "23150", "text": "Function: python.library.functions#pow\nSnippet: pow(base, exp[, mod]) Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp. The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10**2 returns 100, but 10**-2 returns 0.01. For int operands base and exp, if mod is present, mod must also be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod. In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod. Here’s an example of computing an inverse for 38 modulo 97: >>> pow(38, -1, mod=97) 23 >>> 23 * 38 % 97 == 1 True Changed in version 3.8: For int operands, the three-argument form of pow now allows the second argument to be negative, permitting computation of modular inverses. Changed in version 3.8: Allow keyword arguments. Formerly, only positional arguments were supported.", "score": "0.67294836"}, {"id": "42052", "text": "Function: numpy.reference.generated.numpy.lib.scimath.power\nSnippet: numpy.lib.scimath.power lib.scimath.power(x, p)[source] Return x to the power p, (x**p). If x contains negative values, the output is converted to the complex domain. Parameters xarray_like The input value(s). parray_like of ints The power(s) to which x is raised. If x contains multiple values, p has to either be a scalar, or contain the same number of values as x. In the latter case, the result is x[0]**p[0], x[1]**p[1], .... Returns outndarray or scalar The result of x**p. If x and p are scalars, so is out, otherwise an array is returned. See also numpy.power Examples >>> np.set_printoptions(precision=4) >>> np.emath.power([2, 4], 2) array([ 4, 16]) >>> np.emath.power([2, 4], -2) array([0.25 , 0.0625]) >>> np.emath.power([-2, 4], 2) array([ 4.-0.j, 16.+0.j])", "score": "0.67275125"}, {"id": "7848", "text": "Function: torch.tensors#torch.Tensor.float_power\nSnippet: float_power(exponent) → Tensor See torch.float_power()", "score": "0.66940695"}, {"id": "43106", "text": "Function: numpy.reference.generated.numpy.power\nSnippet: numpy.power numpy.power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'power'> First array elements raised to powers from second array, element-wise. Raise each base in x1 to the positionally-corresponding power in x2. x1 and x2 must be broadcastable to the same shape. An integer type raised to a negative integer power will raise a ValueError. Negative values raised to a non-integral value will return nan. To get complex results, cast the input to complex, or specify the dtype to be complex (see the example below). Parameters x1array_like The bases. x2array_like The exponents. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray The bases in x1 raised to the exponents in x2. This is a scalar if both x1 and x2 are scalars. See also float_power power function that promotes integers to float Examples Cube each element in an array. >>> x1 = np.arange(6) >>> x1 [0, 1, 2, 3, 4, 5] >>> np.power(x1, 3) array([ 0, 1, 8, 27, 64, 125]) Raise the bases to different exponents. >>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0] >>> np.power(x1, x2) array([ 0., 1., 8., 27., 16., 5.]) The effect of broadcasting. >>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]]) >>> x2 array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]]) >>> np.power(x1, x2) array([[ 0, 1, 8, 27, 16, 5], [ 0, 1, 8, 27, 16, 5]]) The ** operator can be used as a shorthand for np.power on ndarrays. >>> x2 = np.array([1, 2, 3, 3, 2, 1]) >>> x1 = np.arange(6) >>> x1 ** x2 array([ 0, 1, 8, 27, 16, 5]) Negative values raised to a non-integral value will result in nan (and a warning will be generated). >>> x3 = np.array([-1.0, -4.0]) >>> with np.errstate(invalid='ignore'): ... p = np.power(x3, 1.5) ... >>> p array([nan, nan]) To get complex results, give the argument dtype=complex. >>> np.power(x3, 1.5, dtype=complex) array([-1.83697020e-16-1.j, -1.46957616e-15-8.j])", "score": "0.668768"}, {"id": "20290", "text": "Function: python.library.functions\nSnippet: integer representing the Unicode code point of that character. For example, ord('a') returns the integer 97 and ord('€') (Euro sign) returns 8364. This is the inverse of chr(). pow(base, exp[, mod]) Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp. The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10**2 returns 100, but 10**-2 returns 0.01. For int operands base and exp, if mod is present, mod must also be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod. In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod. Here’s an example of computing an inverse for 38 modulo 97: >>> pow(38, -1, mod=97) 23 >>> 23 * 38 % 97 == 1 True Changed in version 3.8: For int operands, the three-argument form of pow now allows the second argument to be negative, permitting computation of modular inverses. Changed in version 3.8: Allow keyword arguments. Formerly, only positional arguments were supported. print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False) Print objects to the text stream file, separated by sep and followed by end. sep, end, file and flush, if present, must be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end. The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Since printed arguments are converted to text strings, print() cannot be used with binary mode file objects. For these, use file.write(...) instead. Whether output is buffered is usually determined by file, but if the flush keyword argument is true, the stream is forcibly flushed. Changed in version 3.3: Added the flush keyword argument. class property(fget=None, fset=None, fdel=None, doc=None) Return a property attribute. fget is a function for getting an attribute value. fset is a function for setting an attribute value. fdel is a function for deleting an attribute value. And doc creates a docstring for the attribute. A typical use is to define a managed attribute x: class C: def __init__(self): self._x = None def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") If c is an instance of C, c.x", "score": "0.6680976"}]}
{"task_id": "mbpp_94", "code": "from operator import itemgetter \r\ndef index_minimum(test_list):\r\n  res = min(test_list, key = itemgetter(1))[0]\r\n  return (res) ", "test_list": ["assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'", "assert index_minimum([('Yash', 185), ('Dawood', 125), ('Sanya', 175)]) == 'Dawood'", "assert index_minimum([('Sai', 345), ('Salman', 145), ('Ayesha', 96)]) == 'Ayesha'"], "context": "Write a function to extract the index minimum value record from the given tuples.", "function_name": "from operator import itemgetter \r\ndef index_minimum(test_list):", "gold_generation": "res = min(test_list, key = itemgetter(1))[0]\r\n  return (res)", "ctxs": [{"id": "43922", "text": "Function: numpy.reference.generated.numpy.record.min\nSnippet: numpy.record.min method record.min() Scalar method identical to the corresponding array attribute. Please see ndarray.min.", "score": "0.7252547"}, {"id": "20489", "text": "Function: python.library.heapq#heapq.nsmallest\nSnippet: heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n].", "score": "0.6937104"}, {"id": "21919", "text": "Function: python.library.mmap#mmap.mmap.find\nSnippet: find(sub[, start[, end]]) Returns the lowest index in the object where the subsequence sub is found, such that sub is contained in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. Returns -1 on failure. Changed in version 3.5: Writable bytes-like object is now accepted.", "score": "0.69194686"}, {"id": "21889", "text": "Function: python.library.functions#min\nSnippet: min(iterable, *[, key, default]) min(arg1, arg2, *args[, key]) Return the smallest item in an iterable or the smallest of two or more arguments. If one positional argument is provided, it should be an iterable. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.6873741"}, {"id": "20478", "text": "Function: python.library.heapq\nSnippet: key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters. heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n]. heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n]. The latter two functions perform best for smaller values of n. For larger values, it is more efficient to use the sorted() function. Also, when n==1, it is more efficient to use the built-in min() and max() functions. If repeated usage of these functions is required, consider turning the iterable into an actual heap. Basic Examples A heapsort can be implemented by pushing all values onto a heap and then popping off the smallest values one at a time: >>> def heapsort(iterable): ... h = [] ... for value in iterable: ... heappush(h, value) ... return [heappop(h) for i in range(len(h))] ... >>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] This is similar to sorted(iterable), but unlike sorted(), this implementation is not stable. Heap elements can be tuples. This is useful for assigning comparison values (such as task priorities) alongside the main record being tracked: >>> h = [] >>> heappush(h, (5, 'write code')) >>> heappush(h, (7, 'release product')) >>> heappush(h, (1, 'write spec')) >>> heappush(h, (3, 'create tests')) >>> heappop(h) (1, 'write spec') Priority Queue Implementation Notes A priority queue is common use for a heap, and it presents several implementation challenges: Sort stability: how do you get two tasks with equal priorities to be returned in the order they were originally added? Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order. If the priority of a task changes, how do you move it to a new position in the heap? Or if a pending task needs to be deleted, how do you find it and remove it from the queue? A solution to the first two challenges is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were", "score": "0.6804444"}]}
{"task_id": "mbpp_95", "code": "def Find_Min_Length(lst):  \r\n    minLength = min(len(x) for x in lst )\r\n    return minLength ", "test_list": ["assert Find_Min_Length([[1],[1,2]]) == 1", "assert Find_Min_Length([[1,2],[1,2,3],[1,2,3,4]]) == 2", "assert Find_Min_Length([[3,3,3],[4,4,4,4]]) == 3"], "context": "Write a python function to find the minimum length of sublist.", "function_name": "def Find_Min_Length(lst):", "gold_generation": "minLength = min(len(x) for x in lst )\r\n    return minLength", "ctxs": [{"id": "18944", "text": "Function: python.library.ctypes#ctypes.Array._length_\nSnippet: _length_ A positive integer specifying the number of elements in the array. Out-of-range subscripts result in an IndexError. Will be returned by len().", "score": "0.71259844"}, {"id": "21919", "text": "Function: python.library.mmap#mmap.mmap.find\nSnippet: find(sub[, start[, end]]) Returns the lowest index in the object where the subsequence sub is found, such that sub is contained in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. Returns -1 on failure. Changed in version 3.5: Writable bytes-like object is now accepted.", "score": "0.70369697"}, {"id": "21889", "text": "Function: python.library.functions#min\nSnippet: min(iterable, *[, key, default]) min(arg1, arg2, *args[, key]) Return the smallest item in an iterable or the smallest of two or more arguments. If one positional argument is provided, it should be an iterable. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.6938498"}, {"id": "18264", "text": "Function: python.library.stdtypes#bytearray.find\nSnippet: bytes.find(sub[, start[, end]]) bytearray.find(sub[, start[, end]]) Return the lowest index in the data where the subsequence sub is found, such that sub is contained in the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> b'Py' in b'Python' True Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.69099605"}, {"id": "18308", "text": "Function: python.library.stdtypes#bytes.find\nSnippet: bytes.find(sub[, start[, end]]) bytearray.find(sub[, start[, end]]) Return the lowest index in the data where the subsequence sub is found, such that sub is contained in the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> b'Py' in b'Python' True Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.68924093"}]}
{"task_id": "mbpp_96", "code": "def divisor(n):\r\n  for i in range(n):\r\n    x = len([i for i in range(1,n+1) if not n % i])\r\n  return x", "test_list": ["assert divisor(15) == 4 ", "assert divisor(12) == 6", "assert divisor(9) == 3"], "context": "Write a python function to find the number of divisors of a given integer.", "function_name": "def divisor(n):", "gold_generation": "for i in range(n):\r\n    x = len([i for i in range(1,n+1) if not n % i])\r\n  return x", "ctxs": [{"id": "21805", "text": "Function: python.library.math#math.gcd\nSnippet: math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported.", "score": "0.68569106"}, {"id": "22281", "text": "Function: python.library.numbers#numbers.Rational.numerator\nSnippet: numerator Abstract.", "score": "0.67364067"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6719319"}, {"id": "22280", "text": "Function: python.library.numbers#numbers.Rational.denominator\nSnippet: denominator Abstract.", "score": "0.6708423"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.669919"}]}
{"task_id": "mbpp_97", "code": "def frequency_lists(list1):\r\n    list1 = [item for sublist in list1 for item in sublist]\r\n    dic_data = {}\r\n    for num in list1:\r\n        if num in dic_data.keys():\r\n            dic_data[num] += 1\r\n        else:\r\n            key = num\r\n            value = 1\r\n            dic_data[key] = value\r\n    return dic_data\r\n", "test_list": ["assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}", "assert frequency_lists([[1,2,3,4],[5,6,7,8],[9,10,11,12]])=={1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1,10:1,11:1,12:1}", "assert frequency_lists([[20,30,40,17],[18,16,14,13],[10,20,30,40]])=={20:2,30:2,40:2,17: 1,18:1, 16: 1,14: 1,13: 1, 10: 1}"], "context": "Write a function to find frequency count of list of lists.", "function_name": "def frequency_lists(list1):", "gold_generation": "list1 = [item for sublist in list1 for item in sublist]\r\n    dic_data = {}\r\n    for num in list1:\r\n        if num in dic_data.keys():\r\n            dic_data[num] += 1\r\n        else:\r\n            key = num\r\n            value = 1\r\n            dic_data[key] = value\r\n    return dic_data", "ctxs": [{"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.70764595"}, {"id": "14927", "text": "Function: pandas.reference.api.pandas.period.freq\nSnippet: pandas.Period.freq Period.freq", "score": "0.69028455"}, {"id": "22190", "text": "Function: python.library.multiprocessing.shared_memory#multiprocessing.shared_memory.ShareableList.count\nSnippet: count(value) Returns the number of occurrences of value.", "score": "0.68900096"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.68648636"}, {"id": "22306", "text": "Function: python.library.operator#operator.countOf\nSnippet: operator.countOf(a, b) Return the number of occurrences of b in a.", "score": "0.6859237"}]}
{"task_id": "mbpp_98", "code": "def multiply_num(numbers):  \r\n    total = 1\r\n    for x in numbers:\r\n        total *= x  \r\n    return total/len(numbers) ", "test_list": ["assert multiply_num((8, 2, 3, -1, 7))==-67.2", "assert multiply_num((-10,-20,-30))==-2000.0", "assert multiply_num((19,15,18))==1710.0"], "context": "Write a function to multiply all the numbers in a list and divide with the length of the list.", "function_name": "def multiply_num(numbers):", "gold_generation": "total = 1\r\n    for x in numbers:\r\n        total *= x  \r\n    return total/len(numbers)", "ctxs": [{"id": "19495", "text": "Function: python.library.decimal#decimal.Context.multiply\nSnippet: multiply(x, y) Return the product of x and y.", "score": "0.6927894"}, {"id": "14410", "text": "Function: pandas.reference.api.pandas.dataframe.multiply\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6549365"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.647735"}, {"id": "19466", "text": "Function: python.library.decimal#decimal.Context.divide\nSnippet: divide(x, y) Return x divided by y.", "score": "0.64557856"}, {"id": "43029", "text": "Function: numpy.reference.generated.numpy.multiply\nSnippet: numpy.multiply numpy.multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'multiply'> Multiply arguments element-wise. Parameters x1, x2array_like Input arrays to be multiplied. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray The product of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. Notes Equivalent to x1 * x2 in terms of array broadcasting. Examples >>> np.multiply(2.0, 4.0) 8.0 >>> x1 = np.arange(9.0).reshape((3, 3)) >>> x2 = np.arange(3.0) >>> np.multiply(x1, x2) array([[ 0., 1., 4.], [ 0., 4., 10.], [ 0., 7., 16.]]) The * operator can be used as a shorthand for np.multiply on ndarrays. >>> x1 = np.arange(9.0).reshape((3, 3)) >>> x2 = np.arange(3.0) >>> x1 * x2 array([[ 0., 1., 4.], [ 0., 4., 10.], [ 0., 7., 16.]])", "score": "0.6407725"}]}
{"task_id": "mbpp_99", "code": "def decimal_to_binary(n): \r\n    return bin(n).replace(\"0b\",\"\") ", "test_list": ["assert decimal_to_binary(8) == '1000'", "assert decimal_to_binary(18) == '10010'", "assert decimal_to_binary(7) == '111' "], "context": "Write a function to convert the given decimal number to its binary equivalent.", "function_name": "def decimal_to_binary(n):", "gold_generation": "return bin(n).replace(\"0b\",\"\")", "ctxs": [{"id": "19499", "text": "Function: python.library.decimal#decimal.Context.normalize\nSnippet: normalize(x) Reduces x to its simplest form.", "score": "0.74377006"}, {"id": "19516", "text": "Function: python.library.decimal#decimal.Decimal\nSnippet: class decimal.Decimal(value=\"0\", context=None) Construct a new Decimal object based from value. value can be an integer, string, tuple, float, or another Decimal object. If no value is given, returns Decimal('0'). If value is a string, it should conform to the decimal numeric string syntax after leading and trailing whitespace characters, as well as underscores throughout, are removed: sign ::= '+' | '-' digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' indicator ::= 'e' | 'E' digits ::= digit [digit]... decimal-part ::= digits '.' [digits] | ['.'] digits exponent-part ::= indicator [sign] digits infinity ::= 'Infinity' | 'Inf' nan ::= 'NaN' [digits] | 'sNaN' [digits] numeric-value ::= decimal-part [exponent-part] | infinity numeric-string ::= [sign] numeric-value | [sign] nan Other Unicode decimal digits are also permitted where digit appears above. These include decimal digits from various other alphabets (for example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits '\\uff10' through '\\uff19'. If value is a tuple, it should have three components, a sign (0 for positive or 1 for negative), a tuple of digits, and an integer exponent. For example, Decimal((0, (1, 4, 1, 4), -3)) returns Decimal('1.414'). If value is a float, the binary floating point value is losslessly converted to its exact decimal equivalent. This conversion can often require 53 or more digits of precision. For example, Decimal(float('1.1')) converts to Decimal('1.100000000000000088817841970012523233890533447265625'). The context precision does not affect how many digits are stored. That is determined exclusively by the number of digits in value. For example, Decimal('3.00000') records all five zeros even if the context precision is only three. The purpose of the context argument is determining what to do if value is a malformed string. If the context traps InvalidOperation, an exception is raised; otherwise, the constructor returns a new Decimal with the value of NaN. Once constructed, Decimal objects are immutable. Changed in version 3.2: The argument to the constructor is now permitted to be a float instance. Changed in version 3.3: float arguments raise an exception if the FloatOperation trap is set. By default the trap is off. Changed in version 3.6: Underscores are allowed for grouping, as with integral and floating-point literals in code. Decimal floating point objects share many properties with the other built-in numeric types such as float and int. All of the usual math operations and special methods apply. Likewise, decimal objects can be copied, pickled, printed, used as dictionary keys, used as set elements, compared, sorted, and coerced to another type (such as float or int). There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator % is applied to Decimal objects, the sign of the result is the sign of the dividend rather than the sign of the divisor: >>> (-7) % 4 1 >>> Decimal(-7) % Decimal(4) Decimal('-3') The integer division operator // behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather", "score": "0.7308959"}, {"id": "19536", "text": "Function: python.library.decimal#decimal.Decimal.from_float\nSnippet: from_float(f) Classmethod that converts a float to a decimal number, exactly. Note Decimal.from_float(0.1) is not the same as Decimal(‘0.1’). Since 0.1 is not exactly representable in binary floating point, the value is stored as the nearest representable value which is 0x1.999999999999ap-4. That equivalent value in decimal is 0.1000000000000000055511151231257827021181583404541015625. Note From Python 3.2 onwards, a Decimal instance can also be constructed directly from a float. >>> Decimal.from_float(0.1) Decimal('0.1000000000000000055511151231257827021181583404541015625') >>> Decimal.from_float(float('nan')) Decimal('NaN') >>> Decimal.from_float(float('inf')) Decimal('Infinity') >>> Decimal.from_float(float('-inf')) Decimal('-Infinity') New in version 3.1.", "score": "0.73026764"}, {"id": "18215", "text": "Function: python.library.functions#bin\nSnippet: bin(x) Convert an integer number to a binary string prefixed with “0b”. The result is a valid Python expression. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> bin(3) '0b11' >>> bin(-10) '-0b1010' If prefix “0b” is desired or not, you can use either of the following ways. >>> format(14, '#b'), format(14, 'b') ('0b1110', '1110') >>> f'{14:#b}', f'{14:b}' ('0b1110', '1110') See also format() for more information.", "score": "0.7258387"}, {"id": "19442", "text": "Function: python.library.decimal\nSnippet: In developing fixed-point applications, it is convenient to define functions to handle the quantize() step: >>> def mul(x, y, fp=TWOPLACES): ... return (x * y).quantize(fp) >>> def div(x, y, fp=TWOPLACES): ... return (x / y).quantize(fp) >>> mul(a, b) # Automatically preserve fixed-point Decimal('325.62') >>> div(b, a) Decimal('0.03') Q. There are many ways to express the same value. The numbers 200, 200.000, 2E2, and 02E+4 all have the same value at various precisions. Is there a way to transform them to a single recognizable canonical value? A. The normalize() method maps all equivalent values to a single representative: >>> values = map(Decimal, '200 200.000 2E2 .02E+4'.split()) >>> [v.normalize() for v in values] [Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2')] Q. Some decimal values always print with exponential notation. Is there a way to get a non-exponential representation? A. For some values, exponential notation is the only way to express the number of significant places in the coefficient. For example, expressing 5.0E+3 as 5000 keeps the value constant but cannot show the original’s two-place significance. If an application does not care about tracking significance, it is easy to remove the exponent and trailing zeroes, losing significance, but keeping the value unchanged: >>> def remove_exponent(d): ... return d.quantize(Decimal(1)) if d == d.to_integral() else d.normalize() >>> remove_exponent(Decimal('5E+3')) Decimal('5000') Q. Is there a way to convert a regular float to a Decimal? A. Yes, any binary floating point number can be exactly expressed as a Decimal though an exact conversion may take more precision than intuition would suggest: >>> Decimal(math.pi) Decimal('3.141592653589793115997963468544185161590576171875') Q. Within a complex calculation, how can I make sure that I haven’t gotten a spurious result because of insufficient precision or rounding anomalies. A. The decimal module makes it easy to test results. A best practice is to re-run calculations using greater precision and with various rounding modes. Widely differing results indicate insufficient precision, rounding mode issues, ill-conditioned inputs, or a numerically unstable algorithm. Q. I noticed that context precision is applied to the results of operations but not to the inputs. Is there anything to watch out for when mixing values of different precisions? A. Yes. The principle is that all values are considered to be exact and so is the arithmetic on those values. Only the results are rounded. The advantage for inputs is that “what you type is what you get”. A disadvantage is that the results can look odd if you forget that the inputs haven’t been rounded: >>> getcontext().prec = 3 >>> Decimal('3.104') + Decimal('2.104') Decimal('5.21') >>> Decimal('3.104') + Decimal('0.000') + Decimal('2.104') Decimal('5.20') The solution is either to increase precision or to force rounding of inputs using the unary plus operation: >>> getcontext().prec = 3 >>> +Decimal('1.23456789') # unary plus triggers rounding Decimal('1.23') Alternatively, inputs can be rounded upon creation using the Context.create_decimal() method: >>> Context(prec=5, rounding=ROUND_DOWN).create_decimal('1.2345678') Decimal('1.2345') Q. Is the CPython implementation fast for large numbers? A. Yes. In the CPython and PyPy3 implementations, the C/CFFI versions of the decimal module integrate the high speed libmpdec library for arbitrary precision", "score": "0.7243474"}]}
{"task_id": "mbpp_100", "code": "import sys\r\ndef next_smallest_palindrome(num):\r\n    numstr = str(num)\r\n    for i in range(num+1,sys.maxsize):\r\n        if str(i) == str(i)[::-1]:\r\n            return i", "test_list": ["assert next_smallest_palindrome(99)==101", "assert next_smallest_palindrome(1221)==1331", "assert next_smallest_palindrome(120)==121"], "context": "Write a function to find the next smallest palindrome of a specified number.", "function_name": "import sys\r\ndef next_smallest_palindrome(num):", "gold_generation": "numstr = str(num)\r\n    for i in range(num+1,sys.maxsize):\r\n        if str(i) == str(i)[::-1]:\r\n            return i", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.69683075"}, {"id": "19497", "text": "Function: python.library.decimal#decimal.Context.next_plus\nSnippet: next_plus(x) Returns the smallest representable number larger than x.", "score": "0.688845"}, {"id": "41724", "text": "Function: numpy.reference.generated.numpy.char.find\nSnippet: numpy.char.find char.find(a, sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. Calls str.find element-wise. For each element, return the lowest index in the string where substring sub is found, such that sub is contained in the range [start, end]. Parameters aarray_like of str or unicode substr or unicode start, endint, optional Optional arguments start and end are interpreted as in slice notation. Returns outndarray or int Output array of ints. Returns -1 if sub is not found. See also str.find", "score": "0.6786295"}, {"id": "19559", "text": "Function: python.library.decimal#decimal.Decimal.next_plus\nSnippet: next_plus(context=None) Return the smallest number representable in the given context (or in the current thread’s context if no context is given) that is larger than the given operand.", "score": "0.6772832"}, {"id": "21822", "text": "Function: python.library.math#math.nextafter\nSnippet: math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9.", "score": "0.6686587"}]}
{"task_id": "mbpp_101", "code": "def kth_element(arr, n, k):\r\n  for i in range(n):\r\n    for j in range(0, n-i-1):\r\n      if arr[j] > arr[j+1]:\r\n        arr[j], arr[j+1] == arr[j+1], arr[j]\r\n  return arr[k-1]", "test_list": ["assert kth_element([12,3,5,7,19], 5, 2) == 3", "assert kth_element([17,24,8,23], 4, 3) == 8", "assert kth_element([16,21,25,36,4], 5, 4) == 36"], "context": "Write a function to find the kth element in the given array.", "function_name": "def kth_element(arr, n, k):", "gold_generation": "for i in range(n):\r\n    for j in range(0, n-i-1):\r\n      if arr[j] > arr[j+1]:\r\n        arr[j], arr[j+1] == arr[j+1], arr[j]\r\n  return arr[k-1]", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.6970252"}, {"id": "43864", "text": "Function: numpy.reference.generated.numpy.recarray.partition\nSnippet: numpy.recarray.partition method recarray.partition(kth, axis=- 1, kind='introselect', order=None) Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array. All elements smaller than the kth element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined. New in version 1.8.0. Parameters kthint or sequence of ints Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. Deprecated since version 1.22.0: Passing booleans as index is deprecated. axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘introselect’}, optional Selection algorithm. Default is ‘introselect’. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.partition Return a parititioned copy of an array. argpartition Indirect partition. sort Full sort. Notes See np.partition for notes on the different algorithms. Examples >>> a = np.array([3, 4, 2, 1]) >>> a.partition(3) >>> a array([2, 1, 3, 4]) >>> a.partition((1, 3)) >>> a array([1, 2, 3, 4])", "score": "0.68127906"}, {"id": "42550", "text": "Function: numpy.reference.generated.numpy.ndarray.partition\nSnippet: numpy.ndarray.partition method ndarray.partition(kth, axis=- 1, kind='introselect', order=None) Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array. All elements smaller than the kth element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined. New in version 1.8.0. Parameters kthint or sequence of ints Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. Deprecated since version 1.22.0: Passing booleans as index is deprecated. axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘introselect’}, optional Selection algorithm. Default is ‘introselect’. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.partition Return a parititioned copy of an array. argpartition Indirect partition. sort Full sort. Notes See np.partition for notes on the different algorithms. Examples >>> a = np.array([3, 4, 2, 1]) >>> a.partition(3) >>> a array([2, 1, 3, 4]) >>> a.partition((1, 3)) >>> a array([1, 2, 3, 4])", "score": "0.677923"}, {"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.67548466"}, {"id": "6696", "text": "Function: torch.generated.torch.kthvalue#torch.kthvalue\nSnippet: torch.kthvalue(input, k, dim=None, keepdim=False, *, out=None) -> (Tensor, LongTensor) Returns a namedtuple (values, indices) where values is the k th smallest element of each row of the input tensor in the given dimension dim. And indices is the index location of each element found. If dim is not given, the last dimension of the input is chosen. If keepdim is True, both the values and indices tensors are the same size as input, except in the dimension dim where they are of size 1. Otherwise, dim is squeezed (see torch.squeeze()), resulting in both the values and indices tensors having 1 fewer dimension than the input tensor. Note When input is a CUDA tensor and there are multiple valid k th values, this function may nondeterministically return indices for any of them. Parameters input (Tensor) – the input tensor. k (int) – k for the k-th smallest element dim (int, optional) – the dimension to find the kth value along keepdim (bool) – whether the output tensor has dim retained or not. Keyword Arguments out (tuple, optional) – the output tuple of (Tensor, LongTensor) can be optionally given to be used as output buffers Example: >>> x = torch.arange(1., 6.) >>> x tensor([ 1., 2., 3., 4., 5.]) >>> torch.kthvalue(x, 4) torch.return_types.kthvalue(values=tensor(4.), indices=tensor(3)) >>> x=torch.arange(1.,7.).resize_(2,3) >>> x tensor([[ 1., 2., 3.], [ 4., 5., 6.]]) >>> torch.kthvalue(x, 2, 0, True) torch.return_types.kthvalue(values=tensor([[4., 5., 6.]]), indices=tensor([[1, 1, 1]]))", "score": "0.67344254"}]}
{"task_id": "mbpp_102", "code": "def snake_to_camel(word):\r\n        import re\r\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))", "test_list": ["assert snake_to_camel('python_program')=='PythonProgram'", "assert snake_to_camel('python_language')==('PythonLanguage')", "assert snake_to_camel('programming_language')==('ProgrammingLanguage')"], "context": "Write a function to convert snake case string to camel case string.", "function_name": "def snake_to_camel(word):", "gold_generation": "import re\r\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))", "ctxs": [{"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.7236941"}, {"id": "25742", "text": "Function: python.library.stdtypes\nSnippet: Strings also support two styles of string formatting, one providing a large degree of flexibility and customization (see str.format(), Format String Syntax and Custom String Formatting) and the other based on C printf style formatting that handles a narrower range of types and is slightly harder to use correctly, but is often faster for the cases it can handle (printf-style String Formatting). The Text Processing Services section of the standard library covers a number of other modules that provide various text related utilities (including regular expression support in the re module). str.capitalize() Return a copy of the string with its first character capitalized and the rest lowercased. Changed in version 3.8: The first character is now put into titlecase rather than uppercase. This means that characters like digraphs will only have their first letter capitalized, instead of the full character. str.casefold() Return a casefolded copy of the string. Casefolded strings may be used for caseless matching. Casefolding is similar to lowercasing but more aggressive because it is intended to remove all case distinctions in a string. For example, the German lowercase letter 'ß' is equivalent to \"ss\". Since it is already lowercase, lower() would do nothing to 'ß'; casefold() converts it to \"ss\". The casefolding algorithm is described in section 3.13 of the Unicode Standard. New in version 3.3. str.center(width[, fillchar]) Return centered in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. str.encode(encoding=\"utf-8\", errors=\"strict\") Return an encoded version of the string as a bytes object. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other possible values are 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and any other name registered via codecs.register_error(), see section Error Handlers. For a list of possible encodings, see section Standard Encodings. By default, the errors argument is not checked for best performances, but only used at the first encoding error. Enable the Python Development Mode, or use a debug build to check errors. Changed in version 3.1: Support for keyword arguments added. Changed in version 3.9: The errors is now checked in development mode and in debug mode. str.endswith(suffix[, start[, end]]) Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. str.expandtabs(tabsize=8) Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. Tab positions occur every tabsize characters (default is 8, giving tab positions at columns 0, 8, 16 and so", "score": "0.69285965"}, {"id": "25759", "text": "Function: python.library.stdtypes\nSnippet: apostrophes can be constructed using regular expressions: >>> import re >>> def titlecase(s): ... return re.sub(rb\"[A-Za-z]+('[A-Za-z]+)?\", ... lambda mo: mo.group(0)[0:1].upper() + ... mo.group(0)[1:].lower(), ... s) ... >>> titlecase(b\"they're bill's friends.\") b\"They're Bill's Friends.\" Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.upper() bytearray.upper() Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart. For example: >>> b'Hello World'.upper() b'HELLO WORLD' Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.zfill(width) bytearray.zfill(width) Return a copy of the sequence left filled with ASCII b'0' digits to make a sequence of length width. A leading sign prefix (b'+'/ b'-') is handled by inserting the padding after the sign character rather than before. For bytes objects, the original sequence is returned if width is less than or equal to len(seq). For example: >>> b\"42\".zfill(5) b'00042' >>> b\"-42\".zfill(5) b'-0042' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. printf-style Bytes Formatting Note The formatting operations described here exhibit a variety of quirks that lead to a number of common errors (such as failing to display tuples and dictionaries correctly). If the value being printed may be a tuple or dictionary, wrap it in a tuple. Bytes objects (bytes/bytearray) have one unique built-in operation: the % operator (modulo). This is also known as the bytes formatting or interpolation operator. Given format % values (where format is a bytes object), % conversion specifications in format are replaced with zero or more elements of values. The effect is similar to using the sprintf() in the C language. If format requires a single argument, values may be a single non-tuple object. 5 Otherwise, values must be a tuple with exactly the number of items specified by the format bytes object, or a single mapping object (for example, a dictionary). A conversion specifier contains two or more characters and has the following components, which must occur in this order: The '%' character, which marks the start of the specifier. Mapping key (optional), consisting of a parenthesised sequence of characters (for example, (somename)). Conversion flags (optional), which affect the result of some conversion types. Minimum field width (optional). If specified as an '*' (asterisk), the actual width is read from the next element of the tuple in values, and the object to convert comes after the minimum field width and optional precision. Precision (optional), given as a '.' (dot) followed by the precision. If specified as '*' (an asterisk), the actual precision is read from the next element of the tuple in values, and the value to convert comes after the precision.", "score": "0.6922512"}, {"id": "24381", "text": "Function: python.library.stdtypes#str.swapcase\nSnippet: str.swapcase() Return a copy of the string with uppercase characters converted to lowercase and vice versa. Note that it is not necessarily true that s.swapcase().swapcase() == s.", "score": "0.68932587"}, {"id": "5026", "text": "Function: tensorflow.raw_ops.stringupper\nSnippet: tf.raw_ops.StringUpper Converts all lowercase characters into their respective uppercase replacements. View aliases Compat aliases for migration See Migration guide for more details. tf.compat.v1.raw_ops.StringUpper tf.raw_ops.StringUpper( input, encoding='', name=None ) Example: tf.strings.upper(\"CamelCase string and ALL CAPS\") <tf.Tensor: shape=(), dtype=string, numpy=b'CAMELCASE STRING AND ALL CAPS'> Args input A Tensor of type string. encoding An optional string. Defaults to \"\". name A name for the operation (optional). Returns A Tensor of type string.", "score": "0.6868787"}]}
{"task_id": "mbpp_103", "code": "def eulerian_num(n, m): \r\n\tif (m >= n or n == 0): \r\n\t\treturn 0 \r\n\tif (m == 0): \r\n\t\treturn 1 \r\n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))", "test_list": ["assert eulerian_num(3, 1) == 4", "assert eulerian_num(4, 1) == 11", "assert eulerian_num(5, 3) == 26"], "context": "Write a function to find eulerian number a(n, m).", "function_name": "def eulerian_num(n, m):", "gold_generation": "if (m >= n or n == 0): \r\n\t\treturn 0 \r\n\tif (m == 0): \r\n\t\treturn 1 \r\n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6763166"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6561993"}, {"id": "21785", "text": "Function: python.library.math#math.atanh\nSnippet: math.atanh(x) Return the inverse hyperbolic tangent of x.", "score": "0.65399504"}, {"id": "21782", "text": "Function: python.library.math#math.asinh\nSnippet: math.asinh(x) Return the inverse hyperbolic sine of x.", "score": "0.6428423"}, {"id": "21802", "text": "Function: python.library.math#math.frexp\nSnippet: math.frexp(x) Return the mantissa and exponent of x as the pair (m, e). m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way.", "score": "0.64144456"}]}
{"task_id": "mbpp_104", "code": "def sort_sublists(input_list):\r\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \r\n    return result\r", "test_list": ["assert sort_sublists(([\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]))==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]", "assert sort_sublists(([\" red \",\"green\" ],[\"blue \",\" black\"],[\" orange\",\"brown\"]))==[[' red ', 'green'], [' black', 'blue '], [' orange', 'brown']]", "assert sort_sublists(([\"zilver\",\"gold\"], [\"magnesium\",\"aluminium\"], [\"steel\", \"bronze\"]))==[['gold', 'zilver'],['aluminium', 'magnesium'], ['bronze', 'steel']]"], "context": "Write a function to sort each sublist of strings in a given list of lists using lambda function.", "function_name": "def sort_sublists(input_list):", "gold_generation": "result = [sorted(x, key = lambda x:x[0]) for x in input_list] \r\n    return result", "ctxs": [{"id": "15305", "text": "Function: pandas.reference.api.pandas.series.sort_index\nSnippet: s = pd.Series([1, 2, 3, 4], index=['A', 'b', 'C', 'd']) >>> s.sort_index(key=lambda x : x.str.lower()) A 1 b 2 C 3 d 4 dtype: int64", "score": "0.69745505"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6904531"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.68401873"}, {"id": "14668", "text": "Function: pandas.reference.api.pandas.index\nSnippet: Compute slice locations for input labels. sort(*args, **kwargs) Use sort_values instead. sort_values([return_indexer, ascending, ...]) Return a sorted copy of the index. sortlevel([level, ascending, sort_remaining]) For internal compatibility with the Index API. str alias of pandas.core.strings.accessor.StringMethods symmetric_difference(other[, result_name, sort]) Compute the symmetric difference of two Index objects. take(indices[, axis, allow_fill, fill_value]) Return a new Index of the values selected by the indices. to_flat_index() Identity method. to_frame([index, name]) Create a DataFrame with a column containing the Index. to_list() Return a list of the values. to_native_types([slicer]) (DEPRECATED) Format specified values of self and return them. to_numpy([dtype, copy, na_value]) A NumPy ndarray representing the values in this Series or Index. to_series([index, name]) Create a Series with both index and values equal to the index keys. tolist() Return a list of the values. transpose(*args, **kwargs) Return the transpose, which is by definition self. union(other[, sort]) Form the union of two Index objects. unique([level]) Return unique values in the index. value_counts([normalize, sort, ascending, ...]) Return a Series containing counts of unique values. where(cond[, other]) Replace values where the condition is False. view", "score": "0.67477846"}, {"id": "21356", "text": "Function: python.library.stdtypes#list\nSnippet: class list([iterable]) Lists may be constructed in several ways: Using a pair of square brackets to denote the empty list: [] Using square brackets, separating items with commas: [a], [a, b, c] Using a list comprehension: [x for x in iterable] Using the type constructor: list() or list(iterable) The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to iterable[:]. For example, list('abc') returns ['a', 'b', 'c'] and list( (1, 2, 3) ) returns [1, 2, 3]. If no argument is given, the constructor creates a new empty list, []. Many other operations also produce lists, including the sorted() built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.67019236"}]}
{"task_id": "mbpp_105", "code": "def count(lst):   \r\n    return sum(lst) ", "test_list": ["assert count([True,False,True]) == 2", "assert count([False,False]) == 0", "assert count([True,True,True]) == 3"], "context": "Write a python function to count true booleans in the given list.", "function_name": "def count(lst):", "gold_generation": "return sum(lst)", "ctxs": [{"id": "25584", "text": "Function: python.library.constants#True\nSnippet: True The true value of the bool type. Assignments to True are illegal and raise a SyntaxError.", "score": "0.69375974"}, {"id": "20128", "text": "Function: python.library.constants#False\nSnippet: False The false value of the bool type. Assignments to False are illegal and raise a SyntaxError.", "score": "0.6792236"}, {"id": "19682", "text": "Function: python.library.dis#dis.hascompare\nSnippet: dis.hascompare Sequence of bytecodes of Boolean operations.", "score": "0.67907774"}, {"id": "22352", "text": "Function: python.library.operator#operator.truth\nSnippet: operator.truth(obj) Return True if obj is true, and False otherwise. This is equivalent to using the bool constructor.", "score": "0.6789305"}, {"id": "42717", "text": "Function: numpy.reference.generated.numpy.count_nonzero\nSnippet: numpy.count_nonzero numpy.count_nonzero(a, axis=None, *, keepdims=False)[source] Counts the number of non-zero values in the array a. The word “non-zero” is in reference to the Python 2.x built-in method __nonzero__() (renamed __bool__() in Python 3.x) of Python objects that tests an object’s “truthfulness”. For example, any number is considered truthful if it is nonzero, whereas any string is considered truthful if it is not the empty string. Thus, this function (recursively) counts how many elements in a (and in sub-arrays thereof) have their __nonzero__() or __bool__() method evaluated to True. Parameters aarray_like The array for which to count non-zeros. axisint or tuple, optional Axis or tuple of axes along which to count non-zeros. Default is None, meaning that non-zeros will be counted along a flattened version of a. New in version 1.12.0. keepdimsbool, optional If this is set to True, the axes that are counted are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. New in version 1.19.0. Returns countint or array of int Number of non-zero values in the array along a given axis. Otherwise, the total number of non-zero values in the array is returned. See also nonzero Return the coordinates of all the non-zero values. Examples >>> np.count_nonzero(np.eye(4)) 4 >>> a = np.array([[0, 1, 7, 0], ... [3, 0, 2, 19]]) >>> np.count_nonzero(a) 5 >>> np.count_nonzero(a, axis=0) array([1, 1, 2, 1]) >>> np.count_nonzero(a, axis=1) array([2, 3]) >>> np.count_nonzero(a, axis=1, keepdims=True) array([[2], [3]])", "score": "0.67335206"}]}
{"task_id": "mbpp_106", "code": "def add_lists(test_list, test_tup):\r\n  res = tuple(list(test_tup) + test_list)\r\n  return (res) ", "test_list": ["assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)", "assert add_lists([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)", "assert add_lists([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)"], "context": "Write a function to add the given list to the given tuples.", "function_name": "def add_lists(test_list, test_tup):", "gold_generation": "res = tuple(list(test_tup) + test_list)\r\n  return (res)", "ctxs": [{"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.67212236"}, {"id": "18617", "text": "Function: python.library.collections\nSnippet: a new instance of the named tuple replacing specified fields with new values: >>> p = Point(x=11, y=22) >>> p._replace(x=33) Point(x=33, y=22) >>> for partnum, record in inventory.items(): ... inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now()) somenamedtuple._fields Tuple of strings listing the field names. Useful for introspection and for creating new named tuple types from existing named tuples. >>> p._fields # view the field names ('x', 'y') >>> Color = namedtuple('Color', 'red green blue') >>> Pixel = namedtuple('Pixel', Point._fields + Color._fields) >>> Pixel(11, 22, 128, 255, 0) Pixel(x=11, y=22, red=128, green=255, blue=0) somenamedtuple._field_defaults Dictionary mapping field names to default values. >>> Account = namedtuple('Account', ['type', 'balance'], defaults=[0]) >>> Account._field_defaults {'balance': 0} >>> Account('premium') Account(type='premium', balance=0) To retrieve a field whose name is stored in a string, use the getattr() function: >>> getattr(p, 'x') 11 To convert a dictionary to a named tuple, use the double-star-operator (as described in Unpacking Argument Lists): >>> d = {'x': 11, 'y': 22} >>> Point(**d) Point(x=11, y=22) Since a named tuple is a regular Python class, it is easy to add or change functionality with a subclass. Here is how to add a calculated field and a fixed-width print format: >>> class Point(namedtuple('Point', ['x', 'y'])): ... __slots__ = () ... @property ... def hypot(self): ... return (self.x ** 2 + self.y ** 2) ** 0.5 ... def __str__(self): ... return 'Point: x=%6.3f y=%6.3f hypot=%6.3f' % (self.x, self.y, self.hypot) >>> for p in Point(3, 4), Point(14, 5/7): ... print(p) Point: x= 3.000 y= 4.000 hypot= 5.000 Point: x=14.000 y= 0.714 hypot=14.018 The subclass shown above sets __slots__ to an empty tuple. This helps keep memory requirements low by preventing the creation of instance dictionaries. Subclassing is not useful for adding new, stored fields. Instead, simply create a new named tuple type from the _fields attribute: >>> Point3D = namedtuple('Point3D', Point._fields + ('z',)) Docstrings can be customized by making direct assignments to the __doc__ fields: >>> Book = namedtuple('Book', ['id', 'title', 'authors']) >>> Book.__doc__ += ': Hardcover book in active collection' >>> Book.id.__doc__ = '13-digit ISBN' >>> Book.title.__doc__ = 'Title of first printing' >>> Book.authors.__doc__ = 'List of authors sorted by last name' Changed in version 3.5: Property docstrings became writeable. See also See typing.NamedTuple for a way to add type hints for named tuples. It also provides an elegant notation using the class keyword: class Component(NamedTuple): part_number: int weight: float description: Optional[str] = None See types.SimpleNamespace() for a mutable namespace based on an underlying dictionary instead of a tuple. The dataclasses module provides a decorator and functions for automatically adding generated special methods to user-defined classes. OrderedDict objects Ordered dictionaries are just like regular dictionaries but have some extra capabilities relating to ordering operations. They have become less important now that the built-in dict class gained the ability to remember insertion order (this new behavior became guaranteed in Python 3.7). Some differences from dict still remain: The regular dict was designed to be very good at mapping operations. Tracking insertion order was secondary. The OrderedDict was designed to be", "score": "0.66339934"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.66338205"}, {"id": "42611", "text": "Function: numpy.reference.generated.numpy.add\nSnippet: numpy.add numpy.add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'add'> Add arguments element-wise. Parameters x1, x2array_like The arrays to be added. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns addndarray or scalar The sum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. Notes Equivalent to x1 + x2 in terms of array broadcasting. Examples >>> np.add(1.0, 4.0) 5.0 >>> x1 = np.arange(9.0).reshape((3, 3)) >>> x2 = np.arange(3.0) >>> np.add(x1, x2) array([[ 0., 2., 4.], [ 3., 5., 7.], [ 6., 8., 10.]]) The + operator can be used as a shorthand for np.add on ndarrays. >>> x1 = np.arange(9.0).reshape((3, 3)) >>> x2 = np.arange(3.0) >>> x1 + x2 array([[ 0., 2., 4.], [ 3., 5., 7.], [ 6., 8., 10.]])", "score": "0.6572987"}, {"id": "42756", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.as_list\nSnippet: numpy.distutils.misc_util.as_list(seq)[source]", "score": "0.6517215"}]}
{"task_id": "mbpp_107", "code": "def count_Hexadecimal(L,R) :  \r\n    count = 0;  \r\n    for i in range(L,R + 1) : \r\n        if (i >= 10 and i <= 15) : \r\n            count += 1;  \r\n        elif (i > 15) : \r\n            k = i;  \r\n            while (k != 0) :  \r\n                if (k % 16 >= 10) : \r\n                    count += 1;  \r\n                k = k // 16;  \r\n    return count;  ", "test_list": ["assert count_Hexadecimal(10,15) == 6", "assert count_Hexadecimal(2,4) == 0", "assert count_Hexadecimal(15,16) == 1"], "context": "Write a python function to count hexadecimal numbers for a given range.", "function_name": "def count_Hexadecimal(L,R) :", "gold_generation": "count = 0;  \r\n    for i in range(L,R + 1) : \r\n        if (i >= 10 and i <= 15) : \r\n            count += 1;  \r\n        elif (i > 15) : \r\n            k = i;  \r\n            while (k != 0) :  \r\n                if (k % 16 >= 10) : \r\n                    count += 1;  \r\n                k = k // 16;  \r\n    return count;", "ctxs": [{"id": "20284", "text": "Function: python.library.functions\nSnippet: hexadecimal string prefixed with “0x”. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> hex(255) '0xff' >>> hex(-42) '-0x2a' If you want to convert an integer number to an uppercase or lower hexadecimal string with prefix or not, you can use either of the following ways: >>> '%#x' % 255, '%x' % 255, '%X' % 255 ('0xff', 'ff', 'FF') >>> format(255, '#x'), format(255, 'x'), format(255, 'X') ('0xff', 'ff', 'FF') >>> f'{255:#x}', f'{255:x}', f'{255:X}' ('0xff', 'ff', 'FF') See also format() for more information. See also int() for converting a hexadecimal string to an integer using a base of 16. Note To obtain a hexadecimal string representation for a float, use the float.hex() method. id(object) Return the “identity” of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value. CPython implementation detail: This is the address of the object in memory. Raises an auditing event builtins.id with argument id. input([prompt]) If the prompt argument is present, it is written to standard output without a trailing newline. The function then reads a line from input, converts it to a string (stripping a trailing newline), and returns that. When EOF is read, EOFError is raised. Example: >>> s = input('--> ') --> Monty Python's Flying Circus >>> s \"Monty Python's Flying Circus\" If the readline module was loaded, then input() will use it to provide elaborate line editing and history features. Raises an auditing event builtins.input with argument prompt before reading input Raises an auditing event builtins.input/result with the result after successfully reading input. class int([x]) class int(x, base=10) Return an integer object constructed from a number or string x, or return 0 if no arguments are given. If x defines __int__(), int(x) returns x.__int__(). If x defines __index__(), it returns x.__index__(). If x defines __trunc__(), it returns x.__trunc__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in radix base. Optionally, the literal can be preceded by + or - (with no space in between) and surrounded by whitespace. A base-n literal consists of the digits 0 to n-1, with a to z (or A to Z) having values 10 to 35. The default base is 10. The allowed values are 0 and 2–36. Base-2, -8, and -16 literals can be optionally prefixed with 0b/0B, 0o/0O, or 0x/0X, as with integer literals in code. Base 0 means to interpret exactly as a code literal, so that the actual base is 2, 8, 10, or 16, and so that int('010', 0) is not legal, while int('010') is, as well as int('010', 8). The integer type is described in Numeric Types — int, float, complex. Changed in version 3.4: If base is not an instance of int", "score": "0.70697606"}, {"id": "21304", "text": "Function: python.library.itertools#itertools.count\nSnippet: itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments.", "score": "0.7034791"}, {"id": "24414", "text": "Function: python.library.string#string.hexdigits\nSnippet: string.hexdigits The string '0123456789abcdefABCDEF'.", "score": "0.69809455"}, {"id": "20491", "text": "Function: python.library.functions#hex\nSnippet: hex(x) Convert an integer number to a lowercase hexadecimal string prefixed with “0x”. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> hex(255) '0xff' >>> hex(-42) '-0x2a' If you want to convert an integer number to an uppercase or lower hexadecimal string with prefix or not, you can use either of the following ways: >>> '%#x' % 255, '%x' % 255, '%X' % 255 ('0xff', 'ff', 'FF') >>> format(255, '#x'), format(255, 'x'), format(255, 'X') ('0xff', 'ff', 'FF') >>> f'{255:#x}', f'{255:x}', f'{255:X}' ('0xff', 'ff', 'FF') See also format() for more information. See also int() for converting a hexadecimal string to an integer using a base of 16. Note To obtain a hexadecimal string representation for a float, use the float.hex() method.", "score": "0.6972325"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.6965128"}]}
{"task_id": "mbpp_108", "code": "import heapq\r\ndef merge_sorted_list(num1,num2,num3):\r\n  num1=sorted(num1)\r\n  num2=sorted(num2)\r\n  num3=sorted(num3)\r\n  result = heapq.merge(num1,num2,num3)\r\n  return list(result)", "test_list": ["assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]", "assert merge_sorted_list([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12])==[1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]", "assert merge_sorted_list([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1],[25, 35, 22, 85, 14, 65, 75, 25, 58],[12, 74, 9, 50, 61, 41])==[1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]"], "context": "Write a function to merge multiple sorted inputs into a single sorted iterator using heap queue algorithm.", "function_name": "import heapq\r\ndef merge_sorted_list(num1,num2,num3):", "gold_generation": "num1=sorted(num1)\r\n  num2=sorted(num2)\r\n  num3=sorted(num3)\r\n  result = heapq.merge(num1,num2,num3)\r\n  return list(result)", "ctxs": [{"id": "20487", "text": "Function: python.library.heapq#heapq.merge\nSnippet: heapq.merge(*iterables, key=None, reverse=False) Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an iterator over the sorted values. Similar to sorted(itertools.chain(*iterables)) but returns an iterable, does not pull the data into memory all at once, and assumes that each of the input streams is already sorted (smallest to largest). Has two optional arguments which must be specified as keyword arguments. key specifies a key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters.", "score": "0.8063375"}, {"id": "20478", "text": "Function: python.library.heapq\nSnippet: key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters. heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n]. heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n]. The latter two functions perform best for smaller values of n. For larger values, it is more efficient to use the sorted() function. Also, when n==1, it is more efficient to use the built-in min() and max() functions. If repeated usage of these functions is required, consider turning the iterable into an actual heap. Basic Examples A heapsort can be implemented by pushing all values onto a heap and then popping off the smallest values one at a time: >>> def heapsort(iterable): ... h = [] ... for value in iterable: ... heappush(h, value) ... return [heappop(h) for i in range(len(h))] ... >>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] This is similar to sorted(iterable), but unlike sorted(), this implementation is not stable. Heap elements can be tuples. This is useful for assigning comparison values (such as task priorities) alongside the main record being tracked: >>> h = [] >>> heappush(h, (5, 'write code')) >>> heappush(h, (7, 'release product')) >>> heappush(h, (1, 'write spec')) >>> heappush(h, (3, 'create tests')) >>> heappop(h) (1, 'write spec') Priority Queue Implementation Notes A priority queue is common use for a heap, and it presents several implementation challenges: Sort stability: how do you get two tasks with equal priorities to be returned in the order they were originally added? Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order. If the priority of a task changes, how do you move it to a new position in the heap? Or if a pending task needs to be deleted, how do you find it and remove it from the queue? A solution to the first two challenges is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were", "score": "0.74632996"}, {"id": "20477", "text": "Function: python.library.heapq\nSnippet: heapq — Heap queue algorithm Source code: Lib/heapq.py This module provides an implementation of the heap queue algorithm, also known as the priority queue algorithm. Heaps are binary trees for which every parent node has a value less than or equal to any of its children. This implementation uses arrays for which heap[k] <= heap[2*k+1] and heap[k] <= heap[2*k+2] for all k, counting elements from zero. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that its smallest element is always the root, heap[0]. The API below differs from textbook heap algorithms in two aspects: (a) We use zero-based indexing. This makes the relationship between the index for a node and the indexes for its children slightly less obvious, but is more suitable since Python uses zero-based indexing. (b) Our pop method returns the smallest item, not the largest (called a “min heap” in textbooks; a “max heap” is more common in texts because of its suitability for in-place sorting). These two make it possible to view the heap as a regular Python list without surprises: heap[0] is the smallest item, and heap.sort() maintains the heap invariant! To create a heap, use a list initialized to [], or you can transform a populated list into a heap via function heapify(). The following functions are provided: heapq.heappush(heap, item) Push the value item onto the heap, maintaining the heap invariant. heapq.heappop(heap) Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0]. heapq.heappushpop(heap, item) Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop(). heapq.heapify(x) Transform list x into a heap, in-place, in linear time. heapq.heapreplace(heap, item) Pop and return the smallest item from the heap, and also push the new item. The heap size doesn’t change. If the heap is empty, IndexError is raised. This one step operation is more efficient than a heappop() followed by heappush() and can be more appropriate when using a fixed-size heap. The pop/push combination always returns an element from the heap and replaces it with item. The value returned may be larger than the item added. If that isn’t desired, consider using heappushpop() instead. Its push/pop combination returns the smaller of the two values, leaving the larger value on the heap. The module also offers three general purpose functions based on heaps. heapq.merge(*iterables, key=None, reverse=False) Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an iterator over the sorted values. Similar to sorted(itertools.chain(*iterables)) but returns an iterable, does not pull the data into memory all at once, and assumes that each of the input streams is already sorted (smallest to largest). Has two optional arguments which must be specified as keyword arguments. key specifies a", "score": "0.73092896"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.7291992"}, {"id": "20482", "text": "Function: python.library.heapq#heapq.heapify\nSnippet: heapq.heapify(x) Transform list x into a heap, in-place, in linear time.", "score": "0.71689594"}]}
{"task_id": "mbpp_109", "code": "def odd_Equivalent(s,n): \r\n    count=0\r\n    for i in range(0,n): \r\n        if (s[i] == '1'): \r\n            count = count + 1\r\n    return count ", "test_list": ["assert odd_Equivalent(\"011001\",6) == 3", "assert odd_Equivalent(\"11011\",5) == 4", "assert odd_Equivalent(\"1010\",4) == 2"], "context": "Write a python function to find the count of rotations of a binary string with odd value.", "function_name": "def odd_Equivalent(s,n):", "gold_generation": "count=0\r\n    for i in range(0,n): \r\n        if (s[i] == '1'): \r\n            count = count + 1\r\n    return count", "ctxs": [{"id": "19507", "text": "Function: python.library.decimal#decimal.Context.rotate\nSnippet: rotate(x, y) Returns a rotated copy of x, y times.", "score": "0.7131743"}, {"id": "19566", "text": "Function: python.library.decimal#decimal.Decimal.rotate\nSnippet: rotate(other, context=None) Return the result of rotating the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to rotate. If the second operand is positive then rotation is to the left; otherwise rotation is to the right. The coefficient of the first operand is padded on the left with zeros to length precision if necessary. The sign and exponent of the first operand are unchanged.", "score": "0.6881605"}, {"id": "30892", "text": "Function: matplotlib.collections_api#matplotlib.collections.RegularPolyCollection.get_rotation\nSnippet: get_rotation()[source]", "score": "0.6824564"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.67820275"}, {"id": "18676", "text": "Function: python.library.collections#collections.deque.rotate\nSnippet: rotate(n=1) Rotate the deque n steps to the right. If n is negative, rotate to the left. When the deque is not empty, rotating one step to the right is equivalent to d.appendleft(d.pop()), and rotating one step to the left is equivalent to d.append(d.popleft()).", "score": "0.67813843"}]}
{"task_id": "mbpp_110", "code": "def extract_missing(test_list, strt_val, stop_val):\r\n  res = []\r\n  for sub in test_list:\r\n    if sub[0] > strt_val:\r\n      res.append((strt_val, sub[0]))\r\n      strt_val = sub[1]\r\n    if strt_val < stop_val:\r\n      res.append((strt_val, stop_val))\r\n  return (res) ", "test_list": ["assert extract_missing([(6, 9), (15, 34), (48, 70)], 2, 100) == [(2, 6), (9, 100), (9, 15), (34, 100), (34, 48), (70, 100)]", "assert extract_missing([(7, 2), (15, 19), (38, 50)], 5, 60) == [(5, 7), (2, 60), (2, 15), (19, 60), (19, 38), (50, 60)]", "assert extract_missing([(7, 2), (15, 19), (38, 50)], 1, 52) == [(1, 7), (2, 52), (2, 15), (19, 52), (19, 38), (50, 52)]"], "context": "Write a function to extract the ranges that are missing from the given list with the given start range and end range values.", "function_name": "def extract_missing(test_list, strt_val, stop_val):", "gold_generation": "res = []\r\n  for sub in test_list:\r\n    if sub[0] > strt_val:\r\n      res.append((strt_val, sub[0]))\r\n      strt_val = sub[1]\r\n    if strt_val < stop_val:\r\n      res.append((strt_val, stop_val))\r\n  return (res)", "ctxs": [{"id": "25740", "text": "Function: python.library.stdtypes\nSnippet: omitted, it defaults to 0. If step is zero, ValueError is raised. For a positive step, the contents of a range r are determined by the formula r[i] = start + step*i where i >= 0 and r[i] < stop. For a negative step, the contents of the range are still determined by the formula r[i] = start + step*i, but the constraints are i >= 0 and r[i] > stop. A range object will be empty if r[0] does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than sys.maxsize are permitted but some features (such as len()) may raise OverflowError. Range examples: >>> list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> list(range(0, 30, 5)) [0, 5, 10, 15, 20, 25] >>> list(range(0, 10, 3)) [0, 3, 6, 9] >>> list(range(0, -10, -1)) [0, -1, -2, -3, -4, -5, -6, -7, -8, -9] >>> list(range(0)) [] >>> list(range(1, 0)) [] Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). start The value of the start parameter (or 0 if the parameter was not supplied) stop The value of the stop parameter step The value of the step parameter (or 1 if the parameter was not supplied) The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and subranges as needed). Range objects implement the collections.abc.Sequence ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): >>> r = range(0, 20, 2) >>> r range(0, 20, 2) >>> 11 in r False >>> 10 in r True >>> r.index(10) 5 >>> r[5] 10 >>> r[:5] range(0, 10, 2) >>> r[-1] 18 Testing range objects for equality with == and != compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different start, stop and step attributes, for example range(0) == range(2, 1, 3) or range(0, 3, 2) == range(0, 4, 2).) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test int objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity). New in version 3.3: The", "score": "0.67140675"}, {"id": "21919", "text": "Function: python.library.mmap#mmap.mmap.find\nSnippet: find(sub[, start[, end]]) Returns the lowest index in the object where the subsequence sub is found, such that sub is contained in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. Returns -1 on failure. Changed in version 3.5: Writable bytes-like object is now accepted.", "score": "0.66548276"}, {"id": "8590", "text": "Function: werkzeug.datastructures.index#werkzeug.datastructures.Range.ranges\nSnippet: ranges A list of (begin, end) tuples for the range header provided. The ranges are non-inclusive.", "score": "0.66521174"}, {"id": "21309", "text": "Function: python.library.itertools#itertools.islice\nSnippet: itertools.islice(iterable, stop) itertools.islice(iterable, start, stop[, step]) Make an iterator that returns selected elements from the iterable. If start is non-zero, then elements from the iterable are skipped until start is reached. Afterward, elements are returned consecutively unless step is set higher than one which results in items being skipped. If stop is None, then iteration continues until the iterator is exhausted, if at all; otherwise, it stops at the specified position. Unlike regular slicing, islice() does not support negative values for start, stop, or step. Can be used to extract related fields from data where the internal structure has been flattened (for example, a multi-line report may list a name field on every third line). Roughly equivalent to: def islice(iterable, *args): # islice('ABCDEFG', 2) --> A B # islice('ABCDEFG', 2, 4) --> C D # islice('ABCDEFG', 2, None) --> C D E F G # islice('ABCDEFG', 0, None, 2) --> A C E G s = slice(*args) start, stop, step = s.start or 0, s.stop or sys.maxsize, s.step or 1 it = iter(range(start, stop, step)) try: nexti = next(it) except StopIteration: # Consume *iterable* up to the *start* position. for i, element in zip(range(start), iterable): pass return try: for i, element in enumerate(iterable): if i == nexti: yield element nexti = next(it) except StopIteration: # Consume to *stop*. for i, element in zip(range(i + 1, stop), iterable): pass If start is None, then iteration starts at zero. If step is None, then the step defaults to one.", "score": "0.6650562"}, {"id": "24372", "text": "Function: python.library.stdtypes#str.rindex\nSnippet: str.rindex(sub[, start[, end]]) Like rfind() but raises ValueError when the substring sub is not found.", "score": "0.66208416"}]}
{"task_id": "mbpp_111", "code": "def common_in_nested_lists(nestedlist):\r\n    result = list(set.intersection(*map(set, nestedlist)))\r\n    return result", "test_list": ["assert common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])==[18, 12]", "assert common_in_nested_lists([[12, 5, 23, 25, 45], [7, 11, 5, 23, 28], [1, 5, 8, 18, 23, 16]])==[5,23]", "assert common_in_nested_lists([[2, 3,4, 1], [4, 5], [6,4, 8],[4, 5], [6, 8,4]])==[4]"], "context": "Write a function to find common elements in given nested lists. * list item * list item * list item * list item", "function_name": "def common_in_nested_lists(nestedlist):", "gold_generation": "result = list(set.intersection(*map(set, nestedlist)))\r\n    return result", "ctxs": [{"id": "18655", "text": "Function: python.library.collections#collections.Counter.most_common\nSnippet: most_common([n]) Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered in the order first encountered: >>> Counter('abracadabra').most_common(3) [('a', 5), ('b', 2), ('r', 2)]", "score": "0.68371856"}, {"id": "21311", "text": "Function: python.library.itertools#itertools.product\nSnippet: itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs.", "score": "0.67698723"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.6729114"}, {"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.67275554"}, {"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.6724744"}]}
{"task_id": "mbpp_112", "code": "def perimeter(diameter,height) : \r\n    return 2*(diameter+height)  ", "test_list": ["assert perimeter(2,4) == 12", "assert perimeter(1,2) == 6", "assert perimeter(3,1) == 8"], "context": "Write a python function to find the perimeter of a cylinder.", "function_name": "def perimeter(diameter,height) :", "gold_generation": "return 2*(diameter+height)", "ctxs": [{"id": "36357", "text": "Function: django.ref.contrib.gis.functions#django.contrib.gis.db.models.functions.Perimeter\nSnippet: class Perimeter(expression, **extra)", "score": "0.71009094"}, {"id": "25592", "text": "Function: python.library.turtle\nSnippet: steps – an integer (or None) Draw a circle with given radius. The center is radius units left of the turtle; extent – an angle – determines which part of the circle is drawn. If extent is not given, draw the entire circle. If extent is not a full circle, one endpoint of the arc is the current pen position. Draw the arc in counterclockwise direction if radius is positive, otherwise in clockwise direction. Finally the direction of the turtle is changed by the amount of extent. As the circle is approximated by an inscribed regular polygon, steps determines the number of steps to use. If not given, it will be calculated automatically. May be used to draw regular polygons. >>> turtle.home() >>> turtle.position() (0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(50) >>> turtle.position() (-0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(120, 180) # draw a semicircle >>> turtle.position() (0.00,240.00) >>> turtle.heading() 180.0 turtle.dot(size=None, *color) Parameters size – an integer >= 1 (if given) color – a colorstring or a numeric color tuple Draw a circular dot with diameter size, using color. If size is not given, the maximum of pensize+4 and 2*pensize is used. >>> turtle.home() >>> turtle.dot() >>> turtle.fd(50); turtle.dot(20, \"blue\"); turtle.fd(50) >>> turtle.position() (100.00,-0.00) >>> turtle.heading() 0.0 turtle.stamp() Stamp a copy of the turtle shape onto the canvas at the current turtle position. Return a stamp_id for that stamp, which can be used to delete it by calling clearstamp(stamp_id). >>> turtle.color(\"blue\") >>> turtle.stamp() 11 >>> turtle.fd(50) turtle.clearstamp(stampid) Parameters stampid – an integer, must be return value of previous stamp() call Delete stamp with given stampid. >>> turtle.position() (150.00,-0.00) >>> turtle.color(\"blue\") >>> astamp = turtle.stamp() >>> turtle.fd(50) >>> turtle.position() (200.00,-0.00) >>> turtle.clearstamp(astamp) >>> turtle.position() (200.00,-0.00) turtle.clearstamps(n=None) Parameters n – an integer (or None) Delete all or first/last n of turtle’s stamps. If n is None, delete all stamps, if n > 0 delete first n stamps, else if n < 0 delete last n stamps. >>> for i in range(8): ... turtle.stamp(); turtle.fd(30) 13 14 15 16 17 18 19 20 >>> turtle.clearstamps(2) >>> turtle.clearstamps(-2) >>> turtle.clearstamps() turtle.undo() Undo (repeatedly) the last turtle action(s). Number of available undo actions is determined by the size of the undobuffer. >>> for i in range(4): ... turtle.fd(50); turtle.lt(80) ... >>> for i in range(8): ... turtle.undo() turtle.speed(speed=None) Parameters speed – an integer in the range 0..10 or a speedstring (see below) Set the turtle’s speed to an integer value in the range 0..10. If no argument is given, return current speed. If input is a number greater than 10 or smaller than 0.5, speed is set to 0. Speedstrings are mapped to speedvalues as follows: “fastest”: 0 “fast”: 10 “normal”: 6 “slow”: 3 “slowest”: 1 Speeds from 1 to 10 enforce increasingly faster animation of line drawing and turtle turning. Attention: speed = 0 means that no animation takes place. forward/back makes turtle jump and likewise left/right make the turtle turn instantly. >>> turtle.speed() 3 >>> turtle.speed('normal') >>> turtle.speed() 6 >>> turtle.speed(9) >>> turtle.speed() 9", "score": "0.6860157"}, {"id": "33487", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: barbs_doc='\\nPlot a 2D field of barbs.\\n\\nCall signature::\\n\\n barbs([X, Y], U, V, [C], **kw)\\n\\nWhere *X*, *Y* define the barb locations, *U*, *V* define the barb\\ndirections, and *C* optionally sets the color.\\n\\nAll arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked\\n*X*, *Y* are not supported at present.\\n\\nBarbs are traditionally used in meteorology as a way to plot the speed\\nand direction of wind observations, but can technically be used to\\nplot any two dimensional vector quantity. As opposed to arrows, which\\ngive vector magnitude by the length of the arrow, the barbs give more\\nquantitative information about the vector magnitude by putting slanted\\nlines or a triangle for various increments in magnitude, as show\\nschematically below::\\n\\n : /\\\\ \\\\\\n : / \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : ------------------------------\\n\\nThe largest increment is given by a triangle (or \"flag\"). After those\\ncome full lines (barbs). The smallest increment is a half line. There\\nis only, of course, ever at most 1 half line. If the magnitude is\\nsmall and only needs a single half-line and no full lines or\\ntriangles, the half-line is offset from the end of the barb so that it\\ncan be easily distinguished from barbs with a single full line. The\\nmagnitude for the barb shown above would nominally be 65, using the\\nstandard increments of 50, 10, and 5.\\n\\nSee also https://en.wikipedia.org/wiki/Wind_barb.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the barb locations. See *pivot* for how the\\n barbs are drawn to the x, y positions.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y components of the barb shaft.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If", "score": "0.6851689"}, {"id": "13179", "text": "Function: pygame.ref.draw\nSnippet: the given surface. The line has a thickness of one pixel and the endpoints have a height and width of one pixel each. The way a line and it's endpoints are drawn: If both endpoints are equal, only a single pixel is drawn (after rounding floats to nearest integer). Otherwise if the line is not steep (i.e. if the length along the x-axis is greater than the height along the y-axis): For each endpoint: If x, the endpoint's x-coordinate, is a whole number find which pixels would be covered by it and draw them. Otherwise: Calculate the position of the nearest point with a whole number for it's x-coordinate, when extending the line past the endpoint. Find which pixels would be covered and how much by that point. If the endpoint is the left one, multiply the coverage by (1 - the decimal part of x). Otherwise multiply the coverage by the decimal part of x. Then draw those pixels. e.g.: The left endpoint of the line ((1, 1.3), (5, 3)) would cover 70% of the pixel (1, 1) and 30% of the pixel (1, 2) while the right one would cover 100% of the pixel (5, 3). The left endpoint of the line ((1.2, 1.4), (4.6, 3.1)) would cover 56% (i.e. 0.8 * 70%) of the pixel (1, 1) and 24% (i.e. 0.8 * 30%) of the pixel (1, 2) while the right one would cover 42% (i.e. 0.6 * 70%) of the pixel (5, 3) and 18% (i.e. 0.6 * 30%) of the pixel (5, 4) while the right Then for each point between the endpoints, along the line, whose x-coordinate is a whole number: Find which pixels would be covered and how much by that point and draw them. e.g.: The points along the line ((1, 1), (4, 2.5)) would be (2, 1.5) and (3, 2) and would cover 50% of the pixel (2, 1), 50% of the pixel (2, 2) and 100% of the pixel (3, 2). The points along the line ((1.2, 1.4), (4.6, 3.1)) would be (2, 1.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)), (3, 2.3) (covering 70% of the pixel (3, 2) and 30% of the pixel (3, 3)) and (4, 2.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)) Otherwise do the same for steep lines as for non-steep lines except along the y-axis instead of the x-axis (using y instead of x, top instead of left and bottom instead of right). Note Regarding float values for coordinates, a point with coordinate consisting of two whole numbers is considered being right in the center of said pixel (and having a height and width of 1 pixel would therefore completely cover it), while a point with coordinate where one (or both) of the numbers have non-zero decimal parts would be partially covering two (or four if both numbers have decimal parts) adjacent pixels, e.g. the point (1.4, 2) covers", "score": "0.6736035"}, {"id": "25615", "text": "Function: python.library.turtle#turtle.circle\nSnippet: turtle.circle(radius, extent=None, steps=None) Parameters radius – a number extent – a number (or None) steps – an integer (or None) Draw a circle with given radius. The center is radius units left of the turtle; extent – an angle – determines which part of the circle is drawn. If extent is not given, draw the entire circle. If extent is not a full circle, one endpoint of the arc is the current pen position. Draw the arc in counterclockwise direction if radius is positive, otherwise in clockwise direction. Finally the direction of the turtle is changed by the amount of extent. As the circle is approximated by an inscribed regular polygon, steps determines the number of steps to use. If not given, it will be calculated automatically. May be used to draw regular polygons. >>> turtle.home() >>> turtle.position() (0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(50) >>> turtle.position() (-0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(120, 180) # draw a semicircle >>> turtle.position() (0.00,240.00) >>> turtle.heading() 180.0", "score": "0.67303836"}]}
{"task_id": "mbpp_113", "code": "def check_integer(text):\r\n text = text.strip()\r\n if len(text) < 1:\r\n    return None\r\n else:\r\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\r\n          return True\r\n     elif (text[0] in \"+-\") and \\\r\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\r\n         return True\r\n     else:\r\n        return False", "test_list": ["assert check_integer(\"python\")==False", "assert check_integer(\"1\")==True", "assert check_integer(\"12345\")==True"], "context": "Write a function to check if a string represents an integer or not.", "function_name": "def check_integer(text):", "gold_generation": "text = text.strip()\r\n if len(text) < 1:\r\n    return None\r\n else:\r\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\r\n          return True\r\n     elif (text[0] in \"+-\") and \\\r\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\r\n         return True\r\n     else:\r\n        return False", "ctxs": [{"id": "14019", "text": "Function: pandas.reference.api.pandas.api.types.is_integer\nSnippet: pandas.api.types.is_integer pandas.api.types.is_integer() Return True if given object is integer. Returns bool", "score": "0.73841465"}, {"id": "24357", "text": "Function: python.library.stdtypes#str.isnumeric\nSnippet: str.isnumeric() Return True if all characters in the string are numeric characters, and there is at least one character, False otherwise. Numeric characters include digit characters, and all characters that have the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH. Formally, numeric characters are those with the property value Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric.", "score": "0.7348156"}, {"id": "15340", "text": "Function: pandas.reference.api.pandas.series.str.isnumeric\nSnippet: pandas.Series.str.isnumeric Series.str.isnumeric()[source] Check whether all characters in each string are numeric. This is equivalent to running the Python string method str.isnumeric() for each element of the Series/Index. If a string has zero characters, False is returned for that check. Returns Series or Index of bool Series or Index of boolean values with the same length as the original Series/Index. See also Series.str.isalpha Check whether all characters are alphabetic. Series.str.isnumeric Check whether all characters are numeric. Series.str.isalnum Check whether all characters are alphanumeric. Series.str.isdigit Check whether all characters are digits. Series.str.isdecimal Check whether all characters are decimal. Series.str.isspace Check whether all characters are whitespace. Series.str.islower Check whether all characters are lowercase. Series.str.isupper Check whether all characters are uppercase. Series.str.istitle Check whether all characters are titlecase. Examples Checks for Alphabetic and Numeric Characters >>> s1 = pd.Series(['one', 'one1', '1', '']) >>> s1.str.isalpha() 0 True 1 False 2 False 3 False dtype: bool >>> s1.str.isnumeric() 0 False 1 False 2 True 3 False dtype: bool >>> s1.str.isalnum() 0 True 1 True 2 True 3 False dtype: bool Note that checks against characters mixed with any additional punctuation or whitespace will evaluate to false for an alphanumeric check. >>> s2 = pd.Series(['A B', '1.5', '3,000']) >>> s2.str.isalnum() 0 False 1 False 2 False dtype: bool More Detailed Checks for Numeric Characters There are several different but overlapping sets of numeric characters that can be checked for. >>> s3 = pd.Series(['23', '³', '⅕', '']) The s3.str.isdecimal method checks for characters used to form numbers in base 10. >>> s3.str.isdecimal() 0 True 1 False 2 False 3 False dtype: bool The s.str.isdigit method is the same as s3.str.isdecimal but also includes special digits, like superscripted and subscripted digits in unicode. >>> s3.str.isdigit() 0 True 1 True 2 False 3 False dtype: bool The s.str.isnumeric method is the same as s3.str.isdigit but also includes other characters that can represent quantities such as unicode fractions. >>> s3.str.isnumeric() 0 True 1 True 2 True 3 False dtype: bool Checks for Whitespace >>> s4 = pd.Series([' ', '\\t\\r\\n ', '']) >>> s4.str.isspace() 0 True 1 True 2 False dtype: bool Checks for Character Case >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) >>> s5.str.islower() 0 True 1 False 2 False 3 False dtype: bool >>> s5.str.isupper() 0 False 1 False 2 True 3 False dtype: bool The s5.str.istitle method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters. >>> s5.str.istitle() 0 False 1 True 2 False 3 False dtype: bool", "score": "0.71766955"}, {"id": "15338", "text": "Function: pandas.reference.api.pandas.series.str.isdigit\nSnippet: pandas.Series.str.isdigit Series.str.isdigit()[source] Check whether all characters in each string are digits. This is equivalent to running the Python string method str.isdigit() for each element of the Series/Index. If a string has zero characters, False is returned for that check. Returns Series or Index of bool Series or Index of boolean values with the same length as the original Series/Index. See also Series.str.isalpha Check whether all characters are alphabetic. Series.str.isnumeric Check whether all characters are numeric. Series.str.isalnum Check whether all characters are alphanumeric. Series.str.isdigit Check whether all characters are digits. Series.str.isdecimal Check whether all characters are decimal. Series.str.isspace Check whether all characters are whitespace. Series.str.islower Check whether all characters are lowercase. Series.str.isupper Check whether all characters are uppercase. Series.str.istitle Check whether all characters are titlecase. Examples Checks for Alphabetic and Numeric Characters >>> s1 = pd.Series(['one', 'one1', '1', '']) >>> s1.str.isalpha() 0 True 1 False 2 False 3 False dtype: bool >>> s1.str.isnumeric() 0 False 1 False 2 True 3 False dtype: bool >>> s1.str.isalnum() 0 True 1 True 2 True 3 False dtype: bool Note that checks against characters mixed with any additional punctuation or whitespace will evaluate to false for an alphanumeric check. >>> s2 = pd.Series(['A B', '1.5', '3,000']) >>> s2.str.isalnum() 0 False 1 False 2 False dtype: bool More Detailed Checks for Numeric Characters There are several different but overlapping sets of numeric characters that can be checked for. >>> s3 = pd.Series(['23', '³', '⅕', '']) The s3.str.isdecimal method checks for characters used to form numbers in base 10. >>> s3.str.isdecimal() 0 True 1 False 2 False 3 False dtype: bool The s.str.isdigit method is the same as s3.str.isdecimal but also includes special digits, like superscripted and subscripted digits in unicode. >>> s3.str.isdigit() 0 True 1 True 2 False 3 False dtype: bool The s.str.isnumeric method is the same as s3.str.isdigit but also includes other characters that can represent quantities such as unicode fractions. >>> s3.str.isnumeric() 0 True 1 True 2 True 3 False dtype: bool Checks for Whitespace >>> s4 = pd.Series([' ', '\\t\\r\\n ', '']) >>> s4.str.isspace() 0 True 1 True 2 False dtype: bool Checks for Character Case >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) >>> s5.str.islower() 0 True 1 False 2 False 3 False dtype: bool >>> s5.str.isupper() 0 False 1 False 2 True 3 False dtype: bool The s5.str.istitle method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters. >>> s5.str.istitle() 0 False 1 True 2 False 3 False dtype: bool", "score": "0.71612525"}, {"id": "42786", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.is_string\nSnippet: numpy.distutils.misc_util.is_string(s)[source]", "score": "0.7148424"}]}
{"task_id": "mbpp_114", "code": "from collections import Counter \r\ndef assign_freq(test_list):\r\n  res = [(*key, val) for key, val in Counter(test_list).items()]\r\n  return (str(res)) ", "test_list": ["assert assign_freq([(6, 5, 8), (2, 7), (6, 5, 8), (6, 5, 8), (9, ), (2, 7)] ) == '[(6, 5, 8, 3), (2, 7, 2), (9, 1)]'", "assert assign_freq([(4, 2, 4), (7, 1), (4, 8), (4, 2, 4), (9, 2), (7, 1)] ) == '[(4, 2, 4, 2), (7, 1, 2), (4, 8, 1), (9, 2, 1)]'", "assert assign_freq([(11, 13, 10), (17, 21), (4, 2, 3), (17, 21), (9, 2), (4, 2, 3)] ) == '[(11, 13, 10, 1), (17, 21, 2), (4, 2, 3, 2), (9, 2, 1)]'"], "context": "Write a function to assign frequency to each tuple in the given tuple list.", "function_name": "from collections import Counter \r\ndef assign_freq(test_list):", "gold_generation": "res = [(*key, val) for key, val in Counter(test_list).items()]\r\n  return (str(res))", "ctxs": [{"id": "14927", "text": "Function: pandas.reference.api.pandas.period.freq\nSnippet: pandas.Period.freq Period.freq", "score": "0.6954873"}, {"id": "16415", "text": "Function: pandas.reference.api.pandas.tseries.offsets.week.freqstr\nSnippet: pandas.tseries.offsets.Week.freqstr Week.freqstr", "score": "0.6845623"}, {"id": "15131", "text": "Function: pandas.reference.api.pandas.series.dt.freq\nSnippet: pandas.Series.dt.freq Series.dt.freq", "score": "0.6841791"}, {"id": "15446", "text": "Function: pandas.reference.api.pandas.timedelta.freq\nSnippet: pandas.Timedelta.freq Timedelta.freq", "score": "0.6814807"}, {"id": "16106", "text": "Function: pandas.reference.api.pandas.tseries.offsets.micro.freqstr\nSnippet: pandas.tseries.offsets.Micro.freqstr Micro.freqstr", "score": "0.6701409"}]}
{"task_id": "mbpp_115", "code": "def empty_dit(list1):\r\n empty_dit=all(not d for d in list1)\r\n return empty_dit", "test_list": ["assert empty_dit([{},{},{}])==True", "assert empty_dit([{1,2},{},{}])==False", "assert empty_dit({})==True"], "context": "Write a function to check whether all dictionaries in a list are empty or not.", "function_name": "def empty_dit(list1):", "gold_generation": "empty_dit=all(not d for d in list1)\r\n return empty_dit", "ctxs": [{"id": "17577", "text": "Function: python.library.functions#all\nSnippet: all(iterable) Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to: def all(iterable): for element in iterable: if not element: return False return True", "score": "0.7289583"}, {"id": "25768", "text": "Function: python.library.stdtypes\nSnippet: The example above shows part of the implementation of collections.Counter. A different __missing__ method is used by collections.defaultdict. d[key] = value Set d[key] to value. del d[key] Remove d[key] from d. Raises a KeyError if key is not in the map. key in d Return True if d has a key key, else False. key not in d Equivalent to not key in d. iter(d) Return an iterator over the keys of the dictionary. This is a shortcut for iter(d.keys()). clear() Remove all items from the dictionary. copy() Return a shallow copy of the dictionary. classmethod fromkeys(iterable[, value]) Create a new dictionary with keys from iterable and values set to value. fromkeys() is a class method that returns a new dictionary. value defaults to None. All of the values refer to just a single instance, so it generally doesn’t make sense for value to be a mutable object such as an empty list. To get distinct values, use a dict comprehension instead. get(key[, default]) Return the value for key if key is in the dictionary, else default. If default is not given, it defaults to None, so that this method never raises a KeyError. items() Return a new view of the dictionary’s items ((key, value) pairs). See the documentation of view objects. keys() Return a new view of the dictionary’s keys. See the documentation of view objects. pop(key[, default]) If key is in the dictionary, remove it and return its value, else return default. If default is not given and key is not in the dictionary, a KeyError is raised. popitem() Remove and return a (key, value) pair from the dictionary. Pairs are returned in LIFO order. popitem() is useful to destructively iterate over a dictionary, as often used in set algorithms. If the dictionary is empty, calling popitem() raises a KeyError. Changed in version 3.7: LIFO order is now guaranteed. In prior versions, popitem() would return an arbitrary key/value pair. reversed(d) Return a reverse iterator over the keys of the dictionary. This is a shortcut for reversed(d.keys()). New in version 3.8. setdefault(key[, default]) If key is in the dictionary, return its value. If not, insert key with a value of default and return default. default defaults to None. update([other]) Update the dictionary with the key/value pairs from other, overwriting existing keys. Return None. update() accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those key/value pairs: d.update(red=1, blue=2). values() Return a new view of the dictionary’s values. See the documentation of view objects. An equality comparison between one dict.values() view and another will always return False. This also applies when comparing dict.values() to itself: >>> d = {'a': 1} >>> d.values() == d.values() False d | other Create a new dictionary with the merged keys and values of d and other, which must both be dictionaries. The values of other take priority when d and other share keys.", "score": "0.711185"}, {"id": "17578", "text": "Function: python.library.functions#any\nSnippet: any(iterable) Return True if any element of the iterable is true. If the iterable is empty, return False. Equivalent to: def any(iterable): for element in iterable: if element: return True return False", "score": "0.70907766"}, {"id": "17971", "text": "Function: python.library.asyncio-queue#asyncio.Queue.empty\nSnippet: empty() Return True if the queue is empty, False otherwise.", "score": "0.70260143"}, {"id": "22202", "text": "Function: python.library.multiprocessing#multiprocessing.SimpleQueue.empty\nSnippet: empty() Return True if the queue is empty, False otherwise.", "score": "0.6942855"}]}
{"task_id": "mbpp_116", "code": "def tuple_to_int(nums):\r\n    result = int(''.join(map(str,nums)))\r\n    return result", "test_list": ["assert tuple_to_int((1,2,3))==123", "assert tuple_to_int((4,5,6))==456", "assert tuple_to_int((5,6,7))==567"], "context": "Write a function to convert a given tuple of positive integers into an integer.", "function_name": "def tuple_to_int(nums):", "gold_generation": "result = int(''.join(map(str,nums)))\r\n    return result", "ctxs": [{"id": "20204", "text": "Function: python.library.fractions#fractions.Fraction.as_integer_ratio\nSnippet: as_integer_ratio() Return a tuple of two integers, whose ratio is equal to the Fraction and with a positive denominator. New in version 3.8.", "score": "0.71008253"}, {"id": "41307", "text": "Function: django.ref.utils#django.utils.http.int_to_base36\nSnippet: int_to_base36(i) [source] Converts a positive integer to a base 36 string.", "score": "0.6896932"}, {"id": "25732", "text": "Function: python.library.stdtypes\nSnippet: there were an infinite number of sign bits. Additional Methods on Integer Types The int type implements the numbers.Integral abstract base class. In addition, it provides a few more methods: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1. int.to_bytes(length, byteorder, *, signed=False) Return an array of bytes representing an integer. >>> (1024).to_bytes(2, byteorder='big') b'\\x04\\x00' >>> (1024).to_bytes(10, byteorder='big') b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00' >>> (-1024).to_bytes(10, byteorder='big', signed=True) b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00' >>> x = 1000 >>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little') b'\\xe8\\x03' The integer is represented using length bytes. An OverflowError is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument determines whether two’s complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. The default value for signed is False. New in version 3.2. classmethod int.from_bytes(bytes, byteorder, *, signed=False) Return the integer represented by the given array of bytes. >>> int.from_bytes(b'\\x00\\x10', byteorder='big') 16 >>> int.from_bytes(b'\\x00\\x10', byteorder='little') 4096 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True) -1024 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False) 64512 >>> int.from_bytes([255, 0, 0], byteorder='big') 16711680 The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. New in version 3.2. int.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original integer and with a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. New in version 3.8. Additional Methods on Float The float type implements the numbers.Real abstract base class. float also has the following additional methods. float.as_integer_ratio() Return a pair of integers whose", "score": "0.681922"}, {"id": "20189", "text": "Function: python.library.stdtypes#float.as_integer_ratio\nSnippet: float.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original float and with a positive denominator. Raises OverflowError on infinities and a ValueError on NaNs.", "score": "0.6810674"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6765057"}]}
{"task_id": "mbpp_117", "code": "def list_to_float(test_list):\r\n  res = []\r\n  for tup in test_list:\r\n    temp = []\r\n    for ele in tup:\r\n      if ele.isalpha():\r\n        temp.append(ele)\r\n      else:\r\n        temp.append(float(ele))\r\n    res.append((temp[0],temp[1])) \r\n  return (str(res)) ", "test_list": ["assert list_to_float( [(\"3\", \"4\"), (\"1\", \"26.45\"), (\"7.32\", \"8\"), (\"4\", \"8\")] ) == '[(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]'", "assert list_to_float( [(\"4\", \"4\"), (\"2\", \"27\"), (\"4.12\", \"9\"), (\"7\", \"11\")] ) == '[(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]'", "assert list_to_float( [(\"6\", \"78\"), (\"5\", \"26.45\"), (\"1.33\", \"4\"), (\"82\", \"13\")] ) == '[(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]'"], "context": "Write a function to convert all possible convertible elements in the list to float.", "function_name": "def list_to_float(test_list):", "gold_generation": "res = []\r\n  for tup in test_list:\r\n    temp = []\r\n    for ele in tup:\r\n      if ele.isalpha():\r\n        temp.append(ele)\r\n      else:\r\n        temp.append(float(ele))\r\n    res.append((temp[0],temp[1])) \r\n  return (str(res))", "ctxs": [{"id": "6875", "text": "Function: torch.generated.torch.nn.flatten#torch.nn.Flatten.float\nSnippet: float() Casts all floating point parameters and buffers to float datatype. Returns self Return type Module", "score": "0.7211435"}, {"id": "42189", "text": "Function: numpy.reference.generated.numpy.ma.maskedarray.__float__\nSnippet: numpy.ma.MaskedArray.__float__ method ma.MaskedArray.__float__()[source] Convert to float.", "score": "0.71920115"}, {"id": "29139", "text": "Function: matplotlib.category_api#matplotlib.category.StrCategoryConverter.convert\nSnippet: staticconvert(value, unit, axis)[source] Convert strings in value to floats using mapping information stored in the unit object. Parameters valuestr or iterable Value or list of values to be converted. unitUnitData An object mapping strings to integers. axisAxis The axis on which the converted value is plotted. Note axis is unused. Returns float or ndarray[float]", "score": "0.7161971"}, {"id": "7311", "text": "Function: torch.generated.torch.nn.unflatten#torch.nn.Unflatten.float\nSnippet: float() Casts all floating point parameters and buffers to float datatype. Returns self Return type Module", "score": "0.71526057"}, {"id": "6663", "text": "Function: torch.generated.torch.jit.scriptmodule#torch.jit.ScriptModule.float\nSnippet: float() Casts all floating point parameters and buffers to float datatype. Returns self Return type Module", "score": "0.7117653"}]}
{"task_id": "mbpp_118", "code": "def string_to_list(string): \r\n    lst = list(string.split(\" \")) \r\n    return lst", "test_list": ["assert string_to_list(\"python programming\")==['python','programming']", "assert string_to_list(\"lists tuples strings\")==['lists','tuples','strings']", "assert string_to_list(\"write a program\")==['write','a','program']"], "context": "[link text](https:// [link text](https:// [link text](https://)))write a function to convert a string to a list.", "function_name": "def string_to_list(string):", "gold_generation": "lst = list(string.split(\" \")) \r\n    return lst", "ctxs": [{"id": "17646", "text": "Function: python.library.array#array.array.tolist\nSnippet: array.tolist() Convert the array to an ordinary list with the same items.", "score": "0.70213497"}, {"id": "22925", "text": "Function: python.library.parser#parser.ST.tolist\nSnippet: ST.tolist(line_info=False, col_info=False) Same as st2list(st, line_info, col_info).", "score": "0.6930032"}, {"id": "21860", "text": "Function: python.library.stdtypes#memoryview.tolist\nSnippet: tolist() Return the data in the buffer as a list of elements. >>> memoryview(b'abc').tolist() [97, 98, 99] >>> import array >>> a = array.array('d', [1.1, 2.2, 3.3]) >>> m = memoryview(a) >>> m.tolist() [1.1, 2.2, 3.3] Changed in version 3.3: tolist() now supports all single character native formats in struct module syntax as well as multi-dimensional representations.", "score": "0.6853211"}, {"id": "20293", "text": "Function: python.library.functions\nSnippet: reference to a function from a class body and you want to avoid the automatic transformation to instance method. For these cases, use this idiom: class C: builtin_open = staticmethod(open) For more information on static methods, see The standard type hierarchy. class str(object='') class str(object=b'', encoding='utf-8', errors='strict') Return a str version of object. See str() for details. str is the built-in string class. For general information about strings, see Text Sequence Type — str. sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument. super([type[, object-or-type]]) Return a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object-or-type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if __mro__ of object-or-type is D -> B -> C -> A -> object and the value of type is B, then super() searches C -> A -> object. The __mro__ attribute of the object-or-type lists the method resolution search order used by both getattr() and super(). The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, isinstance(obj, type) must be true. If the second argument is a type, issubclass(type2, type) must be true (this is useful for classmethods). There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: class C(B): def method(self, arg): super().method(arg) # This does the same thing as: # super(C, self).method(arg) In addition to method lookups,", "score": "0.6798202"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.6722154"}]}
{"task_id": "mbpp_119", "code": "def search(arr,n) :\r\n    XOR = 0\r\n    for i in range(n) :\r\n        XOR = XOR ^ arr[i]\r\n    return (XOR)", "test_list": ["assert search([1,1,2,2,3],5) == 3", "assert search([1,1,3,3,4,4,5,5,7,7,8],11) == 8", "assert search([1,2,2,3,3,4,4],7) == 1"], "context": "Write a python function to find the element that appears only once in a sorted array.", "function_name": "def search(arr,n) :", "gold_generation": "XOR = 0\r\n    for i in range(n) :\r\n        XOR = XOR ^ arr[i]\r\n    return (XOR)", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.75416934"}, {"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.7323799"}, {"id": "22322", "text": "Function: python.library.operator#operator.indexOf\nSnippet: operator.indexOf(a, b) Return the index of the first of occurrence of b in a.", "score": "0.6974773"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6905872"}, {"id": "41778", "text": "Function: numpy.reference.generated.numpy.chararray.find\nSnippet: numpy.chararray.find method chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.6898256"}]}
{"task_id": "mbpp_120", "code": "def max_product_tuple(list1):\r\n    result_max = max([abs(x * y) for x, y in list1] )\r\n    return result_max", "test_list": ["assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36", "assert max_product_tuple([(10,20), (15,2), (5,10)] )==200", "assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484"], "context": "Write a function to find the maximum product from the pairs of tuples within a given list.", "function_name": "def max_product_tuple(list1):", "gold_generation": "result_max = max([abs(x * y) for x, y in list1] )\r\n    return result_max", "ctxs": [{"id": "21311", "text": "Function: python.library.itertools#itertools.product\nSnippet: itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs.", "score": "0.6804142"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.67452925"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.6605458"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.65956646"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.65606606"}]}
{"task_id": "mbpp_121", "code": "def check_triplet(A, n, sum, count):\r\n    if count == 3 and sum == 0:\r\n        return True\r\n    if count == 3 or n == 0 or sum < 0:\r\n        return False\r\n    return check_triplet(A, n - 1, sum - A[n - 1], count + 1) or\\\r\n           check_triplet(A, n - 1, sum, count)", "test_list": ["assert check_triplet([2, 7, 4, 0, 9, 5, 1, 3], 8, 6, 0) == True", "assert check_triplet([1, 4, 5, 6, 7, 8, 5, 9], 8, 6, 0) == False", "assert check_triplet([10, 4, 2, 3, 5], 5, 15, 0) == True"], "context": "Write a function to find the triplet with sum of the given array", "function_name": "def check_triplet(A, n, sum, count):", "gold_generation": "if count == 3 and sum == 0:\r\n        return True\r\n    if count == 3 or n == 0 or sum < 0:\r\n        return False\r\n    return check_triplet(A, n - 1, sum - A[n - 1], count + 1) or\\\r\n           check_triplet(A, n - 1, sum, count)", "ctxs": [{"id": "43881", "text": "Function: numpy.reference.generated.numpy.recarray.sum\nSnippet: numpy.recarray.sum method recarray.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True) Return the sum of the array elements over the given axis. Refer to numpy.sum for full documentation. See also numpy.sum equivalent function", "score": "0.6616869"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6544211"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6463485"}, {"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.64319825"}, {"id": "19648", "text": "Function: python.library.difflib#difflib.SequenceMatcher.get_matching_blocks\nSnippet: get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]", "score": "0.64254034"}]}
{"task_id": "mbpp_122", "code": "MAX = 3000 \r\ndef smartNumber(n): \r\n\tprimes = [0] * MAX \r\n\tresult = [] \r\n\tfor i in range(2, MAX): \r\n\t\tif (primes[i] == 0): \r\n\t\t\tprimes[i] = 1 \r\n\t\t\tj = i * 2 \r\n\t\t\twhile (j < MAX): \r\n\t\t\t\tprimes[j] -= 1 \r\n\t\t\t\tif ( (primes[j] + 3) == 0): \r\n\t\t\t\t\tresult.append(j) \r\n\t\t\t\tj = j + i \r\n\tresult.sort() \r\n\treturn result[n - 1] ", "test_list": ["assert smartNumber(1) == 30", "assert smartNumber(50) == 273", "assert smartNumber(1000) == 2664"], "context": "Write a function to find n’th smart number.", "function_name": "MAX = 3000 \r\ndef smartNumber(n):", "gold_generation": "primes = [0] * MAX \r\n\tresult = [] \r\n\tfor i in range(2, MAX): \r\n\t\tif (primes[i] == 0): \r\n\t\t\tprimes[i] = 1 \r\n\t\t\tj = i * 2 \r\n\t\t\twhile (j < MAX): \r\n\t\t\t\tprimes[j] -= 1 \r\n\t\t\t\tif ( (primes[j] + 3) == 0): \r\n\t\t\t\t\tresult.append(j) \r\n\t\t\t\tj = j + i \r\n\tresult.sort() \r\n\treturn result[n - 1]", "ctxs": [{"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.66627526"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.6593265"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.65657234"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.65524304"}, {"id": "16245", "text": "Function: pandas.reference.api.pandas.tseries.offsets.nano.n\nSnippet: pandas.tseries.offsets.Nano.n Nano.n", "score": "0.6472244"}]}
{"task_id": "mbpp_123", "code": "def amicable_numbers_sum(limit):\r\n    if not isinstance(limit, int):\r\n        return \"Input is not an integer!\"\r\n    if limit < 1:\r\n        return \"Input must be bigger than 0!\"\r\n    amicables = set()\r\n    for num in range(2, limit+1):\r\n        if num in amicables:\r\n            continue\r\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\r\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\r\n        if num == sum_fact2 and num != sum_fact:\r\n            amicables.add(num)\r\n            amicables.add(sum_fact2)\r\n    return sum(amicables)", "test_list": ["assert amicable_numbers_sum(999)==504", "assert amicable_numbers_sum(9999)==31626", "assert amicable_numbers_sum(99)==0"], "context": "Write a function to sum all amicable numbers from 1 to a specified number.", "function_name": "def amicable_numbers_sum(limit):", "gold_generation": "if not isinstance(limit, int):\r\n        return \"Input is not an integer!\"\r\n    if limit < 1:\r\n        return \"Input must be bigger than 0!\"\r\n    amicables = set()\r\n    for num in range(2, limit+1):\r\n        if num in amicables:\r\n            continue\r\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\r\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\r\n        if num == sum_fact2 and num != sum_fact:\r\n            amicables.add(num)\r\n            amicables.add(sum_fact2)\r\n    return sum(amicables)", "ctxs": [{"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.6751929"}, {"id": "19451", "text": "Function: python.library.decimal#decimal.Context.add\nSnippet: add(x, y) Return the sum of x and y.", "score": "0.6706767"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.6655103"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.6583323"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.65193224"}]}
{"task_id": "mbpp_124", "code": "import cmath\r\ndef angle_complex(a,b):\r\n  cn=complex(a,b)\r\n  angle=cmath.phase(a+b)\r\n  return angle", "test_list": ["assert angle_complex(0,1j)==1.5707963267948966 ", "assert angle_complex(2,1j)==0.4636476090008061", "assert angle_complex(0,2j)==1.5707963267948966"], "context": "Write a function to get the angle of a complex number.", "function_name": "import cmath\r\ndef angle_complex(a,b):", "gold_generation": "cn=complex(a,b)\r\n  angle=cmath.phase(a+b)\r\n  return angle", "ctxs": [{"id": "42617", "text": "Function: numpy.reference.generated.numpy.angle\nSnippet: numpy.angle numpy.angle(z, deg=False)[source] Return the angle of the complex argument. Parameters zarray_like A complex number or sequence of complex numbers. degbool, optional Return angle in degrees if True, radians if False (default). Returns anglendarray or scalar The counterclockwise angle from the positive real axis on the complex plane in the range (-pi, pi], with dtype as numpy.float64. Changed in version 1.16.0: This function works on subclasses of ndarray like ma.array. See also arctan2 absolute Notes Although the angle of the complex number 0 is undefined, numpy.angle(0) returns the value 0. Examples >>> np.angle([1.0, 1.0j, 1+1j]) # in radians array([ 0. , 1.57079633, 0.78539816]) # may vary >>> np.angle(1+1j, deg=True) # in degrees 45.0", "score": "0.72265196"}, {"id": "18481", "text": "Function: python.library.cmath#cmath.rect\nSnippet: cmath.rect(r, phi) Return the complex number x with polar coordinates r and phi. Equivalent to r * (math.cos(phi) + math.sin(phi)*1j).", "score": "0.71321595"}, {"id": "21781", "text": "Function: python.library.math#math.asin\nSnippet: math.asin(x) Return the arc sine of x, in radians. The result is between -pi/2 and pi/2.", "score": "0.7023729"}, {"id": "3435", "text": "Function: tensorflow.math.angle\nSnippet: tf.math.angle View source on GitHub Returns the element-wise argument of a complex (or real) tensor. View aliases Compat aliases for migration See Migration guide for more details. tf.compat.v1.angle, tf.compat.v1.math.angle tf.math.angle( input, name=None ) Given a tensor input, this operation returns a tensor of type float that is the argument of each element in input considered as a complex number. The elements in input are considered to be complex numbers of the form \\(a + bj\\), where a is the real part and b is the imaginary part. If input is real then b is zero by definition. The argument returned by this function is of the form \\(atan2(b, a)\\). If input is real, a tensor of all zeros is returned. For example: input = tf.constant([-2.25 + 4.75j, 3.25 + 5.75j], dtype=tf.complex64) tf.math.angle(input).numpy() # ==> array([2.0131705, 1.056345 ], dtype=float32) Args input A Tensor. Must be one of the following types: float, double, complex64, complex128. name A name for the operation (optional). Returns A Tensor of type float32 or float64.", "score": "0.700537"}, {"id": "7716", "text": "Function: torch.tensors#torch.Tensor.angle\nSnippet: angle() → Tensor See torch.angle()", "score": "0.69893044"}]}
{"task_id": "mbpp_125", "code": "def find_length(string, n): \r\n\tcurrent_sum = 0\r\n\tmax_sum = 0\r\n\tfor i in range(n): \r\n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \r\n\t\tif current_sum < 0: \r\n\t\t\tcurrent_sum = 0\r\n\t\tmax_sum = max(current_sum, max_sum) \r\n\treturn max_sum if max_sum else 0", "test_list": ["assert find_length(\"11000010001\", 11) == 6", "assert find_length(\"10111\", 5) == 1", "assert find_length(\"11011101100101\", 14) == 2 "], "context": "Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.", "function_name": "def find_length(string, n):", "gold_generation": "current_sum = 0\r\n\tmax_sum = 0\r\n\tfor i in range(n): \r\n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \r\n\t\tif current_sum < 0: \r\n\t\t\tcurrent_sum = 0\r\n\t\tmax_sum = max(current_sum, max_sum) \r\n\treturn max_sum if max_sum else 0", "ctxs": [{"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6832351"}, {"id": "24346", "text": "Function: python.library.stdtypes#str.find\nSnippet: str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True", "score": "0.6710633"}, {"id": "41724", "text": "Function: numpy.reference.generated.numpy.char.find\nSnippet: numpy.char.find char.find(a, sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. Calls str.find element-wise. For each element, return the lowest index in the string where substring sub is found, such that sub is contained in the range [start, end]. Parameters aarray_like of str or unicode substr or unicode start, endint, optional Optional arguments start and end are interpreted as in slice notation. Returns outndarray or int Output array of ints. Returns -1 if sub is not found. See also str.find", "score": "0.6696548"}, {"id": "19628", "text": "Function: python.library.difflib\nSnippet: as large as ratio(): >>> s = SequenceMatcher(None, \"abcd\", \"bcde\") >>> s.ratio() 0.75 >>> s.quick_ratio() 0.75 >>> s.real_quick_ratio() 1.0 SequenceMatcher Examples This example compares two strings, considering blanks to be “junk”: >>> s = SequenceMatcher(lambda x: x == \" \", ... \"private Thread currentThread;\", ... \"private volatile Thread currentThread;\") ratio() returns a float in [0, 1], measuring the similarity of the sequences. As a rule of thumb, a ratio() value over 0.6 means the sequences are close matches: >>> print(round(s.ratio(), 3)) 0.866 If you’re only interested in where the sequences match, get_matching_blocks() is handy: >>> for block in s.get_matching_blocks(): ... print(\"a[%d] and b[%d] match for %d elements\" % block) a[0] and b[0] match for 8 elements a[8] and b[17] match for 21 elements a[29] and b[38] match for 0 elements Note that the last tuple returned by get_matching_blocks() is always a dummy, (len(a), len(b), 0), and this is the only case in which the last tuple element (number of elements matched) is 0. If you want to know how to change the first sequence into the second, use get_opcodes(): >>> for opcode in s.get_opcodes(): ... print(\"%6s a[%d:%d] b[%d:%d]\" % opcode) equal a[0:8] b[0:8] insert a[8:8] b[8:17] equal a[8:29] b[17:38] See also The get_close_matches() function in this module which shows how simple code building on SequenceMatcher can be used to do useful work. Simple version control recipe for a small application built with SequenceMatcher. Differ Objects Note that Differ-generated deltas make no claim to be minimal diffs. To the contrary, minimal diffs are often counter-intuitive, because they synch up anywhere possible, sometimes accidental matches 100 pages apart. Restricting synch points to contiguous matches preserves some notion of locality, at the occasional cost of producing a longer diff. The Differ class has this constructor: class difflib.Differ(linejunk=None, charjunk=None) Optional keyword parameters linejunk and charjunk are for filter functions (or None): linejunk: A function that accepts a single string argument, and returns true if the string is junk. The default is None, meaning that no line is considered junk. charjunk: A function that accepts a single character argument (a string of length 1), and returns true if the character is junk. The default is None, meaning that no character is considered junk. These junk-filtering functions speed up matching to find differences and do not cause any differing lines or characters to be ignored. Read the description of the find_longest_match() method’s isjunk parameter for an explanation. Differ objects are used (deltas generated) via a single method: compare(a, b) Compare two sequences of lines, and generate the delta (a sequence of lines). Each sequence must contain individual single-line strings ending with newlines. Such sequences can be obtained from the readlines() method of file-like objects. The delta generated also consists of newline-terminated strings, ready to be printed as-is via the writelines() method of a file-like object. Differ Example This example compares two texts. First we set up the texts, sequences of individual single-line strings ending with newlines (such sequences can also be obtained from the readlines() method", "score": "0.6695636"}, {"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.66772825"}]}
{"task_id": "mbpp_126", "code": "def sum(a,b): \r\n    sum = 0\r\n    for i in range (1,min(a,b)): \r\n        if (a % i == 0 and b % i == 0): \r\n            sum += i \r\n    return sum", "test_list": ["assert sum(10,15) == 6", "assert sum(100,150) == 93", "assert sum(4,6) == 3"], "context": "Write a python function to find the sum of common divisors of two given numbers.", "function_name": "def sum(a,b):", "gold_generation": "sum = 0\r\n    for i in range (1,min(a,b)): \r\n        if (a % i == 0 and b % i == 0): \r\n            sum += i \r\n    return sum", "ctxs": [{"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.69520557"}, {"id": "19495", "text": "Function: python.library.decimal#decimal.Context.multiply\nSnippet: multiply(x, y) Return the product of x and y.", "score": "0.6734975"}, {"id": "19451", "text": "Function: python.library.decimal#decimal.Context.add\nSnippet: add(x, y) Return the sum of x and y.", "score": "0.6715288"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.67100775"}, {"id": "21805", "text": "Function: python.library.math#math.gcd\nSnippet: math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported.", "score": "0.66677105"}]}
{"task_id": "mbpp_127", "code": "def multiply_int(x, y):\r\n    if y < 0:\r\n        return -multiply_int(x, -y)\r\n    elif y == 0:\r\n        return 0\r\n    elif y == 1:\r\n        return x\r\n    else:\r\n        return x + multiply_int(x, y - 1)", "test_list": ["assert multiply_int(10,20)==200", "assert multiply_int(5,10)==50", "assert multiply_int(4,8)==32"], "context": "Write a function to multiply two integers without using the * operator in python.", "function_name": "def multiply_int(x, y):", "gold_generation": "if y < 0:\r\n        return -multiply_int(x, -y)\r\n    elif y == 0:\r\n        return 0\r\n    elif y == 1:\r\n        return x\r\n    else:\r\n        return x + multiply_int(x, y - 1)", "ctxs": [{"id": "19495", "text": "Function: python.library.decimal#decimal.Context.multiply\nSnippet: multiply(x, y) Return the product of x and y.", "score": "0.7138767"}, {"id": "22393", "text": "Function: python.library.operator#operator.__pow__\nSnippet: operator.pow(a, b) operator.__pow__(a, b) Return a ** b, for a and b numbers.", "score": "0.7019188"}, {"id": "22347", "text": "Function: python.library.operator#operator.pow\nSnippet: operator.pow(a, b) operator.__pow__(a, b) Return a ** b, for a and b numbers.", "score": "0.6965874"}, {"id": "22387", "text": "Function: python.library.operator#operator.__mul__\nSnippet: operator.mul(a, b) operator.__mul__(a, b) Return a * b, for a and b numbers.", "score": "0.6960207"}, {"id": "22341", "text": "Function: python.library.operator#operator.mul\nSnippet: operator.mul(a, b) operator.__mul__(a, b) Return a * b, for a and b numbers.", "score": "0.69574386"}]}
{"task_id": "mbpp_128", "code": "def long_words(n, str):\r\n    word_len = []\r\n    txt = str.split(\" \")\r\n    for x in txt:\r\n        if len(x) > n:\r\n            word_len.append(x)\r\n    return word_len\t", "test_list": ["assert long_words(3,\"python is a programming language\")==['python','programming','language']", "assert long_words(2,\"writing a program\")==['writing','program']", "assert long_words(5,\"sorting list\")==['sorting']"], "context": "Write a function to shortlist words that are longer than n from a given list of words.", "function_name": "def long_words(n, str):", "gold_generation": "word_len = []\r\n    txt = str.split(\" \")\r\n    for x in txt:\r\n        if len(x) > n:\r\n            word_len.append(x)\r\n    return word_len", "ctxs": [{"id": "19634", "text": "Function: python.library.difflib#difflib.get_close_matches\nSnippet: difflib.get_close_matches(word, possibilities, n=3, cutoff=0.6) Return a list of the best “good enough” matches. word is a sequence for which close matches are desired (typically a string), and possibilities is a list of sequences against which to match word (typically a list of strings). Optional argument n (default 3) is the maximum number of close matches to return; n must be greater than 0. Optional argument cutoff (default 0.6) is a float in the range [0, 1]. Possibilities that don’t score at least that similar to word are ignored. The best (no more than n) matches among the possibilities are returned in a list, sorted by similarity score, most similar first. >>> get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy']) ['apple', 'ape'] >>> import keyword >>> get_close_matches('wheel', keyword.kwlist) ['while'] >>> get_close_matches('pineapple', keyword.kwlist) [] >>> get_close_matches('accept', keyword.kwlist) ['except']", "score": "0.6732912"}, {"id": "25027", "text": "Function: python.library.textwrap#textwrap.TextWrapper.break_long_words\nSnippet: break_long_words (default: True) If true, then words longer than width will be broken in order to ensure that no lines are longer than width. If it is false, long words will not be broken, and some lines may be longer than width. (Long words will be put on a line by themselves, in order to minimize the amount by which width is exceeded.)", "score": "0.64582396"}, {"id": "37002", "text": "Function: django.ref.contrib.postgres.search#django.contrib.postgres.search.TrigramWordDistance\nSnippet: class TrigramWordDistance(string, expression, **extra)", "score": "0.638337"}, {"id": "25020", "text": "Function: python.library.textwrap\nSnippet: \"'\", followed by a space. One problem with this is algorithm is that it is unable to detect the difference between “Dr.” in [...] Dr. Frankenstein's monster [...] and “Spot.” in [...] See Spot. See Spot run [...] fix_sentence_endings is false by default. Since the sentence detection algorithm relies on string.lowercase for the definition of “lowercase letter”, and a convention of using two spaces after a period to separate sentences on the same line, it is specific to English-language texts. break_long_words (default: True) If true, then words longer than width will be broken in order to ensure that no lines are longer than width. If it is false, long words will not be broken, and some lines may be longer than width. (Long words will be put on a line by themselves, in order to minimize the amount by which width is exceeded.) break_on_hyphens (default: True) If true, wrapping will occur preferably on whitespaces and right after hyphens in compound words, as it is customary in English. If false, only whitespaces will be considered as potentially good places for line breaks, but you need to set break_long_words to false if you want truly insecable words. Default behaviour in previous versions was to always allow breaking hyphenated words. max_lines (default: None) If not None, then the output will contain at most max_lines lines, with placeholder appearing at the end of the output. New in version 3.4. placeholder (default: ' [...]') String that will appear at the end of the output text if it has been truncated. New in version 3.4. TextWrapper also provides some public methods, analogous to the module-level convenience functions: wrap(text) Wraps the single paragraph in text (a string) so every line is at most width characters long. All wrapping options are taken from instance attributes of the TextWrapper instance. Returns a list of output lines, without final newlines. If the wrapped output has no content, the returned list is empty. fill(text) Wraps the single paragraph in text, and returns a single string containing the wrapped paragraph.", "score": "0.6366328"}, {"id": "41856", "text": "Function: numpy.reference.distutils_guide\nSnippet: function and subroutine blocks in the file with names that contain ‘<…>’ according to the rules in ‘<…>’. The number of comma-separated words in ‘<…>’ determines the number of times the block is repeated. What these words are indicates what that repeat rule, ‘<…>’, should be replaced with in each block. All of the repeat rules in a block must contain the same number of comma-separated words indicating the number of times that block should be repeated. If the word in the repeat rule needs a comma, leftarrow, or rightarrow, then prepend it with a backslash ‘ '. If a word in the repeat rule matches ‘ \\<index>’ then it will be replaced with the <index>-th word in the same repeat specification. There are two forms for the repeat rule: named and short. Named repeat rule A named repeat rule is useful when the same set of repeats must be used several times in a block. It is specified using <rule1=item1, item2, item3,…, itemN>, where N is the number of times the block should be repeated. On each repeat of the block, the entire expression, ‘<…>’ will be replaced first with item1, and then with item2, and so forth until N repeats are accomplished. Once a named repeat specification has been introduced, the same repeat rule may be used in the current block by referring only to the name (i.e. <rule1>). Short repeat rule A short repeat rule looks like <item1, item2, item3, …, itemN>. The rule specifies that the entire expression, ‘<…>’ should be replaced first with item1, and then with item2, and so forth until N repeats are accomplished. Pre-defined names The following predefined named repeat rules are available: <prefix=s,d,c,z> <_c=s,d,c,z> <_t=real, double precision, complex, double complex> <ftype=real, double precision, complex, double complex> <ctype=float, double, complex_float, complex_double> <ftypereal=float, double precision, \\0, \\1> <ctypereal=float, double, \\0, \\1> Other files Non-Fortran files use a separate syntax for defining template blocks that should be repeated using a variable expansion similar to the named repeat rules of the Fortran-specific repeats. NumPy Distutils preprocesses C source files (extension: .c.src) written in a custom templating language to generate C code. The @ symbol is used to wrap macro-style variables to empower a string substitution mechanism that might describe (for instance) a set of data types. The template language blocks are delimited by /**begin repeat and /**end repeat**/ lines, which may also be nested using consecutively numbered delimiting lines such as /**begin repeat1 and /**end repeat1**/: /**begin repeat on a line by itself marks the beginning of a segment that should be repeated. Named variable expansions are defined using #name=item1, item2, item3, ..., itemN# and placed on successive lines. These variables are replaced in each repeat block with corresponding word. All named variables in the same repeat block must define the same number of words. In specifying the repeat rule for a named variable, item*N is short- hand for item, item, ..., item repeated N times. In addition, parenthesis in combination with *N can be", "score": "0.6363509"}]}
{"task_id": "mbpp_129", "code": "def magic_square_test(my_matrix):\r\n    iSize = len(my_matrix[0])\r\n    sum_list = []\r\n    sum_list.extend([sum (lines) for lines in my_matrix])   \r\n    for col in range(iSize):\r\n        sum_list.append(sum(row[col] for row in my_matrix))\r\n    result1 = 0\r\n    for i in range(0,iSize):\r\n        result1 +=my_matrix[i][i]\r\n    sum_list.append(result1)      \r\n    result2 = 0\r\n    for i in range(iSize-1,-1,-1):\r\n        result2 +=my_matrix[i][i]\r\n    sum_list.append(result2)\r\n    if len(set(sum_list))>1:\r\n        return False\r\n    return True", "test_list": ["assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True", "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]])==True", "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 7]])==False"], "context": "Write a function to calculate magic square.", "function_name": "def magic_square_test(my_matrix):", "gold_generation": "iSize = len(my_matrix[0])\r\n    sum_list = []\r\n    sum_list.extend([sum (lines) for lines in my_matrix])   \r\n    for col in range(iSize):\r\n        sum_list.append(sum(row[col] for row in my_matrix))\r\n    result1 = 0\r\n    for i in range(0,iSize):\r\n        result1 +=my_matrix[i][i]\r\n    sum_list.append(result1)      \r\n    result2 = 0\r\n    for i in range(iSize-1,-1,-1):\r\n        result2 +=my_matrix[i][i]\r\n    sum_list.append(result2)\r\n    if len(set(sum_list))>1:\r\n        return False\r\n    return True", "ctxs": [{"id": "21777", "text": "Function: python.library.math\nSnippet: Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers. math.sqrt(x) Return the square root of x. Trigonometric functions math.acos(x) Return the arc cosine of x, in radians. The result is between 0 and pi. math.asin(x) Return the arc sine of x, in radians. The result is between -pi/2 and pi/2. math.atan(x) Return the arc tangent of x, in radians. The result is between -pi/2 and pi/2. math.atan2(y, x) Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4. math.cos(x) Return the cosine of x radians. math.dist(p, q) Return the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Roughly equivalent to: sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q))) New in version 3.8. math.hypot(*coordinates) Return the Euclidean norm, sqrt(sum(x**2 for x in coordinates)). This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point (x, y), this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, sqrt(x*x + y*y). Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. math.sin(x) Return the sine of x radians. math.tan(x) Return the tangent of x radians. Angular conversion math.degrees(x) Convert angle x from radians to degrees. math.radians(x) Convert angle x from degrees to radians. Hyperbolic functions Hyperbolic functions are analogs of trigonometric functions that are based on hyperbolas instead of circles. math.acosh(x) Return the inverse hyperbolic cosine of x. math.asinh(x) Return the inverse hyperbolic sine of x. math.atanh(x) Return the inverse hyperbolic tangent of x. math.cosh(x) Return the hyperbolic cosine of x. math.sinh(x) Return the hyperbolic sine of x. math.tanh(x) Return the hyperbolic tangent of x. Special functions math.erf(x) Return the error function at x. The erf() function can be used to compute traditional statistical functions such as the cumulative standard normal distribution: def phi(x): 'Cumulative distribution function for the standard normal distribution' return (1.0 + erf(x / sqrt(2.0))) / 2.0 New in version 3.2. math.erfc(x) Return the complementary error function at x. The complementary error function is defined as 1.0 - erf(x). It is used for large values of x where a subtraction from one would cause a loss of significance. New in version 3.2. math.gamma(x) Return the Gamma function at x. New in version 3.2. math.lgamma(x) Return the natural logarithm of the absolute value of the Gamma function at x. New in version 3.2. Constants math.pi The mathematical constant π =", "score": "0.6786993"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.67507756"}, {"id": "20290", "text": "Function: python.library.functions\nSnippet: integer representing the Unicode code point of that character. For example, ord('a') returns the integer 97 and ord('€') (Euro sign) returns 8364. This is the inverse of chr(). pow(base, exp[, mod]) Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp. The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10**2 returns 100, but 10**-2 returns 0.01. For int operands base and exp, if mod is present, mod must also be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod. In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod. Here’s an example of computing an inverse for 38 modulo 97: >>> pow(38, -1, mod=97) 23 >>> 23 * 38 % 97 == 1 True Changed in version 3.8: For int operands, the three-argument form of pow now allows the second argument to be negative, permitting computation of modular inverses. Changed in version 3.8: Allow keyword arguments. Formerly, only positional arguments were supported. print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False) Print objects to the text stream file, separated by sep and followed by end. sep, end, file and flush, if present, must be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end. The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Since printed arguments are converted to text strings, print() cannot be used with binary mode file objects. For these, use file.write(...) instead. Whether output is buffered is usually determined by file, but if the flush keyword argument is true, the stream is forcibly flushed. Changed in version 3.3: Added the flush keyword argument. class property(fget=None, fset=None, fdel=None, doc=None) Return a property attribute. fget is a function for getting an attribute value. fset is a function for setting an attribute value. fdel is a function for deleting an attribute value. And doc creates a docstring for the attribute. A typical use is to define a managed attribute x: class C: def __init__(self): self._x = None def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") If c is an instance of C, c.x", "score": "0.67488486"}, {"id": "14440", "text": "Function: pandas.reference.api.pandas.dataframe.pow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6687517"}, {"id": "14410", "text": "Function: pandas.reference.api.pandas.dataframe.multiply\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6650325"}]}
{"task_id": "mbpp_130", "code": "from collections import defaultdict\r\ndef max_occurrences(nums):\r\n    dict = defaultdict(int)\r\n    for i in nums:\r\n        dict[i] += 1\r\n    result = max(dict.items(), key=lambda x: x[1]) \r\n    return result", "test_list": ["assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==(2, 5)", "assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,16,18])==(8, 2)", "assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==(20, 3)"], "context": "Write a function to find the item with maximum frequency in a given list.", "function_name": "from collections import defaultdict\r\ndef max_occurrences(nums):", "gold_generation": "dict = defaultdict(int)\r\n    for i in nums:\r\n        dict[i] += 1\r\n    result = max(dict.items(), key=lambda x: x[1]) \r\n    return result", "ctxs": [{"id": "18120", "text": "Function: python.library.audioop#audioop.findmax\nSnippet: audioop.findmax(fragment, length) Search fragment for a slice of length length samples (not bytes!) with maximum energy, i.e., return i for which rms(fragment[i*2:(i+length)*2]) is maximal. The fragments should both contain 2-byte samples. The routine takes time proportional to len(fragment).", "score": "0.7064534"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.6789348"}, {"id": "18126", "text": "Function: python.library.audioop#audioop.max\nSnippet: audioop.max(fragment, width) Return the maximum of the absolute value of all samples in a fragment.", "score": "0.6698353"}, {"id": "18127", "text": "Function: python.library.audioop#audioop.maxpp\nSnippet: audioop.maxpp(fragment, width) Return the maximum peak-peak value in the sound fragment.", "score": "0.6696038"}, {"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.65991896"}]}
{"task_id": "mbpp_131", "code": "def reverse_vowels(str1):\r\n\tvowels = \"\"\r\n\tfor char in str1:\r\n\t\tif char in \"aeiouAEIOU\":\r\n\t\t\tvowels += char\r\n\tresult_string = \"\"\r\n\tfor char in str1:\r\n\t\tif char in \"aeiouAEIOU\":\r\n\t\t\tresult_string += vowels[-1]\r\n\t\t\tvowels = vowels[:-1]\r\n\t\telse:\r\n\t\t\tresult_string += char\r\n\treturn result_string", "test_list": ["assert reverse_vowels(\"Python\") == \"Python\"", "assert reverse_vowels(\"USA\") == \"ASU\"", "assert reverse_vowels(\"ab\") == \"ab\""], "context": "Write a python function to reverse only the vowels of a given string.", "function_name": "def reverse_vowels(str1):", "gold_generation": "vowels = \"\"\r\n\tfor char in str1:\r\n\t\tif char in \"aeiouAEIOU\":\r\n\t\t\tvowels += char\r\n\tresult_string = \"\"\r\n\tfor char in str1:\r\n\t\tif char in \"aeiouAEIOU\":\r\n\t\t\tresult_string += vowels[-1]\r\n\t\t\tvowels = vowels[:-1]\r\n\t\telse:\r\n\t\t\tresult_string += char\r\n\treturn result_string", "ctxs": [{"id": "17643", "text": "Function: python.library.array#array.array.reverse\nSnippet: array.reverse() Reverse the order of the items in the array.", "score": "0.67262584"}, {"id": "24400", "text": "Function: python.library.string#string.ascii_lowercase\nSnippet: string.ascii_lowercase The lowercase letters 'abcdefghijklmnopqrstuvwxyz'. This value is not locale-dependent and will not change.", "score": "0.6714231"}, {"id": "25746", "text": "Function: python.library.stdtypes\nSnippet: Return -1 on failure. str.rindex(sub[, start[, end]]) Like rfind() but raises ValueError when the substring sub is not found. str.rjust(width[, fillchar]) Return the string right justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.rpartition(sep) Split the string at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself. str.rsplit(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any whitespace string is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below. str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty' str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3'] str.splitlines([keepends]) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. This", "score": "0.67047554"}, {"id": "18131", "text": "Function: python.library.audioop#audioop.reverse\nSnippet: audioop.reverse(fragment, width) Reverse the samples in a fragment and returns the modified fragment.", "score": "0.664998"}, {"id": "24364", "text": "Function: python.library.stdtypes#str.lower\nSnippet: str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard.", "score": "0.6645878"}]}
{"task_id": "mbpp_132", "code": "def tup_string(tup1):\r\n  str =  ''.join(tup1)\r\n  return str", "test_list": ["assert tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'))==(\"exercises\")", "assert tup_string(('p','y','t','h','o','n'))==(\"python\")", "assert tup_string(('p','r','o','g','r','a','m'))==(\"program\")"], "context": "Write a function to convert tuple to a string.", "function_name": "def tup_string(tup1):", "gold_generation": "str =  ''.join(tup1)\r\n  return str", "ctxs": [{"id": "36422", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.Envelope.tuple\nSnippet: tuple", "score": "0.7095982"}, {"id": "41649", "text": "Function: numpy.reference.generated.numpy.char.chararray.dumps\nSnippet: numpy.char.chararray.dumps method char.chararray.dumps() Returns the pickle of the array as a string. pickle.loads will convert the string back to an array. Parameters None", "score": "0.69774425"}, {"id": "36544", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.OGRGeometry.tuple\nSnippet: tuple", "score": "0.69728017"}, {"id": "24412", "text": "Function: python.library.string#string.Formatter.parse\nSnippet: parse(format_string) Loop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields. The values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None.", "score": "0.69629276"}, {"id": "36438", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.Field.as_string\nSnippet: as_string()", "score": "0.6935649"}]}
{"task_id": "mbpp_133", "code": "def sum_negativenum(nums):\r\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\r\n  return sum(sum_negativenum)", "test_list": ["assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==-32", "assert sum_negativenum([10,15,-14,13,-18,12,-20])==-52", "assert sum_negativenum([19, -65, 57, 39, 152,-639, 121, 44, 90, -190])==-894"], "context": "Write a function to calculate the sum of the negative numbers of a given list of numbers using lambda function.", "function_name": "def sum_negativenum(nums):", "gold_generation": "sum_negativenum = list(filter(lambda nums:nums<0,nums))\r\n  return sum(sum_negativenum)", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.66005313"}, {"id": "18611", "text": "Function: python.library.collections\nSnippet: Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6}) New in version 3.2. The usual dictionary methods are available for Counter objects except for two which work differently for counters. fromkeys(iterable) This class method is not implemented for Counter objects. update([iterable-or-mapping]) Elements are counted from an iterable or added-in from another mapping (or counter). Like dict.update() but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of (key, value) pairs. Common patterns for working with Counter objects: sum(c.values()) # total of all counts c.clear() # reset all counts list(c) # list unique elements set(c) # convert to a set dict(c) # convert to a regular dictionary c.items() # convert to a list of (elem, cnt) pairs Counter(dict(list_of_pairs)) # convert from a list of (elem, cnt) pairs c.most_common()[:-n-1:-1] # n least common elements +c # remove zero and negative counts Several mathematical operations are provided for combining Counter objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. Intersection and union return the minimum and maximum of corresponding counts. Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less. >>> c = Counter(a=3, b=1) >>> d = Counter(a=1, b=2) >>> c + d # add two counters together: c[x] + d[x] Counter({'a': 4, 'b': 3}) >>> c - d # subtract (keeping only positive counts) Counter({'a': 2}) >>> c & d # intersection: min(c[x], d[x]) Counter({'a': 1, 'b': 1}) >>> c | d # union: max(c[x], d[x]) Counter({'a': 3, 'b': 2}) Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter. >>> c = Counter(a=2, b=-4) >>> +c Counter({'a': 2}) >>> -c Counter({'b': 4}) New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations. Note Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values. To help with those use cases, this section documents the minimum range and type restrictions. The Counter class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you could store anything in the value field. The most_common() method requires only that the values be orderable. For in-place operations such as c[key] += 1, the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for update() and subtract() which allow negative and zero", "score": "0.6588712"}, {"id": "19451", "text": "Function: python.library.decimal#decimal.Context.add\nSnippet: add(x, y) Return the sum of x and y.", "score": "0.6569581"}, {"id": "43061", "text": "Function: numpy.reference.generated.numpy.negative\nSnippet: numpy.negative numpy.negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'negative'> Numerical negative, element-wise. Parameters xarray_like or scalar Input array. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar Returned array or scalar: y = -x. This is a scalar if x is a scalar. Examples >>> np.negative([1.,-1.]) array([-1., 1.]) The unary - operator can be used as a shorthand for np.negative on ndarrays. >>> x1 = np.array(([1., -1.])) >>> -x1 array([-1., 1.])", "score": "0.65318924"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.6523181"}]}
{"task_id": "mbpp_134", "code": "def check_last (arr,n,p): \r\n    _sum = 0\r\n    for i in range(n): \r\n        _sum = _sum + arr[i] \r\n    if p == 1: \r\n        if _sum % 2 == 0: \r\n            return \"ODD\"\r\n        else: \r\n            return \"EVEN\"\r\n    return \"EVEN\"\r\n      ", "test_list": ["assert check_last([5,7,10],3,1) == \"ODD\"", "assert check_last([2,3],2,3) == \"EVEN\"", "assert check_last([1,2,3],3,1) == \"ODD\""], "context": "Write a python function to check whether the last element of given array is even or odd after performing an operation p times.", "function_name": "def check_last (arr,n,p):", "gold_generation": "_sum = 0\r\n    for i in range(n): \r\n        _sum = _sum + arr[i] \r\n    if p == 1: \r\n        if _sum % 2 == 0: \r\n            return \"ODD\"\r\n        else: \r\n            return \"EVEN\"\r\n    return \"EVEN\"", "ctxs": [{"id": "42587", "text": "Function: numpy.reference.generated.numpy.nditer.iternext\nSnippet: numpy.nditer.iternext method nditer.iternext() Check whether iterations are left, and perform a single internal iteration without returning the result. Used in the C-style pattern do-while pattern. For an example, see nditer. Returns iternextbool Whether or not there are iterations left.", "score": "0.6753358"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6729094"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.670585"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.66712415"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6661872"}]}
{"task_id": "mbpp_135", "code": "def hexagonal_num(n): \r\n\treturn n*(2*n - 1) ", "test_list": ["assert hexagonal_num(10) == 190", "assert hexagonal_num(5) == 45", "assert hexagonal_num(7) == 91"], "context": "Write a function to find the nth hexagonal number.", "function_name": "def hexagonal_num(n):", "gold_generation": "return n*(2*n - 1)", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6967875"}, {"id": "27626", "text": "Function: matplotlib._as_gen.matplotlib.axes.axes.hexbin\nSnippet: matplotlib.axes.Axes.hexbin Axes.hexbin(x, y, C=None, gridsize=100, bins=None, xscale='linear', yscale='linear', extent=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, edgecolors='face', reduce_C_function=<function mean>, mincnt=None, marginals=False, *, data=None, **kwargs)[source] Make a 2D hexagonal binning plot of points x, y. If C is None, the value of the hexagon is determined by the number of points in the hexagon. Otherwise, C specifies values at the coordinate (x[i], y[i]). For each hexagon, these values are reduced using reduce_C_function. Parameters x, yarray-like The data positions. x and y must be of the same length. Carray-like, optional If given, these values are accumulated in the bins. Otherwise, every point has a value of 1. Must be of the same length as x and y. gridsizeint or (int, int), default: 100 If a single int, the number of hexagons in the x-direction. The number of hexagons in the y-direction is chosen such that the hexagons are approximately regular. Alternatively, if a tuple (nx, ny), the number of hexagons in the x-direction and the y-direction. bins'log' or int or sequence, default: None Discretization of the hexagon values. If None, no binning is applied; the color of each hexagon directly corresponds to its count value. If 'log', use a logarithmic scale for the colormap. Internally, \\(log_{10}(i+1)\\) is used to determine the hexagon color. This is equivalent to norm=LogNorm(). If an integer, divide the counts in the specified number of bins, and color the hexagons accordingly. If a sequence of values, the values of the lower bound of the bins to be used. xscale{'linear', 'log'}, default: 'linear' Use a linear or log10 scale on the horizontal axis. yscale{'linear', 'log'}, default: 'linear' Use a linear or log10 scale on the vertical axis. mincntint > 0, default: None If not None, only display cells with more than mincnt number of points in the cell. marginalsbool, default: False If marginals is True, plot the marginal density as colormapped rectangles along the bottom of the x-axis and left of the y-axis. extent4-tuple of float, default: None The limits of the bins (xmin, xmax, ymin, ymax). The default assigns the limits based on gridsize, x, y, xscale and yscale. If xscale or yscale is set to 'log', the limits are expected to be the exponent for a power of 10. E.g. for x-limits of 1 and 50 in 'linear' scale and y-limits of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3). Returns PolyCollection A PolyCollection defining the hexagonal bins. PolyCollection.get_offsets contains a Mx2 array containing the x, y positions of the M hexagon centers. PolyCollection.get_array contains the values of the M hexagons. If marginals is True, horizontal bar and vertical bar (both PolyCollections) will be attached to the return collection as attributes hbar and vbar. Other Parameters cmapstr or Colormap, default: rcParams[\"image.cmap\"] (default: 'viridis') The Colormap instance or registered colormap name used to map the bin values to colors. normNormalize, optional The Normalize instance scales the bin values to the canonical colormap range [0, 1] for mapping to colors. By default, the data range is mapped", "score": "0.6933674"}, {"id": "33344", "text": "Function: matplotlib._as_gen.matplotlib.pyplot.hexbin\nSnippet: matplotlib.pyplot.hexbin matplotlib.pyplot.hexbin(x, y, C=None, gridsize=100, bins=None, xscale='linear', yscale='linear', extent=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, edgecolors='face', reduce_C_function=<function mean>, mincnt=None, marginals=False, *, data=None, **kwargs)[source] Make a 2D hexagonal binning plot of points x, y. If C is None, the value of the hexagon is determined by the number of points in the hexagon. Otherwise, C specifies values at the coordinate (x[i], y[i]). For each hexagon, these values are reduced using reduce_C_function. Parameters x, yarray-like The data positions. x and y must be of the same length. Carray-like, optional If given, these values are accumulated in the bins. Otherwise, every point has a value of 1. Must be of the same length as x and y. gridsizeint or (int, int), default: 100 If a single int, the number of hexagons in the x-direction. The number of hexagons in the y-direction is chosen such that the hexagons are approximately regular. Alternatively, if a tuple (nx, ny), the number of hexagons in the x-direction and the y-direction. bins'log' or int or sequence, default: None Discretization of the hexagon values. If None, no binning is applied; the color of each hexagon directly corresponds to its count value. If 'log', use a logarithmic scale for the colormap. Internally, \\(log_{10}(i+1)\\) is used to determine the hexagon color. This is equivalent to norm=LogNorm(). If an integer, divide the counts in the specified number of bins, and color the hexagons accordingly. If a sequence of values, the values of the lower bound of the bins to be used. xscale{'linear', 'log'}, default: 'linear' Use a linear or log10 scale on the horizontal axis. yscale{'linear', 'log'}, default: 'linear' Use a linear or log10 scale on the vertical axis. mincntint > 0, default: None If not None, only display cells with more than mincnt number of points in the cell. marginalsbool, default: False If marginals is True, plot the marginal density as colormapped rectangles along the bottom of the x-axis and left of the y-axis. extent4-tuple of float, default: None The limits of the bins (xmin, xmax, ymin, ymax). The default assigns the limits based on gridsize, x, y, xscale and yscale. If xscale or yscale is set to 'log', the limits are expected to be the exponent for a power of 10. E.g. for x-limits of 1 and 50 in 'linear' scale and y-limits of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3). Returns PolyCollection A PolyCollection defining the hexagonal bins. PolyCollection.get_offsets contains a Mx2 array containing the x, y positions of the M hexagon centers. PolyCollection.get_array contains the values of the M hexagons. If marginals is True, horizontal bar and vertical bar (both PolyCollections) will be attached to the return collection as attributes hbar and vbar. Other Parameters cmapstr or Colormap, default: rcParams[\"image.cmap\"] (default: 'viridis') The Colormap instance or registered colormap name used to map the bin values to colors. normNormalize, optional The Normalize instance scales the bin values to the canonical colormap range [0, 1] for mapping to colors. By default, the data range is mapped", "score": "0.6907435"}, {"id": "14432", "text": "Function: pandas.reference.api.pandas.dataframe.plot.hexbin\nSnippet: pandas.DataFrame.plot.hexbin DataFrame.plot.hexbin(x, y, C=None, reduce_C_function=None, gridsize=None, **kwargs)[source] Generate a hexagonal binning plot. Generate a hexagonal binning plot of x versus y. If C is None (the default), this is a histogram of the number of occurrences of the observations at (x[i], y[i]). If C is specified, specifies values at given coordinates (x[i], y[i]). These values are accumulated for each hexagonal bin and then reduced according to reduce_C_function, having as default the NumPy’s mean function (numpy.mean()). (If C is specified, it must also be a 1-D sequence of the same length as x and y, or a column label.) Parameters x:int or str The column label or position for x points. y:int or str The column label or position for y points. C:int or str, optional The column label or position for the value of (x, y) point. reduce_C_function:callable, default np.mean Function of one argument that reduces all the values in a bin to a single number (e.g. np.mean, np.max, np.sum, np.std). gridsize:int or tuple of (int, int), default 100 The number of hexagons in the x-direction. The corresponding number of hexagons in the y-direction is chosen in a way that the hexagons are approximately regular. Alternatively, gridsize can be a tuple with two elements specifying the number of hexagons in the x-direction and the y-direction. **kwargs Additional keyword arguments are documented in DataFrame.plot(). Returns matplotlib.AxesSubplot The matplotlib Axes on which the hexbin is plotted. See also DataFrame.plot Make plots of a DataFrame. matplotlib.pyplot.hexbin Hexagonal binning plot using matplotlib, the matplotlib function that is used under the hood. Examples The following examples are generated with random data from a normal distribution. >>> n = 10000 >>> df = pd.DataFrame({'x': np.random.randn(n), ... 'y': np.random.randn(n)}) >>> ax = df.plot.hexbin(x='x', y='y', gridsize=20) The next example uses C and np.sum as reduce_C_function. Note that ‘observations’ values ranges from 1 to 5 but the result plot shows values up to more than 25. This is because of the reduce_C_function. >>> n = 500 >>> df = pd.DataFrame({ ... 'coord_x': np.random.uniform(-3, 3, size=n), ... 'coord_y': np.random.uniform(30, 50, size=n), ... 'observations': np.random.randint(1,5, size=n) ... }) >>> ax = df.plot.hexbin(x='coord_x', ... y='coord_y', ... C='observations', ... reduce_C_function=np.sum, ... gridsize=10, ... cmap=\"viridis\")", "score": "0.677424"}, {"id": "14447", "text": "Function: pandas.reference.api.pandas.dataframe.radd\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6773303"}]}
{"task_id": "mbpp_136", "code": "def cal_electbill(units):\r\n if(units < 50):\r\n    amount = units * 2.60\r\n    surcharge = 25\r\n elif(units <= 100):\r\n    amount = 130 + ((units - 50) * 3.25)\r\n    surcharge = 35\r\n elif(units <= 200):\r\n    amount = 130 + 162.50 + ((units - 100) * 5.26)\r\n    surcharge = 45\r\n else:\r\n    amount = 130 + 162.50 + 526 + ((units - 200) * 8.45)\r\n    surcharge = 75\r\n total = amount + surcharge\r\n return total", "test_list": ["assert cal_electbill(75)==246.25", "assert cal_electbill(265)==1442.75", "assert cal_electbill(100)==327.5"], "context": "Write a function to calculate electricity bill.", "function_name": "def cal_electbill(units):", "gold_generation": "if(units < 50):\r\n    amount = units * 2.60\r\n    surcharge = 25\r\n elif(units <= 100):\r\n    amount = 130 + ((units - 50) * 3.25)\r\n    surcharge = 35\r\n elif(units <= 200):\r\n    amount = 130 + 162.50 + ((units - 100) * 5.26)\r\n    surcharge = 45\r\n else:\r\n    amount = 130 + 162.50 + 526 + ((units - 200) * 8.45)\r\n    surcharge = 75\r\n total = amount + surcharge\r\n return total", "ctxs": [{"id": "19441", "text": "Function: python.library.decimal\nSnippet: >>> print(exp(Decimal(2))) 7.389056098930650227230427461 >>> print(exp(2.0)) 7.38905609893 >>> print(exp(2+0j)) (7.38905609893+0j) \"\"\" getcontext().prec += 2 i, lasts, s, fact, num = 0, 0, 1, 1, 1 while s != lasts: lasts = s i += 1 fact *= i num *= x s += num / fact getcontext().prec -= 2 return +s def cos(x): \"\"\"Return the cosine of x as measured in radians. The Taylor series approximation works best for a small value of x. For larger values, first compute x = x % (2 * pi). >>> print(cos(Decimal('0.5'))) 0.8775825618903727161162815826 >>> print(cos(0.5)) 0.87758256189 >>> print(cos(0.5+0j)) (0.87758256189+0j) \"\"\" getcontext().prec += 2 i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1 while s != lasts: lasts = s i += 2 fact *= i * (i-1) num *= x * x sign *= -1 s += num / fact * sign getcontext().prec -= 2 return +s def sin(x): \"\"\"Return the sine of x as measured in radians. The Taylor series approximation works best for a small value of x. For larger values, first compute x = x % (2 * pi). >>> print(sin(Decimal('0.5'))) 0.4794255386042030002732879352 >>> print(sin(0.5)) 0.479425538604 >>> print(sin(0.5+0j)) (0.479425538604+0j) \"\"\" getcontext().prec += 2 i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1 while s != lasts: lasts = s i += 2 fact *= i * (i-1) num *= x * x sign *= -1 s += num / fact * sign getcontext().prec -= 2 return +s Decimal FAQ Q. It is cumbersome to type decimal.Decimal('1234.5'). Is there a way to minimize typing when using the interactive interpreter? A. Some users abbreviate the constructor to just a single letter: >>> D = decimal.Decimal >>> D('1.23') + D('3.45') Decimal('4.68') Q. In a fixed-point application with two decimal places, some inputs have many places and need to be rounded. Others are not supposed to have excess digits and need to be validated. What methods should be used? A. The quantize() method rounds to a fixed number of decimal places. If the Inexact trap is set, it is also useful for validation: >>> TWOPLACES = Decimal(10) ** -2 # same as Decimal('0.01') >>> # Round to two places >>> Decimal('3.214').quantize(TWOPLACES) Decimal('3.21') >>> # Validate that a number does not exceed two places >>> Decimal('3.21').quantize(TWOPLACES, context=Context(traps=[Inexact])) Decimal('3.21') >>> Decimal('3.214').quantize(TWOPLACES, context=Context(traps=[Inexact])) Traceback (most recent call last): ... Inexact: None Q. Once I have valid two place inputs, how do I maintain that invariant throughout an application? A. Some operations like addition, subtraction, and multiplication by an integer will automatically preserve fixed point. Others operations, like division and non-integer multiplication, will change the number of decimal places and need to be followed-up with a quantize() step: >>> a = Decimal('102.72') # Initial fixed-point values >>> b = Decimal('3.17') >>> a + b # Addition preserves fixed-point Decimal('105.89') >>> a - b Decimal('99.55') >>> a * 42 # So does integer multiplication Decimal('4314.24') >>> (a * b).quantize(TWOPLACES) # Must quantize non-integer multiplication Decimal('325.62') >>> (b / a).quantize(TWOPLACES) # And quantize division Decimal('0.03')", "score": "0.6470179"}, {"id": "20290", "text": "Function: python.library.functions\nSnippet: integer representing the Unicode code point of that character. For example, ord('a') returns the integer 97 and ord('€') (Euro sign) returns 8364. This is the inverse of chr(). pow(base, exp[, mod]) Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp. The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10**2 returns 100, but 10**-2 returns 0.01. For int operands base and exp, if mod is present, mod must also be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod. In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod. Here’s an example of computing an inverse for 38 modulo 97: >>> pow(38, -1, mod=97) 23 >>> 23 * 38 % 97 == 1 True Changed in version 3.8: For int operands, the three-argument form of pow now allows the second argument to be negative, permitting computation of modular inverses. Changed in version 3.8: Allow keyword arguments. Formerly, only positional arguments were supported. print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False) Print objects to the text stream file, separated by sep and followed by end. sep, end, file and flush, if present, must be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end. The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Since printed arguments are converted to text strings, print() cannot be used with binary mode file objects. For these, use file.write(...) instead. Whether output is buffered is usually determined by file, but if the flush keyword argument is true, the stream is forcibly flushed. Changed in version 3.3: Added the flush keyword argument. class property(fget=None, fset=None, fdel=None, doc=None) Return a property attribute. fget is a function for getting an attribute value. fset is a function for setting an attribute value. fdel is a function for deleting an attribute value. And doc creates a docstring for the attribute. A typical use is to define a managed attribute x: class C: def __init__(self): self._x = None def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") If c is an instance of C, c.x", "score": "0.6438006"}, {"id": "35803", "text": "Function: django.ref.models.database-functions#django.db.models.functions.Power\nSnippet: class Power(expression1, expression2, **extra)", "score": "0.6437596"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.62892056"}, {"id": "23150", "text": "Function: python.library.functions#pow\nSnippet: pow(base, exp[, mod]) Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp. The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10**2 returns 100, but 10**-2 returns 0.01. For int operands base and exp, if mod is present, mod must also be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod. In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod. Here’s an example of computing an inverse for 38 modulo 97: >>> pow(38, -1, mod=97) 23 >>> 23 * 38 % 97 == 1 True Changed in version 3.8: For int operands, the three-argument form of pow now allows the second argument to be negative, permitting computation of modular inverses. Changed in version 3.8: Allow keyword arguments. Formerly, only positional arguments were supported.", "score": "0.628165"}]}
{"task_id": "mbpp_137", "code": "from array import array\r\ndef zero_count(nums):\r\n    n = len(nums)\r\n    n1 = 0\r\n    for x in nums:\r\n        if x == 0:\r\n            n1 += 1\r\n        else:\r\n          None\r\n    return round(n1/n,2)", "test_list": ["assert zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.15", "assert zero_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.00", "assert zero_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.00"], "context": "Write a function to find the ration of zeroes in an array of integers.", "function_name": "from array import array\r\ndef zero_count(nums):", "gold_generation": "n = len(nums)\r\n    n1 = 0\r\n    for x in nums:\r\n        if x == 0:\r\n            n1 += 1\r\n        else:\r\n          None\r\n    return round(n1/n,2)", "ctxs": [{"id": "20189", "text": "Function: python.library.stdtypes#float.as_integer_ratio\nSnippet: float.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original float and with a positive denominator. Raises OverflowError on infinities and a ValueError on NaNs.", "score": "0.67366296"}, {"id": "21070", "text": "Function: python.library.stdtypes#int.as_integer_ratio\nSnippet: int.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original integer and with a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. New in version 3.8.", "score": "0.6689861"}, {"id": "20204", "text": "Function: python.library.fractions#fractions.Fraction.as_integer_ratio\nSnippet: as_integer_ratio() Return a tuple of two integers, whose ratio is equal to the Fraction and with a positive denominator. New in version 3.8.", "score": "0.66809344"}, {"id": "43863", "text": "Function: numpy.reference.generated.numpy.recarray.nonzero\nSnippet: numpy.recarray.nonzero method recarray.nonzero() Return the indices of the elements that are non-zero. Refer to numpy.nonzero for full documentation. See also numpy.nonzero equivalent function", "score": "0.6636983"}, {"id": "41678", "text": "Function: numpy.reference.generated.numpy.char.chararray.nonzero\nSnippet: numpy.char.chararray.nonzero method char.chararray.nonzero() Return the indices of the elements that are non-zero. Refer to numpy.nonzero for full documentation. See also numpy.nonzero equivalent function", "score": "0.66250724"}]}
{"task_id": "mbpp_138", "code": "def is_Sum_Of_Powers_Of_Two(n): \r\n    if (n % 2 == 1): \r\n        return False\r\n    else: \r\n        return True", "test_list": ["assert is_Sum_Of_Powers_Of_Two(10) == True", "assert is_Sum_Of_Powers_Of_Two(7) == False", "assert is_Sum_Of_Powers_Of_Two(14) == True"], "context": "Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.", "function_name": "def is_Sum_Of_Powers_Of_Two(n):", "gold_generation": "if (n % 2 == 1): \r\n        return False\r\n    else: \r\n        return True", "ctxs": [{"id": "21810", "text": "Function: python.library.math#math.isinf\nSnippet: math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise.", "score": "0.7016721"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.69681495"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.68848026"}, {"id": "21825", "text": "Function: python.library.math#math.pow\nSnippet: math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError. Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers.", "score": "0.683264"}, {"id": "21811", "text": "Function: python.library.math#math.isnan\nSnippet: math.isnan(x) Return True if x is a NaN (not a number), and False otherwise.", "score": "0.68047285"}]}
{"task_id": "mbpp_139", "code": "def circle_circumference(r):\r\n  perimeter=2*3.1415*r\r\n  return perimeter", "test_list": ["assert circle_circumference(10)==62.830000000000005", "assert circle_circumference(5)==31.415000000000003", "assert circle_circumference(4)==25.132"], "context": "Write a function to find the circumference of a circle.", "function_name": "def circle_circumference(r):", "gold_generation": "perimeter=2*3.1415*r\r\n  return perimeter", "ctxs": [{"id": "25592", "text": "Function: python.library.turtle\nSnippet: steps – an integer (or None) Draw a circle with given radius. The center is radius units left of the turtle; extent – an angle – determines which part of the circle is drawn. If extent is not given, draw the entire circle. If extent is not a full circle, one endpoint of the arc is the current pen position. Draw the arc in counterclockwise direction if radius is positive, otherwise in clockwise direction. Finally the direction of the turtle is changed by the amount of extent. As the circle is approximated by an inscribed regular polygon, steps determines the number of steps to use. If not given, it will be calculated automatically. May be used to draw regular polygons. >>> turtle.home() >>> turtle.position() (0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(50) >>> turtle.position() (-0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(120, 180) # draw a semicircle >>> turtle.position() (0.00,240.00) >>> turtle.heading() 180.0 turtle.dot(size=None, *color) Parameters size – an integer >= 1 (if given) color – a colorstring or a numeric color tuple Draw a circular dot with diameter size, using color. If size is not given, the maximum of pensize+4 and 2*pensize is used. >>> turtle.home() >>> turtle.dot() >>> turtle.fd(50); turtle.dot(20, \"blue\"); turtle.fd(50) >>> turtle.position() (100.00,-0.00) >>> turtle.heading() 0.0 turtle.stamp() Stamp a copy of the turtle shape onto the canvas at the current turtle position. Return a stamp_id for that stamp, which can be used to delete it by calling clearstamp(stamp_id). >>> turtle.color(\"blue\") >>> turtle.stamp() 11 >>> turtle.fd(50) turtle.clearstamp(stampid) Parameters stampid – an integer, must be return value of previous stamp() call Delete stamp with given stampid. >>> turtle.position() (150.00,-0.00) >>> turtle.color(\"blue\") >>> astamp = turtle.stamp() >>> turtle.fd(50) >>> turtle.position() (200.00,-0.00) >>> turtle.clearstamp(astamp) >>> turtle.position() (200.00,-0.00) turtle.clearstamps(n=None) Parameters n – an integer (or None) Delete all or first/last n of turtle’s stamps. If n is None, delete all stamps, if n > 0 delete first n stamps, else if n < 0 delete last n stamps. >>> for i in range(8): ... turtle.stamp(); turtle.fd(30) 13 14 15 16 17 18 19 20 >>> turtle.clearstamps(2) >>> turtle.clearstamps(-2) >>> turtle.clearstamps() turtle.undo() Undo (repeatedly) the last turtle action(s). Number of available undo actions is determined by the size of the undobuffer. >>> for i in range(4): ... turtle.fd(50); turtle.lt(80) ... >>> for i in range(8): ... turtle.undo() turtle.speed(speed=None) Parameters speed – an integer in the range 0..10 or a speedstring (see below) Set the turtle’s speed to an integer value in the range 0..10. If no argument is given, return current speed. If input is a number greater than 10 or smaller than 0.5, speed is set to 0. Speedstrings are mapped to speedvalues as follows: “fastest”: 0 “fast”: 10 “normal”: 6 “slow”: 3 “slowest”: 1 Speeds from 1 to 10 enforce increasingly faster animation of line drawing and turtle turning. Attention: speed = 0 means that no animation takes place. forward/back makes turtle jump and likewise left/right make the turtle turn instantly. >>> turtle.speed() 3 >>> turtle.speed('normal') >>> turtle.speed() 6 >>> turtle.speed(9) >>> turtle.speed() 9", "score": "0.68220603"}, {"id": "25615", "text": "Function: python.library.turtle#turtle.circle\nSnippet: turtle.circle(radius, extent=None, steps=None) Parameters radius – a number extent – a number (or None) steps – an integer (or None) Draw a circle with given radius. The center is radius units left of the turtle; extent – an angle – determines which part of the circle is drawn. If extent is not given, draw the entire circle. If extent is not a full circle, one endpoint of the arc is the current pen position. Draw the arc in counterclockwise direction if radius is positive, otherwise in clockwise direction. Finally the direction of the turtle is changed by the amount of extent. As the circle is approximated by an inscribed regular polygon, steps determines the number of steps to use. If not given, it will be calculated automatically. May be used to draw regular polygons. >>> turtle.home() >>> turtle.position() (0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(50) >>> turtle.position() (-0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(120, 180) # draw a semicircle >>> turtle.position() (0.00,240.00) >>> turtle.heading() 180.0", "score": "0.6720393"}, {"id": "21829", "text": "Function: python.library.math#math.sin\nSnippet: math.sin(x) Return the sine of x radians.", "score": "0.66438353"}, {"id": "36341", "text": "Function: django.ref.contrib.gis.functions#django.contrib.gis.db.models.functions.BoundingCircle\nSnippet: class BoundingCircle(expression, num_seg=48, **extra)", "score": "0.66270065"}, {"id": "21777", "text": "Function: python.library.math\nSnippet: Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers. math.sqrt(x) Return the square root of x. Trigonometric functions math.acos(x) Return the arc cosine of x, in radians. The result is between 0 and pi. math.asin(x) Return the arc sine of x, in radians. The result is between -pi/2 and pi/2. math.atan(x) Return the arc tangent of x, in radians. The result is between -pi/2 and pi/2. math.atan2(y, x) Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4. math.cos(x) Return the cosine of x radians. math.dist(p, q) Return the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Roughly equivalent to: sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q))) New in version 3.8. math.hypot(*coordinates) Return the Euclidean norm, sqrt(sum(x**2 for x in coordinates)). This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point (x, y), this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, sqrt(x*x + y*y). Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. math.sin(x) Return the sine of x radians. math.tan(x) Return the tangent of x radians. Angular conversion math.degrees(x) Convert angle x from radians to degrees. math.radians(x) Convert angle x from degrees to radians. Hyperbolic functions Hyperbolic functions are analogs of trigonometric functions that are based on hyperbolas instead of circles. math.acosh(x) Return the inverse hyperbolic cosine of x. math.asinh(x) Return the inverse hyperbolic sine of x. math.atanh(x) Return the inverse hyperbolic tangent of x. math.cosh(x) Return the hyperbolic cosine of x. math.sinh(x) Return the hyperbolic sine of x. math.tanh(x) Return the hyperbolic tangent of x. Special functions math.erf(x) Return the error function at x. The erf() function can be used to compute traditional statistical functions such as the cumulative standard normal distribution: def phi(x): 'Cumulative distribution function for the standard normal distribution' return (1.0 + erf(x / sqrt(2.0))) / 2.0 New in version 3.2. math.erfc(x) Return the complementary error function at x. The complementary error function is defined as 1.0 - erf(x). It is used for large values of x where a subtraction from one would cause a loss of significance. New in version 3.2. math.gamma(x) Return the Gamma function at x. New in version 3.2. math.lgamma(x) Return the natural logarithm of the absolute value of the Gamma function at x. New in version 3.2. Constants math.pi The mathematical constant π =", "score": "0.6619633"}]}
{"task_id": "mbpp_140", "code": "def extract_singly(test_list):\r\n  res = []\r\n  temp = set()\r\n  for inner in test_list:\r\n    for ele in inner:\r\n      if not ele in temp:\r\n        temp.add(ele)\r\n        res.append(ele)\r\n  return (res) ", "test_list": ["assert extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 4, 5, 7, 1]", "assert extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)]) == [1, 2, 3, 4, 7, 8]", "assert extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)]) == [7, 8, 9, 10, 11, 12]"], "context": "Write a function to extract elements that occur singly in the given tuple list.", "function_name": "def extract_singly(test_list):", "gold_generation": "res = []\r\n  temp = set()\r\n  for inner in test_list:\r\n    for ele in inner:\r\n      if not ele in temp:\r\n        temp.add(ele)\r\n        res.append(ele)\r\n  return (res)", "ctxs": [{"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6889356"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6830919"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.68229383"}, {"id": "20295", "text": "Function: python.library.functions\nSnippet: aggregates elements from each of the iterables. Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator. Equivalent to: def zip(*iterables): # zip('ABCD', 'xy') --> Ax By sentinel = object() iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using zip(*[iter(s)]*n). This repeats the same iterator n times so that each output tuple has the result of n calls to the iterator. This has the effect of dividing the input into n-length chunks. zip() should only be used with unequal length inputs when you don’t care about trailing, unmatched values from the longer iterables. If those values are important, use itertools.zip_longest() instead. zip() in conjunction with the * operator can be used to unzip a list: >>> x = [1, 2, 3] >>> y = [4, 5, 6] >>> zipped = zip(x, y) >>> list(zipped) [(1, 4), (2, 5), (3, 6)] >>> x2, y2 = zip(*zip(x, y)) >>> x == list(x2) and y == list(y2) True __import__(name, globals=None, locals=None, fromlist=(), level=0) Note This is an advanced function that is not needed in everyday Python programming, unlike importlib.import_module(). This function is invoked by the import statement. It can be replaced (by importing the builtins module and assigning to builtins.__import__) in order to change semantics of the import statement, but doing so is strongly discouraged as it is usually simpler to use import hooks (see PEP 302) to attain the same goals and does not cause issues with code which assumes the default import implementation is in use. Direct use of __import__() is also discouraged in favor of importlib.import_module(). The function imports the module name, potentially using the given globals and locals to determine how to interpret the name in a package context. The fromlist gives the names of objects or submodules that should be imported from the module given by name. The standard implementation does not use its locals argument at all, and uses its globals only to determine the package context of the import statement. level specifies whether to use absolute or relative imports. 0 (the default) means only perform absolute imports. Positive values for level indicate the number of parent directories to search relative to the directory of the module calling __import__() (see PEP 328 for the details). When the name variable is of the form package.module, normally, the top-level package (the name up till the first dot) is returned, not the module named by name. However, when a non-empty fromlist argument is given, the module named by name is returned. For example, the statement import spam results", "score": "0.68183124"}, {"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.6801369"}]}
{"task_id": "mbpp_141", "code": "def pancake_sort(nums):\r\n    arr_len = len(nums)\r\n    while arr_len > 1:\r\n        mi = nums.index(max(nums[0:arr_len]))\r\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\r\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\r\n        arr_len -= 1\r\n    return nums", "test_list": ["assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]", "assert pancake_sort([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]", "assert pancake_sort([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]"], "context": "Write a function to sort a list of elements using pancake sort.", "function_name": "def pancake_sort(nums):", "gold_generation": "arr_len = len(nums)\r\n    while arr_len > 1:\r\n        mi = nums.index(max(nums[0:arr_len]))\r\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\r\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\r\n        arr_len -= 1\r\n    return nums", "ctxs": [{"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.7044579"}, {"id": "23949", "text": "Function: python.library.functions#sorted\nSnippet: sorted(iterable, *, key=None, reverse=False) Return a new sorted list from the items in iterable. Has two optional arguments which must be specified as keyword arguments. key specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. Use functools.cmp_to_key() to convert an old-style cmp function to a key function. The built-in sorted() function is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO.", "score": "0.6924913"}, {"id": "41639", "text": "Function: numpy.reference.generated.numpy.char.chararray.argsort\nSnippet: numpy.char.chararray.argsort method char.chararray.argsort(axis=- 1, kind=None, order=None)[source] Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.68837893"}, {"id": "41764", "text": "Function: numpy.reference.generated.numpy.chararray.argsort\nSnippet: numpy.chararray.argsort method chararray.argsort(axis=- 1, kind=None, order=None)[source] Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.68477994"}, {"id": "42341", "text": "Function: numpy.reference.generated.numpy.ma.sort\nSnippet: numpy.ma.sort ma.sort(a, axis=- 1, kind=None, order=None, endwith=True, fill_value=None)[source] Return a sorted copy of the masked array. Equivalent to creating a copy of the array and applying the MaskedArray sort() method. Refer to MaskedArray.sort for the full documentation See also MaskedArray.sort equivalent method", "score": "0.6834793"}]}
{"task_id": "mbpp_142", "code": "def count_samepair(list1,list2,list3):\r\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\r\n    return result", "test_list": ["assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])==3", "assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==4", "assert count_samepair([1,2,3,4,2,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==5"], "context": "Write a function to count the same pair in three given lists.", "function_name": "def count_samepair(list1,list2,list3):", "gold_generation": "result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\r\n    return result", "ctxs": [{"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.68898946"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6690047"}, {"id": "19648", "text": "Function: python.library.difflib#difflib.SequenceMatcher.get_matching_blocks\nSnippet: get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]", "score": "0.6634128"}, {"id": "18611", "text": "Function: python.library.collections\nSnippet: Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6}) New in version 3.2. The usual dictionary methods are available for Counter objects except for two which work differently for counters. fromkeys(iterable) This class method is not implemented for Counter objects. update([iterable-or-mapping]) Elements are counted from an iterable or added-in from another mapping (or counter). Like dict.update() but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of (key, value) pairs. Common patterns for working with Counter objects: sum(c.values()) # total of all counts c.clear() # reset all counts list(c) # list unique elements set(c) # convert to a set dict(c) # convert to a regular dictionary c.items() # convert to a list of (elem, cnt) pairs Counter(dict(list_of_pairs)) # convert from a list of (elem, cnt) pairs c.most_common()[:-n-1:-1] # n least common elements +c # remove zero and negative counts Several mathematical operations are provided for combining Counter objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. Intersection and union return the minimum and maximum of corresponding counts. Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less. >>> c = Counter(a=3, b=1) >>> d = Counter(a=1, b=2) >>> c + d # add two counters together: c[x] + d[x] Counter({'a': 4, 'b': 3}) >>> c - d # subtract (keeping only positive counts) Counter({'a': 2}) >>> c & d # intersection: min(c[x], d[x]) Counter({'a': 1, 'b': 1}) >>> c | d # union: max(c[x], d[x]) Counter({'a': 3, 'b': 2}) Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter. >>> c = Counter(a=2, b=-4) >>> +c Counter({'a': 2}) >>> -c Counter({'b': 4}) New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations. Note Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values. To help with those use cases, this section documents the minimum range and type restrictions. The Counter class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you could store anything in the value field. The most_common() method requires only that the values be orderable. For in-place operations such as c[key] += 1, the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for update() and subtract() which allow negative and zero", "score": "0.66019326"}, {"id": "19651", "text": "Function: python.library.difflib#difflib.SequenceMatcher.ratio\nSnippet: ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5", "score": "0.6599758"}]}
{"task_id": "mbpp_143", "code": "def find_lists(Input): \r\n\tif isinstance(Input, list): \r\n\t\treturn 1\r\n\telse: \r\n\t\treturn len(Input) ", "test_list": ["assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2", "assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3", "assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1"], "context": "Write a function to find number of lists present in the given tuple.", "function_name": "def find_lists(Input):", "gold_generation": "if isinstance(Input, list): \r\n\t\treturn 1\r\n\telse: \r\n\t\treturn len(Input)", "ctxs": [{"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6946802"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6848848"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.67941004"}, {"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.6769488"}, {"id": "42756", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.as_list\nSnippet: numpy.distutils.misc_util.as_list(seq)[source]", "score": "0.6744015"}]}
{"task_id": "mbpp_144", "code": "def sum_Pairs(arr,n): \r\n    sum = 0\r\n    for i in range(n - 1,-1,-1): \r\n        sum += i*arr[i] - (n-1-i) * arr[i] \r\n    return sum", "test_list": ["assert sum_Pairs([1,8,9,15,16],5) == 74", "assert sum_Pairs([1,2,3,4],4) == 10", "assert sum_Pairs([1,2,3,4,5,7,9,11,14],9) == 188"], "context": "Write a python function to find the sum of absolute differences in all pairs of the given array.", "function_name": "def sum_Pairs(arr,n):", "gold_generation": "sum = 0\r\n    for i in range(n - 1,-1,-1): \r\n        sum += i*arr[i] - (n-1-i) * arr[i] \r\n    return sum", "ctxs": [{"id": "42610", "text": "Function: numpy.reference.generated.numpy.absolute\nSnippet: numpy.absolute numpy.absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'absolute'> Calculate the absolute value element-wise. np.abs is a shorthand for this function. Parameters xarray_like Input array. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns absolutendarray An ndarray containing the absolute value of each element in x. For complex input, a + ib, the absolute value is \\(\\sqrt{ a^2 + b^2 }\\). This is a scalar if x is a scalar. Examples >>> x = np.array([-1.2, 1.2]) >>> np.absolute(x) array([ 1.2, 1.2]) >>> np.absolute(1.2 + 1j) 1.5620499351813308 Plot the function over [-10, 10]: >>> import matplotlib.pyplot as plt >>> x = np.linspace(start=-10, stop=10, num=101) >>> plt.plot(x, np.absolute(x)) >>> plt.show() Plot the function over the complex plane: >>> xx = x + 1j * x[:, np.newaxis] >>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray') >>> plt.show() The abs function can be used as a shorthand for np.absolute on ndarrays. >>> x = np.array([-1.2, 1.2]) >>> abs(x) array([1.2, 1.2])", "score": "0.68171716"}, {"id": "11669", "text": "Function: sklearn.modules.generated.sklearn.metrics.pairwise_distances_chunked#sklearn.metrics.pairwise_distances_chunked\nSnippet: avg_dist >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func) >>> neigh, avg_dist = next(gen) >>> neigh [array([0, 3]), array([1]), array([2]), array([0, 3]), array([4])] >>> avg_dist array([0.039..., 0. , 0. , 0.039..., 0. ]) Where r is defined per sample, we need to make use of start: >>> r = [.2, .4, .4, .3, .1] >>> def reduce_func(D_chunk, start): ... neigh = [np.flatnonzero(d < r[i]) ... for i, d in enumerate(D_chunk, start)] ... return neigh >>> neigh = next(pairwise_distances_chunked(X, reduce_func=reduce_func)) >>> neigh [array([0, 3]), array([0, 1]), array([2]), array([0, 3]), array([4])] Force row-by-row generation by reducing working_memory: >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func, ... working_memory=0) >>> next(gen) [array([0, 3])] >>> next(gen) [array([0, 1])]", "score": "0.6813011"}, {"id": "12719", "text": "Function: sklearn.modules.generated.sklearn.metrics.pairwise_distances_chunked\nSnippet: neigh, avg_dist >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func) >>> neigh, avg_dist = next(gen) >>> neigh [array([0, 3]), array([1]), array([2]), array([0, 3]), array([4])] >>> avg_dist array([0.039..., 0. , 0. , 0.039..., 0. ]) Where r is defined per sample, we need to make use of start: >>> r = [.2, .4, .4, .3, .1] >>> def reduce_func(D_chunk, start): ... neigh = [np.flatnonzero(d < r[i]) ... for i, d in enumerate(D_chunk, start)] ... return neigh >>> neigh = next(pairwise_distances_chunked(X, reduce_func=reduce_func)) >>> neigh [array([0, 3]), array([0, 1]), array([2]), array([0, 3]), array([4])] Force row-by-row generation by reducing working_memory: >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func, ... working_memory=0) >>> next(gen) [array([0, 3])] >>> next(gen) [array([0, 1])]", "score": "0.67841566"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6776409"}, {"id": "19651", "text": "Function: python.library.difflib#difflib.SequenceMatcher.ratio\nSnippet: ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5", "score": "0.67484075"}]}
{"task_id": "mbpp_145", "code": "def max_Abs_Diff(arr,n): \r\n    minEle = arr[0] \r\n    maxEle = arr[0] \r\n    for i in range(1, n): \r\n        minEle = min(minEle,arr[i]) \r\n        maxEle = max(maxEle,arr[i]) \r\n    return (maxEle - minEle) ", "test_list": ["assert max_Abs_Diff((2,1,5,3),4) == 4", "assert max_Abs_Diff((9,3,2,5,1),5) == 8", "assert max_Abs_Diff((3,2,1),3) == 2"], "context": "Write a python function to find the maximum difference between any two elements in a given array.", "function_name": "def max_Abs_Diff(arr,n):", "gold_generation": "minEle = arr[0] \r\n    maxEle = arr[0] \r\n    for i in range(1, n): \r\n        minEle = min(minEle,arr[i]) \r\n        maxEle = max(maxEle,arr[i]) \r\n    return (maxEle - minEle)", "ctxs": [{"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.707031"}, {"id": "43968", "text": "Function: numpy.reference.generated.numpy.testing.assert_array_max_ulp\nSnippet: numpy.testing.assert_array_max_ulp testing.assert_array_max_ulp(a, b, maxulp=1, dtype=None)[source] Check that all items of arrays differ in at most N Units in the Last Place. Parameters a, barray_like Input arrays to be compared. maxulpint, optional The maximum number of units in the last place that elements of a and b can differ. Default is 1. dtypedtype, optional Data-type to convert a and b to if given. Default is None. Returns retndarray Array containing number of representable floating point numbers between items in a and b. Raises AssertionError If one or more elements differ by more than maxulp. See also assert_array_almost_equal_nulp Compare two arrays relatively to their spacing. Notes For computing the ULP difference, this API does not differentiate between various representations of NAN (ULP difference between 0x7fc00000 and 0xffc00000 is zero). Examples >>> a = np.linspace(0., 1., 100) >>> res = np.testing.assert_array_max_ulp(a, np.arcsin(np.sin(a)))", "score": "0.70502406"}, {"id": "19490", "text": "Function: python.library.decimal#decimal.Context.max\nSnippet: max(x, y) Compares two values numerically and returns the maximum.", "score": "0.684296"}, {"id": "43857", "text": "Function: numpy.reference.generated.numpy.recarray.max\nSnippet: numpy.recarray.max method recarray.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the maximum along a given axis. Refer to numpy.amax for full documentation. See also numpy.amax equivalent function", "score": "0.67507577"}, {"id": "43965", "text": "Function: numpy.reference.generated.numpy.testing.assert_array_almost_equal_nulp\nSnippet: numpy.testing.assert_array_almost_equal_nulp testing.assert_array_almost_equal_nulp(x, y, nulp=1)[source] Compare two arrays relatively to their spacing. This is a relatively robust method to compare two arrays whose amplitude is variable. Parameters x, yarray_like Input arrays. nulpint, optional The maximum number of unit in the last place for tolerance (see Notes). Default is 1. Returns None Raises AssertionError If the spacing between x and y for one or more elements is larger than nulp. See also assert_array_max_ulp Check that all items of arrays differ in at most N Units in the Last Place. spacing Return the distance between x and the nearest adjacent number. Notes An assertion is raised if the following condition is not met: abs(x - y) <= nulps * spacing(maximum(abs(x), abs(y))) Examples >>> x = np.array([1., 1e-10, 1e-20]) >>> eps = np.finfo(x.dtype).eps >>> np.testing.assert_array_almost_equal_nulp(x, x*eps/2 + x) >>> np.testing.assert_array_almost_equal_nulp(x, x*eps + x) Traceback (most recent call last): ... AssertionError: X and Y are not equal to 1 ULP (max is 2)", "score": "0.6721565"}]}
{"task_id": "mbpp_146", "code": "def ascii_value_string(str1):\r\n  for i in range(len(str1)):\r\n   return ord(str1[i])", "test_list": ["assert ascii_value_string(\"python\")==112", "assert ascii_value_string(\"Program\")==80", "assert ascii_value_string(\"Language\")==76"], "context": "Write a function to find the ascii value of total characters in a string.", "function_name": "def ascii_value_string(str1):", "gold_generation": "for i in range(len(str1)):\r\n   return ord(str1[i])", "ctxs": [{"id": "24414", "text": "Function: python.library.string#string.hexdigits\nSnippet: string.hexdigits The string '0123456789abcdefABCDEF'.", "score": "0.70086855"}, {"id": "21151", "text": "Function: python.library.io#io.TextIOBase.write\nSnippet: write(s) Write the string s to the stream and return the number of characters written.", "score": "0.6998263"}, {"id": "41757", "text": "Function: numpy.reference.generated.numpy.char.str_len\nSnippet: numpy.char.str_len char.str_len(a)[source] Return len(a) element-wise. Parameters aarray_like of str or unicode Returns outndarray Output array of integers See also builtins.len", "score": "0.6954113"}, {"id": "24401", "text": "Function: python.library.string#string.ascii_uppercase\nSnippet: string.ascii_uppercase The uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. This value is not locale-dependent and will not change.", "score": "0.69474375"}, {"id": "17650", "text": "Function: python.library.functions#ascii\nSnippet: ascii(object) As repr(), return a string containing a printable representation of an object, but escape the non-ASCII characters in the string returned by repr() using \\x, \\u or \\U escapes. This generates a string similar to that returned by repr() in Python 2.", "score": "0.6941481"}]}
{"task_id": "mbpp_147", "code": "def max_path_sum(tri, m, n): \r\n\tfor i in range(m-1, -1, -1): \r\n\t\tfor j in range(i+1): \r\n\t\t\tif (tri[i+1][j] > tri[i+1][j+1]): \r\n\t\t\t\ttri[i][j] += tri[i+1][j] \r\n\t\t\telse: \r\n\t\t\t\ttri[i][j] += tri[i+1][j+1] \r\n\treturn tri[0][0]", "test_list": ["assert max_path_sum([[1, 0, 0], [4, 8, 0], [1, 5, 3]], 2, 2) == 14", "assert max_path_sum([[13, 0, 0], [7, 4, 0], [2, 4, 6]], 2, 2) == 24 ", "assert max_path_sum([[2, 0, 0], [11, 18, 0], [21, 25, 33]], 2, 2) == 53"], "context": "Write a function to find the maximum total path sum in the given triangle.", "function_name": "def max_path_sum(tri, m, n):", "gold_generation": "for i in range(m-1, -1, -1): \r\n\t\tfor j in range(i+1): \r\n\t\t\tif (tri[i+1][j] > tri[i+1][j+1]): \r\n\t\t\t\ttri[i][j] += tri[i+1][j] \r\n\t\t\telse: \r\n\t\t\t\ttri[i][j] += tri[i+1][j+1] \r\n\treturn tri[0][0]", "ctxs": [{"id": "42806", "text": "Function: numpy.reference.generated.numpy.einsum\nSnippet: shown returns the optimal path in the majority of cases. In some cases ‘optimal’ will return the superlative path through a more expensive, exhaustive search. For iterative calculations it may be advisable to calculate the optimal path once and reuse that path by supplying it as an argument. An example is given below. See numpy.einsum_path for more details. Examples >>> a = np.arange(25).reshape(5,5) >>> b = np.arange(5) >>> c = np.arange(6).reshape(2,3) Trace of a matrix: >>> np.einsum('ii', a) 60 >>> np.einsum(a, [0,0]) 60 >>> np.trace(a) 60 Extract the diagonal (requires explicit form): >>> np.einsum('ii->i', a) array([ 0, 6, 12, 18, 24]) >>> np.einsum(a, [0,0], [0]) array([ 0, 6, 12, 18, 24]) >>> np.diag(a) array([ 0, 6, 12, 18, 24]) Sum over an axis (requires explicit form): >>> np.einsum('ij->i', a) array([ 10, 35, 60, 85, 110]) >>> np.einsum(a, [0,1], [0]) array([ 10, 35, 60, 85, 110]) >>> np.sum(a, axis=1) array([ 10, 35, 60, 85, 110]) For higher dimensional arrays summing a single axis can be done with ellipsis: >>> np.einsum('...j->...', a) array([ 10, 35, 60, 85, 110]) >>> np.einsum(a, [Ellipsis,1], [Ellipsis]) array([ 10, 35, 60, 85, 110]) Compute a matrix transpose, or reorder any number of axes: >>> np.einsum('ji', c) array([[0, 3], [1, 4], [2, 5]]) >>> np.einsum('ij->ji', c) array([[0, 3], [1, 4], [2, 5]]) >>> np.einsum(c, [1,0]) array([[0, 3], [1, 4], [2, 5]]) >>> np.transpose(c) array([[0, 3], [1, 4], [2, 5]]) Vector inner products: >>> np.einsum('i,i', b, b) 30 >>> np.einsum(b, [0], b, [0]) 30 >>> np.inner(b,b) 30 Matrix vector multiplication: >>> np.einsum('ij,j', a, b) array([ 30, 80, 130, 180, 230]) >>> np.einsum(a, [0,1], b, [1]) array([ 30, 80, 130, 180, 230]) >>> np.dot(a, b) array([ 30, 80, 130, 180, 230]) >>> np.einsum('...j,j', a, b) array([ 30, 80, 130, 180, 230]) Broadcasting and scalar multiplication: >>> np.einsum('..., ...', 3, c) array([[ 0, 3, 6], [ 9, 12, 15]]) >>> np.einsum(',ij', 3, c) array([[ 0, 3, 6], [ 9, 12, 15]]) >>> np.einsum(3, [Ellipsis], c, [Ellipsis]) array([[ 0, 3, 6], [ 9, 12, 15]]) >>> np.multiply(3, c) array([[ 0, 3, 6], [ 9, 12, 15]]) Vector outer product: >>> np.einsum('i,j', np.arange(2)+1, b) array([[0, 1, 2, 3, 4], [0, 2, 4, 6, 8]]) >>> np.einsum(np.arange(2)+1, [0], b, [1]) array([[0, 1, 2, 3, 4], [0, 2, 4, 6, 8]]) >>> np.outer(np.arange(2)+1, b) array([[0, 1, 2, 3, 4], [0, 2, 4, 6, 8]]) Tensor contraction: >>> a = np.arange(60.).reshape(3,4,5) >>> b = np.arange(24.).reshape(4,3,2) >>> np.einsum('ijk,jil->kl', a, b) array([[4400., 4730.], [4532., 4874.], [4664., 5018.], [4796., 5162.], [4928., 5306.]]) >>> np.einsum(a, [0,1,2], b, [1,0,3], [2,3]) array([[4400., 4730.], [4532., 4874.], [4664., 5018.], [4796., 5162.], [4928., 5306.]]) >>> np.tensordot(a,b, axes=([1,0],[0,1])) array([[4400., 4730.], [4532., 4874.], [4664., 5018.], [4796., 5162.], [4928., 5306.]]) Writeable returned arrays (since version 1.10.0): >>> a = np.zeros((3, 3)) >>> np.einsum('ii->i', a)[:] = 1 >>> a array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) Example of ellipsis use: >>> a = np.arange(6).reshape((3,2)) >>> b = np.arange(12).reshape((4,3)) >>> np.einsum('ki,jk->ij', a, b) array([[10, 28, 46, 64], [13, 40, 67, 94]]) >>> np.einsum('ki,...k->i...', a, b) array([[10, 28, 46,", "score": "0.67808926"}, {"id": "42808", "text": "Function: numpy.reference.generated.numpy.einsum_path\nSnippet: numpy.einsum_path numpy.einsum_path(subscripts, *operands, optimize='greedy')[source] Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays. Parameters subscriptsstr Specifies the subscripts for summation. *operandslist of array_like These are the arrays for the operation. optimize{bool, list, tuple, ‘greedy’, ‘optimal’} Choose the type of path. If a tuple is provided, the second argument is assumed to be the maximum intermediate size created. If only a single argument is provided the largest input or output array size is used as a maximum intermediate size. if a list is given that starts with einsum_path, uses this as the contraction path if False no optimization is taken if True defaults to the ‘greedy’ algorithm ‘optimal’ An algorithm that combinatorially explores all possible ways of contracting the listed tensors and choosest the least costly path. Scales exponentially with the number of terms in the contraction. ‘greedy’ An algorithm that chooses the best pair contraction at each step. Effectively, this algorithm searches the largest inner, Hadamard, and then outer products at each step. Scales cubically with the number of terms in the contraction. Equivalent to the ‘optimal’ path for most contractions. Default is ‘greedy’. Returns pathlist of tuples A list representation of the einsum path. string_reprstr A printable representation of the einsum path. See also einsum, linalg.multi_dot Notes The resulting path indicates which terms of the input contraction should be contracted first, the result of this contraction is then appended to the end of the contraction list. This list can then be iterated over until all intermediate contractions are complete. Examples We can begin with a chain dot example. In this case, it is optimal to contract the b and c tensors first as represented by the first element of the path (1, 2). The resulting tensor is added to the end of the contraction and the remaining contraction (0, 1) is then completed. >>> np.random.seed(123) >>> a = np.random.rand(2, 2) >>> b = np.random.rand(2, 5) >>> c = np.random.rand(5, 2) >>> path_info = np.einsum_path('ij,jk,kl->il', a, b, c, optimize='greedy') >>> print(path_info[0]) ['einsum_path', (1, 2), (0, 1)] >>> print(path_info[1]) Complete contraction: ij,jk,kl->il # may vary Naive scaling: 4 Optimized scaling: 3 Naive FLOP count: 1.600e+02 Optimized FLOP count: 5.600e+01 Theoretical speedup: 2.857 Largest intermediate: 4.000e+00 elements ------------------------------------------------------------------------- scaling current remaining ------------------------------------------------------------------------- 3 kl,jk->jl ij,jl->il 3 jl,ij->il il->il A more complex index transformation example. >>> I = np.random.rand(10, 10, 10, 10) >>> C = np.random.rand(10, 10) >>> path_info = np.einsum_path('ea,fb,abcd,gc,hd->efgh', C, C, I, C, C, ... optimize='greedy') >>> print(path_info[0]) ['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)] >>> print(path_info[1]) Complete contraction: ea,fb,abcd,gc,hd->efgh # may vary Naive scaling: 8 Optimized scaling: 5 Naive FLOP count: 8.000e+08 Optimized FLOP count: 8.000e+05 Theoretical speedup: 1000.000 Largest intermediate: 1.000e+04 elements -------------------------------------------------------------------------- scaling current remaining -------------------------------------------------------------------------- 5 abcd,ea->bcde fb,gc,hd,bcde->efgh 5 bcde,fb->cdef gc,hd,cdef->efgh 5 cdef,gc->defg hd,defg->efgh 5 defg,hd->efgh efgh->efgh", "score": "0.6758143"}, {"id": "16912", "text": "Function: skimage.api.skimage.graph#skimage.graph.MCP\nSnippet: class skimage.graph.MCP(costs, offsets=None, fully_connected=True, sampling=None) Bases: object A class for finding the minimum cost path through a given n-d costs array. Given an n-d costs array, this class can be used to find the minimum-cost path through that array from any set of points to any other set of points. Basic usage is to initialize the class and call find_costs() with a one or more starting indices (and an optional list of end indices). After that, call traceback() one or more times to find the path from any given end-position to the closest starting index. New paths through the same costs array can be found by calling find_costs() repeatedly. The cost of a path is calculated simply as the sum of the values of the costs array at each point on the path. The class MCP_Geometric, on the other hand, accounts for the fact that diagonal vs. axial moves are of different lengths, and weights the path cost accordingly. Array elements with infinite or negative costs will simply be ignored, as will paths whose cumulative cost overflows to infinite. Parameters costsndarray offsetsiterable, optional A list of offset tuples: each offset specifies a valid move from a given n-d position. If not provided, offsets corresponding to a singly- or fully-connected n-d neighborhood will be constructed with make_offsets(), using the fully_connected parameter value. fully_connectedbool, optional If no offsets are provided, this determines the connectivity of the generated neighborhood. If true, the path may go along diagonals between elements of the costs array; otherwise only axial moves are permitted. samplingtuple, optional For each dimension, specifies the distance between two cells/voxels. If not given or None, the distance is assumed unit. Attributes offsetsndarray Equivalent to the offsets provided to the constructor, or if none were so provided, the offsets created for the requested n-d neighborhood. These are useful for interpreting the traceback array returned by the find_costs() method. __init__(costs, offsets=None, fully_connected=True, sampling=None) See class documentation. find_costs() Find the minimum-cost path from the given starting points. This method finds the minimum-cost path to the specified ending indices from any one of the specified starting indices. If no end positions are given, then the minimum-cost path to every position in the costs array will be found. Parameters startsiterable A list of n-d starting indices (where n is the dimension of the costs array). The minimum cost path to the closest/cheapest starting point will be found. endsiterable, optional A list of n-d ending indices. find_all_endsbool, optional If ‘True’ (default), the minimum-cost-path to every specified end-position will be found; otherwise the algorithm will stop when a a path is found to any end-position. (If no ends were specified, then this parameter has no effect.) Returns cumulative_costsndarray Same shape as the costs array; this array records the minimum cost path from the nearest/cheapest starting index to each index considered. (If ends were specified, not all elements in the array will necessarily be considered: positions not evaluated will have a cumulative cost of inf. If find_all_ends is ‘False’, only one", "score": "0.65473986"}, {"id": "11348", "text": "Function: sklearn.modules.generated.sklearn.linear_model.multitasklasso#sklearn.linear_model.MultiTaskLasso.path\nSnippet: static path(*args, **kwargs) [source] Compute elastic net path with coordinate descent. The elastic net optimization function varies for mono and multi-outputs. For mono-output tasks it is: 1 / (2 * n_samples) * ||y - Xw||^2_2 + alpha * l1_ratio * ||w||_1 + 0.5 * alpha * (1 - l1_ratio) * ||w||^2_2 For multi-output tasks it is: (1 / (2 * n_samples)) * ||Y - XW||^Fro_2 + alpha * l1_ratio * ||W||_21 + 0.5 * alpha * (1 - l1_ratio) * ||W||_Fro^2 Where: ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2} i.e. the sum of norm of each row. Read more in the User Guide. Parameters X{array-like, sparse matrix} of shape (n_samples, n_features) Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If y is mono-output then X can be sparse. y{array-like, sparse matrix} of shape (n_samples,) or (n_samples, n_outputs) Target values. l1_ratiofloat, default=0.5 Number between 0 and 1 passed to elastic net (scaling between l1 and l2 penalties). l1_ratio=1 corresponds to the Lasso. epsfloat, default=1e-3 Length of the path. eps=1e-3 means that alpha_min / alpha_max = 1e-3. n_alphasint, default=100 Number of alphas along the regularization path. alphasndarray, default=None List of alphas where to compute the models. If None alphas are set automatically. precompute‘auto’, bool or array-like of shape (n_features, n_features), default=’auto’ Whether to use a precomputed Gram matrix to speed up calculations. If set to 'auto' let us decide. The Gram matrix can also be passed as argument. Xyarray-like of shape (n_features,) or (n_features, n_outputs), default=None Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed. copy_Xbool, default=True If True, X will be copied; else, it may be overwritten. coef_initndarray of shape (n_features, ), default=None The initial values of the coefficients. verbosebool or int, default=False Amount of verbosity. return_n_iterbool, default=False Whether to return the number of iterations or not. positivebool, default=False If set to True, forces coefficients to be positive. (Only allowed when y.ndim == 1). check_inputbool, default=True If set to False, the input validation checks are skipped (including the Gram matrix when provided). It is assumed that they are handled by the caller. **paramskwargs Keyword arguments passed to the coordinate descent solver. Returns alphasndarray of shape (n_alphas,) The alphas along the path where models are computed. coefsndarray of shape (n_features, n_alphas) or (n_outputs, n_features, n_alphas) Coefficients along the path. dual_gapsndarray of shape (n_alphas,) The dual gaps at the end of the optimization for each alpha. n_iterslist of int The number of iterations taken by the coordinate descent optimizer to reach the specified tolerance for each alpha. (Is returned when return_n_iter is set to True). See also MultiTaskElasticNet MultiTaskElasticNetCV ElasticNet ElasticNetCV Notes For an example, see examples/linear_model/plot_lasso_coordinate_descent_path.py.", "score": "0.6501657"}, {"id": "11363", "text": "Function: sklearn.modules.generated.sklearn.linear_model.multitasklassocv#sklearn.linear_model.MultiTaskLassoCV.path\nSnippet: static path(*args, **kwargs) [source] Compute Lasso path with coordinate descent The Lasso optimization function varies for mono and multi-outputs. For mono-output tasks it is: (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1 For multi-output tasks it is: (1 / (2 * n_samples)) * ||Y - XW||^2_Fro + alpha * ||W||_21 Where: ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2} i.e. the sum of norm of each row. Read more in the User Guide. Parameters X{array-like, sparse matrix} of shape (n_samples, n_features) Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If y is mono-output then X can be sparse. y{array-like, sparse matrix} of shape (n_samples,) or (n_samples, n_outputs) Target values epsfloat, default=1e-3 Length of the path. eps=1e-3 means that alpha_min / alpha_max = 1e-3 n_alphasint, default=100 Number of alphas along the regularization path alphasndarray, default=None List of alphas where to compute the models. If None alphas are set automatically precompute‘auto’, bool or array-like of shape (n_features, n_features), default=’auto’ Whether to use a precomputed Gram matrix to speed up calculations. If set to 'auto' let us decide. The Gram matrix can also be passed as argument. Xyarray-like of shape (n_features,) or (n_features, n_outputs), default=None Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed. copy_Xbool, default=True If True, X will be copied; else, it may be overwritten. coef_initndarray of shape (n_features, ), default=None The initial values of the coefficients. verbosebool or int, default=False Amount of verbosity. return_n_iterbool, default=False whether to return the number of iterations or not. positivebool, default=False If set to True, forces coefficients to be positive. (Only allowed when y.ndim == 1). **paramskwargs keyword arguments passed to the coordinate descent solver. Returns alphasndarray of shape (n_alphas,) The alphas along the path where models are computed. coefsndarray of shape (n_features, n_alphas) or (n_outputs, n_features, n_alphas) Coefficients along the path. dual_gapsndarray of shape (n_alphas,) The dual gaps at the end of the optimization for each alpha. n_iterslist of int The number of iterations taken by the coordinate descent optimizer to reach the specified tolerance for each alpha. See also lars_path Lasso LassoLars LassoCV LassoLarsCV sklearn.decomposition.sparse_encode Notes For an example, see examples/linear_model/plot_lasso_coordinate_descent_path.py. To avoid unnecessary memory duplication the X argument of the fit method should be directly passed as a Fortran-contiguous numpy array. Note that in certain cases, the Lars solver may be significantly faster to implement this functionality. In particular, linear interpolation can be used to retrieve model coefficients between the values output by lars_path Examples Comparing lasso_path and lars_path with interpolation: >>> X = np.array([[1, 2, 3.1], [2.3, 5.4, 4.3]]).T >>> y = np.array([1, 2, 3.1]) >>> # Use lasso_path to compute a coefficient path >>> _, coef_path, _ = lasso_path(X, y, alphas=[5., 1., .5]) >>> print(coef_path) [[0. 0. 0.46874778] [0.2159048 0.4425765 0.23689075]] >>> # Now use lars_path and 1D linear interpolation to compute the >>> # same path >>> from sklearn.linear_model import lars_path >>> alphas, active, coef_path_lars = lars_path(X, y, method='lasso') >>> from scipy import interpolate", "score": "0.64804065"}]}
{"task_id": "mbpp_148", "code": "def sum_digits_single(x) : \r\n    ans = 0\r\n    while x : \r\n        ans += x % 10\r\n        x //= 10  \r\n    return ans \r\ndef closest(x) : \r\n    ans = 0\r\n    while (ans * 10 + 9 <= x) : \r\n        ans = ans * 10 + 9  \r\n    return ans   \r\ndef sum_digits_twoparts(N) : \r\n    A = closest(N)  \r\n    return sum_digits_single(A) + sum_digits_single(N - A) ", "test_list": ["assert sum_digits_twoparts(35)==17", "assert sum_digits_twoparts(7)==7", "assert sum_digits_twoparts(100)==19"], "context": "Write a function to divide a number into two parts such that the sum of digits is maximum.", "function_name": "def sum_digits_single(x) :", "gold_generation": "ans = 0\r\n    while x : \r\n        ans += x % 10\r\n        x //= 10  \r\n    return ans \r\ndef closest(x) : \r\n    ans = 0\r\n    while (ans * 10 + 9 <= x) : \r\n        ans = ans * 10 + 9  \r\n    return ans   \r\ndef sum_digits_twoparts(N) : \r\n    A = closest(N)  \r\n    return sum_digits_single(A) + sum_digits_single(N - A)", "ctxs": [{"id": "19587", "text": "Function: python.library.decimal#decimal.MAX_PREC\nSnippet: decimal.MAX_PREC", "score": "0.65287864"}, {"id": "42840", "text": "Function: numpy.reference.generated.numpy.floor_divide\nSnippet: numpy.floor_divide numpy.floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'floor_divide'> Return the largest integer smaller or equal to the division of the inputs. It is equivalent to the Python // operator and pairs with the Python % (remainder), function so that a = a % b + b * (a // b) up to roundoff. Parameters x1array_like Numerator. x2array_like Denominator. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray y = floor(x1/x2) This is a scalar if both x1 and x2 are scalars. See also remainder Remainder complementary to floor_divide. divmod Simultaneous floor division and remainder. divide Standard division. floor Round a number to the nearest integer toward minus infinity. ceil Round a number to the nearest integer toward infinity. Examples >>> np.floor_divide(7,3) 2 >>> np.floor_divide([1., 2., 3., 4.], 2.5) array([ 0., 0., 1., 1.]) The // operator can be used as a shorthand for np.floor_divide on ndarrays. >>> x1 = np.array([1., 2., 3., 4.]) >>> x1 // 2.5 array([0., 0., 1., 1.])", "score": "0.65235764"}, {"id": "19490", "text": "Function: python.library.decimal#decimal.Context.max\nSnippet: max(x, y) Compares two values numerically and returns the maximum.", "score": "0.6423368"}, {"id": "19448", "text": "Function: python.library.decimal#decimal.Context\nSnippet: operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x - y * n, where n is the integer nearest the exact value of x / y (if the result is 0 then its sign will be the sign of x). rotate(x, y) Returns a rotated copy of x, y times. same_quantum(x, y) Returns True if the two operands have the same exponent. scaleb(x, y) Returns the first operand after adding the second value its exp. shift(x, y) Returns a shifted copy of x, y times. sqrt(x) Square root of a non-negative number to context precision. subtract(x, y) Return the difference between x and y. to_eng_string(x) Convert to a string, using engineering", "score": "0.6377406"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.63405544"}]}
{"task_id": "mbpp_149", "code": "def longest_subseq_with_diff_one(arr, n): \r\n\tdp = [1 for i in range(n)] \r\n\tfor i in range(n): \r\n\t\tfor j in range(i): \r\n\t\t\tif ((arr[i] == arr[j]+1) or (arr[i] == arr[j]-1)): \r\n\t\t\t\tdp[i] = max(dp[i], dp[j]+1) \r\n\tresult = 1\r\n\tfor i in range(n): \r\n\t\tif (result < dp[i]): \r\n\t\t\tresult = dp[i] \r\n\treturn result", "test_list": ["assert longest_subseq_with_diff_one([1, 2, 3, 4, 5, 3, 2], 7) == 6", "assert longest_subseq_with_diff_one([10, 9, 4, 5, 4, 8, 6], 7) == 3", "assert longest_subseq_with_diff_one([1, 2, 3, 2, 3, 7, 2, 1], 8) == 7"], "context": "Write a function to find the longest subsequence such that the difference between adjacents is one for the given array.", "function_name": "def longest_subseq_with_diff_one(arr, n):", "gold_generation": "dp = [1 for i in range(n)] \r\n\tfor i in range(n): \r\n\t\tfor j in range(i): \r\n\t\t\tif ((arr[i] == arr[j]+1) or (arr[i] == arr[j]-1)): \r\n\t\t\t\tdp[i] = max(dp[i], dp[j]+1) \r\n\tresult = 1\r\n\tfor i in range(n): \r\n\t\tif (result < dp[i]): \r\n\t\t\tresult = dp[i] \r\n\treturn result", "ctxs": [{"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.7203241"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.7114957"}, {"id": "19646", "text": "Function: python.library.difflib#difflib.SequenceMatcher.find_longest_match\nSnippet: find_longest_match(alo=0, ahi=None, blo=0, bhi=None) Find longest matching block in a[alo:ahi] and b[blo:bhi]. If isjunk was omitted or None, find_longest_match() returns (i, j, k) such that a[i:i+k] is equal to b[j:j+k], where alo <= i <= i+k <= ahi and blo <= j <= j+k <= bhi. For all (i', j', k') meeting those conditions, the additional conditions k >= k', i <= i', and if i == i', j <= j' are also met. In other words, of all maximal matching blocks, return one that starts earliest in a, and of all those maximal matching blocks that start earliest in a, return the one that starts earliest in b. >>> s = SequenceMatcher(None, \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=0, b=4, size=5) If isjunk was provided, first the longest matching block is determined as above, but with the additional restriction that no junk element appears in the block. Then that block is extended as far as possible by matching (only) junk elements on both sides. So the resulting block never matches on junk except as identical junk happens to be adjacent to an interesting match. Here’s the same example as before, but considering blanks to be junk. That prevents ' abcd' from matching the ' abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments.", "score": "0.710761"}, {"id": "19648", "text": "Function: python.library.difflib#difflib.SequenceMatcher.get_matching_blocks\nSnippet: get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]", "score": "0.6951829"}, {"id": "18285", "text": "Function: python.library.stdtypes#bytearray.rfind\nSnippet: bytes.rfind(sub[, start[, end]]) bytearray.rfind(sub[, start[, end]]) Return the highest index in the sequence where the subsequence sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.6851798"}]}
{"task_id": "mbpp_150", "code": "def does_Contain_B(a,b,c): \r\n    if (a == b): \r\n        return True\r\n    if ((b - a) * c > 0 and (b - a) % c == 0): \r\n        return True\r\n    return False", "test_list": ["assert does_Contain_B(1,7,3) == True", "assert does_Contain_B(1,-3,5) == False", "assert does_Contain_B(3,2,5) == False"], "context": "Write a python function to find whether the given number is present in the infinite sequence or not.", "function_name": "def does_Contain_B(a,b,c):", "gold_generation": "if (a == b): \r\n        return True\r\n    if ((b - a) * c > 0 and (b - a) % c == 0): \r\n        return True\r\n    return False", "ctxs": [{"id": "19475", "text": "Function: python.library.decimal#decimal.Context.is_infinite\nSnippet: is_infinite(x) Returns True if x is infinite; otherwise returns False.", "score": "0.72681135"}, {"id": "42785", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.is_sequence\nSnippet: numpy.distutils.misc_util.is_sequence(seq)[source]", "score": "0.7231238"}, {"id": "19539", "text": "Function: python.library.decimal#decimal.Decimal.is_infinite\nSnippet: is_infinite() Return True if the argument is either positive or negative infinity and False otherwise.", "score": "0.7222494"}, {"id": "21810", "text": "Function: python.library.math#math.isinf\nSnippet: math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise.", "score": "0.7222216"}, {"id": "21809", "text": "Function: python.library.math#math.isfinite\nSnippet: math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2.", "score": "0.714526"}]}
{"task_id": "mbpp_151", "code": "def gcd(p,q):\r\n    while q != 0:\r\n        p, q = q,p%q\r\n    return p\r\ndef is_coprime(x,y):\r\n    return gcd(x,y) == 1", "test_list": ["assert is_coprime(17,13) == True", "assert is_coprime(15,21) == False", "assert is_coprime(25,45) == False"], "context": "Write a python function to check whether the given number is co-prime or not.", "function_name": "def gcd(p,q):", "gold_generation": "while q != 0:\r\n        p, q = q,p%q\r\n    return p\r\ndef is_coprime(x,y):\r\n    return gcd(x,y) == 1", "ctxs": [{"id": "21810", "text": "Function: python.library.math#math.isinf\nSnippet: math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise.", "score": "0.65983385"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.65803456"}, {"id": "21811", "text": "Function: python.library.math#math.isnan\nSnippet: math.isnan(x) Return True if x is a NaN (not a number), and False otherwise.", "score": "0.6569221"}, {"id": "14026", "text": "Function: pandas.reference.api.pandas.api.types.is_number\nSnippet: pandas.api.types.is_number pandas.api.types.is_number(obj)[source] Check if the object is a number. Returns True when the object is a number, and False if is not. Parameters obj:any type The object to check if is a number. Returns is_number:bool Whether obj is a number or not. See also api.types.is_integer Checks a subgroup of numbers. Examples >>> from pandas.api.types import is_number >>> is_number(1) True >>> is_number(7.15) True Booleans are valid because they are int subclass. >>> is_number(False) True >>> is_number(\"foo\") False >>> is_number(\"5\") False", "score": "0.64370203"}, {"id": "19474", "text": "Function: python.library.decimal#decimal.Context.is_finite\nSnippet: is_finite(x) Returns True if x is finite; otherwise returns False.", "score": "0.64292145"}]}
{"task_id": "mbpp_152", "code": "def merge(a,b):\r\n    c = []\r\n    while len(a) != 0 and len(b) != 0:\r\n        if a[0] < b[0]:\r\n            c.append(a[0])\r\n            a.remove(a[0])\r\n        else:\r\n            c.append(b[0])\r\n            b.remove(b[0])\r\n    if len(a) == 0:\r\n        c += b\r\n    else:\r\n        c += a\r\n    return c\r\ndef merge_sort(x):\r\n    if len(x) == 0 or len(x) == 1:\r\n        return x\r\n    else:\r\n        middle = len(x)//2\r\n        a = merge_sort(x[:middle])\r\n        b = merge_sort(x[middle:])\r\n        return merge(a,b)\r\n", "test_list": ["assert merge_sort([3, 4, 2, 6, 5, 7, 1, 9]) == [1, 2, 3, 4, 5, 6, 7, 9]", "assert merge_sort([7, 25, 45, 78, 11, 33, 19]) == [7, 11, 19, 25, 33, 45, 78]", "assert merge_sort([3, 1, 4, 9, 8]) == [1, 3, 4, 8, 9]"], "context": "Write a function to sort the given array by using merge sort.", "function_name": "def merge(a,b):", "gold_generation": "c = []\r\n    while len(a) != 0 and len(b) != 0:\r\n        if a[0] < b[0]:\r\n            c.append(a[0])\r\n            a.remove(a[0])\r\n        else:\r\n            c.append(b[0])\r\n            b.remove(b[0])\r\n    if len(a) == 0:\r\n        c += b\r\n    else:\r\n        c += a\r\n    return c\r\ndef merge_sort(x):\r\n    if len(x) == 0 or len(x) == 1:\r\n        return x\r\n    else:\r\n        middle = len(x)//2\r\n        a = merge_sort(x[:middle])\r\n        b = merge_sort(x[middle:])\r\n        return merge(a,b)", "ctxs": [{"id": "41696", "text": "Function: numpy.reference.generated.numpy.char.chararray.sort\nSnippet: numpy.char.chararray.sort method char.chararray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.6974088"}, {"id": "43832", "text": "Function: numpy.reference.generated.numpy.recarray.argsort\nSnippet: numpy.recarray.argsort method recarray.argsort(axis=- 1, kind=None, order=None) Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.6943863"}, {"id": "42341", "text": "Function: numpy.reference.generated.numpy.ma.sort\nSnippet: numpy.ma.sort ma.sort(a, axis=- 1, kind=None, order=None, endwith=True, fill_value=None)[source] Return a sorted copy of the masked array. Equivalent to creating a copy of the array and applying the MaskedArray sort() method. Refer to MaskedArray.sort for the full documentation See also MaskedArray.sort equivalent method", "score": "0.69192475"}, {"id": "43877", "text": "Function: numpy.reference.generated.numpy.recarray.sort\nSnippet: numpy.recarray.sort method recarray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.6911241"}, {"id": "43195", "text": "Function: numpy.reference.generated.numpy.sort\nSnippet: numpy.sort numpy.sort(a, axis=- 1, kind=None, order=None)[source] Return a sorted copy of an array. Parameters aarray_like Array to be sorted. axisint or None, optional Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort or radix sort under the covers and, in general, the actual implementation will vary with data type. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0.: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. Returns sorted_arrayndarray Array of the same type and shape as a. See also ndarray.sort Method to sort an array in-place. argsort Indirect sort. lexsort Indirect stable sort on multiple keys. searchsorted Find elements in a sorted array. partition Partial sort. Notes The various sorting algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The four algorithms implemented in NumPy have the following properties: kind speed worst case work space stable ‘quicksort’ 1 O(n^2) 0 no ‘heapsort’ 3 O(n*log(n)) 0 no ‘mergesort’ 2 O(n*log(n)) ~n/2 yes ‘timsort’ 2 O(n*log(n)) ~n/2 yes Note The datatype determines which of ‘mergesort’ or ‘timsort’ is actually used, even if ‘mergesort’ is specified. User selection at a finer scale is not currently available. All the sort algorithms make temporary copies of the data when sorting along any but the last axis. Consequently, sorting along the last axis is faster and uses less space than sorting along any other axis. The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts. Previous to numpy 1.4.0 sorting real and complex arrays containing nan values led to undefined behaviour. In numpy versions >= 1.4.0 nan values are sorted to the end. The extended sort order is: Real: [R, nan] Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj] where R is a non-nan real value. Complex values with the same nan placements are sorted according to the non-nan part if it exists. Non-nan values are sorted as before. New in version 1.12.0. quicksort has been changed to introsort. When sorting does not make enough progress it switches to heapsort. This implementation makes quicksort O(n*log(n)) in the worst case. ‘stable’ automatically chooses the best stable sorting algorithm for the data type being", "score": "0.6855484"}]}
{"task_id": "mbpp_153", "code": "def parabola_vertex(a, b, c): \r\n  vertex=(((-b / (2 * a)),(((4 * a * c) - (b * b)) / (4 * a))))\r\n  return vertex", "test_list": ["assert parabola_vertex(5,3,2)==(-0.3, 1.55)", "assert parabola_vertex(9,8,4)==(-0.4444444444444444, 2.2222222222222223)", "assert parabola_vertex(2,4,6)==(-1.0, 4.0)"], "context": "Write a function to find the vertex of a parabola.", "function_name": "def parabola_vertex(a, b, c):", "gold_generation": "vertex=(((-b / (2 * a)),(((4 * a * c) - (b * b)) / (4 * a))))\r\n  return vertex", "ctxs": [{"id": "43592", "text": "Function: numpy.reference.generated.numpy.polynomial.polynomial.polyline\nSnippet: numpy.polynomial.polynomial.polyline polynomial.polynomial.polyline(off, scl)[source] Returns an array representing a linear polynomial. Parameters off, sclscalars The “y-intercept” and “slope” of the line, respectively. Returns yndarray This module’s representation of the linear polynomial off + scl*x. See also numpy.polynomial.chebyshev.chebline numpy.polynomial.legendre.legline numpy.polynomial.laguerre.lagline numpy.polynomial.hermite.hermline numpy.polynomial.hermite_e.hermeline Examples >>> from numpy.polynomial import polynomial as P >>> P.polyline(1,-1) array([ 1, -1]) >>> P.polyval(1, P.polyline(1,-1)) # should be 0 0.0", "score": "0.6373627"}, {"id": "43306", "text": "Function: numpy.reference.generated.numpy.polynomial.chebyshev.chebline\nSnippet: numpy.polynomial.chebyshev.chebline polynomial.chebyshev.chebline(off, scl)[source] Chebyshev series whose graph is a straight line. Parameters off, sclscalars The specified line is given by off + scl*x. Returns yndarray This module’s representation of the Chebyshev series for off + scl*x. See also numpy.polynomial.polynomial.polyline numpy.polynomial.legendre.legline numpy.polynomial.laguerre.lagline numpy.polynomial.hermite.hermline numpy.polynomial.hermite_e.hermeline Examples >>> import numpy.polynomial.chebyshev as C >>> C.chebline(3,2) array([3, 2]) >>> C.chebval(-3, C.chebline(3,2)) # should be -3 -3.0", "score": "0.62596834"}, {"id": "43559", "text": "Function: numpy.reference.generated.numpy.polynomial.legendre.legline\nSnippet: numpy.polynomial.legendre.legline polynomial.legendre.legline(off, scl)[source] Legendre series whose graph is a straight line. Parameters off, sclscalars The specified line is given by off + scl*x. Returns yndarray This module’s representation of the Legendre series for off + scl*x. See also numpy.polynomial.polynomial.polyline numpy.polynomial.chebyshev.chebline numpy.polynomial.laguerre.lagline numpy.polynomial.hermite.hermline numpy.polynomial.hermite_e.hermeline Examples >>> import numpy.polynomial.legendre as L >>> L.legline(3,2) array([3, 2]) >>> L.legval(-3, L.legline(3,2)) # should be -3 -3.0", "score": "0.62502855"}, {"id": "21804", "text": "Function: python.library.math#math.gamma\nSnippet: math.gamma(x) Return the Gamma function at x. New in version 3.2.", "score": "0.6215818"}, {"id": "33487", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: barbs_doc='\\nPlot a 2D field of barbs.\\n\\nCall signature::\\n\\n barbs([X, Y], U, V, [C], **kw)\\n\\nWhere *X*, *Y* define the barb locations, *U*, *V* define the barb\\ndirections, and *C* optionally sets the color.\\n\\nAll arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked\\n*X*, *Y* are not supported at present.\\n\\nBarbs are traditionally used in meteorology as a way to plot the speed\\nand direction of wind observations, but can technically be used to\\nplot any two dimensional vector quantity. As opposed to arrows, which\\ngive vector magnitude by the length of the arrow, the barbs give more\\nquantitative information about the vector magnitude by putting slanted\\nlines or a triangle for various increments in magnitude, as show\\nschematically below::\\n\\n : /\\\\ \\\\\\n : / \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : ------------------------------\\n\\nThe largest increment is given by a triangle (or \"flag\"). After those\\ncome full lines (barbs). The smallest increment is a half line. There\\nis only, of course, ever at most 1 half line. If the magnitude is\\nsmall and only needs a single half-line and no full lines or\\ntriangles, the half-line is offset from the end of the barb so that it\\ncan be easily distinguished from barbs with a single full line. The\\nmagnitude for the barb shown above would nominally be 65, using the\\nstandard increments of 50, 10, and 5.\\n\\nSee also https://en.wikipedia.org/wiki/Wind_barb.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the barb locations. See *pivot* for how the\\n barbs are drawn to the x, y positions.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y components of the barb shaft.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If", "score": "0.6203676"}]}
{"task_id": "mbpp_154", "code": "def specified_element(nums, N):\r\n    result = [i[N] for i in nums]\r\n    return result", "test_list": ["assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]", "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]", "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],3)==[2,2,5]"], "context": "Write a function to extract every specified element from a given two dimensional list.", "function_name": "def specified_element(nums, N):", "gold_generation": "result = [i[N] for i in nums]\r\n    return result", "ctxs": [{"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.6635995"}, {"id": "20295", "text": "Function: python.library.functions\nSnippet: aggregates elements from each of the iterables. Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator. Equivalent to: def zip(*iterables): # zip('ABCD', 'xy') --> Ax By sentinel = object() iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using zip(*[iter(s)]*n). This repeats the same iterator n times so that each output tuple has the result of n calls to the iterator. This has the effect of dividing the input into n-length chunks. zip() should only be used with unequal length inputs when you don’t care about trailing, unmatched values from the longer iterables. If those values are important, use itertools.zip_longest() instead. zip() in conjunction with the * operator can be used to unzip a list: >>> x = [1, 2, 3] >>> y = [4, 5, 6] >>> zipped = zip(x, y) >>> list(zipped) [(1, 4), (2, 5), (3, 6)] >>> x2, y2 = zip(*zip(x, y)) >>> x == list(x2) and y == list(y2) True __import__(name, globals=None, locals=None, fromlist=(), level=0) Note This is an advanced function that is not needed in everyday Python programming, unlike importlib.import_module(). This function is invoked by the import statement. It can be replaced (by importing the builtins module and assigning to builtins.__import__) in order to change semantics of the import statement, but doing so is strongly discouraged as it is usually simpler to use import hooks (see PEP 302) to attain the same goals and does not cause issues with code which assumes the default import implementation is in use. Direct use of __import__() is also discouraged in favor of importlib.import_module(). The function imports the module name, potentially using the given globals and locals to determine how to interpret the name in a package context. The fromlist gives the names of objects or submodules that should be imported from the module given by name. The standard implementation does not use its locals argument at all, and uses its globals only to determine the package context of the import statement. level specifies whether to use absolute or relative imports. 0 (the default) means only perform absolute imports. Positive values for level indicate the number of parent directories to search relative to the directory of the module calling __import__() (see PEP 328 for the details). When the name variable is of the form package.module, normally, the top-level package (the name up till the first dot) is returned, not the module named by name. However, when a non-empty fromlist argument is given, the module named by name is returned. For example, the statement import spam results", "score": "0.65969086"}, {"id": "27121", "text": "Function: python.library.functions#zip\nSnippet: zip(*iterables) Make an iterator that aggregates elements from each of the iterables. Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator. Equivalent to: def zip(*iterables): # zip('ABCD', 'xy') --> Ax By sentinel = object() iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using zip(*[iter(s)]*n). This repeats the same iterator n times so that each output tuple has the result of n calls to the iterator. This has the effect of dividing the input into n-length chunks. zip() should only be used with unequal length inputs when you don’t care about trailing, unmatched values from the longer iterables. If those values are important, use itertools.zip_longest() instead. zip() in conjunction with the * operator can be used to unzip a list: >>> x = [1, 2, 3] >>> y = [4, 5, 6] >>> zipped = zip(x, y) >>> list(zipped) [(1, 4), (2, 5), (3, 6)] >>> x2, y2 = zip(*zip(x, y)) >>> x == list(x2) and y == list(y2) True", "score": "0.65504813"}, {"id": "21309", "text": "Function: python.library.itertools#itertools.islice\nSnippet: itertools.islice(iterable, stop) itertools.islice(iterable, start, stop[, step]) Make an iterator that returns selected elements from the iterable. If start is non-zero, then elements from the iterable are skipped until start is reached. Afterward, elements are returned consecutively unless step is set higher than one which results in items being skipped. If stop is None, then iteration continues until the iterator is exhausted, if at all; otherwise, it stops at the specified position. Unlike regular slicing, islice() does not support negative values for start, stop, or step. Can be used to extract related fields from data where the internal structure has been flattened (for example, a multi-line report may list a name field on every third line). Roughly equivalent to: def islice(iterable, *args): # islice('ABCDEFG', 2) --> A B # islice('ABCDEFG', 2, 4) --> C D # islice('ABCDEFG', 2, None) --> C D E F G # islice('ABCDEFG', 0, None, 2) --> A C E G s = slice(*args) start, stop, step = s.start or 0, s.stop or sys.maxsize, s.step or 1 it = iter(range(start, stop, step)) try: nexti = next(it) except StopIteration: # Consume *iterable* up to the *start* position. for i, element in zip(range(start), iterable): pass return try: for i, element in enumerate(iterable): if i == nexti: yield element nexti = next(it) except StopIteration: # Consume to *stop*. for i, element in zip(range(i + 1, stop), iterable): pass If start is None, then iteration starts at zero. If step is None, then the step defaults to one.", "score": "0.6488685"}, {"id": "25502", "text": "Function: python.library.traceback#traceback.format_list\nSnippet: traceback.format_list(extracted_list) Given a list of tuples or FrameSummary objects as returned by extract_tb() or extract_stack(), return a list of strings ready for printing. Each string in the resulting list corresponds to the item with the same index in the argument list. Each string ends in a newline; the strings may contain internal newlines as well, for those items whose source text line is not None.", "score": "0.6472151"}]}
{"task_id": "mbpp_155", "code": "def even_bit_toggle_number(n) : \r\n    res = 0; count = 0; temp = n \r\n    while (temp > 0) :     \r\n        if (count % 2 == 1) : \r\n            res = res | (1 << count)      \r\n        count = count + 1\r\n        temp >>= 1 \r\n    return n ^ res ", "test_list": ["assert even_bit_toggle_number(10) == 0", "assert even_bit_toggle_number(20) == 30", "assert even_bit_toggle_number(30) == 20"], "context": "Write a python function to toggle all even bits of a given number.", "function_name": "def even_bit_toggle_number(n) :", "gold_generation": "res = 0; count = 0; temp = n \r\n    while (temp > 0) :     \r\n        if (count % 2 == 1) : \r\n            res = res | (1 << count)      \r\n        count = count + 1\r\n        temp >>= 1 \r\n    return n ^ res", "ctxs": [{"id": "19487", "text": "Function: python.library.decimal#decimal.Context.logical_invert\nSnippet: logical_invert(x) Invert all the digits in x.", "score": "0.69060725"}, {"id": "19597", "text": "Function: python.library.decimal#decimal.ROUND_HALF_EVEN\nSnippet: decimal.ROUND_HALF_EVEN Round to nearest with ties going to nearest even integer.", "score": "0.6884757"}, {"id": "7758", "text": "Function: torch.tensors#torch.Tensor.bitwise_or_\nSnippet: bitwise_or_() → Tensor In-place version of bitwise_or()", "score": "0.6829543"}, {"id": "7760", "text": "Function: torch.tensors#torch.Tensor.bitwise_xor_\nSnippet: bitwise_xor_() → Tensor In-place version of bitwise_xor()", "score": "0.6778424"}, {"id": "7757", "text": "Function: torch.tensors#torch.Tensor.bitwise_or\nSnippet: bitwise_or() → Tensor See torch.bitwise_or()", "score": "0.6701609"}]}
{"task_id": "mbpp_156", "code": "def tuple_int_str(tuple_str):\r\n    result = tuple((int(x[0]), int(x[1])) for x in tuple_str)\r\n    return result", "test_list": ["assert tuple_int_str((('333', '33'), ('1416', '55')))==((333, 33), (1416, 55))", "assert tuple_int_str((('999', '99'), ('1000', '500')))==((999, 99), (1000, 500))", "assert tuple_int_str((('666', '66'), ('1500', '555')))==((666, 66), (1500, 555))"], "context": "Write a function to convert a tuple of string values to a tuple of integer values.", "function_name": "def tuple_int_str(tuple_str):", "gold_generation": "result = tuple((int(x[0]), int(x[1])) for x in tuple_str)\r\n    return result", "ctxs": [{"id": "18617", "text": "Function: python.library.collections\nSnippet: a new instance of the named tuple replacing specified fields with new values: >>> p = Point(x=11, y=22) >>> p._replace(x=33) Point(x=33, y=22) >>> for partnum, record in inventory.items(): ... inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now()) somenamedtuple._fields Tuple of strings listing the field names. Useful for introspection and for creating new named tuple types from existing named tuples. >>> p._fields # view the field names ('x', 'y') >>> Color = namedtuple('Color', 'red green blue') >>> Pixel = namedtuple('Pixel', Point._fields + Color._fields) >>> Pixel(11, 22, 128, 255, 0) Pixel(x=11, y=22, red=128, green=255, blue=0) somenamedtuple._field_defaults Dictionary mapping field names to default values. >>> Account = namedtuple('Account', ['type', 'balance'], defaults=[0]) >>> Account._field_defaults {'balance': 0} >>> Account('premium') Account(type='premium', balance=0) To retrieve a field whose name is stored in a string, use the getattr() function: >>> getattr(p, 'x') 11 To convert a dictionary to a named tuple, use the double-star-operator (as described in Unpacking Argument Lists): >>> d = {'x': 11, 'y': 22} >>> Point(**d) Point(x=11, y=22) Since a named tuple is a regular Python class, it is easy to add or change functionality with a subclass. Here is how to add a calculated field and a fixed-width print format: >>> class Point(namedtuple('Point', ['x', 'y'])): ... __slots__ = () ... @property ... def hypot(self): ... return (self.x ** 2 + self.y ** 2) ** 0.5 ... def __str__(self): ... return 'Point: x=%6.3f y=%6.3f hypot=%6.3f' % (self.x, self.y, self.hypot) >>> for p in Point(3, 4), Point(14, 5/7): ... print(p) Point: x= 3.000 y= 4.000 hypot= 5.000 Point: x=14.000 y= 0.714 hypot=14.018 The subclass shown above sets __slots__ to an empty tuple. This helps keep memory requirements low by preventing the creation of instance dictionaries. Subclassing is not useful for adding new, stored fields. Instead, simply create a new named tuple type from the _fields attribute: >>> Point3D = namedtuple('Point3D', Point._fields + ('z',)) Docstrings can be customized by making direct assignments to the __doc__ fields: >>> Book = namedtuple('Book', ['id', 'title', 'authors']) >>> Book.__doc__ += ': Hardcover book in active collection' >>> Book.id.__doc__ = '13-digit ISBN' >>> Book.title.__doc__ = 'Title of first printing' >>> Book.authors.__doc__ = 'List of authors sorted by last name' Changed in version 3.5: Property docstrings became writeable. See also See typing.NamedTuple for a way to add type hints for named tuples. It also provides an elegant notation using the class keyword: class Component(NamedTuple): part_number: int weight: float description: Optional[str] = None See types.SimpleNamespace() for a mutable namespace based on an underlying dictionary instead of a tuple. The dataclasses module provides a decorator and functions for automatically adding generated special methods to user-defined classes. OrderedDict objects Ordered dictionaries are just like regular dictionaries but have some extra capabilities relating to ordering operations. They have become less important now that the built-in dict class gained the ability to remember insertion order (this new behavior became guaranteed in Python 3.7). Some differences from dict still remain: The regular dict was designed to be very good at mapping operations. Tracking insertion order was secondary. The OrderedDict was designed to be", "score": "0.71351355"}, {"id": "25737", "text": "Function: python.library.stdtypes\nSnippet: a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str objects, you can build a list and use str.join() at the end or else write to an io.StringIO instance and retrieve its value when complete if concatenating bytes objects, you can similarly use bytes.join() or io.BytesIO, or you can do in-place concatenation with a bytearray object. bytearray objects are mutable and have an efficient overallocation mechanism if concatenating tuple objects, extend a list instead for other types, investigate the relevant class documentation Some sequence types (such as range) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition. index raises ValueError when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using s[i:j].index(x), only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. Immutable Sequence Types The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the hash() built-in. This support allows immutable sequences, such as tuple instances, to be used as dict keys and stored in set and frozenset instances. Attempting to hash an immutable sequence that contains unhashable values will result in TypeError. Mutable Sequence Types The operations in the following table are defined on mutable sequence types. The collections.abc.MutableSequence ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, bytearray only accepts integers that meet the value restriction 0 <= x <= 255). Operation Result Notes s[i] = x item i of s is replaced by x s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t del s[i:j] same as s[i:j] = [] s[i:j:k] = t the elements of s[i:j:k] are replaced by those of t (1) del s[i:j:k] removes the elements of s[i:j:k] from the list s.append(x) appends x to the end of the sequence (same as s[len(s):len(s)] = [x]) s.clear() removes all items from s (same as del s[:]) (5) s.copy() creates a shallow copy of s (same as s[:]) (5) s.extend(t) or s += t extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t) s *= n updates s with its contents repeated n times (6) s.insert(i, x) inserts x into s at the index given by i (same as s[i:i] = [x]) s.pop([i]) retrieves the item at i and also removes it", "score": "0.69069505"}, {"id": "18685", "text": "Function: python.library.collections#collections.somenamedtuple._replace\nSnippet: somenamedtuple._replace(**kwargs) Return a new instance of the named tuple replacing specified fields with new values: >>> p = Point(x=11, y=22) >>> p._replace(x=33) Point(x=33, y=22) >>> for partnum, record in inventory.items(): ... inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now())", "score": "0.68456304"}, {"id": "24412", "text": "Function: python.library.string#string.Formatter.parse\nSnippet: parse(format_string) Loop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields. The values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None.", "score": "0.67772853"}, {"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.67603487"}]}
{"task_id": "mbpp_157", "code": "from itertools import groupby\r\ndef encode_list(list1):\r\n    return [[len(list(group)), key] for key, group in groupby(list1)]", "test_list": ["assert encode_list([1,1,2,3,4,4.3,5,1])==[[2, 1], [1, 2], [1, 3], [1, 4], [1, 4.3], [1, 5], [1, 1]]", "assert encode_list('automatically')==[[1, 'a'], [1, 'u'], [1, 't'], [1, 'o'], [1, 'm'], [1, 'a'], [1, 't'], [1, 'i'], [1, 'c'], [1, 'a'], [2, 'l'], [1, 'y']]", "assert encode_list('python')==[[1, 'p'], [1, 'y'], [1, 't'], [1, 'h'], [1, 'o'], [1, 'n']]"], "context": "Write a function to reflect the run-length encoding from a list.", "function_name": "from itertools import groupby\r\ndef encode_list(list1):", "gold_generation": "return [[len(list(group)), key] for key, group in groupby(list1)]", "ctxs": [{"id": "25737", "text": "Function: python.library.stdtypes\nSnippet: a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str objects, you can build a list and use str.join() at the end or else write to an io.StringIO instance and retrieve its value when complete if concatenating bytes objects, you can similarly use bytes.join() or io.BytesIO, or you can do in-place concatenation with a bytearray object. bytearray objects are mutable and have an efficient overallocation mechanism if concatenating tuple objects, extend a list instead for other types, investigate the relevant class documentation Some sequence types (such as range) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition. index raises ValueError when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using s[i:j].index(x), only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. Immutable Sequence Types The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the hash() built-in. This support allows immutable sequences, such as tuple instances, to be used as dict keys and stored in set and frozenset instances. Attempting to hash an immutable sequence that contains unhashable values will result in TypeError. Mutable Sequence Types The operations in the following table are defined on mutable sequence types. The collections.abc.MutableSequence ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, bytearray only accepts integers that meet the value restriction 0 <= x <= 255). Operation Result Notes s[i] = x item i of s is replaced by x s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t del s[i:j] same as s[i:j] = [] s[i:j:k] = t the elements of s[i:j:k] are replaced by those of t (1) del s[i:j:k] removes the elements of s[i:j:k] from the list s.append(x) appends x to the end of the sequence (same as s[len(s):len(s)] = [x]) s.clear() removes all items from s (same as del s[:]) (5) s.copy() creates a shallow copy of s (same as s[:]) (5) s.extend(t) or s += t extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t) s *= n updates s with its contents repeated n times (6) s.insert(i, x) inserts x into s at the index given by i (same as s[i:i] = [x]) s.pop([i]) retrieves the item at i and also removes it", "score": "0.7030095"}, {"id": "21151", "text": "Function: python.library.io#io.TextIOBase.write\nSnippet: write(s) Write the string s to the stream and return the number of characters written.", "score": "0.6948995"}, {"id": "41757", "text": "Function: numpy.reference.generated.numpy.char.str_len\nSnippet: numpy.char.str_len char.str_len(a)[source] Return len(a) element-wise. Parameters aarray_like of str or unicode Returns outndarray Output array of integers See also builtins.len", "score": "0.68765855"}, {"id": "18601", "text": "Function: python.library.codecs#codecs.StreamWriter.writelines\nSnippet: writelines(list) Writes the concatenated list of strings to the stream (possibly by reusing the write() method). The standard bytes-to-bytes codecs do not support this method.", "score": "0.68477017"}, {"id": "18291", "text": "Function: python.library.stdtypes#bytearray.split\nSnippet: bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3']", "score": "0.6841602"}]}
{"task_id": "mbpp_158", "code": "def min_Ops(arr,n,k): \r\n    max1 = max(arr) \r\n    res = 0\r\n    for i in range(0,n):  \r\n        if ((max1 - arr[i]) % k != 0): \r\n            return -1 \r\n        else: \r\n            res += (max1 - arr[i]) / k \r\n    return int(res) ", "test_list": ["assert min_Ops([2,2,2,2],4,3) == 0", "assert min_Ops([4,2,6,8],4,3) == -1", "assert min_Ops([21,33,9,45,63],5,6) == 24"], "context": "Write a python function to find k number of operations required to make all elements equal.", "function_name": "def min_Ops(arr,n,k):", "gold_generation": "max1 = max(arr) \r\n    res = 0\r\n    for i in range(0,n):  \r\n        if ((max1 - arr[i]) % k != 0): \r\n            return -1 \r\n        else: \r\n            res += (max1 - arr[i]) / k \r\n    return int(res)", "ctxs": [{"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.68401027"}, {"id": "19649", "text": "Function: python.library.difflib#difflib.SequenceMatcher.get_opcodes\nSnippet: get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f'", "score": "0.68260956"}, {"id": "18611", "text": "Function: python.library.collections\nSnippet: Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6}) New in version 3.2. The usual dictionary methods are available for Counter objects except for two which work differently for counters. fromkeys(iterable) This class method is not implemented for Counter objects. update([iterable-or-mapping]) Elements are counted from an iterable or added-in from another mapping (or counter). Like dict.update() but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of (key, value) pairs. Common patterns for working with Counter objects: sum(c.values()) # total of all counts c.clear() # reset all counts list(c) # list unique elements set(c) # convert to a set dict(c) # convert to a regular dictionary c.items() # convert to a list of (elem, cnt) pairs Counter(dict(list_of_pairs)) # convert from a list of (elem, cnt) pairs c.most_common()[:-n-1:-1] # n least common elements +c # remove zero and negative counts Several mathematical operations are provided for combining Counter objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. Intersection and union return the minimum and maximum of corresponding counts. Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less. >>> c = Counter(a=3, b=1) >>> d = Counter(a=1, b=2) >>> c + d # add two counters together: c[x] + d[x] Counter({'a': 4, 'b': 3}) >>> c - d # subtract (keeping only positive counts) Counter({'a': 2}) >>> c & d # intersection: min(c[x], d[x]) Counter({'a': 1, 'b': 1}) >>> c | d # union: max(c[x], d[x]) Counter({'a': 3, 'b': 2}) Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter. >>> c = Counter(a=2, b=-4) >>> +c Counter({'a': 2}) >>> -c Counter({'b': 4}) New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations. Note Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values. To help with those use cases, this section documents the minimum range and type restrictions. The Counter class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you could store anything in the value field. The most_common() method requires only that the values be orderable. For in-place operations such as c[key] += 1, the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for update() and subtract() which allow negative and zero", "score": "0.6820086"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6787264"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.67485315"}]}
{"task_id": "mbpp_159", "code": "def month_season(month,days):\r\n if month in ('January', 'February', 'March'):\r\n\t season = 'winter'\r\n elif month in ('April', 'May', 'June'):\r\n\t season = 'spring'\r\n elif month in ('July', 'August', 'September'):\r\n\t season = 'summer'\r\n else:\r\n\t season = 'autumn'\r\n if (month == 'March') and (days > 19):\r\n\t season = 'spring'\r\n elif (month == 'June') and (days > 20):\r\n\t season = 'summer'\r\n elif (month == 'September') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'October') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'November') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'December') and (days > 20):\r\n\t season = 'winter'\r\n return season", "test_list": ["assert month_season('January',4)==('winter')", "assert month_season('October',28)==('autumn')", "assert month_season('June',6)==('spring')"], "context": "Write a function to print the season for the given month and day.", "function_name": "def month_season(month,days):", "gold_generation": "if month in ('January', 'February', 'March'):\r\n\t season = 'winter'\r\n elif month in ('April', 'May', 'June'):\r\n\t season = 'spring'\r\n elif month in ('July', 'August', 'September'):\r\n\t season = 'summer'\r\n else:\r\n\t season = 'autumn'\r\n if (month == 'March') and (days > 19):\r\n\t season = 'spring'\r\n elif (month == 'June') and (days > 20):\r\n\t season = 'summer'\r\n elif (month == 'September') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'October') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'November') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'December') and (days > 20):\r\n\t season = 'winter'\r\n return season", "ctxs": [{"id": "18409", "text": "Function: python.library.calendar#calendar.TextCalendar.prmonth\nSnippet: prmonth(theyear, themonth, w=0, l=0) Print a month’s calendar as returned by formatmonth().", "score": "0.72052395"}, {"id": "18404", "text": "Function: python.library.calendar#calendar.prmonth\nSnippet: calendar.prmonth(theyear, themonth, w=0, l=0) Prints a month’s calendar as returned by month().", "score": "0.7165066"}, {"id": "18364", "text": "Function: python.library.calendar\nSnippet: names. n specifies the width in characters for one weekday. calendar.monthrange(year, month) Returns weekday of first day of the month and number of days in month, for the specified year and month. calendar.monthcalendar(year, month) Returns a matrix representing a month’s calendar. Each row represents a week; days outside of the month are represented by zeros. Each week begins with Monday unless set by setfirstweekday(). calendar.prmonth(theyear, themonth, w=0, l=0) Prints a month’s calendar as returned by month(). calendar.month(theyear, themonth, w=0, l=0) Returns a month’s calendar in a multi-line string using the formatmonth() of the TextCalendar class. calendar.prcal(year, w=0, l=0, c=6, m=3) Prints the calendar for an entire year as returned by calendar(). calendar.calendar(year, w=2, l=1, c=6, m=3) Returns a 3-column calendar for an entire year as a multi-line string using the formatyear() of the TextCalendar class. calendar.timegm(tuple) An unrelated but handy function that takes a time tuple such as returned by the gmtime() function in the time module, and returns the corresponding Unix timestamp value, assuming an epoch of 1970, and the POSIX encoding. In fact, time.gmtime() and timegm() are each others’ inverse. The calendar module exports the following data attributes: calendar.day_name An array that represents the days of the week in the current locale. calendar.day_abbr An array that represents the abbreviated days of the week in the current locale. calendar.month_name An array that represents the months of the year in the current locale. This follows normal convention of January being month number 1, so it has a length of 13 and month_name[0] is the empty string. calendar.month_abbr An array that represents the abbreviated months of the year in the current locale. This follows normal convention of January being month number 1, so it has a length of 13 and month_abbr[0] is the empty string. See also Module datetime Object-oriented interface to dates and times with similar functionality to the time module. Module time Low-level time related functions.", "score": "0.70514137"}, {"id": "18398", "text": "Function: python.library.calendar#calendar.month\nSnippet: calendar.month(theyear, themonth, w=0, l=0) Returns a month’s calendar in a multi-line string using the formatmonth() of the TextCalendar class.", "score": "0.6947653"}, {"id": "18362", "text": "Function: python.library.calendar\nSnippet: weeks. Weeks are lists of seven datetime.date objects. monthdays2calendar(year, month) Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers. monthdayscalendar(year, month) Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers. yeardatescalendar(year, width=3) Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects. yeardays2calendar(year, width=3) Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero. yeardayscalendar(year, width=3) Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero. class calendar.TextCalendar(firstweekday=0) This class can be used to generate plain text calendars. TextCalendar instances have the following methods: formatmonth(theyear, themonth, w=0, l=0) Return a month’s calendar in a multi-line string. If w is provided, it specifies the width of the date columns, which are centered. If l is given, it specifies the number of lines that each week will use. Depends on the first weekday as specified in the constructor or set by the setfirstweekday() method. prmonth(theyear, themonth, w=0, l=0) Print a month’s calendar as returned by formatmonth(). formatyear(theyear, w=2, l=1, c=6, m=3) Return a m-column calendar for an entire year as a multi-line string. Optional parameters w, l, and c are for date column width, lines per week, and number of spaces between month columns, respectively. Depends on the first weekday as specified in the constructor or set by the setfirstweekday() method. The earliest year for which a calendar can be generated is platform-dependent. pryear(theyear, w=2, l=1, c=6, m=3) Print the calendar for an entire year as returned by formatyear(). class calendar.HTMLCalendar(firstweekday=0) This class can be used to generate HTML calendars. HTMLCalendar instances have the following methods: formatmonth(theyear, themonth, withyear=True) Return a month’s calendar as an HTML table. If withyear is true the year will be included in the header, otherwise just the month name will be used. formatyear(theyear, width=3) Return a year’s calendar as an HTML table. width (defaulting to 3) specifies the number of months per row. formatyearpage(theyear, width=3, css='calendar.css', encoding=None) Return a year’s calendar as a complete HTML page. width (defaulting to 3) specifies the number of months per row. css is the name for the cascading style sheet to be used. None can be passed if no style sheet should be used. encoding specifies the encoding to be used for the output (defaulting to the system default encoding). HTMLCalendar has the following attributes you can override to customize the CSS classes used by the calendar: cssclasses A", "score": "0.6897901"}]}
{"task_id": "mbpp_160", "code": "def solution (a, b, n): \r\n\ti = 0\r\n\twhile i * a <= n: \r\n\t\tif (n - (i * a)) % b == 0: \r\n\t\t\treturn (\"x = \",i ,\", y = \", \r\n\t\t\tint((n - (i * a)) / b)) \r\n\t\t\treturn 0\r\n\t\ti = i + 1\r\n\treturn (\"No solution\") ", "test_list": ["assert solution(2, 3, 7) == ('x = ', 2, ', y = ', 1)", "assert solution(4, 2, 7) == 'No solution'", "assert solution(1, 13, 17) == ('x = ', 4, ', y = ', 1)"], "context": "Write a function to find x and y that satisfies ax + by = n.", "function_name": "def solution (a, b, n):", "gold_generation": "i = 0\r\n\twhile i * a <= n: \r\n\t\tif (n - (i * a)) % b == 0: \r\n\t\t\treturn (\"x = \",i ,\", y = \", \r\n\t\t\tint((n - (i * a)) / b)) \r\n\t\t\treturn 0\r\n\t\ti = i + 1\r\n\treturn (\"No solution\")", "ctxs": [{"id": "41591", "text": "Function: numpy.glossary\nSnippet: since y is a view on x >>> y array([3, 2, 4])", "score": "0.6405388"}, {"id": "42079", "text": "Function: numpy.reference.generated.numpy.linalg.solve\nSnippet: numpy.linalg.solve linalg.solve(a, b)[source] Solve a linear matrix equation, or system of linear scalar equations. Computes the “exact” solution, x, of the well-determined, i.e., full rank, linear matrix equation ax = b. Parameters a(…, M, M) array_like Coefficient matrix. b{(…, M,), (…, M, K)}, array_like Ordinate or “dependent variable” values. Returns x{(…, M,), (…, M, K)} ndarray Solution to the system a x = b. Returned shape is identical to b. Raises LinAlgError If a is singular or not square. See also scipy.linalg.solve Similar function in SciPy. Notes New in version 1.8.0. Broadcasting rules apply, see the numpy.linalg documentation for details. The solutions are computed using LAPACK routine _gesv. a must be square and of full-rank, i.e., all rows (or, equivalently, columns) must be linearly independent; if either is not true, use lstsq for the least-squares best “solution” of the system/equation. References 1 G. Strang, Linear Algebra and Its Applications, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 22. Examples Solve the system of equations x0 + 2 * x1 = 1 and 3 * x0 + 5 * x1 = 2: >>> a = np.array([[1, 2], [3, 5]]) >>> b = np.array([1, 2]) >>> x = np.linalg.solve(a, b) >>> x array([-1., 1.]) Check that the solution is correct: >>> np.allclose(np.dot(a, x), b) True", "score": "0.6392229"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6366599"}, {"id": "43274", "text": "Function: numpy.reference.generated.numpy.where\nSnippet: numpy.where numpy.where(condition, [x, y, ]/) Return elements chosen from x or y depending on condition. Note When only condition is provided, this function is a shorthand for np.asarray(condition).nonzero(). Using nonzero directly should be preferred, as it behaves correctly for subclasses. The rest of this documentation covers only the case where all three arguments are provided. Parameters conditionarray_like, bool Where True, yield x, otherwise yield y. x, yarray_like Values from which to choose. x, y and condition need to be broadcastable to some shape. Returns outndarray An array with elements from x where condition is True, and elements from y elsewhere. See also choose nonzero The function that is called when x and y are omitted Notes If all the arrays are 1-D, where is equivalent to: [xv if c else yv for c, xv, yv in zip(condition, x, y)] Examples >>> a = np.arange(10) >>> a array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) >>> np.where(a < 5, a, 10*a) array([ 0, 1, 2, 3, 4, 50, 60, 70, 80, 90]) This can be used on multidimensional arrays too: >>> np.where([[True, False], [True, True]], ... [[1, 2], [3, 4]], ... [[9, 8], [7, 6]]) array([[1, 8], [3, 4]]) The shapes of x, y, and the condition are broadcast together: >>> x, y = np.ogrid[:3, :4] >>> np.where(x < y, x, 10 + y) # both x and 10+y are broadcast array([[10, 0, 0, 0], [10, 11, 1, 1], [10, 11, 12, 2]]) >>> a = np.array([[0, 1, 2], ... [0, 2, 4], ... [0, 3, 6]]) >>> np.where(a < 4, a, -1) # -1 is broadcast array([[ 0, 1, 2], [ 0, 2, -1], [ 0, 3, -1]])", "score": "0.62561965"}, {"id": "42808", "text": "Function: numpy.reference.generated.numpy.einsum_path\nSnippet: numpy.einsum_path numpy.einsum_path(subscripts, *operands, optimize='greedy')[source] Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays. Parameters subscriptsstr Specifies the subscripts for summation. *operandslist of array_like These are the arrays for the operation. optimize{bool, list, tuple, ‘greedy’, ‘optimal’} Choose the type of path. If a tuple is provided, the second argument is assumed to be the maximum intermediate size created. If only a single argument is provided the largest input or output array size is used as a maximum intermediate size. if a list is given that starts with einsum_path, uses this as the contraction path if False no optimization is taken if True defaults to the ‘greedy’ algorithm ‘optimal’ An algorithm that combinatorially explores all possible ways of contracting the listed tensors and choosest the least costly path. Scales exponentially with the number of terms in the contraction. ‘greedy’ An algorithm that chooses the best pair contraction at each step. Effectively, this algorithm searches the largest inner, Hadamard, and then outer products at each step. Scales cubically with the number of terms in the contraction. Equivalent to the ‘optimal’ path for most contractions. Default is ‘greedy’. Returns pathlist of tuples A list representation of the einsum path. string_reprstr A printable representation of the einsum path. See also einsum, linalg.multi_dot Notes The resulting path indicates which terms of the input contraction should be contracted first, the result of this contraction is then appended to the end of the contraction list. This list can then be iterated over until all intermediate contractions are complete. Examples We can begin with a chain dot example. In this case, it is optimal to contract the b and c tensors first as represented by the first element of the path (1, 2). The resulting tensor is added to the end of the contraction and the remaining contraction (0, 1) is then completed. >>> np.random.seed(123) >>> a = np.random.rand(2, 2) >>> b = np.random.rand(2, 5) >>> c = np.random.rand(5, 2) >>> path_info = np.einsum_path('ij,jk,kl->il', a, b, c, optimize='greedy') >>> print(path_info[0]) ['einsum_path', (1, 2), (0, 1)] >>> print(path_info[1]) Complete contraction: ij,jk,kl->il # may vary Naive scaling: 4 Optimized scaling: 3 Naive FLOP count: 1.600e+02 Optimized FLOP count: 5.600e+01 Theoretical speedup: 2.857 Largest intermediate: 4.000e+00 elements ------------------------------------------------------------------------- scaling current remaining ------------------------------------------------------------------------- 3 kl,jk->jl ij,jl->il 3 jl,ij->il il->il A more complex index transformation example. >>> I = np.random.rand(10, 10, 10, 10) >>> C = np.random.rand(10, 10) >>> path_info = np.einsum_path('ea,fb,abcd,gc,hd->efgh', C, C, I, C, C, ... optimize='greedy') >>> print(path_info[0]) ['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)] >>> print(path_info[1]) Complete contraction: ea,fb,abcd,gc,hd->efgh # may vary Naive scaling: 8 Optimized scaling: 5 Naive FLOP count: 8.000e+08 Optimized FLOP count: 8.000e+05 Theoretical speedup: 1000.000 Largest intermediate: 1.000e+04 elements -------------------------------------------------------------------------- scaling current remaining -------------------------------------------------------------------------- 5 abcd,ea->bcde fb,gc,hd,bcde->efgh 5 bcde,fb->cdef gc,hd,cdef->efgh 5 cdef,gc->defg hd,defg->efgh 5 defg,hd->efgh efgh->efgh", "score": "0.622639"}]}
{"task_id": "mbpp_161", "code": "def remove_elements(list1, list2):\r\n    result = [x for x in list1 if x not in list2]\r\n    return result", "test_list": ["assert remove_elements([1,2,3,4,5,6,7,8,9,10],[2,4,6,8])==[1, 3, 5, 7, 9, 10]", "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],[1, 3, 5, 7])==[2, 4, 6, 8, 9, 10]", "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],[5,7])==[1, 2, 3, 4, 6, 8, 9, 10]"], "context": "Write a function to remove all elements from a given list present in another list.", "function_name": "def remove_elements(list1, list2):", "gold_generation": "result = [x for x in list1 if x not in list2]\r\n    return result", "ctxs": [{"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.665992"}, {"id": "25738", "text": "Function: python.library.stdtypes\nSnippet: from s (2) s.remove(x) remove the first item from s where s[i] is equal to x (3) s.reverse() reverses the items of s in place (4) Notes: t must have the same length as the slice it is replacing. The optional argument i defaults to -1, so that by default the last item is removed and returned. remove() raises ValueError when x is not found in s. The reverse() method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence. clear() and copy() are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as dict and set). copy() is not part of the collections.abc.MutableSequence ABC, but most concrete mutable sequence classes provide it. New in version 3.3: clear() and copy() methods. The value n is an integer, or an object implementing __index__(). Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for s * n under Common Sequence Operations. Lists Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). class list([iterable]) Lists may be constructed in several ways: Using a pair of square brackets to denote the empty list: [] Using square brackets, separating items with commas: [a], [a, b, c] Using a list comprehension: [x for x in iterable] Using the type constructor: list() or list(iterable) The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to iterable[:]. For example, list('abc') returns ['a', 'b', 'c'] and list( (1, 2, 3) ) returns [1, 2, 3]. If no argument is given, the constructor creates a new empty list, []. Many other operations also produce lists, including the sorted() built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is", "score": "0.66585433"}, {"id": "18664", "text": "Function: python.library.collections#collections.deque.clear\nSnippet: clear() Remove all elements from the deque leaving it with length 0.", "score": "0.6603304"}, {"id": "18611", "text": "Function: python.library.collections\nSnippet: Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6}) New in version 3.2. The usual dictionary methods are available for Counter objects except for two which work differently for counters. fromkeys(iterable) This class method is not implemented for Counter objects. update([iterable-or-mapping]) Elements are counted from an iterable or added-in from another mapping (or counter). Like dict.update() but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of (key, value) pairs. Common patterns for working with Counter objects: sum(c.values()) # total of all counts c.clear() # reset all counts list(c) # list unique elements set(c) # convert to a set dict(c) # convert to a regular dictionary c.items() # convert to a list of (elem, cnt) pairs Counter(dict(list_of_pairs)) # convert from a list of (elem, cnt) pairs c.most_common()[:-n-1:-1] # n least common elements +c # remove zero and negative counts Several mathematical operations are provided for combining Counter objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. Intersection and union return the minimum and maximum of corresponding counts. Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less. >>> c = Counter(a=3, b=1) >>> d = Counter(a=1, b=2) >>> c + d # add two counters together: c[x] + d[x] Counter({'a': 4, 'b': 3}) >>> c - d # subtract (keeping only positive counts) Counter({'a': 2}) >>> c & d # intersection: min(c[x], d[x]) Counter({'a': 1, 'b': 1}) >>> c | d # union: max(c[x], d[x]) Counter({'a': 3, 'b': 2}) Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter. >>> c = Counter(a=2, b=-4) >>> +c Counter({'a': 2}) >>> -c Counter({'b': 4}) New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations. Note Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values. To help with those use cases, this section documents the minimum range and type restrictions. The Counter class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you could store anything in the value field. The most_common() method requires only that the values be orderable. For in-place operations such as c[key] += 1, the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for update() and subtract() which allow negative and zero", "score": "0.65589666"}, {"id": "20217", "text": "Function: python.library.stdtypes#frozenset.clear\nSnippet: clear() Remove all elements from the set.", "score": "0.65081275"}]}
{"task_id": "mbpp_162", "code": "def sum_series(n):\r\n  if n < 1:\r\n    return 0\r\n  else:\r\n    return n + sum_series(n - 2)", "test_list": ["assert sum_series(6)==12", "assert sum_series(10)==30", "assert sum_series(9)==25"], "context": "Write a function to calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).", "function_name": "def sum_series(n):", "gold_generation": "if n < 1:\r\n    return 0\r\n  else:\r\n    return n + sum_series(n - 2)", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6959226"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.6737616"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6597103"}, {"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.64739496"}, {"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.6456521"}]}
{"task_id": "mbpp_163", "code": "from math import tan, pi\r\ndef area_polygon(s,l):\r\n  area = s * (l ** 2) / (4 * tan(pi / s))\r\n  return area", "test_list": ["assert area_polygon(4,20)==400.00000000000006", "assert area_polygon(10,15)==1731.1969896610804", "assert area_polygon(9,7)==302.90938549487214"], "context": "Write a function to calculate the area of a regular polygon.", "function_name": "from math import tan, pi\r\ndef area_polygon(s,l):", "gold_generation": "area = s * (l ** 2) / (4 * tan(pi / s))\r\n  return area", "ctxs": [{"id": "36509", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.OGRGeometry.area\nSnippet: area", "score": "0.6784274"}, {"id": "36333", "text": "Function: django.ref.contrib.gis.functions#django.contrib.gis.db.models.functions.Area\nSnippet: class Area(expression, **extra)", "score": "0.66686445"}, {"id": "36610", "text": "Function: django.ref.contrib.gis.geos#django.contrib.gis.geos.GEOSGeometry.area\nSnippet: GEOSGeometry.area This property returns the area of the Geometry.", "score": "0.6662967"}, {"id": "30832", "text": "Function: matplotlib.collections_api#matplotlib.collections.RegularPolyCollection\nSnippet: classmatplotlib.collections.RegularPolyCollection(numsides, rotation=0, sizes=(1,), **kwargs)[source] Bases: matplotlib.collections._CollectionWithSizes A collection of n-sided regular polygons. Parameters numsidesint The number of sides of the polygon. rotationfloat The rotation of the polygon in radians. sizestuple of float The area of the circle circumscribing the polygon in points^2. **kwargs Forwarded to Collection. Examples See Lasso Demo for a complete example: offsets = np.random.rand(20, 2) facecolors = [cm.jet(x) for x in np.random.rand(20)] collection = RegularPolyCollection( numsides=5, # a pentagon rotation=0, sizes=(50,), facecolors=facecolors, edgecolors=(\"black\",), linewidths=(1,), offsets=offsets, transOffset=ax.transData, ) add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter.", "score": "0.66334814"}, {"id": "38797", "text": "Function: django.ref.contrib.gis.geos#std:setting-GEOS_LIBRARY_PATH\nSnippet: 0.4), (0.4, 0.6), (0.6, 0.6), (0.6, 0.4), (0.4, 0.4)) >>> poly = Polygon(ext_coords, int_coords) >>> poly = Polygon(LinearRing(ext_coords), LinearRing(int_coords)) classmethod from_bbox(bbox) Returns a polygon object from the given bounding-box, a 4-tuple comprising (xmin, ymin, xmax, ymax). num_interior_rings Returns the number of interior rings in this geometry. Comparing Polygons Note that it is possible to compare Polygon objects directly with < or >, but as the comparison is made through Polygon’s LineString, it does not mean much (but is consistent and quick). You can always force the comparison with the area property: >>> if poly_1.area > poly_2.area: >>> pass Geometry Collections MultiPoint class MultiPoint(*args, **kwargs) MultiPoint objects may be instantiated by passing in Point objects as arguments, or a single sequence of Point objects: >>> mp = MultiPoint(Point(0, 0), Point(1, 1)) >>> mp = MultiPoint( (Point(0, 0), Point(1, 1)) ) MultiLineString class MultiLineString(*args, **kwargs) MultiLineString objects may be instantiated by passing in LineString objects as arguments, or a single sequence of LineString objects: >>> ls1 = LineString((0, 0), (1, 1)) >>> ls2 = LineString((2, 2), (3, 3)) >>> mls = MultiLineString(ls1, ls2) >>> mls = MultiLineString([ls1, ls2]) merged Returns a LineString representing the line merge of all the components in this MultiLineString. closed Returns True if and only if all elements are closed. MultiPolygon class MultiPolygon(*args, **kwargs) MultiPolygon objects may be instantiated by passing Polygon objects as arguments, or a single sequence of Polygon objects: >>> p1 = Polygon( ((0, 0), (0, 1), (1, 1), (0, 0)) ) >>> p2 = Polygon( ((1, 1), (1, 2), (2, 2), (1, 1)) ) >>> mp = MultiPolygon(p1, p2) >>> mp = MultiPolygon([p1, p2]) GeometryCollection class GeometryCollection(*args, **kwargs) GeometryCollection objects may be instantiated by passing in other GEOSGeometry as arguments, or a single sequence of GEOSGeometry objects: >>> poly = Polygon( ((0, 0), (0, 1), (1, 1), (0, 0)) ) >>> gc = GeometryCollection(Point(0, 0), MultiPoint(Point(0, 0), Point(1, 1)), poly) >>> gc = GeometryCollection((Point(0, 0), MultiPoint(Point(0, 0), Point(1, 1)), poly)) Prepared Geometries In order to obtain a prepared geometry, access the GEOSGeometry.prepared property. Once you have a PreparedGeometry instance its spatial predicate methods, listed below, may be used with other GEOSGeometry objects. An operation with a prepared geometry can be orders of magnitude faster – the more complex the geometry that is prepared, the larger the speedup in the operation. For more information, please consult the GEOS wiki page on prepared geometries. For example: >>> from django.contrib.gis.geos import Point, Polygon >>> poly = Polygon.from_bbox((0, 0, 5, 5)) >>> prep_poly = poly.prepared >>> prep_poly.contains(Point(2.5, 2.5)) True PreparedGeometry class PreparedGeometry All methods on PreparedGeometry take an other argument, which must be a GEOSGeometry instance. contains(other) contains_properly(other) covers(other) crosses(other) disjoint(other) intersects(other) overlaps(other) touches(other) within(other) Geometry Factories fromfile(file_h) Parameters: file_h (a Python file object or a string path to the file) – input file that contains spatial data Return type: a GEOSGeometry corresponding to the spatial data in the file Example: >>> from django.contrib.gis.geos import fromfile >>> g = fromfile('/home/bob/geom.wkt') fromstr(string, srid=None) Parameters: string (str) – string that", "score": "0.66024643"}]}
{"task_id": "mbpp_164", "code": "import math \r\ndef divSum(n): \r\n    sum = 1; \r\n    i = 2; \r\n    while(i * i <= n): \r\n        if (n % i == 0): \r\n            sum = (sum + i +math.floor(n / i)); \r\n        i += 1; \r\n    return sum; \r\ndef areEquivalent(num1,num2): \r\n    return divSum(num1) == divSum(num2); ", "test_list": ["assert areEquivalent(36,57) == False", "assert areEquivalent(2,4) == False", "assert areEquivalent(23,47) == True"], "context": "Write a python function to check whether the sum of divisors are same or not.", "function_name": "import math \r\ndef divSum(n):", "gold_generation": "sum = 1; \r\n    i = 2; \r\n    while(i * i <= n): \r\n        if (n % i == 0): \r\n            sum = (sum + i +math.floor(n / i)); \r\n        i += 1; \r\n    return sum; \r\ndef areEquivalent(num1,num2): \r\n    return divSum(num1) == divSum(num2);", "ctxs": [{"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.6799842"}, {"id": "19508", "text": "Function: python.library.decimal#decimal.Context.same_quantum\nSnippet: same_quantum(x, y) Returns True if the two operands have the same exponent.", "score": "0.67164916"}, {"id": "22923", "text": "Function: python.library.parser#parser.ST.isexpr\nSnippet: ST.isexpr() Same as isexpr(st).", "score": "0.66722834"}, {"id": "19457", "text": "Function: python.library.decimal#decimal.Context.compare_total\nSnippet: compare_total(x, y) Compares two operands using their abstract representation.", "score": "0.66620076"}, {"id": "43541", "text": "Function: numpy.reference.generated.numpy.polynomial.legendre.legendre.has_samecoef\nSnippet: numpy.polynomial.legendre.Legendre.has_samecoef method polynomial.legendre.Legendre.has_samecoef(other)[source] Check if coefficients match. New in version 1.6.0. Parameters otherclass instance The other class must have the coef attribute. Returns boolboolean True if the coefficients are the same, False otherwise.", "score": "0.6503029"}]}
{"task_id": "mbpp_165", "code": "def count_char_position(str1): \r\n    count_chars = 0\r\n    for i in range(len(str1)):\r\n        if ((i == ord(str1[i]) - ord('A')) or \r\n            (i == ord(str1[i]) - ord('a'))): \r\n            count_chars += 1\r\n    return count_chars ", "test_list": ["assert count_char_position(\"xbcefg\") == 2", "assert count_char_position(\"ABcED\") == 3", "assert count_char_position(\"AbgdeF\") == 5"], "context": "Write a python function to count characters at same position in a given string (lower and uppercase characters) as in english alphabet.", "function_name": "def count_char_position(str1):", "gold_generation": "count_chars = 0\r\n    for i in range(len(str1)):\r\n        if ((i == ord(str1[i]) - ord('A')) or \r\n            (i == ord(str1[i]) - ord('a'))): \r\n            count_chars += 1\r\n    return count_chars", "ctxs": [{"id": "24401", "text": "Function: python.library.string#string.ascii_uppercase\nSnippet: string.ascii_uppercase The uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. This value is not locale-dependent and will not change.", "score": "0.73287165"}, {"id": "24399", "text": "Function: python.library.string#string.ascii_letters\nSnippet: string.ascii_letters The concatenation of the ascii_lowercase and ascii_uppercase constants described below. This value is not locale-dependent.", "score": "0.7284796"}, {"id": "41736", "text": "Function: numpy.reference.generated.numpy.char.isupper\nSnippet: numpy.char.isupper char.isupper(a)[source] Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. Call str.isupper element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like of str or unicode Returns outndarray Output array of bools See also str.isupper", "score": "0.72758085"}, {"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.72536474"}, {"id": "24400", "text": "Function: python.library.string#string.ascii_lowercase\nSnippet: string.ascii_lowercase The lowercase letters 'abcdefghijklmnopqrstuvwxyz'. This value is not locale-dependent and will not change.", "score": "0.72530776"}]}
{"task_id": "mbpp_166", "code": "def find_even_Pair(A,N): \r\n    evenPair = 0\r\n    for i in range(0,N): \r\n        for j in range(i+1,N): \r\n            if ((A[i] ^ A[j]) % 2 == 0): \r\n                evenPair+=1\r\n    return evenPair; ", "test_list": ["assert find_even_Pair([5,4,7,2,1],5) == 4", "assert find_even_Pair([7,2,8,1,0,5,11],7) == 9", "assert find_even_Pair([1,2,3],3) == 1"], "context": "Write a python function to count the pairs with xor as an even number.", "function_name": "def find_even_Pair(A,N):", "gold_generation": "evenPair = 0\r\n    for i in range(0,N): \r\n        for j in range(i+1,N): \r\n            if ((A[i] ^ A[j]) % 2 == 0): \r\n                evenPair+=1\r\n    return evenPair;", "ctxs": [{"id": "22353", "text": "Function: python.library.operator#operator.xor\nSnippet: operator.xor(a, b) operator.__xor__(a, b) Return the bitwise exclusive or of a and b.", "score": "0.69676226"}, {"id": "22398", "text": "Function: python.library.operator#operator.__xor__\nSnippet: operator.xor(a, b) operator.__xor__(a, b) Return the bitwise exclusive or of a and b.", "score": "0.68828124"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.67569196"}, {"id": "22297", "text": "Function: python.library.operator\nSnippet: known as “true” division. operator.xor(a, b) operator.__xor__(a, b) Return the bitwise exclusive or of a and b. Operations which work with sequences (some of them with mappings too) include: operator.concat(a, b) operator.__concat__(a, b) Return a + b for a and b sequences. operator.contains(a, b) operator.__contains__(a, b) Return the outcome of the test b in a. Note the reversed operands. operator.countOf(a, b) Return the number of occurrences of b in a. operator.delitem(a, b) operator.__delitem__(a, b) Remove the value of a at index b. operator.getitem(a, b) operator.__getitem__(a, b) Return the value of a at index b. operator.indexOf(a, b) Return the index of the first of occurrence of b in a. operator.setitem(a, b, c) operator.__setitem__(a, b, c) Set the value of a at index b to c. operator.length_hint(obj, default=0) Return an estimated length for the object o. First try to return its actual length, then an estimate using object.__length_hint__(), and finally return the default value. New in version 3.4. The operator module also defines tools for generalized attribute and item lookups. These are useful for making fast field extractors as arguments for map(), sorted(), itertools.groupby(), or other functions that expect a function argument. operator.attrgetter(attr) operator.attrgetter(*attrs) Return a callable object that fetches attr from its operand. If more than one attribute is requested, returns a tuple of attributes. The attribute names can also contain dots. For example: After f = attrgetter('name'), the call f(b) returns b.name. After f = attrgetter('name', 'date'), the call f(b) returns (b.name, b.date). After f = attrgetter('name.first', 'name.last'), the call f(b) returns (b.name.first, b.name.last). Equivalent to: def attrgetter(*items): if any(not isinstance(item, str) for item in items): raise TypeError('attribute name must be a string') if len(items) == 1: attr = items[0] def g(obj): return resolve_attr(obj, attr) else: def g(obj): return tuple(resolve_attr(obj, attr) for attr in items) return g def resolve_attr(obj, attr): for name in attr.split(\".\"): obj = getattr(obj, name) return obj operator.itemgetter(item) operator.itemgetter(*items) Return a callable object that fetches item from its operand using the operand’s __getitem__() method. If multiple items are specified, returns a tuple of lookup values. For example: After f = itemgetter(2), the call f(r) returns r[2]. After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3]). Equivalent to: def itemgetter(*items): if len(items) == 1: item = items[0] def g(obj): return obj[item] else: def g(obj): return tuple(obj[item] for item in items) return g The items can be any type accepted by the operand’s __getitem__() method. Dictionaries accept any hashable value. Lists, tuples, and strings accept an index or a slice: >>> itemgetter(1)('ABCDEFG') 'B' >>> itemgetter(1, 3, 5)('ABCDEFG') ('B', 'D', 'F') >>> itemgetter(slice(2, None))('ABCDEFG') 'CDEFG' >>> soldier = dict(rank='captain', name='dotterbart') >>> itemgetter('rank')(soldier) 'captain' Example of using itemgetter() to retrieve specific fields from a tuple record: >>> inventory = [('apple', 3), ('banana', 2), ('pear', 5), ('orange', 1)] >>> getcount = itemgetter(1) >>> list(map(getcount, inventory)) [3, 2, 5, 1] >>> sorted(inventory, key=getcount) [('orange', 1), ('banana', 2), ('apple', 3), ('pear', 5)] operator.methodcaller(name, /, *args, **kwargs) Return a callable object that calls the method name on its operand. If additional", "score": "0.6722035"}, {"id": "42665", "text": "Function: numpy.reference.generated.numpy.bitwise_xor\nSnippet: numpy.bitwise_xor numpy.bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'bitwise_xor'> Compute the bit-wise XOR of two arrays element-wise. Computes the bit-wise XOR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator ^. Parameters x1, x2array_like Only integer and boolean types are handled. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Result. This is a scalar if both x1 and x2 are scalars. See also logical_xor bitwise_and bitwise_or binary_repr Return the binary representation of the input number as a string. Examples The number 13 is represented by 00001101. Likewise, 17 is represented by 00010001. The bit-wise XOR of 13 and 17 is therefore 00011100, or 28: >>> np.bitwise_xor(13, 17) 28 >>> np.binary_repr(28) '11100' >>> np.bitwise_xor(31, 5) 26 >>> np.bitwise_xor([31,3], 5) array([26, 6]) >>> np.bitwise_xor([31,3], [5,6]) array([26, 5]) >>> np.bitwise_xor([True, True], [False, True]) array([ True, False]) The ^ operator can be used as a shorthand for np.bitwise_xor on ndarrays. >>> x1 = np.array([True, True]) >>> x2 = np.array([False, True]) >>> x1 ^ x2 array([ True, False])", "score": "0.66966116"}]}
{"task_id": "mbpp_167", "code": "def next_Power_Of_2(n): \r\n    count = 0; \r\n    if (n and not(n & (n - 1))): \r\n        return n   \r\n    while( n != 0): \r\n        n >>= 1\r\n        count += 1\r\n    return 1 << count; ", "test_list": ["assert next_Power_Of_2(0) == 1", "assert next_Power_Of_2(5) == 8", "assert next_Power_Of_2(17) == 32"], "context": "Write a python function to find smallest power of 2 greater than or equal to n.", "function_name": "def next_Power_Of_2(n):", "gold_generation": "count = 0; \r\n    if (n and not(n & (n - 1))): \r\n        return n   \r\n    while( n != 0): \r\n        n >>= 1\r\n        count += 1\r\n    return 1 << count;", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.7431103"}, {"id": "21813", "text": "Function: python.library.math#math.lcm\nSnippet: math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9.", "score": "0.67321086"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.67318594"}, {"id": "21825", "text": "Function: python.library.math#math.pow\nSnippet: math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError. Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers.", "score": "0.6705037"}, {"id": "21776", "text": "Function: python.library.math\nSnippet: (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9. Note that frexp() and modf() have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 2**52 necessarily has no fractional bits. Power and logarithmic functions math.exp(x) Return e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). math.expm1(x) Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision: >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.0000050000069649e-05 >>> expm1(1e-5) # result accurate to full precision 1.0000050000166668e-05 New in version 3.2. math.log(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). math.log1p(x) Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. math.log2(x) Return the base-2 logarithm of x. This is usually more accurate than log(x, 2). New in version 3.3. See also int.bit_length() returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. math.log10(x) Return the base-10 logarithm of x. This is usually more accurate than log(x, 10). math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", "score": "0.67038417"}]}
{"task_id": "mbpp_168", "code": "def frequency(a,x): \r\n    count = 0  \r\n    for i in a: \r\n        if i == x: count += 1\r\n    return count ", "test_list": ["assert frequency([1,2,3],4) == 0", "assert frequency([1,2,2,3,3,3,4],3) == 3", "assert frequency([0,1,2,3,1,2],1) == 2"], "context": "Write a python function to find the frequency of a number in a given array.", "function_name": "def frequency(a,x):", "gold_generation": "count = 0  \r\n    for i in a: \r\n        if i == x: count += 1\r\n    return count", "ctxs": [{"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.7416646"}, {"id": "14927", "text": "Function: pandas.reference.api.pandas.period.freq\nSnippet: pandas.Period.freq Period.freq", "score": "0.71567655"}, {"id": "15131", "text": "Function: pandas.reference.api.pandas.series.dt.freq\nSnippet: pandas.Series.dt.freq Series.dt.freq", "score": "0.6987338"}, {"id": "15446", "text": "Function: pandas.reference.api.pandas.timedelta.freq\nSnippet: pandas.Timedelta.freq Timedelta.freq", "score": "0.6965175"}, {"id": "15497", "text": "Function: pandas.reference.api.pandas.timestamp.freq\nSnippet: pandas.Timestamp.freq Timestamp.freq", "score": "0.6936373"}]}
{"task_id": "mbpp_169", "code": "def get_pell(n): \r\n\tif (n <= 2): \r\n\t\treturn n \r\n\ta = 1\r\n\tb = 2\r\n\tfor i in range(3, n+1): \r\n\t\tc = 2 * b + a \r\n\t\ta = b \r\n\t\tb = c \r\n\treturn b ", "test_list": ["assert get_pell(4) == 12", "assert get_pell(7) == 169", "assert get_pell(8) == 408"], "context": "Write a function to calculate the nth pell number.", "function_name": "def get_pell(n):", "gold_generation": "if (n <= 2): \r\n\t\treturn n \r\n\ta = 1\r\n\tb = 2\r\n\tfor i in range(3, n+1): \r\n\t\tc = 2 * b + a \r\n\t\ta = b \r\n\t\tb = c \r\n\treturn b", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.694395"}, {"id": "35797", "text": "Function: django.ref.models.database-functions#django.db.models.functions.NthValue\nSnippet: class NthValue(expression, nth=1, **extra)", "score": "0.67568386"}, {"id": "43079", "text": "Function: numpy.reference.generated.numpy.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.66939735"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.66382205"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.66187966"}]}
{"task_id": "mbpp_170", "code": "def sum_range_list(list1, m, n):                                                                                                                                                                                                \r\n    sum_range = 0                                                                                                                                                                                                         \r\n    for i in range(m, n+1, 1):                                                                                                                                                                                        \r\n        sum_range += list1[i]                                                                                                                                                                                                  \r\n    return sum_range   ", "test_list": ["assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],8,10)==29", "assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],5,7)==16", "assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],7,10)==38"], "context": "Write a function to find sum of the numbers in a list between the indices of a specified range.", "function_name": "def sum_range_list(list1, m, n):", "gold_generation": "sum_range = 0                                                                                                                                                                                                         \r\n    for i in range(m, n+1, 1):                                                                                                                                                                                        \r\n        sum_range += list1[i]                                                                                                                                                                                                  \r\n    return sum_range", "ctxs": [{"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.7019106"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.68741775"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.68102396"}, {"id": "42345", "text": "Function: numpy.reference.generated.numpy.ma.sum\nSnippet: numpy.ma.sum ma.sum(self, axis=None, dtype=None, out=None, keepdims=<no value>) = <numpy.ma.core._frommethod object> Return the sum of the array elements over the given axis. Masked elements are set to 0 internally. Refer to numpy.sum for full documentation. See also numpy.ndarray.sum corresponding function for ndarrays numpy.sum equivalent function Examples >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4) >>> x masked_array( data=[[1, --, 3], [--, 5, --], [7, --, 9]], mask=[[False, True, False], [ True, False, True], [False, True, False]], fill_value=999999) >>> x.sum() 25 >>> x.sum(axis=1) masked_array(data=[4, 5, 16], mask=[False, False, False], fill_value=999999) >>> x.sum(axis=0) masked_array(data=[8, 5, 12], mask=[False, False, False], fill_value=999999) >>> print(type(x.sum(axis=0, dtype=np.int64)[0])) <class 'numpy.int64'>", "score": "0.6796349"}, {"id": "43881", "text": "Function: numpy.reference.generated.numpy.recarray.sum\nSnippet: numpy.recarray.sum method recarray.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True) Return the sum of the array elements over the given axis. Refer to numpy.sum for full documentation. See also numpy.sum equivalent function", "score": "0.6772437"}]}
{"task_id": "mbpp_171", "code": "import math\r\ndef perimeter_pentagon(a):\r\n  perimeter=(5*a)\r\n  return perimeter", "test_list": ["assert perimeter_pentagon(5)==25", "assert perimeter_pentagon(10)==50", "assert perimeter_pentagon(15)==75"], "context": "Write a function to find the perimeter of a pentagon.", "function_name": "import math\r\ndef perimeter_pentagon(a):", "gold_generation": "perimeter=(5*a)\r\n  return perimeter", "ctxs": [{"id": "36357", "text": "Function: django.ref.contrib.gis.functions#django.contrib.gis.db.models.functions.Perimeter\nSnippet: class Perimeter(expression, **extra)", "score": "0.69574416"}, {"id": "14476", "text": "Function: pandas.reference.api.pandas.dataframe.rpow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.65432703"}, {"id": "14467", "text": "Function: pandas.reference.api.pandas.dataframe.rfloordiv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6494002"}, {"id": "13179", "text": "Function: pygame.ref.draw\nSnippet: the given surface. The line has a thickness of one pixel and the endpoints have a height and width of one pixel each. The way a line and it's endpoints are drawn: If both endpoints are equal, only a single pixel is drawn (after rounding floats to nearest integer). Otherwise if the line is not steep (i.e. if the length along the x-axis is greater than the height along the y-axis): For each endpoint: If x, the endpoint's x-coordinate, is a whole number find which pixels would be covered by it and draw them. Otherwise: Calculate the position of the nearest point with a whole number for it's x-coordinate, when extending the line past the endpoint. Find which pixels would be covered and how much by that point. If the endpoint is the left one, multiply the coverage by (1 - the decimal part of x). Otherwise multiply the coverage by the decimal part of x. Then draw those pixels. e.g.: The left endpoint of the line ((1, 1.3), (5, 3)) would cover 70% of the pixel (1, 1) and 30% of the pixel (1, 2) while the right one would cover 100% of the pixel (5, 3). The left endpoint of the line ((1.2, 1.4), (4.6, 3.1)) would cover 56% (i.e. 0.8 * 70%) of the pixel (1, 1) and 24% (i.e. 0.8 * 30%) of the pixel (1, 2) while the right one would cover 42% (i.e. 0.6 * 70%) of the pixel (5, 3) and 18% (i.e. 0.6 * 30%) of the pixel (5, 4) while the right Then for each point between the endpoints, along the line, whose x-coordinate is a whole number: Find which pixels would be covered and how much by that point and draw them. e.g.: The points along the line ((1, 1), (4, 2.5)) would be (2, 1.5) and (3, 2) and would cover 50% of the pixel (2, 1), 50% of the pixel (2, 2) and 100% of the pixel (3, 2). The points along the line ((1.2, 1.4), (4.6, 3.1)) would be (2, 1.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)), (3, 2.3) (covering 70% of the pixel (3, 2) and 30% of the pixel (3, 3)) and (4, 2.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)) Otherwise do the same for steep lines as for non-steep lines except along the y-axis instead of the x-axis (using y instead of x, top instead of left and bottom instead of right). Note Regarding float values for coordinates, a point with coordinate consisting of two whole numbers is considered being right in the center of said pixel (and having a height and width of 1 pixel would therefore completely cover it), while a point with coordinate where one (or both) of the numbers have non-zero decimal parts would be partially covering two (or four if both numbers have decimal parts) adjacent pixels, e.g. the point (1.4, 2) covers", "score": "0.64472115"}, {"id": "14447", "text": "Function: pandas.reference.api.pandas.dataframe.radd\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6426725"}]}
{"task_id": "mbpp_172", "code": "def count_occurance(s):\r\n  count=0\r\n  for i in range(len(s)):\r\n    if (s[i]== 's' and s[i+1]=='t' and s[i+2]== 'd'):\r\n      count = count + 1\r\n  return count", "test_list": ["assert count_occurance(\"letstdlenstdporstd\") == 3", "assert count_occurance(\"truststdsolensporsd\") == 1", "assert count_occurance(\"makestdsostdworthit\") == 2"], "context": "Write a function to find the occurence of characters 'std' in the given string 1. list item 1. list item 1. list item 2. list item 2. list item 2. list item", "function_name": "def count_occurance(s):", "gold_generation": "count=0\r\n  for i in range(len(s)):\r\n    if (s[i]== 's' and s[i+1]=='t' and s[i+2]== 'd'):\r\n      count = count + 1\r\n  return count", "ctxs": [{"id": "24346", "text": "Function: python.library.stdtypes#str.find\nSnippet: str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True", "score": "0.72191334"}, {"id": "41724", "text": "Function: numpy.reference.generated.numpy.char.find\nSnippet: numpy.char.find char.find(a, sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. Calls str.find element-wise. For each element, return the lowest index in the string where substring sub is found, such that sub is contained in the range [start, end]. Parameters aarray_like of str or unicode substr or unicode start, endint, optional Optional arguments start and end are interpreted as in slice notation. Returns outndarray or int Output array of ints. Returns -1 if sub is not found. See also str.find", "score": "0.71302116"}, {"id": "24349", "text": "Function: python.library.stdtypes#str.index\nSnippet: str.index(sub[, start[, end]]) Like find(), but raise ValueError when the substring is not found.", "score": "0.70824856"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.69958144"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6990851"}]}
{"task_id": "mbpp_173", "code": "import re\r\ndef remove_splchar(text): \r\n pattern = re.compile('[\\W_]+')\r\n return (pattern.sub('', text))", "test_list": ["assert remove_splchar('python  @#&^%$*program123')==('pythonprogram123')", "assert remove_splchar('python %^$@!^&*()  programming24%$^^()    language')==('pythonprogramming24language')", "assert remove_splchar('python   ^%&^()(+_)(_^&67)                  program')==('python67program')"], "context": "Write a function to remove everything except alphanumeric characters from a string.", "function_name": "import re\r\ndef remove_splchar(text):", "gold_generation": "pattern = re.compile('[\\W_]+')\r\n return (pattern.sub('', text))", "ctxs": [{"id": "41823", "text": "Function: numpy.reference.generated.numpy.chararray.strip\nSnippet: numpy.chararray.strip method chararray.strip(chars=None)[source] For each element in self, return a copy with the leading and trailing characters removed. See also char.strip", "score": "0.7123814"}, {"id": "41702", "text": "Function: numpy.reference.generated.numpy.char.chararray.strip\nSnippet: numpy.char.chararray.strip method char.chararray.strip(chars=None)[source] For each element in self, return a copy with the leading and trailing characters removed. See also char.strip", "score": "0.7114183"}, {"id": "41758", "text": "Function: numpy.reference.generated.numpy.char.strip\nSnippet: numpy.char.strip char.strip(a, chars=None)[source] For each element in a, return a copy with the leading and trailing characters removed. Calls str.strip element-wise. Parameters aarray-like of str or unicode charsstr or unicode, optional The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped. Returns outndarray Output array of str or unicode, depending on input type See also str.strip Examples >>> c = np.array(['aAaAaA', ' aA ', 'abBABba']) >>> c array(['aAaAaA', ' aA ', 'abBABba'], dtype='<U7') >>> np.char.strip(c) array(['aAaAaA', 'aA', 'abBABba'], dtype='<U7') >>> np.char.strip(c, 'a') # 'a' unstripped from c[1] because whitespace leads array(['AaAaA', ' aA ', 'bBABb'], dtype='<U7') >>> np.char.strip(c, 'A') # 'A' unstripped from c[1] because (unprinted) ws trails array(['aAaAa', ' aA ', 'abBABba'], dtype='<U7')", "score": "0.7104293"}, {"id": "41753", "text": "Function: numpy.reference.generated.numpy.char.rstrip\nSnippet: numpy.char.rstrip char.rstrip(a, chars=None)[source] For each element in a, return a copy with the trailing characters removed. Calls str.rstrip element-wise. Parameters aarray-like of str or unicode charsstr or unicode, optional The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped. Returns outndarray Output array of str or unicode, depending on input type See also str.rstrip Examples >>> c = np.array(['aAaAaA', 'abBABba'], dtype='S7'); c array(['aAaAaA', 'abBABba'], dtype='|S7') >>> np.char.rstrip(c, b'a') array(['aAaAaA', 'abBABb'], dtype='|S7') >>> np.char.rstrip(c, b'A') array(['aAaAa', 'abBABba'], dtype='|S7')", "score": "0.6991762"}, {"id": "24380", "text": "Function: python.library.stdtypes#str.strip\nSnippet: str.strip([chars]) Return a copy of the string with the leading and trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> ' spacious '.strip() 'spacious' >>> 'www.example.com'.strip('cmowz.') 'example' The outermost leading and trailing chars argument values are stripped from the string. Characters are removed from the leading end until reaching a string character that is not contained in the set of characters in chars. A similar action takes place on the trailing end. For example: >>> comment_string = '#....... Section 3.2.1 Issue #32 .......' >>> comment_string.strip('.#! ') 'Section 3.2.1 Issue #32'", "score": "0.6879157"}]}
{"task_id": "mbpp_174", "code": "def group_keyvalue(l):\r\n    result = {}\r\n    for k, v in l:\r\n         result.setdefault(k, []).append(v)\r\n    return result", "test_list": ["assert group_keyvalue([('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)])=={'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}", "assert group_keyvalue([('python', 1), ('python', 2), ('python', 3), ('python', 4), ('python', 5)])=={'python': [1,2,3,4,5]}", "assert group_keyvalue([('yellow',100), ('blue', 200), ('yellow', 300), ('blue', 400), ('red', 100)])=={'yellow': [100, 300], 'blue': [200, 400], 'red': [100]}"], "context": "Write a function to group a sequence of key-value pairs into a dictionary of lists.", "function_name": "def group_keyvalue(l):", "gold_generation": "result = {}\r\n    for k, v in l:\r\n         result.setdefault(k, []).append(v)\r\n    return result", "ctxs": [{"id": "21308", "text": "Function: python.library.itertools#itertools.groupby\nSnippet: itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a break or new group every time the value of the key function changes (which is why it is usually necessary to have sorted the data using the same key function). That behavior differs from SQL’s GROUP BY which aggregates common elements regardless of their input order. The returned group is itself an iterator that shares the underlying iterable with groupby(). Because the source is shared, when the groupby() object is advanced, the previous group is no longer visible. So, if that data is needed later, it should be stored as a list: groups = [] uniquekeys = [] data = sorted(data, key=keyfunc) for k, g in groupby(data, keyfunc): groups.append(list(g)) # Store group iterator as a list uniquekeys.append(k) groupby() is roughly equivalent to: class groupby: # [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B # [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D def __init__(self, iterable, key=None): if key is None: key = lambda x: x self.keyfunc = key self.it = iter(iterable) self.tgtkey = self.currkey = self.currvalue = object() def __iter__(self): return self def __next__(self): self.id = object() while self.currkey == self.tgtkey: self.currvalue = next(self.it) # Exit on StopIteration self.currkey = self.keyfunc(self.currvalue) self.tgtkey = self.currkey return (self.currkey, self._grouper(self.tgtkey, self.id)) def _grouper(self, tgtkey, id): while self.id is id and self.currkey == tgtkey: yield self.currvalue try: self.currvalue = next(self.it) except StopIteration: return self.currkey = self.keyfunc(self.currvalue)", "score": "0.69290555"}, {"id": "21292", "text": "Function: python.library.itertools\nSnippet: break or new group every time the value of the key function changes (which is why it is usually necessary to have sorted the data using the same key function). That behavior differs from SQL’s GROUP BY which aggregates common elements regardless of their input order. The returned group is itself an iterator that shares the underlying iterable with groupby(). Because the source is shared, when the groupby() object is advanced, the previous group is no longer visible. So, if that data is needed later, it should be stored as a list: groups = [] uniquekeys = [] data = sorted(data, key=keyfunc) for k, g in groupby(data, keyfunc): groups.append(list(g)) # Store group iterator as a list uniquekeys.append(k) groupby() is roughly equivalent to: class groupby: # [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B # [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D def __init__(self, iterable, key=None): if key is None: key = lambda x: x self.keyfunc = key self.it = iter(iterable) self.tgtkey = self.currkey = self.currvalue = object() def __iter__(self): return self def __next__(self): self.id = object() while self.currkey == self.tgtkey: self.currvalue = next(self.it) # Exit on StopIteration self.currkey = self.keyfunc(self.currvalue) self.tgtkey = self.currkey return (self.currkey, self._grouper(self.tgtkey, self.id)) def _grouper(self, tgtkey, id): while self.id is id and self.currkey == tgtkey: yield self.currvalue try: self.currvalue = next(self.it) except StopIteration: return self.currkey = self.keyfunc(self.currvalue) itertools.islice(iterable, stop) itertools.islice(iterable, start, stop[, step]) Make an iterator that returns selected elements from the iterable. If start is non-zero, then elements from the iterable are skipped until start is reached. Afterward, elements are returned consecutively unless step is set higher than one which results in items being skipped. If stop is None, then iteration continues until the iterator is exhausted, if at all; otherwise, it stops at the specified position. Unlike regular slicing, islice() does not support negative values for start, stop, or step. Can be used to extract related fields from data where the internal structure has been flattened (for example, a multi-line report may list a name field on every third line). Roughly equivalent to: def islice(iterable, *args): # islice('ABCDEFG', 2) --> A B # islice('ABCDEFG', 2, 4) --> C D # islice('ABCDEFG', 2, None) --> C D E F G # islice('ABCDEFG', 0, None, 2) --> A C E G s = slice(*args) start, stop, step = s.start or 0, s.stop or sys.maxsize, s.step or 1 it = iter(range(start, stop, step)) try: nexti = next(it) except StopIteration: # Consume *iterable* up to the *start* position. for i, element in zip(range(start), iterable): pass return try: for i, element in enumerate(iterable): if i == nexti: yield element nexti = next(it) except StopIteration: # Consume to *stop*. for i, element in zip(range(i + 1, stop), iterable): pass If start is None, then iteration starts at zero. If step is None, then the step defaults to one. itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults", "score": "0.6839006"}, {"id": "8549", "text": "Function: werkzeug.datastructures.index#werkzeug.datastructures.MultiDict.lists\nSnippet: lists() Return a iterator of (key, values) pairs, where values is the list of all values associated with the key.", "score": "0.66977376"}, {"id": "42756", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.as_list\nSnippet: numpy.distutils.misc_util.as_list(seq)[source]", "score": "0.66912687"}, {"id": "25767", "text": "Function: python.library.stdtypes\nSnippet: be created by placing a comma-separated list of key: value pairs within braces, for example: {'jack': 4098, 'sjoerd': 4127} or {4098: 'jack', 4127: 'sjoerd'}, or by the dict constructor. class dict(**kwarg) class dict(mapping, **kwarg) class dict(iterable, **kwarg) Return a new dictionary initialized from an optional positional argument and a possibly empty set of keyword arguments. Dictionaries can be created by several means: Use a comma-separated list of key: value pairs within braces: {'jack': 4098, 'sjoerd': 4127} or {4098: 'jack', 4127: 'sjoerd'} Use a dict comprehension: {}, {x: x ** 2 for x in range(10)} Use the type constructor: dict(), dict([('foo', 100), ('bar', 200)]), dict(foo=100, bar=200) If no positional argument is given, an empty dictionary is created. If a positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object. Otherwise, the positional argument must be an iterable object. Each item in the iterable must itself be an iterable with exactly two objects. The first object of each item becomes a key in the new dictionary, and the second object the corresponding value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary. If keyword arguments are given, the keyword arguments and their values are added to the dictionary created from the positional argument. If a key being added is already present, the value from the keyword argument replaces the value from the positional argument. To illustrate, the following examples all return a dictionary equal to {\"one\": 1, \"two\": 2, \"three\": 3}: >>> a = dict(one=1, two=2, three=3) >>> b = {'one': 1, 'two': 2, 'three': 3} >>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3])) >>> d = dict([('two', 2), ('one', 1), ('three', 3)]) >>> e = dict({'three': 3, 'one': 1, 'two': 2}) >>> f = dict({'one': 1, 'three': 3}, two=2) >>> a == b == c == d == e == f True Providing keyword arguments as in the first example only works for keys that are valid Python identifiers. Otherwise, any valid keys can be used. These are the operations that dictionaries support (and therefore, custom mapping types should support too): list(d) Return a list of all the keys used in the dictionary d. len(d) Return the number of items in the dictionary d. d[key] Return the item of d with key key. Raises a KeyError if key is not in the map. If a subclass of dict defines a method __missing__() and key is not present, the d[key] operation calls that method with the key key as argument. The d[key] operation then returns or raises whatever is returned or raised by the __missing__(key) call. No other operations or methods invoke __missing__(). If __missing__() is not defined, KeyError is raised. __missing__() must be a method; it cannot be an instance variable: >>> class Counter(dict): ... def __missing__(self, key): ... return 0 >>> c = Counter() >>> c['red'] 0 >>> c['red'] += 1 >>> c['red'] 1", "score": "0.65729403"}]}
{"task_id": "mbpp_175", "code": "def is_valid_parenthese( str1):\r\n        stack, pchar = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\r\n        for parenthese in str1:\r\n            if parenthese in pchar:\r\n                stack.append(parenthese)\r\n            elif len(stack) == 0 or pchar[stack.pop()] != parenthese:\r\n                return False\r\n        return len(stack) == 0", "test_list": ["assert is_valid_parenthese(\"(){}[]\")==True", "assert is_valid_parenthese(\"()[{)}\")==False", "assert is_valid_parenthese(\"()\")==True"], "context": "Write a function to verify validity of a string of parentheses.", "function_name": "def is_valid_parenthese( str1):", "gold_generation": "stack, pchar = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\r\n        for parenthese in str1:\r\n            if parenthese in pchar:\r\n                stack.append(parenthese)\r\n            elif len(stack) == 0 or pchar[stack.pop()] != parenthese:\r\n                return False\r\n        return len(stack) == 0", "ctxs": [{"id": "23302", "text": "Function: python.library.re\nSnippet: a FutureWarning will be raised in ambiguous cases for the time being. That includes sets starting with a literal '[' or containing literal character sequences '--', '&&', '~~', and '||'. To avoid a warning escape them with a backslash. Changed in version 3.7: FutureWarning is raised if a character set contains constructs that will change semantically in the future. | A|B, where A and B can be arbitrary REs, creates a regular expression that will match either A or B. An arbitrary number of REs can be separated by the '|' in this way. This can be used inside groups (see below) as well. As the target string is scanned, REs separated by '|' are tried from left to right. When one pattern completely matches, that branch is accepted. This means that once A matches, B will not be tested further, even if it would produce a longer overall match. In other words, the '|' operator is never greedy. To match a literal '|', use \\|, or enclose it inside a character class, as in [|]. (...) Matches whatever regular expression is inside the parentheses, and indicates the start and end of a group; the contents of a group can be retrieved after a match has been performed, and can be matched later in the string with the \\number special sequence, described below. To match the literals '(' or ')', use \\( or \\), or enclose them inside a character class: [(], [)]. (?...) This is an extension notation (a '?' following a '(' is not meaningful otherwise). The first character after the '?' determines what the meaning and further syntax of the construct is. Extensions usually do not create a new group; (?P<name>...) is the only exception to this rule. Following are the currently supported extensions. (?aiLmsux) (One or more letters from the set 'a', 'i', 'L', 'm', 's', 'u', 'x'.) The group matches the empty string; the letters set the corresponding flags: re.A (ASCII-only matching), re.I (ignore case), re.L (locale dependent), re.M (multi-line), re.S (dot matches all), re.U (Unicode matching), and re.X (verbose), for the entire regular expression. (The flags are described in Module Contents.) This is useful if you wish to include the flags as part of the regular expression, instead of passing a flag argument to the re.compile() function. Flags should be used first in the expression string. (?:...) A non-capturing version of regular parentheses. Matches whatever regular expression is inside the parentheses, but the substring matched by the group cannot be retrieved after performing a match or referenced later in the pattern. (?aiLmsux-imsx:...) (Zero or more letters from the set 'a', 'i', 'L', 'm', 's', 'u', 'x', optionally followed by '-' followed by one or more letters from the 'i', 'm', 's', 'x'.) The letters set or remove the corresponding flags: re.A (ASCII-only matching), re.I (ignore case), re.L (locale dependent), re.M (multi-line), re.S (dot matches all), re.U (Unicode matching), and re.X (verbose), for the part of the expression. (The flags are described in Module Contents.)", "score": "0.6662032"}, {"id": "41668", "text": "Function: numpy.reference.generated.numpy.char.chararray.istitle\nSnippet: numpy.char.chararray.istitle method char.chararray.istitle()[source] Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. See also char.istitle", "score": "0.6642848"}, {"id": "17667", "text": "Function: python.library.ast#ast.And\nSnippet: class ast.And class ast.Or Boolean operator tokens.", "score": "0.6634866"}, {"id": "23300", "text": "Function: python.library.re\nSnippet: For further information and a gentler presentation, consult the Regular Expression HOWTO. Regular expressions can contain both special and ordinary characters. Most ordinary characters, like 'A', 'a', or '0', are the simplest regular expressions; they simply match themselves. You can concatenate ordinary characters, so last matches the string 'last'. (In the rest of this section, we’ll write RE’s in this special style, usually without quotes, and strings to be matched 'in single quotes'.) Some characters, like '|' or '(', are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. Repetition qualifiers (*, +, ?, {m,n}, etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix ?, and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression (?:a{6})* matches any multiple of six 'a' characters. The special characters are: . (Dot.) In the default mode, this matches any character except a newline. If the DOTALL flag has been specified, this matches any character including a newline. ^ (Caret.) Matches the start of the string, and in MULTILINE mode also matches immediately after each newline. $ Matches the end of the string or just before the newline at the end of the string, and in MULTILINE mode also matches before a newline. foo matches both ‘foo’ and ‘foobar’, while the regular expression foo$ matches only ‘foo’. More interestingly, searching for foo.$ in 'foo1\\nfoo2\\n' matches ‘foo2’ normally, but ‘foo1’ in MULTILINE mode; searching for a single $ in 'foo\\n' will find two (empty) matches: one just before the newline, and one at the end of the string. * Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. ab* will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s. + Causes the resulting RE to match 1 or more repetitions of the preceding RE. ab+ will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’. ? Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. ab? will match either ‘a’ or ‘ab’. *?, +?, ?? The '*', '+', and '?' qualifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE <.*> is matched against '<a> b <c>', it will match the entire string, and not just '<a>'. Adding ? after the qualifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using the RE <.*?> will match only '<a>'. {m} Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, a{6} will match exactly six 'a' characters, but not five. {m,n} Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many", "score": "0.66322964"}, {"id": "25948", "text": "Function: python.library.unittest\nSnippet: <= than second depending on the method name. If not, the test will fail: >>> self.assertGreaterEqual(3, 4) AssertionError: \"3\" unexpectedly not greater than or equal to \"4\" New in version 3.1. assertRegex(text, regex, msg=None) assertNotRegex(text, regex, msg=None) Test that a regex search matches (or does not match) text. In case of failure, the error message will include the pattern and the text (or the pattern and the part of text that unexpectedly matched). regex may be a regular expression object or a string containing a regular expression suitable for use by re.search(). New in version 3.1: Added under the name assertRegexpMatches. Changed in version 3.2: The method assertRegexpMatches() has been renamed to assertRegex(). New in version 3.2: assertNotRegex(). New in version 3.5: The name assertNotRegexpMatches is a deprecated alias for assertNotRegex(). assertCountEqual(first, second, msg=None) Test that sequence first contains the same elements as second, regardless of their order. When they don’t, an error message listing the differences between the sequences will be generated. Duplicate elements are not ignored when comparing first and second. It verifies whether each element has the same count in both sequences. Equivalent to: assertEqual(Counter(list(first)), Counter(list(second))) but works with sequences of unhashable objects as well. New in version 3.2. The assertEqual() method dispatches the equality check for objects of the same type to different type-specific methods. These methods are already implemented for most of the built-in types, but it’s also possible to register new methods using addTypeEqualityFunc(): addTypeEqualityFunc(typeobj, function) Registers a type-specific method called by assertEqual() to check if two objects of exactly the same typeobj (not subclasses) compare equal. function must take two positional arguments and a third msg=None keyword argument just as assertEqual() does. It must raise self.failureException(msg) when inequality between the first two parameters is detected – possibly providing useful information and explaining the inequalities in details in the error message. New in version 3.1. The list of type-specific methods automatically used by assertEqual() are summarized in the following table. Note that it’s usually not necessary to invoke these methods directly. Method Used to compare New in assertMultiLineEqual(a, b) strings 3.1 assertSequenceEqual(a, b) sequences 3.1 assertListEqual(a, b) lists 3.1 assertTupleEqual(a, b) tuples 3.1 assertSetEqual(a, b) sets or frozensets 3.1 assertDictEqual(a, b) dicts 3.1 assertMultiLineEqual(first, second, msg=None) Test that the multiline string first is equal to the string second. When not equal a diff of the two strings highlighting the differences will be included in the error message. This method is used by default when comparing strings with assertEqual(). New in version 3.1. assertSequenceEqual(first, second, msg=None, seq_type=None) Tests that two sequences are equal. If a seq_type is supplied, both first and second must be instances of seq_type or a failure will be raised. If the sequences are different an error message is constructed that shows the difference between the two. This method is not called directly by assertEqual(), but it’s used to implement assertListEqual() and assertTupleEqual(). New in version 3.1. assertListEqual(first, second, msg=None) assertTupleEqual(first, second, msg=None) Tests that two lists or tuples are equal. If", "score": "0.6630023"}]}
{"task_id": "mbpp_176", "code": "def perimeter_triangle(a,b,c):\r\n  perimeter=a+b+c\r\n  return perimeter", "test_list": ["assert perimeter_triangle(10,20,30)==60", "assert perimeter_triangle(3,4,5)==12", "assert perimeter_triangle(25,35,45)==105"], "context": "Write a function to find the perimeter of a triangle.", "function_name": "def perimeter_triangle(a,b,c):", "gold_generation": "perimeter=a+b+c\r\n  return perimeter", "ctxs": [{"id": "36357", "text": "Function: django.ref.contrib.gis.functions#django.contrib.gis.db.models.functions.Perimeter\nSnippet: class Perimeter(expression, **extra)", "score": "0.6926226"}, {"id": "14324", "text": "Function: pandas.reference.api.pandas.dataframe.div\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.67007786"}, {"id": "14476", "text": "Function: pandas.reference.api.pandas.dataframe.rpow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.668845"}, {"id": "14480", "text": "Function: pandas.reference.api.pandas.dataframe.rtruediv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.66259575"}, {"id": "33487", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: barbs_doc='\\nPlot a 2D field of barbs.\\n\\nCall signature::\\n\\n barbs([X, Y], U, V, [C], **kw)\\n\\nWhere *X*, *Y* define the barb locations, *U*, *V* define the barb\\ndirections, and *C* optionally sets the color.\\n\\nAll arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked\\n*X*, *Y* are not supported at present.\\n\\nBarbs are traditionally used in meteorology as a way to plot the speed\\nand direction of wind observations, but can technically be used to\\nplot any two dimensional vector quantity. As opposed to arrows, which\\ngive vector magnitude by the length of the arrow, the barbs give more\\nquantitative information about the vector magnitude by putting slanted\\nlines or a triangle for various increments in magnitude, as show\\nschematically below::\\n\\n : /\\\\ \\\\\\n : / \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : ------------------------------\\n\\nThe largest increment is given by a triangle (or \"flag\"). After those\\ncome full lines (barbs). The smallest increment is a half line. There\\nis only, of course, ever at most 1 half line. If the magnitude is\\nsmall and only needs a single half-line and no full lines or\\ntriangles, the half-line is offset from the end of the barb so that it\\ncan be easily distinguished from barbs with a single full line. The\\nmagnitude for the barb shown above would nominally be 65, using the\\nstandard increments of 50, 10, and 5.\\n\\nSee also https://en.wikipedia.org/wiki/Wind_barb.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the barb locations. See *pivot* for how the\\n barbs are drawn to the x, y positions.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y components of the barb shaft.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If", "score": "0.66098315"}]}
{"task_id": "mbpp_177", "code": "def answer(L,R): \r\n    if (2 * L <= R): \r\n        return (L ,2*L)\r\n    else: \r\n        return (-1) ", "test_list": ["assert answer(3,8) == (3,6)", "assert answer(2,6) == (2,4)", "assert answer(1,3) == (1,2)"], "context": "Write a python function to find two distinct numbers such that their lcm lies within the given range.", "function_name": "def answer(L,R):", "gold_generation": "if (2 * L <= R): \r\n        return (L ,2*L)\r\n    else: \r\n        return (-1)", "ctxs": [{"id": "21813", "text": "Function: python.library.math#math.lcm\nSnippet: math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9.", "score": "0.7413178"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.7404843"}, {"id": "42933", "text": "Function: numpy.reference.generated.numpy.lcm\nSnippet: numpy.lcm numpy.lcm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'lcm'> Returns the lowest common multiple of |x1| and |x2| Parameters x1, x2array_like, int Arrays of values. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). Returns yndarray or scalar The lowest common multiple of the absolute value of the inputs This is a scalar if both x1 and x2 are scalars. See also gcd The greatest common divisor Examples >>> np.lcm(12, 20) 60 >>> np.lcm.reduce([3, 12, 20]) 60 >>> np.lcm.reduce([40, 12, 20]) 120 >>> np.lcm(np.arange(6), 20) array([ 0, 20, 20, 60, 20, 20])", "score": "0.7095419"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.67729914"}, {"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.6761322"}]}
{"task_id": "mbpp_178", "code": "import re\r\ndef string_literals(patterns,text):\r\n  for pattern in patterns:\r\n     if re.search(pattern,  text):\r\n       return ('Matched!')\r\n     else:\r\n       return ('Not Matched!')", "test_list": ["assert string_literals(['language'],'python language')==('Matched!')", "assert string_literals(['program'],'python language')==('Not Matched!')", "assert string_literals(['python'],'programming language')==('Not Matched!')"], "context": "Write a function to search some literals strings in a string.", "function_name": "import re\r\ndef string_literals(patterns,text):", "gold_generation": "for pattern in patterns:\r\n     if re.search(pattern,  text):\r\n       return ('Matched!')\r\n     else:\r\n       return ('Not Matched!')", "ctxs": [{"id": "24349", "text": "Function: python.library.stdtypes#str.index\nSnippet: str.index(sub[, start[, end]]) Like find(), but raise ValueError when the substring is not found.", "score": "0.71853656"}, {"id": "23361", "text": "Function: python.library.re#re.Pattern.search\nSnippet: Pattern.search(string[, pos[, endpos]]) Scan through string looking for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\"", "score": "0.70152664"}, {"id": "23315", "text": "Function: python.library.re\nSnippet: ['carefully', 'quickly'] Finding all Adverbs and their Positions If one wants more information about all matches of a pattern than the matched text, finditer() is useful as it provides match objects instead of strings. Continuing with the previous example, if a writer wanted to find all of the adverbs and their positions in some text, they would use finditer() in the following manner: >>> text = \"He was carefully disguised but captured quickly by police.\" >>> for m in re.finditer(r\"\\w+ly\", text): ... print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0))) 07-16: carefully 40-47: quickly Raw String Notation Raw string notation (r\"text\") keeps regular expressions sane. Without it, every backslash ('\\') in a regular expression would have to be prefixed with another one to escape it. For example, the two following lines of code are functionally identical: >>> re.match(r\"\\W(.)\\1\\W\", \" ff \") <re.Match object; span=(0, 4), match=' ff '> >>> re.match(\"\\\\W(.)\\\\1\\\\W\", \" ff \") <re.Match object; span=(0, 4), match=' ff '> When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, this means r\"\\\\\". Without raw string notation, one must use \"\\\\\\\\\", making the following lines of code functionally identical: >>> re.match(r\"\\\\\", r\"\\\\\") <re.Match object; span=(0, 1), match='\\\\'> >>> re.match(\"\\\\\\\\\", r\"\\\\\") <re.Match object; span=(0, 1), match='\\\\'> Writing a Tokenizer A tokenizer or scanner analyzes a string to categorize groups of characters. This is a useful first step in writing a compiler or interpreter. The text categories are specified with regular expressions. The technique is to combine those into a single master regular expression and to loop over successive matches: from typing import NamedTuple import re class Token(NamedTuple): type: str value: str line: int column: int def tokenize(code): keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'} token_specification = [ ('NUMBER', r'\\d+(\\.\\d*)?'), # Integer or decimal number ('ASSIGN', r':='), # Assignment operator ('END', r';'), # Statement terminator ('ID', r'[A-Za-z]+'), # Identifiers ('OP', r'[+\\-*/]'), # Arithmetic operators ('NEWLINE', r'\\n'), # Line endings ('SKIP', r'[ \\t]+'), # Skip over spaces and tabs ('MISMATCH', r'.'), # Any other character ] tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specification) line_num = 1 line_start = 0 for mo in re.finditer(tok_regex, code): kind = mo.lastgroup value = mo.group() column = mo.start() - line_start if kind == 'NUMBER': value = float(value) if '.' in value else int(value) elif kind == 'ID' and value in keywords: kind = value elif kind == 'NEWLINE': line_start = mo.end() line_num += 1 continue elif kind == 'SKIP': continue elif kind == 'MISMATCH': raise RuntimeError(f'{value!r} unexpected on line {line_num}') yield Token(kind, value, line_num, column) statements = ''' IF quantity THEN total := total + price * quantity; tax := price * 0.05; ENDIF; ''' for token in tokenize(statements): print(token) The tokenizer produces the following output: Token(type='IF', value='IF', line=2, column=4) Token(type='ID', value='quantity', line=2, column=7) Token(type='THEN', value='THEN', line=2, column=16) Token(type='ID', value='total', line=3, column=8) Token(type='ASSIGN', value=':=', line=3, column=14) Token(type='ID', value='total', line=3, column=17) Token(type='OP', value='+', line=3, column=23) Token(type='ID', value='price', line=3, column=25) Token(type='OP', value='*', line=3, column=31) Token(type='ID', value='quantity', line=3, column=33)", "score": "0.69807726"}, {"id": "24346", "text": "Function: python.library.stdtypes#str.find\nSnippet: str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True", "score": "0.6963191"}, {"id": "23310", "text": "Function: python.library.re\nSnippet: for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\" Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). Pattern.fullmatch(string[, pos[, endpos]]) If the whole string matches this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o[gh]\") >>> pattern.fullmatch(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.fullmatch(\"ogre\") # No match as not the full string matches. >>> pattern.fullmatch(\"doggie\", 1, 3) # Matches within given limits. <re.Match object; span=(1, 3), match='og'> New in version 3.4. Pattern.split(string, maxsplit=0) Identical to the split() function, using the compiled pattern. Pattern.findall(string[, pos[, endpos]]) Similar to the findall() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.finditer(string[, pos[, endpos]]) Similar to the finditer() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.sub(repl, string, count=0) Identical to the sub() function, using the compiled pattern. Pattern.subn(repl, string, count=0) Identical to the subn() function, using the compiled pattern. Pattern.flags The regex", "score": "0.6933985"}]}
{"task_id": "mbpp_179", "code": "def is_num_keith(x): \r\n\tterms = [] \r\n\ttemp = x \r\n\tn = 0 \r\n\twhile (temp > 0): \r\n\t\tterms.append(temp % 10) \r\n\t\ttemp = int(temp / 10) \r\n\t\tn+=1 \r\n\tterms.reverse() \r\n\tnext_term = 0 \r\n\ti = n \r\n\twhile (next_term < x): \r\n\t\tnext_term = 0 \r\n\t\tfor j in range(1,n+1): \r\n\t\t\tnext_term += terms[i - j] \r\n\t\tterms.append(next_term) \r\n\t\ti+=1 \r\n\treturn (next_term == x) ", "test_list": ["assert is_num_keith(14) == True", "assert is_num_keith(12) == False", "assert is_num_keith(197) == True"], "context": "Write a function to find if the given number is a keith number or not.", "function_name": "def is_num_keith(x):", "gold_generation": "terms = [] \r\n\ttemp = x \r\n\tn = 0 \r\n\twhile (temp > 0): \r\n\t\tterms.append(temp % 10) \r\n\t\ttemp = int(temp / 10) \r\n\t\tn+=1 \r\n\tterms.reverse() \r\n\tnext_term = 0 \r\n\ti = n \r\n\twhile (next_term < x): \r\n\t\tnext_term = 0 \r\n\t\tfor j in range(1,n+1): \r\n\t\t\tnext_term += terms[i - j] \r\n\t\tterms.append(next_term) \r\n\t\ti+=1 \r\n\treturn (next_term == x)", "ctxs": [{"id": "21811", "text": "Function: python.library.math#math.isnan\nSnippet: math.isnan(x) Return True if x is a NaN (not a number), and False otherwise.", "score": "0.67820215"}, {"id": "21810", "text": "Function: python.library.math#math.isinf\nSnippet: math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise.", "score": "0.6617457"}, {"id": "14026", "text": "Function: pandas.reference.api.pandas.api.types.is_number\nSnippet: pandas.api.types.is_number pandas.api.types.is_number(obj)[source] Check if the object is a number. Returns True when the object is a number, and False if is not. Parameters obj:any type The object to check if is a number. Returns is_number:bool Whether obj is a number or not. See also api.types.is_integer Checks a subgroup of numbers. Examples >>> from pandas.api.types import is_number >>> is_number(1) True >>> is_number(7.15) True Booleans are valid because they are int subclass. >>> is_number(False) True >>> is_number(\"foo\") False >>> is_number(\"5\") False", "score": "0.66062516"}, {"id": "19477", "text": "Function: python.library.decimal#decimal.Context.is_normal\nSnippet: is_normal(x) Returns True if x is a normal number; otherwise returns False.", "score": "0.6481382"}, {"id": "25730", "text": "Function: python.library.stdtypes\nSnippet: equivalent to is. The <, <=, > and >= operators are only defined where they make sense; for example, they raise a TypeError exception when one of the arguments is a complex number. Non-identical instances of a class normally compare as non-equal unless the class defines the __eq__() method. Instances of a class cannot be ordered with respect to other instances of the same class, or other types of object, unless the class defines enough of the methods __lt__(), __le__(), __gt__(), and __ge__() (in general, __lt__() and __eq__() are sufficient, if you want the conventional meanings of the comparison operators). The behavior of the is and is not operators cannot be customized; also they can be applied to any two objects and never raise an exception. Two more operations with the same syntactic priority, in and not in, are supported by types that are iterable or implement the __contains__() method. Numeric Types — int, float, complex There are three distinct numeric types: integers, floating point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating point numbers are usually implemented using double in C; information about the precision and internal representation of floating point numbers for the machine on which your program is running is available in sys.float_info. Complex numbers have a real and imaginary part, which are each a floating point number. To extract these parts from a complex number z, use z.real and z.imag. (The standard library includes the additional numeric types fractions.Fraction, for rationals, and decimal.Decimal, for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating point numbers. Appending 'j' or 'J' to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. 2 The constructors int(), float(), and complex() can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): Operation Result Notes Full documentation x + y sum of x and y x - y difference of x and y x * y product of x and y x / y quotient of x and y x // y floored quotient of x and y (1) x % y remainder of x / y (2) -x x negated +x x unchanged abs(x) absolute value", "score": "0.6442166"}]}
{"task_id": "mbpp_180", "code": "from math import radians, sin, cos, acos\r\ndef distance_lat_long(slat,slon,elat,elon):\r\n dist = 6371.01 * acos(sin(slat)*sin(elat) + cos(slat)*cos(elat)*cos(slon - elon))\r\n return dist", "test_list": ["assert distance_lat_long(23.5,67.5,25.5,69.5)==12179.372041317429", "assert distance_lat_long(10.5,20.5,30.5,40.5)==6069.397933300514", "assert distance_lat_long(10,20,30,40)==6783.751974994595"], "context": "Write a function to calculate distance between two points using latitude and longitude.", "function_name": "from math import radians, sin, cos, acos\r\ndef distance_lat_long(slat,slon,elat,elon):", "gold_generation": "dist = 6371.01 * acos(sin(slat)*sin(elat) + cos(slat)*cos(elat)*cos(slon - elon))\r\n return dist", "ctxs": [{"id": "21792", "text": "Function: python.library.math#math.dist\nSnippet: math.dist(p, q) Return the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Roughly equivalent to: sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q))) New in version 3.8.", "score": "0.69291675"}, {"id": "36344", "text": "Function: django.ref.contrib.gis.functions#django.contrib.gis.db.models.functions.Distance\nSnippet: class Distance(expr1, expr2, spheroid=None, **extra)", "score": "0.6908649"}, {"id": "36638", "text": "Function: django.ref.contrib.gis.geos#django.contrib.gis.geos.GEOSGeometry.interpolate\nSnippet: GEOSGeometry.interpolate(distance)", "score": "0.6639431"}, {"id": "36348", "text": "Function: django.ref.contrib.gis.functions#django.contrib.gis.db.models.functions.GeometryDistance\nSnippet: class GeometryDistance(expr1, expr2, **extra)", "score": "0.6571534"}, {"id": "36703", "text": "Function: django.ref.contrib.gis.geos#django.contrib.gis.geos.WKTWriter.precision\nSnippet: precision", "score": "0.6518303"}]}
{"task_id": "mbpp_181", "code": "def common_prefix_util(str1, str2): \r\n\tresult = \"\"; \r\n\tn1 = len(str1) \r\n\tn2 = len(str2) \r\n\ti = 0\r\n\tj = 0\r\n\twhile i <= n1 - 1 and j <= n2 - 1: \r\n\t\tif (str1[i] != str2[j]): \r\n\t\t\tbreak\r\n\t\tresult += str1[i] \r\n\t\ti += 1\r\n\t\tj += 1\r\n\treturn (result) \r\ndef common_prefix (arr, n): \r\n\tprefix = arr[0] \r\n\tfor i in range (1, n): \r\n\t\tprefix = common_prefix_util(prefix, arr[i]) \r\n\treturn (prefix) ", "test_list": ["assert common_prefix([\"tablets\", \"tables\", \"taxi\", \"tamarind\"], 4) == 'ta'", "assert common_prefix([\"apples\", \"ape\", \"april\"], 3) == 'ap'", "assert common_prefix([\"teens\", \"teenager\", \"teenmar\"], 3) == 'teen'"], "context": "Write a function to find the longest common prefix in the given set of strings.", "function_name": "def common_prefix_util(str1, str2):", "gold_generation": "result = \"\"; \r\n\tn1 = len(str1) \r\n\tn2 = len(str2) \r\n\ti = 0\r\n\tj = 0\r\n\twhile i <= n1 - 1 and j <= n2 - 1: \r\n\t\tif (str1[i] != str2[j]): \r\n\t\t\tbreak\r\n\t\tresult += str1[i] \r\n\t\ti += 1\r\n\t\tj += 1\r\n\treturn (result) \r\ndef common_prefix (arr, n): \r\n\tprefix = arr[0] \r\n\tfor i in range (1, n): \r\n\t\tprefix = common_prefix_util(prefix, arr[i]) \r\n\treturn (prefix)", "ctxs": [{"id": "19646", "text": "Function: python.library.difflib#difflib.SequenceMatcher.find_longest_match\nSnippet: find_longest_match(alo=0, ahi=None, blo=0, bhi=None) Find longest matching block in a[alo:ahi] and b[blo:bhi]. If isjunk was omitted or None, find_longest_match() returns (i, j, k) such that a[i:i+k] is equal to b[j:j+k], where alo <= i <= i+k <= ahi and blo <= j <= j+k <= bhi. For all (i', j', k') meeting those conditions, the additional conditions k >= k', i <= i', and if i == i', j <= j' are also met. In other words, of all maximal matching blocks, return one that starts earliest in a, and of all those maximal matching blocks that start earliest in a, return the one that starts earliest in b. >>> s = SequenceMatcher(None, \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=0, b=4, size=5) If isjunk was provided, first the longest matching block is determined as above, but with the additional restriction that no junk element appears in the block. Then that block is extended as far as possible by matching (only) junk elements on both sides. So the resulting block never matches on junk except as identical junk happens to be adjacent to an interesting match. Here’s the same example as before, but considering blanks to be junk. That prevents ' abcd' from matching the ' abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments.", "score": "0.70626926"}, {"id": "22639", "text": "Function: python.library.os.path#os.path.commonprefix\nSnippet: os.path.commonprefix(list) Return the longest path prefix (taken character-by-character) that is a prefix of all paths in list. If list is empty, return the empty string (''). Note This function may return invalid paths because it works a character at a time. To obtain a valid path, see commonpath(). >>> os.path.commonprefix(['/usr/lib', '/usr/local/lib']) '/usr/l' >>> os.path.commonpath(['/usr/lib', '/usr/local/lib']) '/usr' Changed in version 3.6: Accepts a path-like object.", "score": "0.6958395"}, {"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.68626016"}, {"id": "21316", "text": "Function: python.library.itertools#itertools.zip_longest\nSnippet: itertools.zip_longest(*iterables, fillvalue=None) Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. Roughly equivalent to: def zip_longest(*args, fillvalue=None): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- iterators = [iter(it) for it in args] num_active = len(iterators) if not num_active: return while True: values = [] for i, it in enumerate(iterators): try: value = next(it) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values.append(value) yield tuple(values) If one of the iterables is potentially infinite, then the zip_longest() function should be wrapped with something that limits the number of calls (for example islice() or takewhile()). If not specified, fillvalue defaults to None.", "score": "0.6720234"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.6718417"}]}
{"task_id": "mbpp_182", "code": "import re\r\ndef find_character(string):\r\n  uppercase_characters = re.findall(r\"[A-Z]\", string) \r\n  lowercase_characters = re.findall(r\"[a-z]\", string) \r\n  numerical_characters = re.findall(r\"[0-9]\", string) \r\n  special_characters = re.findall(r\"[, .!?]\", string) \r\n  return uppercase_characters, lowercase_characters, numerical_characters, special_characters", "test_list": ["assert find_character(\"ThisIsGeeksforGeeks\") == (['T', 'I', 'G', 'G'], ['h', 'i', 's', 's', 'e', 'e', 'k', 's', 'f', 'o', 'r', 'e', 'e', 'k', 's'], [], [])", "assert find_character(\"Hithere2\") == (['H'], ['i', 't', 'h', 'e', 'r', 'e'], ['2'], [])", "assert find_character(\"HeyFolks32\") == (['H', 'F'], ['e', 'y', 'o', 'l', 'k', 's'], ['3', '2'], [])"], "context": "Write a function to find uppercase, lowercase, special character and numeric values using regex.", "function_name": "import re\r\ndef find_character(string):", "gold_generation": "uppercase_characters = re.findall(r\"[A-Z]\", string) \r\n  lowercase_characters = re.findall(r\"[a-z]\", string) \r\n  numerical_characters = re.findall(r\"[0-9]\", string) \r\n  special_characters = re.findall(r\"[, .!?]\", string) \r\n  return uppercase_characters, lowercase_characters, numerical_characters, special_characters", "ctxs": [{"id": "23300", "text": "Function: python.library.re\nSnippet: For further information and a gentler presentation, consult the Regular Expression HOWTO. Regular expressions can contain both special and ordinary characters. Most ordinary characters, like 'A', 'a', or '0', are the simplest regular expressions; they simply match themselves. You can concatenate ordinary characters, so last matches the string 'last'. (In the rest of this section, we’ll write RE’s in this special style, usually without quotes, and strings to be matched 'in single quotes'.) Some characters, like '|' or '(', are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. Repetition qualifiers (*, +, ?, {m,n}, etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix ?, and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression (?:a{6})* matches any multiple of six 'a' characters. The special characters are: . (Dot.) In the default mode, this matches any character except a newline. If the DOTALL flag has been specified, this matches any character including a newline. ^ (Caret.) Matches the start of the string, and in MULTILINE mode also matches immediately after each newline. $ Matches the end of the string or just before the newline at the end of the string, and in MULTILINE mode also matches before a newline. foo matches both ‘foo’ and ‘foobar’, while the regular expression foo$ matches only ‘foo’. More interestingly, searching for foo.$ in 'foo1\\nfoo2\\n' matches ‘foo2’ normally, but ‘foo1’ in MULTILINE mode; searching for a single $ in 'foo\\n' will find two (empty) matches: one just before the newline, and one at the end of the string. * Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. ab* will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s. + Causes the resulting RE to match 1 or more repetitions of the preceding RE. ab+ will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’. ? Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. ab? will match either ‘a’ or ‘ab’. *?, +?, ?? The '*', '+', and '?' qualifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE <.*> is matched against '<a> b <c>', it will match the entire string, and not just '<a>'. Adding ? after the qualifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using the RE <.*?> will match only '<a>'. {m} Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, a{6} will match exactly six 'a' characters, but not five. {m,n} Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many", "score": "0.70623714"}, {"id": "23307", "text": "Function: python.library.re\nSnippet: '^' matches only at the beginning of the string, and '$' only at the end of the string and immediately before the newline (if any) at the end of the string. Corresponds to the inline flag (?m). re.S re.DOTALL Make the '.' special character match any character at all, including a newline; without this flag, '.' will match anything except a newline. Corresponds to the inline flag (?s). re.X re.VERBOSE This flag allows you to write regular expressions that look nicer and are more readable by allowing you to visually separate logical sections of the pattern and add comments. Whitespace within the pattern is ignored, except when in a character class, or when preceded by an unescaped backslash, or within tokens like *?, (?: or (?P<...>. When a line contains a # that is not in a character class and is not preceded by an unescaped backslash, all characters from the leftmost such # through the end of the line are ignored. This means that the two following regular expression objects that match a decimal number are functionally equal: a = re.compile(r\"\"\"\\d + # the integral part \\. # the decimal point \\d * # some fractional digits\"\"\", re.X) b = re.compile(r\"\\d+\\.\\d*\") Corresponds to the inline flag (?x). re.search(pattern, string, flags=0) Scan through string looking for the first location where the regular expression pattern produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. re.match(pattern, string, flags=0) If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. Note that even in MULTILINE mode, re.match() will only match at the beginning of the string and not at the beginning of each line. If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). re.fullmatch(pattern, string, flags=0) If the whole string matches the regular expression pattern, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. New in version 3.4. re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string,", "score": "0.69697934"}, {"id": "23341", "text": "Function: python.library.re#re.Match.group\nSnippet: Match.group([group1, ...]) Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an IndexError exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is None. If a group is contained in a part of the pattern that matched multiple times, the last match is returned. >>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\") >>> m.group(0) # The entire match 'Isaac Newton' >>> m.group(1) # The first parenthesized subgroup. 'Isaac' >>> m.group(2) # The second parenthesized subgroup. 'Newton' >>> m.group(1, 2) # Multiple arguments give us a tuple. ('Isaac', 'Newton') If the regular expression uses the (?P<name>...) syntax, the groupN arguments may also be strings identifying groups by their group name. If a string argument is not used as a group name in the pattern, an IndexError exception is raised. A moderately complicated example: >>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm Reynolds\") >>> m.group('first_name') 'Malcolm' >>> m.group('last_name') 'Reynolds' Named groups can also be referred to by their index: >>> m.group(1) 'Malcolm' >>> m.group(2) 'Reynolds' If a group matches multiple times, only the last match is accessible: >>> m = re.match(r\"(..)+\", \"a1b2c3\") # Matches 3 times. >>> m.group(1) # Returns only the last match. 'c3'", "score": "0.6953057"}, {"id": "24361", "text": "Function: python.library.stdtypes#str.isupper\nSnippet: str.isupper() Return True if all cased characters 4 in the string are uppercase and there is at least one cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False", "score": "0.6951241"}, {"id": "23361", "text": "Function: python.library.re#re.Pattern.search\nSnippet: Pattern.search(string[, pos[, endpos]]) Scan through string looking for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\"", "score": "0.69355434"}]}
{"task_id": "mbpp_183", "code": "def count_pairs(arr, n, k):\r\n  count=0;\r\n  for i in range(0,n):\r\n    for j in range(i+1, n):\r\n      if arr[i] - arr[j] == k or arr[j] - arr[i] == k:\r\n        count += 1\r\n  return count", "test_list": ["assert count_pairs([1, 5, 3, 4, 2], 5, 3) == 2", "assert count_pairs([8, 12, 16, 4, 0, 20], 6, 4) == 5", "assert count_pairs([2, 4, 1, 3, 4], 5, 2) == 3"], "context": "Write a function to count all the distinct pairs having a difference of k in any array.", "function_name": "def count_pairs(arr, n, k):", "gold_generation": "count=0;\r\n  for i in range(0,n):\r\n    for j in range(i+1, n):\r\n      if arr[i] - arr[j] == k or arr[j] - arr[i] == k:\r\n        count += 1\r\n  return count", "ctxs": [{"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.68065435"}, {"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.6657397"}, {"id": "18260", "text": "Function: python.library.stdtypes#bytearray.count\nSnippet: bytes.count(sub[, start[, end]]) bytearray.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.6633407"}, {"id": "43179", "text": "Function: numpy.reference.generated.numpy.setdiff1d\nSnippet: numpy.setdiff1d numpy.setdiff1d(ar1, ar2, assume_unique=False)[source] Find the set difference of two arrays. Return the unique values in ar1 that are not in ar2. Parameters ar1array_like Input array. ar2array_like Input comparison array. assume_uniquebool If True, the input arrays are both assumed to be unique, which can speed up the calculation. Default is False. Returns setdiff1dndarray 1D array of values in ar1 that are not in ar2. The result is sorted when assume_unique=False, but otherwise only sorted if the input is sorted. See also numpy.lib.arraysetops Module with a number of other functions for performing set operations on arrays. Examples >>> a = np.array([1, 2, 3, 2, 4, 1]) >>> b = np.array([3, 4, 5, 6]) >>> np.setdiff1d(a, b) array([1, 2])", "score": "0.65638155"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.65538216"}]}
{"task_id": "mbpp_184", "code": "def greater_specificnum(list,num):\r\n greater_specificnum=all(x >= num for x in list)\r\n return greater_specificnum", "test_list": ["assert greater_specificnum([220, 330, 500],200)==True", "assert greater_specificnum([12, 17, 21],20)==False", "assert greater_specificnum([1,2,3,4],10)==False"], "context": "Write a function to find all the values in a list that are greater than a specified number.", "function_name": "def greater_specificnum(list,num):", "gold_generation": "greater_specificnum=all(x >= num for x in list)\r\n return greater_specificnum", "ctxs": [{"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.6830819"}, {"id": "42164", "text": "Function: numpy.reference.generated.numpy.ma.masked_greater\nSnippet: numpy.ma.masked_greater ma.masked_greater(x, value, copy=True)[source] Mask an array where greater than a given value. This function is a shortcut to masked_where, with condition = (x > value). See also masked_where Mask where a condition is met. Examples >>> import numpy.ma as ma >>> a = np.arange(4) >>> a array([0, 1, 2, 3]) >>> ma.masked_greater(a, 2) masked_array(data=[0, 1, 2, --], mask=[False, False, False, True], fill_value=999999)", "score": "0.6764298"}, {"id": "42165", "text": "Function: numpy.reference.generated.numpy.ma.masked_greater_equal\nSnippet: numpy.ma.masked_greater_equal ma.masked_greater_equal(x, value, copy=True)[source] Mask an array where greater than or equal to a given value. This function is a shortcut to masked_where, with condition = (x >= value). See also masked_where Mask where a condition is met. Examples >>> import numpy.ma as ma >>> a = np.arange(4) >>> a array([0, 1, 2, 3]) >>> ma.masked_greater_equal(a, 2) masked_array(data=[0, 1, --, --], mask=[False, False, True, True], fill_value=999999)", "score": "0.67579675"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6744945"}, {"id": "25428", "text": "Function: python.library.token#token.GREATEREQUAL\nSnippet: token.GREATEREQUAL Token value for \">=\".", "score": "0.66106486"}]}
{"task_id": "mbpp_185", "code": "def parabola_focus(a, b, c): \r\n  focus= (((-b / (2 * a)),(((4 * a * c) - (b * b) + 1) / (4 * a))))\r\n  return focus", "test_list": ["assert parabola_focus(5,3,2)==(-0.3, 1.6)", "assert parabola_focus(9,8,4)==(-0.4444444444444444, 2.25)", "assert parabola_focus(2,4,6)==(-1.0, 4.125)"], "context": "Write a function to find the focus of a parabola.", "function_name": "def parabola_focus(a, b, c):", "gold_generation": "focus= (((-b / (2 * a)),(((4 * a * c) - (b * b) + 1) / (4 * a))))\r\n  return focus", "ctxs": [{"id": "25365", "text": "Function: python.library.tkinter.ttk#tkinter.ttk.Treeview.focus\nSnippet: focus(item=None) If item is specified, sets the focus item to item. Otherwise, returns the current focus item, or ‘’ if there is none.", "score": "0.6322064"}, {"id": "27292", "text": "Function: matplotlib.afm_api\nSnippet: e.g. 'acute'.", "score": "0.6230302"}, {"id": "33487", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: barbs_doc='\\nPlot a 2D field of barbs.\\n\\nCall signature::\\n\\n barbs([X, Y], U, V, [C], **kw)\\n\\nWhere *X*, *Y* define the barb locations, *U*, *V* define the barb\\ndirections, and *C* optionally sets the color.\\n\\nAll arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked\\n*X*, *Y* are not supported at present.\\n\\nBarbs are traditionally used in meteorology as a way to plot the speed\\nand direction of wind observations, but can technically be used to\\nplot any two dimensional vector quantity. As opposed to arrows, which\\ngive vector magnitude by the length of the arrow, the barbs give more\\nquantitative information about the vector magnitude by putting slanted\\nlines or a triangle for various increments in magnitude, as show\\nschematically below::\\n\\n : /\\\\ \\\\\\n : / \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : ------------------------------\\n\\nThe largest increment is given by a triangle (or \"flag\"). After those\\ncome full lines (barbs). The smallest increment is a half line. There\\nis only, of course, ever at most 1 half line. If the magnitude is\\nsmall and only needs a single half-line and no full lines or\\ntriangles, the half-line is offset from the end of the barb so that it\\ncan be easily distinguished from barbs with a single full line. The\\nmagnitude for the barb shown above would nominally be 65, using the\\nstandard increments of 50, 10, and 5.\\n\\nSee also https://en.wikipedia.org/wiki/Wind_barb.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the barb locations. See *pivot* for how the\\n barbs are drawn to the x, y positions.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y components of the barb shaft.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If", "score": "0.62188864"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.61950374"}, {"id": "41966", "text": "Function: numpy.reference.generated.numpy.fft.fft2\nSnippet: +0.j ]])", "score": "0.6192895"}]}
{"task_id": "mbpp_186", "code": "import re\r\ndef check_literals(text, patterns):\r\n  for pattern in patterns:\r\n    if re.search(pattern,  text):\r\n        return ('Matched!')\r\n    else:\r\n        return ('Not Matched!')", "test_list": ["assert check_literals('The quick brown fox jumps over the lazy dog.',['fox']) == 'Matched!'", "assert check_literals('The quick brown fox jumps over the lazy dog.',['horse']) == 'Not Matched!'", "assert check_literals('The quick brown fox jumps over the lazy dog.',['lazy']) == 'Matched!'"], "context": "Write a function to search some literals strings in a string by using regex.", "function_name": "import re\r\ndef check_literals(text, patterns):", "gold_generation": "for pattern in patterns:\r\n    if re.search(pattern,  text):\r\n        return ('Matched!')\r\n    else:\r\n        return ('Not Matched!')", "ctxs": [{"id": "23361", "text": "Function: python.library.re#re.Pattern.search\nSnippet: Pattern.search(string[, pos[, endpos]]) Scan through string looking for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\"", "score": "0.72336054"}, {"id": "23367", "text": "Function: python.library.re#re.search\nSnippet: re.search(pattern, string, flags=0) Scan through string looking for the first location where the regular expression pattern produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string.", "score": "0.71920526"}, {"id": "23315", "text": "Function: python.library.re\nSnippet: ['carefully', 'quickly'] Finding all Adverbs and their Positions If one wants more information about all matches of a pattern than the matched text, finditer() is useful as it provides match objects instead of strings. Continuing with the previous example, if a writer wanted to find all of the adverbs and their positions in some text, they would use finditer() in the following manner: >>> text = \"He was carefully disguised but captured quickly by police.\" >>> for m in re.finditer(r\"\\w+ly\", text): ... print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0))) 07-16: carefully 40-47: quickly Raw String Notation Raw string notation (r\"text\") keeps regular expressions sane. Without it, every backslash ('\\') in a regular expression would have to be prefixed with another one to escape it. For example, the two following lines of code are functionally identical: >>> re.match(r\"\\W(.)\\1\\W\", \" ff \") <re.Match object; span=(0, 4), match=' ff '> >>> re.match(\"\\\\W(.)\\\\1\\\\W\", \" ff \") <re.Match object; span=(0, 4), match=' ff '> When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, this means r\"\\\\\". Without raw string notation, one must use \"\\\\\\\\\", making the following lines of code functionally identical: >>> re.match(r\"\\\\\", r\"\\\\\") <re.Match object; span=(0, 1), match='\\\\'> >>> re.match(\"\\\\\\\\\", r\"\\\\\") <re.Match object; span=(0, 1), match='\\\\'> Writing a Tokenizer A tokenizer or scanner analyzes a string to categorize groups of characters. This is a useful first step in writing a compiler or interpreter. The text categories are specified with regular expressions. The technique is to combine those into a single master regular expression and to loop over successive matches: from typing import NamedTuple import re class Token(NamedTuple): type: str value: str line: int column: int def tokenize(code): keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'} token_specification = [ ('NUMBER', r'\\d+(\\.\\d*)?'), # Integer or decimal number ('ASSIGN', r':='), # Assignment operator ('END', r';'), # Statement terminator ('ID', r'[A-Za-z]+'), # Identifiers ('OP', r'[+\\-*/]'), # Arithmetic operators ('NEWLINE', r'\\n'), # Line endings ('SKIP', r'[ \\t]+'), # Skip over spaces and tabs ('MISMATCH', r'.'), # Any other character ] tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specification) line_num = 1 line_start = 0 for mo in re.finditer(tok_regex, code): kind = mo.lastgroup value = mo.group() column = mo.start() - line_start if kind == 'NUMBER': value = float(value) if '.' in value else int(value) elif kind == 'ID' and value in keywords: kind = value elif kind == 'NEWLINE': line_start = mo.end() line_num += 1 continue elif kind == 'SKIP': continue elif kind == 'MISMATCH': raise RuntimeError(f'{value!r} unexpected on line {line_num}') yield Token(kind, value, line_num, column) statements = ''' IF quantity THEN total := total + price * quantity; tax := price * 0.05; ENDIF; ''' for token in tokenize(statements): print(token) The tokenizer produces the following output: Token(type='IF', value='IF', line=2, column=4) Token(type='ID', value='quantity', line=2, column=7) Token(type='THEN', value='THEN', line=2, column=16) Token(type='ID', value='total', line=3, column=8) Token(type='ASSIGN', value=':=', line=3, column=14) Token(type='ID', value='total', line=3, column=17) Token(type='OP', value='+', line=3, column=23) Token(type='ID', value='price', line=3, column=25) Token(type='OP', value='*', line=3, column=31) Token(type='ID', value='quantity', line=3, column=33)", "score": "0.7163253"}, {"id": "23299", "text": "Function: python.library.re\nSnippet: re — Regular expression operations Source code: Lib/re.py This module provides regular expression matching operations similar to those found in Perl. Both patterns and strings to be searched can be Unicode strings (str) as well as 8-bit strings (bytes). However, Unicode strings and 8-bit strings cannot be mixed: that is, you cannot match a Unicode string with a byte pattern or vice-versa; similarly, when asking for a substitution, the replacement string must be of the same type as both the pattern and the search string. Regular expressions use the backslash character ('\\') to indicate special forms or to allow special characters to be used without invoking their special meaning. This collides with Python’s usage of the same character for the same purpose in string literals; for example, to match a literal backslash, one might have to write '\\\\\\\\' as the pattern string, because the regular expression must be \\\\, and each backslash must be expressed as \\\\ inside a regular Python string literal. Also, please note that any invalid escape sequences in Python’s usage of the backslash in string literals now generate a DeprecationWarning and in the future this will become a SyntaxError. This behaviour will happen even if it is a valid escape sequence for a regular expression. The solution is to use Python’s raw string notation for regular expression patterns; backslashes are not handled in any special way in a string literal prefixed with 'r'. So r\"\\n\" is a two-character string containing '\\' and 'n', while \"\\n\" is a one-character string containing a newline. Usually patterns will be expressed in Python code using this raw string notation. It is important to note that most regular expression operations are available as module-level functions and methods on compiled regular expressions. The functions are shortcuts that don’t require you to compile a regex object first, but miss some fine-tuning parameters. See also The third-party regex module, which has an API compatible with the standard library re module, but offers additional functionality and a more thorough Unicode support. Regular Expression Syntax A regular expression (or RE) specifies a set of strings that matches it; the functions in this module let you check if a particular string matches a given regular expression (or if a given regular expression matches a particular string, which comes down to the same thing). Regular expressions can be concatenated to form new regular expressions; if A and B are both regular expressions, then AB is also a regular expression. In general, if a string p matches A and another string q matches B, the string pq will match AB. This holds unless A or B contain low precedence operations; boundary conditions between A and B; or have numbered group references. Thus, complex expressions can easily be constructed from simpler primitive expressions like the ones described here. For details of the theory and implementation of regular expressions, consult the Friedl book [Frie09], or almost any textbook about compiler construction. A brief explanation of the format of regular expressions follows.", "score": "0.71424645"}, {"id": "23310", "text": "Function: python.library.re\nSnippet: for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\" Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). Pattern.fullmatch(string[, pos[, endpos]]) If the whole string matches this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o[gh]\") >>> pattern.fullmatch(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.fullmatch(\"ogre\") # No match as not the full string matches. >>> pattern.fullmatch(\"doggie\", 1, 3) # Matches within given limits. <re.Match object; span=(1, 3), match='og'> New in version 3.4. Pattern.split(string, maxsplit=0) Identical to the split() function, using the compiled pattern. Pattern.findall(string[, pos[, endpos]]) Similar to the findall() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.finditer(string[, pos[, endpos]]) Similar to the finditer() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.sub(repl, string, count=0) Identical to the sub() function, using the compiled pattern. Pattern.subn(repl, string, count=0) Identical to the subn() function, using the compiled pattern. Pattern.flags The regex", "score": "0.7088673"}]}
{"task_id": "mbpp_187", "code": "def longest_common_subsequence(X, Y, m, n): \r\n    if m == 0 or n == 0: \r\n       return 0 \r\n    elif X[m-1] == Y[n-1]: \r\n       return 1 + longest_common_subsequence(X, Y, m-1, n-1) \r\n    else: \r\n       return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n))", "test_list": ["assert longest_common_subsequence(\"AGGTAB\" , \"GXTXAYB\", 6, 7) == 4", "assert longest_common_subsequence(\"ABCDGH\" , \"AEDFHR\", 6, 6) == 3", "assert longest_common_subsequence(\"AXYT\" , \"AYZX\", 4, 4) == 2"], "context": "Write a function to find the longest common subsequence for the given two sequences.", "function_name": "def longest_common_subsequence(X, Y, m, n):", "gold_generation": "if m == 0 or n == 0: \r\n       return 0 \r\n    elif X[m-1] == Y[n-1]: \r\n       return 1 + longest_common_subsequence(X, Y, m-1, n-1) \r\n    else: \r\n       return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n))", "ctxs": [{"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.72766066"}, {"id": "19646", "text": "Function: python.library.difflib#difflib.SequenceMatcher.find_longest_match\nSnippet: find_longest_match(alo=0, ahi=None, blo=0, bhi=None) Find longest matching block in a[alo:ahi] and b[blo:bhi]. If isjunk was omitted or None, find_longest_match() returns (i, j, k) such that a[i:i+k] is equal to b[j:j+k], where alo <= i <= i+k <= ahi and blo <= j <= j+k <= bhi. For all (i', j', k') meeting those conditions, the additional conditions k >= k', i <= i', and if i == i', j <= j' are also met. In other words, of all maximal matching blocks, return one that starts earliest in a, and of all those maximal matching blocks that start earliest in a, return the one that starts earliest in b. >>> s = SequenceMatcher(None, \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=0, b=4, size=5) If isjunk was provided, first the longest matching block is determined as above, but with the additional restriction that no junk element appears in the block. Then that block is extended as far as possible by matching (only) junk elements on both sides. So the resulting block never matches on junk except as identical junk happens to be adjacent to an interesting match. Here’s the same example as before, but considering blanks to be junk. That prevents ' abcd' from matching the ' abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments.", "score": "0.7172014"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.70796955"}, {"id": "19655", "text": "Function: python.library.difflib#difflib.SequenceMatcher.set_seqs\nSnippet: set_seqs(a, b) Set the two sequences to be compared.", "score": "0.6913216"}, {"id": "19648", "text": "Function: python.library.difflib#difflib.SequenceMatcher.get_matching_blocks\nSnippet: get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]", "score": "0.6807014"}]}
{"task_id": "mbpp_188", "code": "def prod_Square(n):\r\n    for i in range(2,(n) + 1):\r\n        if (i*i < (n+1)):\r\n            for j in range(2,n + 1):\r\n                if ((i*i*j*j) == n):\r\n                    return True;\r\n    return False;", "test_list": ["assert prod_Square(25) == False", "assert prod_Square(30) == False", "assert prod_Square(16) == True"], "context": "Write a python function to check whether the given number can be represented by product of two squares or not.", "function_name": "def prod_Square(n):", "gold_generation": "for i in range(2,(n) + 1):\r\n        if (i*i < (n+1)):\r\n            for j in range(2,n + 1):\r\n                if ((i*i*j*j) == n):\r\n                    return True;\r\n    return False;", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.7010765"}, {"id": "19508", "text": "Function: python.library.decimal#decimal.Context.same_quantum\nSnippet: same_quantum(x, y) Returns True if the two operands have the same exponent.", "score": "0.68331754"}, {"id": "43202", "text": "Function: numpy.reference.generated.numpy.square\nSnippet: numpy.square numpy.square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'square'> Return the element-wise square of the input. Parameters xarray_like Input data. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Element-wise x*x, of the same shape and dtype as x. This is a scalar if x is a scalar. See also numpy.linalg.matrix_power sqrt power Examples >>> np.square([-1j, 1]) array([-1.-0.j, 1.+0.j])", "score": "0.6827905"}, {"id": "21826", "text": "Function: python.library.math#math.prod\nSnippet: math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8.", "score": "0.6745359"}, {"id": "21811", "text": "Function: python.library.math#math.isnan\nSnippet: math.isnan(x) Return True if x is a NaN (not a number), and False otherwise.", "score": "0.6729672"}]}
{"task_id": "mbpp_189", "code": "def first_Missing_Positive(arr,n): \r\n    ptr = 0\r\n    for i in range(n):\r\n        if arr[i] == 1:\r\n            ptr = 1\r\n            break\r\n    if ptr == 0:\r\n        return(1)\r\n    for i in range(n):\r\n        if arr[i] <= 0 or arr[i] > n:\r\n            arr[i] = 1\r\n    for i in range(n):\r\n        arr[(arr[i] - 1) % n] += n\r\n    for i in range(n):\r\n        if arr[i] <= n:\r\n            return(i + 1)\r\n    return(n + 1)", "test_list": ["assert first_Missing_Positive([1,2,3,-1,5],5) == 4", "assert first_Missing_Positive([0,-1,-2,1,5,8],6) == 2", "assert first_Missing_Positive([0,1,2,5,-8],5) == 3"], "context": "Write a python function to find the first missing positive number.", "function_name": "def first_Missing_Positive(arr,n):", "gold_generation": "ptr = 0\r\n    for i in range(n):\r\n        if arr[i] == 1:\r\n            ptr = 1\r\n            break\r\n    if ptr == 0:\r\n        return(1)\r\n    for i in range(n):\r\n        if arr[i] <= 0 or arr[i] > n:\r\n            arr[i] = 1\r\n    for i in range(n):\r\n        arr[(arr[i] - 1) % n] += n\r\n    for i in range(n):\r\n        if arr[i] <= n:\r\n            return(i + 1)\r\n    return(n + 1)", "ctxs": [{"id": "21776", "text": "Function: python.library.math\nSnippet: (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9. Note that frexp() and modf() have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 2**52 necessarily has no fractional bits. Power and logarithmic functions math.exp(x) Return e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). math.expm1(x) Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision: >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.0000050000069649e-05 >>> expm1(1e-5) # result accurate to full precision 1.0000050000166668e-05 New in version 3.2. math.log(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). math.log1p(x) Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. math.log2(x) Return the base-2 logarithm of x. This is usually more accurate than log(x, 2). New in version 3.3. See also int.bit_length() returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. math.log10(x) Return the base-10 logarithm of x. This is usually more accurate than log(x, 10). math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", "score": "0.7014389"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.68148446"}, {"id": "21836", "text": "Function: python.library.math#math.ulp\nSnippet: math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9.", "score": "0.6811435"}, {"id": "13013", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos#sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.67731524"}, {"id": "12778", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.670398"}]}
{"task_id": "mbpp_190", "code": "def count_Intgral_Points(x1,y1,x2,y2): \r\n    return ((y2 - y1 - 1) * (x2 - x1 - 1)) ", "test_list": ["assert count_Intgral_Points(1,1,4,4) == 4", "assert count_Intgral_Points(1,2,1,2) == 1", "assert count_Intgral_Points(4,2,6,4) == 1"], "context": "Write a python function to count the number of integral co-ordinates that lie inside a square.", "function_name": "def count_Intgral_Points(x1,y1,x2,y2):", "gold_generation": "return ((y2 - y1 - 1) * (x2 - x1 - 1))", "ctxs": [{"id": "14351", "text": "Function: pandas.reference.api.pandas.dataframe.floordiv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.68432546"}, {"id": "14507", "text": "Function: pandas.reference.api.pandas.dataframe.sub\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6835051"}, {"id": "14324", "text": "Function: pandas.reference.api.pandas.dataframe.div\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.67625475"}, {"id": "43202", "text": "Function: numpy.reference.generated.numpy.square\nSnippet: numpy.square numpy.square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'square'> Return the element-wise square of the input. Parameters xarray_like Input data. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Element-wise x*x, of the same shape and dtype as x. This is a scalar if x is a scalar. See also numpy.linalg.matrix_power sqrt power Examples >>> np.square([-1j, 1]) array([-1.-0.j, 1.+0.j])", "score": "0.67528737"}, {"id": "14440", "text": "Function: pandas.reference.api.pandas.dataframe.pow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6601099"}]}
{"task_id": "mbpp_191", "code": "def check_monthnumber(monthname3):\r\n  if monthname3 ==\"April\" or monthname3== \"June\" or monthname3== \"September\" or monthname3== \"November\":\r\n    return True\r\n  else:\r\n    return False", "test_list": ["assert check_monthnumber(\"February\")==False", "assert check_monthnumber(\"June\")==True", "assert check_monthnumber(\"April\")==True"], "context": "Write a function to check whether the given month name contains 30 days or not.", "function_name": "def check_monthnumber(monthname3):", "gold_generation": "if monthname3 ==\"April\" or monthname3== \"June\" or monthname3== \"September\" or monthname3== \"November\":\r\n    return True\r\n  else:\r\n    return False", "ctxs": [{"id": "19312", "text": "Function: python.library.datetime#datetime.date.month\nSnippet: date.month Between 1 and 12 inclusive.", "score": "0.71150553"}, {"id": "19343", "text": "Function: python.library.datetime#datetime.datetime.month\nSnippet: datetime.month Between 1 and 12 inclusive.", "score": "0.6969503"}, {"id": "15492", "text": "Function: pandas.reference.api.pandas.timestamp.days_in_month\nSnippet: pandas.Timestamp.days_in_month Timestamp.days_in_month Return the number of days in the month. Examples >>> ts = pd.Timestamp(2020, 3, 14) >>> ts.days_in_month 31", "score": "0.6946071"}, {"id": "14955", "text": "Function: pandas.reference.api.pandas.periodindex.days_in_month\nSnippet: pandas.PeriodIndex.days_in_month propertyPeriodIndex.days_in_month The number of days in the month.", "score": "0.6850237"}, {"id": "15127", "text": "Function: pandas.reference.api.pandas.series.dt.days_in_month\nSnippet: pandas.Series.dt.days_in_month Series.dt.days_in_month The number of days in the month.", "score": "0.6845034"}]}
{"task_id": "mbpp_192", "code": "def check_String(str): \r\n    flag_l = False\r\n    flag_n = False\r\n    for i in str: \r\n        if i.isalpha(): \r\n            flag_l = True  \r\n        if i.isdigit(): \r\n            flag_n = True\r\n    return flag_l and flag_n ", "test_list": ["assert check_String('thishasboth29') == True", "assert check_String('python') == False", "assert check_String ('string') == False"], "context": "Write a python function to check whether a string has atleast one letter and one number.", "function_name": "def check_String(str):", "gold_generation": "flag_l = False\r\n    flag_n = False\r\n    for i in str: \r\n        if i.isalpha(): \r\n            flag_l = True  \r\n        if i.isdigit(): \r\n            flag_n = True\r\n    return flag_l and flag_n", "ctxs": [{"id": "24350", "text": "Function: python.library.stdtypes#str.isalnum\nSnippet: str.isalnum() Return True if all characters in the string are alphanumeric and there is at least one character, False otherwise. A character c is alphanumeric if one of the following returns True: c.isalpha(), c.isdecimal(), c.isdigit(), or c.isnumeric().", "score": "0.7374981"}, {"id": "24361", "text": "Function: python.library.stdtypes#str.isupper\nSnippet: str.isupper() Return True if all cased characters 4 in the string are uppercase and there is at least one cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False", "score": "0.71343935"}, {"id": "41785", "text": "Function: numpy.reference.generated.numpy.chararray.isalpha\nSnippet: numpy.chararray.isalpha method chararray.isalpha()[source] Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. See also char.isalpha", "score": "0.7132165"}, {"id": "41662", "text": "Function: numpy.reference.generated.numpy.char.chararray.isalpha\nSnippet: numpy.char.chararray.isalpha method char.chararray.isalpha()[source] Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. See also char.isalpha", "score": "0.7124866"}, {"id": "24356", "text": "Function: python.library.stdtypes#str.islower\nSnippet: str.islower() Return True if all cased characters 4 in the string are lowercase and there is at least one cased character, False otherwise.", "score": "0.7103035"}]}
{"task_id": "mbpp_193", "code": "def remove_tuple(test_tup):\r\n  res = tuple(set(test_tup))\r\n  return (res) ", "test_list": ["assert remove_tuple((1, 3, 5, 2, 3, 5, 1, 1, 3)) == (1, 2, 3, 5)", "assert remove_tuple((2, 3, 4, 4, 5, 6, 6, 7, 8, 8)) == (2, 3, 4, 5, 6, 7, 8)", "assert remove_tuple((11, 12, 13, 11, 11, 12, 14, 13)) == (11, 12, 13, 14)"], "context": "Write a function to remove the duplicates from the given tuple.", "function_name": "def remove_tuple(test_tup):", "gold_generation": "res = tuple(set(test_tup))\r\n  return (res)", "ctxs": [{"id": "18685", "text": "Function: python.library.collections#collections.somenamedtuple._replace\nSnippet: somenamedtuple._replace(**kwargs) Return a new instance of the named tuple replacing specified fields with new values: >>> p = Point(x=11, y=22) >>> p._replace(x=33) Point(x=33, y=22) >>> for partnum, record in inventory.items(): ... inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now())", "score": "0.6855544"}, {"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.6832215"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6791847"}, {"id": "21302", "text": "Function: python.library.itertools#itertools.combinations_with_replacement\nSnippet: itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1.", "score": "0.6754463"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.66858137"}]}
{"task_id": "mbpp_194", "code": "def octal_To_Decimal(n):  \r\n    num = n; \r\n    dec_value = 0; \r\n    base = 1; \r\n    temp = num; \r\n    while (temp): \r\n        last_digit = temp % 10; \r\n        temp = int(temp / 10); \r\n        dec_value += last_digit*base; \r\n        base = base * 8; \r\n    return dec_value; ", "test_list": ["assert octal_To_Decimal(25) == 21", "assert octal_To_Decimal(30) == 24", "assert octal_To_Decimal(40) == 32"], "context": "Write a python function to convert octal number to decimal number.", "function_name": "def octal_To_Decimal(n):", "gold_generation": "num = n; \r\n    dec_value = 0; \r\n    base = 1; \r\n    temp = num; \r\n    while (temp): \r\n        last_digit = temp % 10; \r\n        temp = int(temp / 10); \r\n        dec_value += last_digit*base; \r\n        base = base * 8; \r\n    return dec_value;", "ctxs": [{"id": "19516", "text": "Function: python.library.decimal#decimal.Decimal\nSnippet: class decimal.Decimal(value=\"0\", context=None) Construct a new Decimal object based from value. value can be an integer, string, tuple, float, or another Decimal object. If no value is given, returns Decimal('0'). If value is a string, it should conform to the decimal numeric string syntax after leading and trailing whitespace characters, as well as underscores throughout, are removed: sign ::= '+' | '-' digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' indicator ::= 'e' | 'E' digits ::= digit [digit]... decimal-part ::= digits '.' [digits] | ['.'] digits exponent-part ::= indicator [sign] digits infinity ::= 'Infinity' | 'Inf' nan ::= 'NaN' [digits] | 'sNaN' [digits] numeric-value ::= decimal-part [exponent-part] | infinity numeric-string ::= [sign] numeric-value | [sign] nan Other Unicode decimal digits are also permitted where digit appears above. These include decimal digits from various other alphabets (for example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits '\\uff10' through '\\uff19'. If value is a tuple, it should have three components, a sign (0 for positive or 1 for negative), a tuple of digits, and an integer exponent. For example, Decimal((0, (1, 4, 1, 4), -3)) returns Decimal('1.414'). If value is a float, the binary floating point value is losslessly converted to its exact decimal equivalent. This conversion can often require 53 or more digits of precision. For example, Decimal(float('1.1')) converts to Decimal('1.100000000000000088817841970012523233890533447265625'). The context precision does not affect how many digits are stored. That is determined exclusively by the number of digits in value. For example, Decimal('3.00000') records all five zeros even if the context precision is only three. The purpose of the context argument is determining what to do if value is a malformed string. If the context traps InvalidOperation, an exception is raised; otherwise, the constructor returns a new Decimal with the value of NaN. Once constructed, Decimal objects are immutable. Changed in version 3.2: The argument to the constructor is now permitted to be a float instance. Changed in version 3.3: float arguments raise an exception if the FloatOperation trap is set. By default the trap is off. Changed in version 3.6: Underscores are allowed for grouping, as with integral and floating-point literals in code. Decimal floating point objects share many properties with the other built-in numeric types such as float and int. All of the usual math operations and special methods apply. Likewise, decimal objects can be copied, pickled, printed, used as dictionary keys, used as set elements, compared, sorted, and coerced to another type (such as float or int). There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator % is applied to Decimal objects, the sign of the result is the sign of the dividend rather than the sign of the divisor: >>> (-7) % 4 1 >>> Decimal(-7) % Decimal(4) Decimal('-3') The integer division operator // behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather", "score": "0.759285"}, {"id": "22291", "text": "Function: python.library.functions#oct\nSnippet: oct(x) Convert an integer number to an octal string prefixed with “0o”. The result is a valid Python expression. If x is not a Python int object, it has to define an __index__() method that returns an integer. For example: >>> oct(8) '0o10' >>> oct(-56) '-0o70' If you want to convert an integer number to octal string either with prefix “0o” or not, you can use either of the following ways. >>> '%#o' % 10, '%o' % 10 ('0o12', '12') >>> format(10, '#o'), format(10, 'o') ('0o12', '12') >>> f'{10:#o}', f'{10:o}' ('0o12', '12') See also format() for more information.", "score": "0.7550987"}, {"id": "19432", "text": "Function: python.library.decimal\nSnippet: be necessary. In this case, the rounding mode is determined by the rounding argument if given, else by the given context argument; if neither argument is given the rounding mode of the current thread’s context is used. An error is returned whenever the resulting exponent is greater than Emax or less than Etiny. radix() Return Decimal(10), the radix (base) in which the Decimal class does all its arithmetic. Included for compatibility with the specification. remainder_near(other, context=None) Return the remainder from dividing self by other. This differs from self % other in that the sign of the remainder is chosen so as to minimize its absolute value. More precisely, the return value is self - n * other where n is the integer nearest to the exact value of self / other, and if two integers are equally near then the even one is chosen. If the result is zero then its sign will be the sign of self. >>> Decimal(18).remainder_near(Decimal(10)) Decimal('-2') >>> Decimal(25).remainder_near(Decimal(10)) Decimal('5') >>> Decimal(35).remainder_near(Decimal(10)) Decimal('-5') rotate(other, context=None) Return the result of rotating the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to rotate. If the second operand is positive then rotation is to the left; otherwise rotation is to the right. The coefficient of the first operand is padded on the left with zeros to length precision if necessary. The sign and exponent of the first operand are unchanged. same_quantum(other, context=None) Test whether self and other have the same exponent or whether both are NaN. This operation is unaffected by context and is quiet: no flags are changed and no rounding is performed. As an exception, the C version may raise InvalidOperation if the second operand cannot be converted exactly. scaleb(other, context=None) Return the first operand with exponent adjusted by the second. Equivalently, return the first operand multiplied by 10**other. The second operand must be an integer. shift(other, context=None) Return the result of shifting the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to shift. If the second operand is positive then the shift is to the left; otherwise the shift is to the right. Digits shifted into the coefficient are zeros. The sign and exponent of the first operand are unchanged. sqrt(context=None) Return the square root of the argument to full precision. to_eng_string(context=None) Convert to a string, using engineering notation if an exponent is needed. Engineering notation has an exponent which is a multiple of 3. This can leave up to 3 digits to the left of the decimal place and may require the addition of either one or two trailing zeros. For example, this converts Decimal('123E+1') to Decimal('1.23E+3'). to_integral(rounding=None, context=None) Identical to the to_integral_value() method. The", "score": "0.75048625"}, {"id": "19504", "text": "Function: python.library.decimal#decimal.Context.radix\nSnippet: radix() Just returns 10, as this is Decimal, :)", "score": "0.75016445"}, {"id": "19437", "text": "Function: python.library.decimal\nSnippet: - y * n, where n is the integer nearest the exact value of x / y (if the result is 0 then its sign will be the sign of x). rotate(x, y) Returns a rotated copy of x, y times. same_quantum(x, y) Returns True if the two operands have the same exponent. scaleb(x, y) Returns the first operand after adding the second value its exp. shift(x, y) Returns a shifted copy of x, y times. sqrt(x) Square root of a non-negative number to context precision. subtract(x, y) Return the difference between x and y. to_eng_string(x) Convert to a string, using engineering notation if an exponent is needed. Engineering notation has an exponent which is a multiple of 3. This can leave up to 3 digits to the left of the decimal place and may require the addition of either one or two trailing zeros. to_integral_exact(x) Rounds to an integer. to_sci_string(x) Converts a number to a string using scientific notation. Constants The constants in this section are only relevant for the C module. They are also included in the pure Python version for compatibility. 32-bit 64-bit decimal.MAX_PREC 425000000 999999999999999999 decimal.MAX_EMAX 425000000 999999999999999999 decimal.MIN_EMIN -425000000 -999999999999999999 decimal.MIN_ETINY -849999999 -1999999999999999997 decimal.HAVE_THREADS The value is True. Deprecated, because Python now always has threads. Deprecated since version 3.9. decimal.HAVE_CONTEXTVAR The default value is True. If Python is compiled --without-decimal-contextvar, the C version uses a thread-local rather than a coroutine-local context and the value is False. This is slightly faster in some nested context scenarios. New in version 3.9: backported to 3.7 and 3.8. Rounding modes decimal.ROUND_CEILING Round towards Infinity. decimal.ROUND_DOWN Round towards zero. decimal.ROUND_FLOOR Round towards -Infinity. decimal.ROUND_HALF_DOWN Round to nearest with ties going towards zero. decimal.ROUND_HALF_EVEN Round to nearest with ties going to nearest even integer. decimal.ROUND_HALF_UP Round to nearest with ties going away from zero. decimal.ROUND_UP Round away from zero. decimal.ROUND_05UP Round away from zero if last digit after rounding towards zero would have been 0 or 5; otherwise round towards zero. Signals Signals represent conditions that arise during computation. Each corresponds to one context flag and one context trap enabler. The context flag is set whenever the condition is encountered. After the computation, flags may be checked for informational purposes (for instance, to determine whether a computation was exact). After checking the flags, be sure to clear all flags before starting the next computation. If the context’s trap enabler is set for the signal, then the condition causes a Python exception to be raised. For example, if the DivisionByZero trap is set, then a DivisionByZero exception is raised upon encountering the condition. class decimal.Clamped Altered an exponent to fit representation constraints. Typically, clamping occurs when an exponent falls outside the context’s Emin and Emax limits. If possible, the exponent is reduced to fit by adding zeros to the coefficient. class decimal.DecimalException Base class for other signals and a subclass of ArithmeticError. class decimal.DivisionByZero Signals the division of a non-infinite number by zero. Can occur with division, modulo division, or when raising", "score": "0.743646"}]}
{"task_id": "mbpp_195", "code": "def first(arr,x,n): \r\n    low = 0\r\n    high = n - 1\r\n    res = -1  \r\n    while (low <= high):\r\n        mid = (low + high) // 2 \r\n        if arr[mid] > x:\r\n            high = mid - 1\r\n        elif arr[mid] < x:\r\n            low = mid + 1\r\n        else:\r\n            res = mid\r\n            high = mid - 1\r\n    return res", "test_list": ["assert first([1,2,3,4,5,6,6],6,6) == 5", "assert first([1,2,2,2,3,2,2,4,2],2,9) == 1", "assert first([1,2,3],1,3) == 0"], "context": "Write a python function to find the first position of an element in a sorted array.", "function_name": "def first(arr,x,n):", "gold_generation": "low = 0\r\n    high = n - 1\r\n    res = -1  \r\n    while (low <= high):\r\n        mid = (low + high) // 2 \r\n        if arr[mid] > x:\r\n            high = mid - 1\r\n        elif arr[mid] < x:\r\n            low = mid + 1\r\n        else:\r\n            res = mid\r\n            high = mid - 1\r\n    return res", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.75034404"}, {"id": "22322", "text": "Function: python.library.operator#operator.indexOf\nSnippet: operator.indexOf(a, b) Return the index of the first of occurrence of b in a.", "score": "0.7178949"}, {"id": "43173", "text": "Function: numpy.reference.generated.numpy.searchsorted\nSnippet: numpy.searchsorted numpy.searchsorted(a, v, side='left', sorter=None)[source] Find indices where elements should be inserted to maintain order. Find the indices into a sorted array a such that, if the corresponding elements in v were inserted before the indices, the order of a would be preserved. Assuming that a is sorted: side returned index i satisfies left a[i-1] < v <= a[i] right a[i-1] <= v < a[i] Parameters a1-D array_like Input array. If sorter is None, then it must be sorted in ascending order, otherwise sorter must be an array of indices that sort it. varray_like Values to insert into a. side{‘left’, ‘right’}, optional If ‘left’, the index of the first suitable location found is given. If ‘right’, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of a). sorter1-D array_like, optional Optional array of integer indices that sort array a into ascending order. They are typically the result of argsort. New in version 1.7.0. Returns indicesint or array of ints Array of insertion points with the same shape as v, or an integer if v is a scalar. See also sort Return a sorted copy of an array. histogram Produce histogram from 1-D data. Notes Binary search is used to find the required insertion points. As of NumPy 1.4.0 searchsorted works with real/complex arrays containing nan values. The enhanced sort order is documented in sort. This function uses the same algorithm as the builtin python bisect.bisect_left (side='left') and bisect.bisect_right (side='right') functions, which is also vectorized in the v argument. Examples >>> np.searchsorted([1,2,3,4,5], 3) 2 >>> np.searchsorted([1,2,3,4,5], 3, side='right') 3 >>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3]) array([0, 5, 1, 2])", "score": "0.7099714"}, {"id": "43873", "text": "Function: numpy.reference.generated.numpy.recarray.searchsorted\nSnippet: numpy.recarray.searchsorted method recarray.searchsorted(v, side='left', sorter=None) Find indices where elements of v should be inserted in a to maintain order. For full documentation, see numpy.searchsorted See also numpy.searchsorted equivalent function", "score": "0.7050092"}, {"id": "41691", "text": "Function: numpy.reference.generated.numpy.char.chararray.searchsorted\nSnippet: numpy.char.chararray.searchsorted method char.chararray.searchsorted(v, side='left', sorter=None) Find indices where elements of v should be inserted in a to maintain order. For full documentation, see numpy.searchsorted See also numpy.searchsorted equivalent function", "score": "0.70428824"}]}
{"task_id": "mbpp_196", "code": "def remove_tuples(test_list, K):\r\n  res = [ele for ele in test_list if len(ele) != K]\r\n  return (res) ", "test_list": ["assert remove_tuples([(4, 5), (4, ), (8, 6, 7), (1, ), (3, 4, 6, 7)] , 1) == [(4, 5), (8, 6, 7), (3, 4, 6, 7)]", "assert remove_tuples([(4, 5), (4,5), (6, 7), (1, 2, 3), (3, 4, 6, 7)] ,2) == [(1, 2, 3), (3, 4, 6, 7)]", "assert remove_tuples([(1, 4, 4), (4, 3), (8, 6, 7), (1, ), (3, 6, 7)] , 3) == [(4, 3), (1,)]"], "context": "Write a function to remove all the tuples with length k.", "function_name": "def remove_tuples(test_list, K):", "gold_generation": "res = [ele for ele in test_list if len(ele) != K]\r\n  return (res)", "ctxs": [{"id": "19611", "text": "Function: python.library.stdtypes#dict.clear\nSnippet: clear() Remove all items from the dictionary.", "score": "0.6798362"}, {"id": "18664", "text": "Function: python.library.collections#collections.deque.clear\nSnippet: clear() Remove all elements from the deque leaving it with length 0.", "score": "0.67588985"}, {"id": "20217", "text": "Function: python.library.stdtypes#frozenset.clear\nSnippet: clear() Remove all elements from the set.", "score": "0.6739029"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6672315"}, {"id": "25756", "text": "Function: python.library.stdtypes\nSnippet: binary sequence of byte values to remove may be any bytes-like object. See removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> b'Monty Python'.rstrip(b' Python') b'M' >>> b'Monty Python'.removesuffix(b' Python') b'Monty' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3'] bytes.strip([chars]) bytearray.strip([chars]) Return a copy of the sequence with specified leading and trailing bytes removed. The chars argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters. If omitted or None, the chars argument defaults to removing ASCII whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> b' spacious '.strip() b'spacious' >>> b'www.example.com'.strip(b'cmowz.') b'example' The binary sequence of byte values to remove may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.capitalize() bytearray.capitalize() Return a copy of the sequence with each byte interpreted as an ASCII character, and the first byte capitalized and the rest", "score": "0.6594209"}]}
{"task_id": "mbpp_197", "code": "def find_exponentio(test_tup1, test_tup2):\r\n  res = tuple(ele1 ** ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res)\r\n", "test_list": ["assert find_exponentio((10, 4, 5, 6), (5, 6, 7, 5)) == (100000, 4096, 78125, 7776)", "assert find_exponentio((11, 5, 6, 7), (6, 7, 8, 6)) == (1771561, 78125, 1679616, 117649)", "assert find_exponentio((12, 6, 7, 8), (7, 8, 9, 7)) == (35831808, 1679616, 40353607, 2097152)"], "context": "Write a function to perform the exponentiation of the given two tuples.", "function_name": "def find_exponentio(test_tup1, test_tup2):", "gold_generation": "res = tuple(ele1 ** ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res)", "ctxs": [{"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.6673723"}, {"id": "19524", "text": "Function: python.library.decimal#decimal.Decimal.as_tuple\nSnippet: as_tuple() Return a named tuple representation of the number: DecimalTuple(sign, digits, exponent).", "score": "0.664594"}, {"id": "7848", "text": "Function: torch.tensors#torch.Tensor.float_power\nSnippet: float_power(exponent) → Tensor See torch.float_power()", "score": "0.657498"}, {"id": "22393", "text": "Function: python.library.operator#operator.__pow__\nSnippet: operator.pow(a, b) operator.__pow__(a, b) Return a ** b, for a and b numbers.", "score": "0.6565739"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.65478253"}]}
{"task_id": "mbpp_198", "code": "import math\r\ndef largest_triangle(a,b): \r\n    if (a < 0 or b < 0): \r\n        return -1 \r\n    area = (3 * math.sqrt(3) * pow(a, 2)) / (4 * b);  \r\n    return area ", "test_list": ["assert largest_triangle(4,2)==10.392304845413264", "assert largest_triangle(5,7)==4.639421805988064", "assert largest_triangle(9,1)==105.2220865598093"], "context": "Write a function to find the largest triangle that can be inscribed in an ellipse.", "function_name": "import math\r\ndef largest_triangle(a,b):", "gold_generation": "if (a < 0 or b < 0): \r\n        return -1 \r\n    area = (3 * math.sqrt(3) * pow(a, 2)) / (4 * b);  \r\n    return area", "ctxs": [{"id": "14440", "text": "Function: pandas.reference.api.pandas.dataframe.pow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.65124464"}, {"id": "34305", "text": "Function: matplotlib.tri_api\nSnippet: matplotlib.tri Unstructured triangular grid functions. classmatplotlib.tri.Triangulation(x, y, triangles=None, mask=None)[source] An unstructured triangular grid consisting of npoints points and ntri triangles. The triangles can either be specified by the user or automatically generated using a Delaunay triangulation. Parameters x, y(npoints,) array-like Coordinates of grid points. triangles(ntri, 3) array-like of int, optional For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If not specified, the Delaunay triangulation is calculated. mask(ntri,) array-like of bool, optional Which triangles are masked out. Notes For a Triangulation to be valid it must not have duplicate points, triangles formed from colinear points, or overlapping triangles. Attributes triangles(ntri, 3) array of int For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If you want to take the mask into account, use get_masked_triangles instead. mask(ntri, 3) array of bool Masked out triangles. is_delaunaybool Whether the Triangulation is a calculated Delaunay triangulation (where triangles was not specified) or not. calculate_plane_coefficients(z)[source] Calculate plane equation coefficients for all unmasked triangles from the point (x, y) coordinates and specified z-array of shape (npoints). The returned array has shape (npoints, 3) and allows z-value at (x, y) position in triangle tri to be calculated using z = array[tri, 0] * x + array[tri, 1] * y + array[tri, 2]. propertyedges Return integer array of shape (nedges, 2) containing all edges of non-masked triangles. Each row defines an edge by it's start point index and end point index. Each edge appears only once, i.e. for an edge between points i and j, there will only be either (i, j) or (j, i). get_cpp_triangulation()[source] Return the underlying C++ Triangulation object, creating it if necessary. staticget_from_args_and_kwargs(*args, **kwargs)[source] Return a Triangulation object from the args and kwargs, and the remaining args and kwargs with the consumed values removed. There are two alternatives: either the first argument is a Triangulation object, in which case it is returned, or the args and kwargs are sufficient to create a new Triangulation to return. In the latter case, see Triangulation.__init__ for the possible args and kwargs. get_masked_triangles()[source] Return an array of triangles that are not masked. get_trifinder()[source] Return the default matplotlib.tri.TriFinder of this triangulation, creating it if necessary. This allows the same TriFinder object to be easily shared. propertyneighbors Return integer array of shape (ntri, 3) containing neighbor triangles. For each triangle, the indices of the three triangles that share the same edges, or -1 if there is no such neighboring triangle. neighbors[i, j] is the triangle that is the neighbor to the edge from point index triangles[i, j] to point index triangles[i, (j+1)%3]. set_mask(mask)[source] Set or clear the mask array. Parameters maskNone or bool array of length ntri classmatplotlib.tri.TriContourSet(ax, *args, **kwargs)[source] Bases: matplotlib.contour.ContourSet Create and store a set of contour lines or filled regions for a triangular grid. This class is typically not instantiated directly by the user but by tricontour and tricontourf. Attributes axAxes The Axes object in which the", "score": "0.643496"}, {"id": "14476", "text": "Function: pandas.reference.api.pandas.dataframe.rpow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6431823"}, {"id": "14324", "text": "Function: pandas.reference.api.pandas.dataframe.div\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.63807"}, {"id": "33501", "text": "Function: matplotlib._as_gen.matplotlib.quiver.quiver#matplotlib.quiver.Quiver.quiver_doc\nSnippet: quiver_doc=\"\\nPlot a 2D field of arrows.\\n\\nCall signature::\\n\\n quiver([X, Y], U, V, [C], **kw)\\n\\n*X*, *Y* define the arrow locations, *U*, *V* define the arrow directions, and\\n*C* optionally sets the color.\\n\\nEach arrow is internally represented by a filled polygon with a default edge\\nlinewidth of 0. As a result, an arrow is rather a filled area, not a line with\\na head, and `.PolyCollection` properties like *linewidth*, *linestyle*,\\n*facecolor*, etc. act accordingly.\\n\\n**Arrow size**\\n\\nThe default settings auto-scales the length of the arrows to a reasonable size.\\nTo change this behavior see the *scale* and *scale_units* parameters.\\n\\n**Arrow shape**\\n\\nThe defaults give a slightly swept-back arrow; to make the head a\\ntriangle, make *headaxislength* the same as *headlength*. To make the\\narrow more pointed, reduce *headwidth* or increase *headlength* and\\n*headaxislength*. To make the head smaller relative to the shaft,\\nscale down all the head parameters. You will probably do best to leave\\nminshaft alone.\\n\\n**Arrow outline**\\n\\n*linewidths* and *edgecolors* can be used to customize the arrow\\noutlines.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the arrow locations.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y direction components of the arrow vectors.\\n\\n They must have the same number of elements, matching the number of arrow\\n locations. *U* and *V* may be masked. Only locations unmasked in\\n *U*, *V*, and *C* will be drawn.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the arrow colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *color* instead. The size of *C* must match the number of arrow\\n locations.\\n\\nunits : {'width', 'height', 'dots', 'inches', 'x', 'y', 'xy'}, default: 'width'\\n The arrow dimensions (except for *length*) are measured in multiples of\\n this unit.\\n\\n The following values are supported:\\n\\n - 'width', 'height': The width or height of the axis.\\n - 'dots', 'inches': Pixels or inches based on the figure dpi.\\n - 'x', 'y', 'xy': *X*, *Y* or :math:`\\\\sqrt{X^2 + Y^2}` in data units.\\n\\n The arrows scale differently depending on the units. For\\n 'x' or 'y', the arrows get larger as one zooms in; for other\\n units, the arrow size is independent of the zoom state. For\\n 'width or 'height', the arrow size increases with the width and\\n height of the axes, respectively, when the window is resized;\\n for 'dots' or 'inches', resizing does not change the arrows.\\n\\nangles : {'uv', 'xy'} or array-like, default: 'uv'\\n Method for determining the angle of the arrows.\\n\\n - 'uv': The arrow axis aspect ratio is 1 so that\\n if *U* == *V* the orientation of the arrow on the plot is 45 degrees\\n counter-clockwise from the horizontal axis (positive to the right).\\n\\n Use this if the arrows", "score": "0.63436985"}]}
{"task_id": "mbpp_199", "code": "def highest_Power_of_2(n): \r\n    res = 0; \r\n    for i in range(n, 0, -1):  \r\n        if ((i & (i - 1)) == 0): \r\n            res = i; \r\n            break;      \r\n    return res; ", "test_list": ["assert highest_Power_of_2(10) == 8", "assert highest_Power_of_2(19) == 16", "assert highest_Power_of_2(32) == 32"], "context": "Write a python function to find highest power of 2 less than or equal to given number.", "function_name": "def highest_Power_of_2(n):", "gold_generation": "res = 0; \r\n    for i in range(n, 0, -1):  \r\n        if ((i & (i - 1)) == 0): \r\n            res = i; \r\n            break;      \r\n    return res;", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.70382124"}, {"id": "21825", "text": "Function: python.library.math#math.pow\nSnippet: math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError. Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers.", "score": "0.6917735"}, {"id": "20290", "text": "Function: python.library.functions\nSnippet: integer representing the Unicode code point of that character. For example, ord('a') returns the integer 97 and ord('€') (Euro sign) returns 8364. This is the inverse of chr(). pow(base, exp[, mod]) Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp. The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10**2 returns 100, but 10**-2 returns 0.01. For int operands base and exp, if mod is present, mod must also be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod. In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod. Here’s an example of computing an inverse for 38 modulo 97: >>> pow(38, -1, mod=97) 23 >>> 23 * 38 % 97 == 1 True Changed in version 3.8: For int operands, the three-argument form of pow now allows the second argument to be negative, permitting computation of modular inverses. Changed in version 3.8: Allow keyword arguments. Formerly, only positional arguments were supported. print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False) Print objects to the text stream file, separated by sep and followed by end. sep, end, file and flush, if present, must be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end. The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Since printed arguments are converted to text strings, print() cannot be used with binary mode file objects. For these, use file.write(...) instead. Whether output is buffered is usually determined by file, but if the flush keyword argument is true, the stream is forcibly flushed. Changed in version 3.3: Added the flush keyword argument. class property(fget=None, fset=None, fdel=None, doc=None) Return a property attribute. fget is a function for getting an attribute value. fset is a function for setting an attribute value. fdel is a function for deleting an attribute value. And doc creates a docstring for the attribute. A typical use is to define a managed attribute x: class C: def __init__(self): self._x = None def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") If c is an instance of C, c.x", "score": "0.6778214"}, {"id": "21777", "text": "Function: python.library.math\nSnippet: Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers. math.sqrt(x) Return the square root of x. Trigonometric functions math.acos(x) Return the arc cosine of x, in radians. The result is between 0 and pi. math.asin(x) Return the arc sine of x, in radians. The result is between -pi/2 and pi/2. math.atan(x) Return the arc tangent of x, in radians. The result is between -pi/2 and pi/2. math.atan2(y, x) Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4. math.cos(x) Return the cosine of x radians. math.dist(p, q) Return the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Roughly equivalent to: sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q))) New in version 3.8. math.hypot(*coordinates) Return the Euclidean norm, sqrt(sum(x**2 for x in coordinates)). This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point (x, y), this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, sqrt(x*x + y*y). Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. math.sin(x) Return the sine of x radians. math.tan(x) Return the tangent of x radians. Angular conversion math.degrees(x) Convert angle x from radians to degrees. math.radians(x) Convert angle x from degrees to radians. Hyperbolic functions Hyperbolic functions are analogs of trigonometric functions that are based on hyperbolas instead of circles. math.acosh(x) Return the inverse hyperbolic cosine of x. math.asinh(x) Return the inverse hyperbolic sine of x. math.atanh(x) Return the inverse hyperbolic tangent of x. math.cosh(x) Return the hyperbolic cosine of x. math.sinh(x) Return the hyperbolic sine of x. math.tanh(x) Return the hyperbolic tangent of x. Special functions math.erf(x) Return the error function at x. The erf() function can be used to compute traditional statistical functions such as the cumulative standard normal distribution: def phi(x): 'Cumulative distribution function for the standard normal distribution' return (1.0 + erf(x / sqrt(2.0))) / 2.0 New in version 3.2. math.erfc(x) Return the complementary error function at x. The complementary error function is defined as 1.0 - erf(x). It is used for large values of x where a subtraction from one would cause a loss of significance. New in version 3.2. math.gamma(x) Return the Gamma function at x. New in version 3.2. math.lgamma(x) Return the natural logarithm of the absolute value of the Gamma function at x. New in version 3.2. Constants math.pi The mathematical constant π =", "score": "0.6767264"}, {"id": "19448", "text": "Function: python.library.decimal#decimal.Context\nSnippet: operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x - y * n, where n is the integer nearest the exact value of x / y (if the result is 0 then its sign will be the sign of x). rotate(x, y) Returns a rotated copy of x, y times. same_quantum(x, y) Returns True if the two operands have the same exponent. scaleb(x, y) Returns the first operand after adding the second value its exp. shift(x, y) Returns a shifted copy of x, y times. sqrt(x) Square root of a non-negative number to context precision. subtract(x, y) Return the difference between x and y. to_eng_string(x) Convert to a string, using engineering", "score": "0.676444"}]}
{"task_id": "mbpp_200", "code": "def position_max(list1):\r\n    max_val = max(list1)\r\n    max_result = [i for i, j in enumerate(list1) if j == max_val]\r\n    return max_result", "test_list": ["assert position_max([12,33,23,10,67,89,45,667,23,12,11,10,54])==[7]", "assert position_max([1,2,2,2,4,4,4,5,5,5,5])==[7,8,9,10]", "assert position_max([2,1,5,6,8,3,4,9,10,11,8,12])==[11]"], "context": "Write a function to find all index positions of the maximum values in a given list.", "function_name": "def position_max(list1):", "gold_generation": "max_val = max(list1)\r\n    max_result = [i for i, j in enumerate(list1) if j == max_val]\r\n    return max_result", "ctxs": [{"id": "43829", "text": "Function: numpy.reference.generated.numpy.recarray.argmax\nSnippet: numpy.recarray.argmax method recarray.argmax(axis=None, out=None) Return indices of the maximum values along the given axis. Refer to numpy.argmax for full documentation. See also numpy.argmax equivalent function", "score": "0.696366"}, {"id": "42501", "text": "Function: numpy.reference.generated.numpy.ndarray.argmax\nSnippet: numpy.ndarray.argmax method ndarray.argmax(axis=None, out=None) Return indices of the maximum values along the given axis. Refer to numpy.argmax for full documentation. See also numpy.argmax equivalent function", "score": "0.6912158"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.6869737"}, {"id": "14730", "text": "Function: pandas.reference.api.pandas.index.max\nSnippet: pandas.Index.max Index.max(axis=None, skipna=True, *args, **kwargs)[source] Return the maximum value of the Index. Parameters axis:int, optional For compatibility with NumPy. Only 0 or None are allowed. skipna:bool, default True Exclude NA/null values when showing the result. *args, **kwargs Additional arguments and keywords for compatibility with NumPy. Returns scalar Maximum value. See also Index.min Return the minimum value in an Index. Series.max Return the maximum value in a Series. DataFrame.max Return the maximum values in a DataFrame. Examples >>> idx = pd.Index([3, 2, 1]) >>> idx.max() 3 >>> idx = pd.Index(['c', 'b', 'a']) >>> idx.max() 'c' For a MultiIndex, the maximum is determined lexicographically. >>> idx = pd.MultiIndex.from_product([('a', 'b'), (2, 1)]) >>> idx.max() ('b', 2)", "score": "0.6831677"}, {"id": "43857", "text": "Function: numpy.reference.generated.numpy.recarray.max\nSnippet: numpy.recarray.max method recarray.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the maximum along a given axis. Refer to numpy.amax for full documentation. See also numpy.amax equivalent function", "score": "0.6801399"}]}
{"task_id": "mbpp_201", "code": "def chkList(lst): \r\n    return len(set(lst)) == 1", "test_list": ["assert chkList(['one','one','one']) == True", "assert chkList(['one','Two','Three']) == False", "assert chkList(['bigdata','python','Django']) == False"], "context": "Write a python function to check whether the elements in a list are same or not.", "function_name": "def chkList(lst):", "gold_generation": "return len(set(lst)) == 1", "ctxs": [{"id": "14705", "text": "Function: pandas.reference.api.pandas.index.identical\nSnippet: pandas.Index.identical finalIndex.identical(other)[source] Similar to equals, but checks that object attributes and types are also equal. Returns bool If two Index objects have equal elements and same type True, otherwise False.", "score": "0.71092194"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.7019049"}, {"id": "26075", "text": "Function: python.library.unittest#unittest.TestCase.assertCountEqual\nSnippet: assertCountEqual(first, second, msg=None) Test that sequence first contains the same elements as second, regardless of their order. When they don’t, an error message listing the differences between the sequences will be generated. Duplicate elements are not ignored when comparing first and second. It verifies whether each element has the same count in both sequences. Equivalent to: assertEqual(Counter(list(first)), Counter(list(second))) but works with sequences of unhashable objects as well. New in version 3.2.", "score": "0.68987924"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.68750876"}, {"id": "19651", "text": "Function: python.library.difflib#difflib.SequenceMatcher.ratio\nSnippet: ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5", "score": "0.68469256"}]}
{"task_id": "mbpp_202", "code": "def remove_even(str1):\r\n str2 = ''\r\n for i in range(1, len(str1) + 1):\r\n    if(i % 2 != 0):\r\n        str2 = str2 + str1[i - 1]\r\n return str2", "test_list": ["assert remove_even(\"python\")==(\"pto\")", "assert remove_even(\"program\")==(\"porm\")", "assert remove_even(\"language\")==(\"lnug\")"], "context": "Write a function to remove even characters in a string.", "function_name": "def remove_even(str1):", "gold_generation": "str2 = ''\r\n for i in range(1, len(str1) + 1):\r\n    if(i % 2 != 0):\r\n        str2 = str2 + str1[i - 1]\r\n return str2", "ctxs": [{"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.6849937"}, {"id": "24398", "text": "Function: python.library.string\nSnippet: characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", "score": "0.684241"}, {"id": "25746", "text": "Function: python.library.stdtypes\nSnippet: Return -1 on failure. str.rindex(sub[, start[, end]]) Like rfind() but raises ValueError when the substring sub is not found. str.rjust(width[, fillchar]) Return the string right justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.rpartition(sep) Split the string at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself. str.rsplit(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any whitespace string is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below. str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty' str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3'] str.splitlines([keepends]) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. This", "score": "0.6776976"}, {"id": "24376", "text": "Function: python.library.stdtypes#str.rstrip\nSnippet: str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty'", "score": "0.67319125"}, {"id": "41702", "text": "Function: numpy.reference.generated.numpy.char.chararray.strip\nSnippet: numpy.char.chararray.strip method char.chararray.strip(chars=None)[source] For each element in self, return a copy with the leading and trailing characters removed. See also char.strip", "score": "0.67195225"}]}
{"task_id": "mbpp_203", "code": "def hamming_Distance(n1,n2) : \r\n    x = n1 ^ n2  \r\n    setBits = 0\r\n    while (x > 0) : \r\n        setBits += x & 1\r\n        x >>= 1\r\n    return setBits  ", "test_list": ["assert hamming_Distance(4,8) == 2", "assert hamming_Distance(2,4) == 2", "assert hamming_Distance(1,2) == 2"], "context": "Write a python function to find the hamming distance between given two integers.", "function_name": "def hamming_Distance(n1,n2) :", "gold_generation": "x = n1 ^ n2  \r\n    setBits = 0\r\n    while (x > 0) : \r\n        setBits += x & 1\r\n        x >>= 1\r\n    return setBits", "ctxs": [{"id": "19651", "text": "Function: python.library.difflib#difflib.SequenceMatcher.ratio\nSnippet: ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5", "score": "0.6791736"}, {"id": "19628", "text": "Function: python.library.difflib\nSnippet: as large as ratio(): >>> s = SequenceMatcher(None, \"abcd\", \"bcde\") >>> s.ratio() 0.75 >>> s.quick_ratio() 0.75 >>> s.real_quick_ratio() 1.0 SequenceMatcher Examples This example compares two strings, considering blanks to be “junk”: >>> s = SequenceMatcher(lambda x: x == \" \", ... \"private Thread currentThread;\", ... \"private volatile Thread currentThread;\") ratio() returns a float in [0, 1], measuring the similarity of the sequences. As a rule of thumb, a ratio() value over 0.6 means the sequences are close matches: >>> print(round(s.ratio(), 3)) 0.866 If you’re only interested in where the sequences match, get_matching_blocks() is handy: >>> for block in s.get_matching_blocks(): ... print(\"a[%d] and b[%d] match for %d elements\" % block) a[0] and b[0] match for 8 elements a[8] and b[17] match for 21 elements a[29] and b[38] match for 0 elements Note that the last tuple returned by get_matching_blocks() is always a dummy, (len(a), len(b), 0), and this is the only case in which the last tuple element (number of elements matched) is 0. If you want to know how to change the first sequence into the second, use get_opcodes(): >>> for opcode in s.get_opcodes(): ... print(\"%6s a[%d:%d] b[%d:%d]\" % opcode) equal a[0:8] b[0:8] insert a[8:8] b[8:17] equal a[8:29] b[17:38] See also The get_close_matches() function in this module which shows how simple code building on SequenceMatcher can be used to do useful work. Simple version control recipe for a small application built with SequenceMatcher. Differ Objects Note that Differ-generated deltas make no claim to be minimal diffs. To the contrary, minimal diffs are often counter-intuitive, because they synch up anywhere possible, sometimes accidental matches 100 pages apart. Restricting synch points to contiguous matches preserves some notion of locality, at the occasional cost of producing a longer diff. The Differ class has this constructor: class difflib.Differ(linejunk=None, charjunk=None) Optional keyword parameters linejunk and charjunk are for filter functions (or None): linejunk: A function that accepts a single string argument, and returns true if the string is junk. The default is None, meaning that no line is considered junk. charjunk: A function that accepts a single character argument (a string of length 1), and returns true if the character is junk. The default is None, meaning that no character is considered junk. These junk-filtering functions speed up matching to find differences and do not cause any differing lines or characters to be ignored. Read the description of the find_longest_match() method’s isjunk parameter for an explanation. Differ objects are used (deltas generated) via a single method: compare(a, b) Compare two sequences of lines, and generate the delta (a sequence of lines). Each sequence must contain individual single-line strings ending with newlines. Such sequences can be obtained from the readlines() method of file-like objects. The delta generated also consists of newline-terminated strings, ready to be printed as-is via the writelines() method of a file-like object. Differ Example This example compares two texts. First we set up the texts, sequences of individual single-line strings ending with newlines (such sequences can also be obtained from the readlines() method", "score": "0.66852254"}, {"id": "42873", "text": "Function: numpy.reference.generated.numpy.hamming\nSnippet: numpy.hamming numpy.hamming(M)[source] Return the Hamming window. The Hamming window is a taper formed by using a weighted cosine. Parameters Mint Number of points in the output window. If zero or less, an empty array is returned. Returns outndarray The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd). See also bartlett, blackman, hanning, kaiser Notes The Hamming window is defined as \\[w(n) = 0.54 - 0.46cos\\left(\\frac{2\\pi{n}}{M-1}\\right) \\qquad 0 \\leq n \\leq M-1\\] The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and is described in Blackman and Tukey. It was recommended for smoothing the truncated autocovariance function in the time domain. Most references to the Hamming window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means “removing the foot”, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function. References 1 Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra, Dover Publications, New York. 2 E.R. Kanasewich, “Time Sequence Analysis in Geophysics”, The University of Alberta Press, 1975, pp. 109-110. 3 Wikipedia, “Window function”, https://en.wikipedia.org/wiki/Window_function 4 W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, “Numerical Recipes”, Cambridge University Press, 1986, page 425. Examples >>> np.hamming(12) array([ 0.08 , 0.15302337, 0.34890909, 0.60546483, 0.84123594, # may vary 0.98136677, 0.98136677, 0.84123594, 0.60546483, 0.34890909, 0.15302337, 0.08 ]) Plot the window and the frequency response: >>> import matplotlib.pyplot as plt >>> from numpy.fft import fft, fftshift >>> window = np.hamming(51) >>> plt.plot(window) [<matplotlib.lines.Line2D object at 0x...>] >>> plt.title(\"Hamming window\") Text(0.5, 1.0, 'Hamming window') >>> plt.ylabel(\"Amplitude\") Text(0, 0.5, 'Amplitude') >>> plt.xlabel(\"Sample\") Text(0.5, 0, 'Sample') >>> plt.show() >>> plt.figure() <Figure size 640x480 with 0 Axes> >>> A = fft(window, 2048) / 25.5 >>> mag = np.abs(fftshift(A)) >>> freq = np.linspace(-0.5, 0.5, len(A)) >>> response = 20 * np.log10(mag) >>> response = np.clip(response, -100, 100) >>> plt.plot(freq, response) [<matplotlib.lines.Line2D object at 0x...>] >>> plt.title(\"Frequency response of Hamming window\") Text(0.5, 1.0, 'Frequency response of Hamming window') >>> plt.ylabel(\"Magnitude [dB]\") Text(0, 0.5, 'Magnitude [dB]') >>> plt.xlabel(\"Normalized frequency [cycles per sample]\") Text(0.5, 0, 'Normalized frequency [cycles per sample]') >>> plt.axis('tight') ... >>> plt.show()", "score": "0.6612053"}, {"id": "19646", "text": "Function: python.library.difflib#difflib.SequenceMatcher.find_longest_match\nSnippet: find_longest_match(alo=0, ahi=None, blo=0, bhi=None) Find longest matching block in a[alo:ahi] and b[blo:bhi]. If isjunk was omitted or None, find_longest_match() returns (i, j, k) such that a[i:i+k] is equal to b[j:j+k], where alo <= i <= i+k <= ahi and blo <= j <= j+k <= bhi. For all (i', j', k') meeting those conditions, the additional conditions k >= k', i <= i', and if i == i', j <= j' are also met. In other words, of all maximal matching blocks, return one that starts earliest in a, and of all those maximal matching blocks that start earliest in a, return the one that starts earliest in b. >>> s = SequenceMatcher(None, \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=0, b=4, size=5) If isjunk was provided, first the longest matching block is determined as above, but with the additional restriction that no junk element appears in the block. Then that block is extended as far as possible by matching (only) junk elements on both sides. So the resulting block never matches on junk except as identical junk happens to be adjacent to an interesting match. Here’s the same example as before, but considering blanks to be junk. That prevents ' abcd' from matching the ' abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments.", "score": "0.6606014"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6568662"}]}
{"task_id": "mbpp_204", "code": "def count(s,c) : \r\n    res = 0 \r\n    for i in range(len(s)) : \r\n        if (s[i] == c): \r\n            res = res + 1\r\n    return res ", "test_list": ["assert count(\"abcc\",\"c\") == 2", "assert count(\"ababca\",\"a\") == 3", "assert count(\"mnmm0pm\",\"m\") == 4"], "context": "Write a python function to count the occurrence of a given character in a string.", "function_name": "def count(s,c) :", "gold_generation": "res = 0 \r\n    for i in range(len(s)) : \r\n        if (s[i] == c): \r\n            res = res + 1\r\n    return res", "ctxs": [{"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.75091374"}, {"id": "22306", "text": "Function: python.library.operator#operator.countOf\nSnippet: operator.countOf(a, b) Return the number of occurrences of b in a.", "score": "0.72836447"}, {"id": "41718", "text": "Function: numpy.reference.generated.numpy.char.count\nSnippet: numpy.char.count char.count(a, sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. Calls str.count element-wise. Parameters aarray_like of str or unicode substr or unicode The substring to search for. start, endint, optional Optional arguments start and end are interpreted as slice notation to specify the range in which to count. Returns outndarray Output array of ints. See also str.count Examples >>> c = np.array(['aAaAaA', ' aA ', 'abBABba']) >>> c array(['aAaAaA', ' aA ', 'abBABba'], dtype='<U7') >>> np.char.count(c, 'A') array([3, 1, 1]) >>> np.char.count(c, 'aA') array([3, 1, 0]) >>> np.char.count(c, 'A', start=1, end=4) array([2, 1, 1]) >>> np.char.count(c, 'A', start=1, end=3) array([1, 0, 0])", "score": "0.725269"}, {"id": "41643", "text": "Function: numpy.reference.generated.numpy.char.chararray.count\nSnippet: numpy.char.chararray.count method char.chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.7222154"}, {"id": "41768", "text": "Function: numpy.reference.generated.numpy.chararray.count\nSnippet: numpy.chararray.count method chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.7210059"}]}
{"task_id": "mbpp_205", "code": "def inversion_elements(test_tup):\r\n  res = tuple(list(map(lambda x: ~x, list(test_tup))))\r\n  return (res) ", "test_list": ["assert inversion_elements((7, 8, 9, 1, 10, 7)) == (-8, -9, -10, -2, -11, -8)", "assert inversion_elements((2, 4, 5, 6, 1, 7)) == (-3, -5, -6, -7, -2, -8)", "assert inversion_elements((8, 9, 11, 14, 12, 13)) == (-9, -10, -12, -15, -13, -14)"], "context": "Write a function to find the inversions of tuple elements in the given tuple list.", "function_name": "def inversion_elements(test_tup):", "gold_generation": "res = tuple(list(map(lambda x: ~x, list(test_tup))))\r\n  return (res)", "ctxs": [{"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6876588"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6820235"}, {"id": "25738", "text": "Function: python.library.stdtypes\nSnippet: from s (2) s.remove(x) remove the first item from s where s[i] is equal to x (3) s.reverse() reverses the items of s in place (4) Notes: t must have the same length as the slice it is replacing. The optional argument i defaults to -1, so that by default the last item is removed and returned. remove() raises ValueError when x is not found in s. The reverse() method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence. clear() and copy() are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as dict and set). copy() is not part of the collections.abc.MutableSequence ABC, but most concrete mutable sequence classes provide it. New in version 3.3: clear() and copy() methods. The value n is an integer, or an object implementing __index__(). Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for s * n under Common Sequence Operations. Lists Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). class list([iterable]) Lists may be constructed in several ways: Using a pair of square brackets to denote the empty list: [] Using square brackets, separating items with commas: [a], [a, b, c] Using a list comprehension: [x for x in iterable] Using the type constructor: list() or list(iterable) The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to iterable[:]. For example, list('abc') returns ['a', 'b', 'c'] and list( (1, 2, 3) ) returns [1, 2, 3]. If no argument is given, the constructor creates a new empty list, []. Many other operations also produce lists, including the sorted() built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is", "score": "0.67820984"}, {"id": "43229", "text": "Function: numpy.reference.generated.numpy.transpose\nSnippet: numpy.transpose numpy.transpose(a, axes=None)[source] Reverse or permute the axes of an array; returns the modified array. For an array a with two axes, transpose(a) gives the matrix transpose. Refer to numpy.ndarray.transpose for full documentation. Parameters aarray_like Input array. axestuple or list of ints, optional If specified, it must be a tuple or list which contains a permutation of [0,1,..,N-1] where N is the number of axes of a. The i’th axis of the returned array will correspond to the axis numbered axes[i] of the input. If not specified, defaults to range(a.ndim)[::-1], which reverses the order of the axes. Returns pndarray a with its axes permuted. A view is returned whenever possible. See also ndarray.transpose Equivalent method moveaxis argsort Notes Use transpose(a, argsort(axes)) to invert the transposition of tensors when using the axes keyword argument. Transposing a 1-D array returns an unchanged view of the original array. Examples >>> x = np.arange(4).reshape((2,2)) >>> x array([[0, 1], [2, 3]]) >>> np.transpose(x) array([[0, 2], [1, 3]]) >>> x = np.ones((1, 2, 3)) >>> np.transpose(x, (1, 0, 2)).shape (2, 1, 3) >>> x = np.ones((2, 3, 4, 5)) >>> np.transpose(x).shape (5, 4, 3, 2)", "score": "0.6740043"}, {"id": "42910", "text": "Function: numpy.reference.generated.numpy.invert\nSnippet: numpy.invert numpy.invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'invert'> Compute bit-wise inversion, or bit-wise NOT, element-wise. Computes the bit-wise NOT of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator ~. For signed integer inputs, the two’s complement is returned. In a two’s-complement system negative numbers are represented by the two’s complement of the absolute value. This is the most common method of representing signed integers on computers [1]. A N-bit two’s-complement system can represent every integer in the range \\(-2^{N-1}\\) to \\(+2^{N-1}-1\\). Parameters xarray_like Only integer and boolean types are handled. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Result. This is a scalar if x is a scalar. See also bitwise_and, bitwise_or, bitwise_xor logical_not binary_repr Return the binary representation of the input number as a string. Notes bitwise_not is an alias for invert: >>> np.bitwise_not is np.invert True References 1 Wikipedia, “Two’s complement”, https://en.wikipedia.org/wiki/Two’s_complement Examples We’ve seen that 13 is represented by 00001101. The invert or bit-wise NOT of 13 is then: >>> x = np.invert(np.array(13, dtype=np.uint8)) >>> x 242 >>> np.binary_repr(x, width=8) '11110010' The result depends on the bit-width: >>> x = np.invert(np.array(13, dtype=np.uint16)) >>> x 65522 >>> np.binary_repr(x, width=16) '1111111111110010' When using signed integer types the result is the two’s complement of the result for the unsigned type: >>> np.invert(np.array([13], dtype=np.int8)) array([-14], dtype=int8) >>> np.binary_repr(-14, width=8) '11110010' Booleans are accepted as well: >>> np.invert(np.array([True, False])) array([False, True]) The ~ operator can be used as a shorthand for np.invert on ndarrays. >>> x1 = np.array([True, False]) >>> ~x1 array([False, True])", "score": "0.6732093"}]}
{"task_id": "mbpp_206", "code": "def concatenate_elements(test_tup):\r\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\r\n  return (res) ", "test_list": ["assert concatenate_elements((\"DSP \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"UTS\")) == ('DSP IS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL UTS')", "assert concatenate_elements((\"RES \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"QESR\")) == ('RES IS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL QESR')", "assert concatenate_elements((\"MSAM\", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"SKD\")) == ('MSAMIS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL SKD')"], "context": "Write a function to perform the adjacent element concatenation in the given tuples.", "function_name": "def concatenate_elements(test_tup):", "gold_generation": "res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\r\n  return (res)", "ctxs": [{"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.68927556"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.6879574"}, {"id": "25737", "text": "Function: python.library.stdtypes\nSnippet: a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str objects, you can build a list and use str.join() at the end or else write to an io.StringIO instance and retrieve its value when complete if concatenating bytes objects, you can similarly use bytes.join() or io.BytesIO, or you can do in-place concatenation with a bytearray object. bytearray objects are mutable and have an efficient overallocation mechanism if concatenating tuple objects, extend a list instead for other types, investigate the relevant class documentation Some sequence types (such as range) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition. index raises ValueError when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using s[i:j].index(x), only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. Immutable Sequence Types The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the hash() built-in. This support allows immutable sequences, such as tuple instances, to be used as dict keys and stored in set and frozenset instances. Attempting to hash an immutable sequence that contains unhashable values will result in TypeError. Mutable Sequence Types The operations in the following table are defined on mutable sequence types. The collections.abc.MutableSequence ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, bytearray only accepts integers that meet the value restriction 0 <= x <= 255). Operation Result Notes s[i] = x item i of s is replaced by x s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t del s[i:j] same as s[i:j] = [] s[i:j:k] = t the elements of s[i:j:k] are replaced by those of t (1) del s[i:j:k] removes the elements of s[i:j:k] from the list s.append(x) appends x to the end of the sequence (same as s[len(s):len(s)] = [x]) s.clear() removes all items from s (same as del s[:]) (5) s.copy() creates a shallow copy of s (same as s[:]) (5) s.extend(t) or s += t extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t) s *= n updates s with its contents repeated n times (6) s.insert(i, x) inserts x into s at the index given by i (same as s[i:i] = [x]) s.pop([i]) retrieves the item at i and also removes it", "score": "0.6838133"}, {"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.6834435"}, {"id": "42115", "text": "Function: numpy.reference.generated.numpy.ma.concatenate\nSnippet: numpy.ma.concatenate ma.concatenate(arrays, axis=0)[source] Concatenate a sequence of arrays along the given axis. Parameters arrayssequence of array_like The arrays must have the same shape, except in the dimension corresponding to axis (the first, by default). axisint, optional The axis along which the arrays will be joined. Default is 0. Returns resultMaskedArray The concatenated array with any masked entries preserved. See also numpy.concatenate Equivalent function in the top-level NumPy module. Examples >>> import numpy.ma as ma >>> a = ma.arange(3) >>> a[1] = ma.masked >>> b = ma.arange(2, 5) >>> a masked_array(data=[0, --, 2], mask=[False, True, False], fill_value=999999) >>> b masked_array(data=[2, 3, 4], mask=False, fill_value=999999) >>> ma.concatenate([a, b]) masked_array(data=[0, --, 2, 2, 3, 4], mask=[False, True, False, False, False, False], fill_value=999999)", "score": "0.6812825"}]}
{"task_id": "mbpp_207", "code": "def find_longest_repeating_subseq(str): \r\n\tn = len(str) \r\n\tdp = [[0 for k in range(n+1)] for l in range(n+1)] \r\n\tfor i in range(1, n+1): \r\n\t\tfor j in range(1, n+1): \r\n\t\t\tif (str[i-1] == str[j-1] and i != j): \r\n\t\t\t\tdp[i][j] = 1 + dp[i-1][j-1] \r\n\t\t\telse: \r\n\t\t\t\tdp[i][j] = max(dp[i][j-1], dp[i-1][j]) \r\n\treturn dp[n][n]", "test_list": ["assert find_longest_repeating_subseq(\"AABEBCDD\") == 3", "assert find_longest_repeating_subseq(\"aabb\") == 2", "assert find_longest_repeating_subseq(\"aab\") == 1"], "context": "Write a function to count the longest repeating subsequences such that the two subsequences don’t have same string characters at same positions.", "function_name": "def find_longest_repeating_subseq(str):", "gold_generation": "n = len(str) \r\n\tdp = [[0 for k in range(n+1)] for l in range(n+1)] \r\n\tfor i in range(1, n+1): \r\n\t\tfor j in range(1, n+1): \r\n\t\t\tif (str[i-1] == str[j-1] and i != j): \r\n\t\t\t\tdp[i][j] = 1 + dp[i-1][j-1] \r\n\t\t\telse: \r\n\t\t\t\tdp[i][j] = max(dp[i][j-1], dp[i-1][j]) \r\n\treturn dp[n][n]", "ctxs": [{"id": "19646", "text": "Function: python.library.difflib#difflib.SequenceMatcher.find_longest_match\nSnippet: find_longest_match(alo=0, ahi=None, blo=0, bhi=None) Find longest matching block in a[alo:ahi] and b[blo:bhi]. If isjunk was omitted or None, find_longest_match() returns (i, j, k) such that a[i:i+k] is equal to b[j:j+k], where alo <= i <= i+k <= ahi and blo <= j <= j+k <= bhi. For all (i', j', k') meeting those conditions, the additional conditions k >= k', i <= i', and if i == i', j <= j' are also met. In other words, of all maximal matching blocks, return one that starts earliest in a, and of all those maximal matching blocks that start earliest in a, return the one that starts earliest in b. >>> s = SequenceMatcher(None, \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=0, b=4, size=5) If isjunk was provided, first the longest matching block is determined as above, but with the additional restriction that no junk element appears in the block. Then that block is extended as far as possible by matching (only) junk elements on both sides. So the resulting block never matches on junk except as identical junk happens to be adjacent to an interesting match. Here’s the same example as before, but considering blanks to be junk. That prevents ' abcd' from matching the ' abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments.", "score": "0.72474873"}, {"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.71523905"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.7111796"}, {"id": "18304", "text": "Function: python.library.stdtypes#bytes.count\nSnippet: bytes.count(sub[, start[, end]]) bytearray.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.69889873"}, {"id": "18260", "text": "Function: python.library.stdtypes#bytearray.count\nSnippet: bytes.count(sub[, start[, end]]) bytearray.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.6987066"}]}
{"task_id": "mbpp_208", "code": "import re\r\ndef is_decimal(num):\r\n  num_fetch = re.compile(r\"\"\"^[0-9]+(\\.[0-9]{1,2})?$\"\"\")\r\n  result = num_fetch.search(num)\r\n  return bool(result)", "test_list": ["assert is_decimal('123.11') == True", "assert is_decimal('0.21') == True", "assert is_decimal('123.1214') == False"], "context": "Write a function to check the given decimal with a precision of 2 by using regex.", "function_name": "import re\r\ndef is_decimal(num):", "gold_generation": "num_fetch = re.compile(r\"\"\"^[0-9]+(\\.[0-9]{1,2})?$\"\"\")\r\n  result = num_fetch.search(num)\r\n  return bool(result)", "ctxs": [{"id": "19587", "text": "Function: python.library.decimal#decimal.MAX_PREC\nSnippet: decimal.MAX_PREC", "score": "0.7129576"}, {"id": "23307", "text": "Function: python.library.re\nSnippet: '^' matches only at the beginning of the string, and '$' only at the end of the string and immediately before the newline (if any) at the end of the string. Corresponds to the inline flag (?m). re.S re.DOTALL Make the '.' special character match any character at all, including a newline; without this flag, '.' will match anything except a newline. Corresponds to the inline flag (?s). re.X re.VERBOSE This flag allows you to write regular expressions that look nicer and are more readable by allowing you to visually separate logical sections of the pattern and add comments. Whitespace within the pattern is ignored, except when in a character class, or when preceded by an unescaped backslash, or within tokens like *?, (?: or (?P<...>. When a line contains a # that is not in a character class and is not preceded by an unescaped backslash, all characters from the leftmost such # through the end of the line are ignored. This means that the two following regular expression objects that match a decimal number are functionally equal: a = re.compile(r\"\"\"\\d + # the integral part \\. # the decimal point \\d * # some fractional digits\"\"\", re.X) b = re.compile(r\"\\d+\\.\\d*\") Corresponds to the inline flag (?x). re.search(pattern, string, flags=0) Scan through string looking for the first location where the regular expression pattern produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. re.match(pattern, string, flags=0) If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. Note that even in MULTILINE mode, re.match() will only match at the beginning of the string and not at the beginning of each line. If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). re.fullmatch(pattern, string, flags=0) If the whole string matches the regular expression pattern, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. New in version 3.4. re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string,", "score": "0.7084171"}, {"id": "19516", "text": "Function: python.library.decimal#decimal.Decimal\nSnippet: class decimal.Decimal(value=\"0\", context=None) Construct a new Decimal object based from value. value can be an integer, string, tuple, float, or another Decimal object. If no value is given, returns Decimal('0'). If value is a string, it should conform to the decimal numeric string syntax after leading and trailing whitespace characters, as well as underscores throughout, are removed: sign ::= '+' | '-' digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' indicator ::= 'e' | 'E' digits ::= digit [digit]... decimal-part ::= digits '.' [digits] | ['.'] digits exponent-part ::= indicator [sign] digits infinity ::= 'Infinity' | 'Inf' nan ::= 'NaN' [digits] | 'sNaN' [digits] numeric-value ::= decimal-part [exponent-part] | infinity numeric-string ::= [sign] numeric-value | [sign] nan Other Unicode decimal digits are also permitted where digit appears above. These include decimal digits from various other alphabets (for example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits '\\uff10' through '\\uff19'. If value is a tuple, it should have three components, a sign (0 for positive or 1 for negative), a tuple of digits, and an integer exponent. For example, Decimal((0, (1, 4, 1, 4), -3)) returns Decimal('1.414'). If value is a float, the binary floating point value is losslessly converted to its exact decimal equivalent. This conversion can often require 53 or more digits of precision. For example, Decimal(float('1.1')) converts to Decimal('1.100000000000000088817841970012523233890533447265625'). The context precision does not affect how many digits are stored. That is determined exclusively by the number of digits in value. For example, Decimal('3.00000') records all five zeros even if the context precision is only three. The purpose of the context argument is determining what to do if value is a malformed string. If the context traps InvalidOperation, an exception is raised; otherwise, the constructor returns a new Decimal with the value of NaN. Once constructed, Decimal objects are immutable. Changed in version 3.2: The argument to the constructor is now permitted to be a float instance. Changed in version 3.3: float arguments raise an exception if the FloatOperation trap is set. By default the trap is off. Changed in version 3.6: Underscores are allowed for grouping, as with integral and floating-point literals in code. Decimal floating point objects share many properties with the other built-in numeric types such as float and int. All of the usual math operations and special methods apply. Likewise, decimal objects can be copied, pickled, printed, used as dictionary keys, used as set elements, compared, sorted, and coerced to another type (such as float or int). There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator % is applied to Decimal objects, the sign of the result is the sign of the dividend rather than the sign of the divisor: >>> (-7) % 4 1 >>> Decimal(-7) % Decimal(4) Decimal('-3') The integer division operator // behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather", "score": "0.6929362"}, {"id": "19504", "text": "Function: python.library.decimal#decimal.Context.radix\nSnippet: radix() Just returns 10, as this is Decimal, :)", "score": "0.6776806"}, {"id": "19455", "text": "Function: python.library.decimal#decimal.Context.compare\nSnippet: compare(x, y) Compares x and y numerically.", "score": "0.67502636"}]}
{"task_id": "mbpp_209", "code": "import heapq as hq\r\ndef heap_replace(heap,a):\r\n  hq.heapify(heap)\r\n  hq.heapreplace(heap, a)\r\n  return heap", "test_list": ["assert heap_replace( [25, 44, 68, 21, 39, 23, 89],21)==[21, 25, 23, 44, 39, 68, 89]", "assert heap_replace([25, 44, 68, 21, 39, 23, 89],110)== [23, 25, 68, 44, 39, 110, 89]", "assert heap_replace([25, 44, 68, 21, 39, 23, 89],500)==[23, 25, 68, 44, 39, 500, 89]"], "context": "Write a function to delete the smallest element from the given heap and then insert a new item.", "function_name": "import heapq as hq\r\ndef heap_replace(heap,a):", "gold_generation": "hq.heapify(heap)\r\n  hq.heapreplace(heap, a)\r\n  return heap", "ctxs": [{"id": "20486", "text": "Function: python.library.heapq#heapq.heapreplace\nSnippet: heapq.heapreplace(heap, item) Pop and return the smallest item from the heap, and also push the new item. The heap size doesn’t change. If the heap is empty, IndexError is raised. This one step operation is more efficient than a heappop() followed by heappush() and can be more appropriate when using a fixed-size heap. The pop/push combination always returns an element from the heap and replaces it with item. The value returned may be larger than the item added. If that isn’t desired, consider using heappushpop() instead. Its push/pop combination returns the smaller of the two values, leaving the larger value on the heap.", "score": "0.7707026"}, {"id": "20485", "text": "Function: python.library.heapq#heapq.heappushpop\nSnippet: heapq.heappushpop(heap, item) Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop().", "score": "0.7512595"}, {"id": "20483", "text": "Function: python.library.heapq#heapq.heappop\nSnippet: heapq.heappop(heap) Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0].", "score": "0.74698764"}, {"id": "20477", "text": "Function: python.library.heapq\nSnippet: heapq — Heap queue algorithm Source code: Lib/heapq.py This module provides an implementation of the heap queue algorithm, also known as the priority queue algorithm. Heaps are binary trees for which every parent node has a value less than or equal to any of its children. This implementation uses arrays for which heap[k] <= heap[2*k+1] and heap[k] <= heap[2*k+2] for all k, counting elements from zero. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that its smallest element is always the root, heap[0]. The API below differs from textbook heap algorithms in two aspects: (a) We use zero-based indexing. This makes the relationship between the index for a node and the indexes for its children slightly less obvious, but is more suitable since Python uses zero-based indexing. (b) Our pop method returns the smallest item, not the largest (called a “min heap” in textbooks; a “max heap” is more common in texts because of its suitability for in-place sorting). These two make it possible to view the heap as a regular Python list without surprises: heap[0] is the smallest item, and heap.sort() maintains the heap invariant! To create a heap, use a list initialized to [], or you can transform a populated list into a heap via function heapify(). The following functions are provided: heapq.heappush(heap, item) Push the value item onto the heap, maintaining the heap invariant. heapq.heappop(heap) Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0]. heapq.heappushpop(heap, item) Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop(). heapq.heapify(x) Transform list x into a heap, in-place, in linear time. heapq.heapreplace(heap, item) Pop and return the smallest item from the heap, and also push the new item. The heap size doesn’t change. If the heap is empty, IndexError is raised. This one step operation is more efficient than a heappop() followed by heappush() and can be more appropriate when using a fixed-size heap. The pop/push combination always returns an element from the heap and replaces it with item. The value returned may be larger than the item added. If that isn’t desired, consider using heappushpop() instead. Its push/pop combination returns the smaller of the two values, leaving the larger value on the heap. The module also offers three general purpose functions based on heaps. heapq.merge(*iterables, key=None, reverse=False) Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an iterator over the sorted values. Similar to sorted(itertools.chain(*iterables)) but returns an iterable, does not pull the data into memory all at once, and assumes that each of the input streams is already sorted (smallest to largest). Has two optional arguments which must be specified as keyword arguments. key specifies a", "score": "0.7343283"}, {"id": "20489", "text": "Function: python.library.heapq#heapq.nsmallest\nSnippet: heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n].", "score": "0.7034682"}]}
{"task_id": "mbpp_210", "code": "import re\r\ndef is_allowed_specific_char(string):\r\n    get_char = re.compile(r'[^a-zA-Z0-9.]')\r\n    string = get_char.search(string)\r\n    return not bool(string)", "test_list": ["assert is_allowed_specific_char(\"ABCDEFabcdef123450\") == True", "assert is_allowed_specific_char(\"*&%@#!}{\") == False", "assert is_allowed_specific_char(\"HELLOhowareyou98765\") == True"], "context": "Write a function to check that the given string contains only a certain set of characters(in this case a-z, a-z and 0-9) by using regex.", "function_name": "import re\r\ndef is_allowed_specific_char(string):", "gold_generation": "get_char = re.compile(r'[^a-zA-Z0-9.]')\r\n    string = get_char.search(string)\r\n    return not bool(string)", "ctxs": [{"id": "23304", "text": "Function: python.library.re\nSnippet: Similar to positive lookbehind assertions, the contained pattern must only match strings of some fixed length. Patterns which start with negative lookbehind assertions may match at the beginning of the string being searched. (?(id/name)yes-pattern|no-pattern) Will try to match with yes-pattern if the group with given id or name exists, and with no-pattern if it doesn’t. no-pattern is optional and can be omitted. For example, (<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$) is a poor email matching pattern, which will match with '<user@host.com>' as well as 'user@host.com', but not with '<user@host.com' nor 'user@host.com>'. The special sequences consist of '\\' and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, \\$ matches the character '$'. \\number Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, (.+) \\1 matches 'the the' or '55 55', but not 'thethe' (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the '[' and ']' of a character class, all numeric escapes are treated as characters. \\A Matches only at the start of the string. \\b Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of word characters. Note that formally, \\b is defined as the boundary between a \\w and a \\W character (or vice versa), or between \\w and the beginning/end of the string. This means that r'\\bfoo\\b' matches 'foo', 'foo.', '(foo)', 'bar foo baz' but not 'foobar' or 'foo3'. By default Unicode alphanumerics are the ones used in Unicode patterns, but this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. Inside a character range, \\b represents the backspace character, for compatibility with Python’s string literals. \\B Matches the empty string, but only when it is not at the beginning or end of a word. This means that r'py\\B' matches 'python', 'py3', 'py2', but not 'py', 'py.', or 'py!'. \\B is just the opposite of \\b, so word characters in Unicode patterns are Unicode alphanumerics or the underscore, although this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. \\d For Unicode (str) patterns: Matches any Unicode decimal digit (that is, any character in Unicode character category [Nd]). This includes [0-9], and also many other digit characters. If the ASCII flag is used only [0-9] is matched. For 8-bit (bytes) patterns: Matches any decimal digit; this is equivalent to [0-9]. \\D Matches any character which is not a decimal digit. This is the opposite of \\d. If the", "score": "0.70261526"}, {"id": "23301", "text": "Function: python.library.re\nSnippet: repetitions as possible. For example, a{3,5} will match from 3 to 5 'a' characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, a{4,}b will match 'aaaab' or a thousand 'a' characters followed by a 'b', but not 'aaab'. The comma may not be omitted or the modifier would be confused with the previously described form. {m,n}? Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous qualifier. For example, on the 6-character string 'aaaaaa', a{3,5} will match 5 'a' characters, while a{3,5}? will only match 3 characters. \\ Either escapes special characters (permitting you to match characters like '*', '?', and so forth), or signals a special sequence; special sequences are discussed below. If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions. [] Used to indicate a set of characters. In a set: Characters can be listed individually, e.g. [amk] will match 'a', 'm', or 'k'. Ranges of characters can be indicated by giving two characters and separating them by a '-', for example [a-z] will match any lowercase ASCII letter, [0-5][0-9] will match all the two-digits numbers from 00 to 59, and [0-9A-Fa-f] will match any hexadecimal digit. If - is escaped (e.g. [a\\-z]) or if it’s placed as the first or last character (e.g. [-a] or [a-]), it will match a literal '-'. Special characters lose their special meaning inside sets. For example, [(+*)] will match any of the literal characters '(', '+', '*', or ')'. Character classes such as \\w or \\S (defined below) are also accepted inside a set, although the characters they match depends on whether ASCII or LOCALE mode is in force. Characters that are not within a range can be matched by complementing the set. If the first character of the set is '^', all the characters that are not in the set will be matched. For example, [^5] will match any character except '5', and [^^] will match any character except '^'. ^ has no special meaning if it’s not the first character in the set. To match a literal ']' inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both [()[\\]{}] and []()[{}] will both match a parenthesis. Support of nested sets and set operations as in Unicode Technical Standard #18 might be added in the future. This would change the syntax, so to facilitate this change", "score": "0.6936513"}, {"id": "23307", "text": "Function: python.library.re\nSnippet: '^' matches only at the beginning of the string, and '$' only at the end of the string and immediately before the newline (if any) at the end of the string. Corresponds to the inline flag (?m). re.S re.DOTALL Make the '.' special character match any character at all, including a newline; without this flag, '.' will match anything except a newline. Corresponds to the inline flag (?s). re.X re.VERBOSE This flag allows you to write regular expressions that look nicer and are more readable by allowing you to visually separate logical sections of the pattern and add comments. Whitespace within the pattern is ignored, except when in a character class, or when preceded by an unescaped backslash, or within tokens like *?, (?: or (?P<...>. When a line contains a # that is not in a character class and is not preceded by an unescaped backslash, all characters from the leftmost such # through the end of the line are ignored. This means that the two following regular expression objects that match a decimal number are functionally equal: a = re.compile(r\"\"\"\\d + # the integral part \\. # the decimal point \\d * # some fractional digits\"\"\", re.X) b = re.compile(r\"\\d+\\.\\d*\") Corresponds to the inline flag (?x). re.search(pattern, string, flags=0) Scan through string looking for the first location where the regular expression pattern produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. re.match(pattern, string, flags=0) If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. Note that even in MULTILINE mode, re.match() will only match at the beginning of the string and not at the beginning of each line. If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). re.fullmatch(pattern, string, flags=0) If the whole string matches the regular expression pattern, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. New in version 3.4. re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string,", "score": "0.6910471"}, {"id": "23300", "text": "Function: python.library.re\nSnippet: For further information and a gentler presentation, consult the Regular Expression HOWTO. Regular expressions can contain both special and ordinary characters. Most ordinary characters, like 'A', 'a', or '0', are the simplest regular expressions; they simply match themselves. You can concatenate ordinary characters, so last matches the string 'last'. (In the rest of this section, we’ll write RE’s in this special style, usually without quotes, and strings to be matched 'in single quotes'.) Some characters, like '|' or '(', are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. Repetition qualifiers (*, +, ?, {m,n}, etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix ?, and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression (?:a{6})* matches any multiple of six 'a' characters. The special characters are: . (Dot.) In the default mode, this matches any character except a newline. If the DOTALL flag has been specified, this matches any character including a newline. ^ (Caret.) Matches the start of the string, and in MULTILINE mode also matches immediately after each newline. $ Matches the end of the string or just before the newline at the end of the string, and in MULTILINE mode also matches before a newline. foo matches both ‘foo’ and ‘foobar’, while the regular expression foo$ matches only ‘foo’. More interestingly, searching for foo.$ in 'foo1\\nfoo2\\n' matches ‘foo2’ normally, but ‘foo1’ in MULTILINE mode; searching for a single $ in 'foo\\n' will find two (empty) matches: one just before the newline, and one at the end of the string. * Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. ab* will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s. + Causes the resulting RE to match 1 or more repetitions of the preceding RE. ab+ will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’. ? Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. ab? will match either ‘a’ or ‘ab’. *?, +?, ?? The '*', '+', and '?' qualifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE <.*> is matched against '<a> b <c>', it will match the entire string, and not just '<a>'. Adding ? after the qualifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using the RE <.*?> will match only '<a>'. {m} Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, a{6} will match exactly six 'a' characters, but not five. {m,n} Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many", "score": "0.6865934"}, {"id": "23361", "text": "Function: python.library.re#re.Pattern.search\nSnippet: Pattern.search(string[, pos[, endpos]]) Scan through string looking for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\"", "score": "0.6841433"}]}
{"task_id": "mbpp_211", "code": "def count_Num(n): \r\n    if (n == 1): \r\n        return 1\r\n    count = pow(2,n - 2) \r\n    return count ", "test_list": ["assert count_Num(2) == 1", "assert count_Num(3) == 2", "assert count_Num(1) == 1"], "context": "Write a python function to count numbers whose oth and nth bits are set.", "function_name": "def count_Num(n):", "gold_generation": "if (n == 1): \r\n        return 1\r\n    count = pow(2,n - 2) \r\n    return count", "ctxs": [{"id": "13465", "text": "Function: pygame.ref.mask#pygame.mask.Mask.count\nSnippet: count() Returns the number of set bits count() -> bits Returns: the number of set bits in the mask Return type: int", "score": "0.7335822"}, {"id": "25732", "text": "Function: python.library.stdtypes\nSnippet: there were an infinite number of sign bits. Additional Methods on Integer Types The int type implements the numbers.Integral abstract base class. In addition, it provides a few more methods: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1. int.to_bytes(length, byteorder, *, signed=False) Return an array of bytes representing an integer. >>> (1024).to_bytes(2, byteorder='big') b'\\x04\\x00' >>> (1024).to_bytes(10, byteorder='big') b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00' >>> (-1024).to_bytes(10, byteorder='big', signed=True) b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00' >>> x = 1000 >>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little') b'\\xe8\\x03' The integer is represented using length bytes. An OverflowError is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument determines whether two’s complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. The default value for signed is False. New in version 3.2. classmethod int.from_bytes(bytes, byteorder, *, signed=False) Return the integer represented by the given array of bytes. >>> int.from_bytes(b'\\x00\\x10', byteorder='big') 16 >>> int.from_bytes(b'\\x00\\x10', byteorder='little') 4096 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True) -1024 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False) 64512 >>> int.from_bytes([255, 0, 0], byteorder='big') 16711680 The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. New in version 3.2. int.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original integer and with a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. New in version 3.8. Additional Methods on Float The float type implements the numbers.Real abstract base class. float also has the following additional methods. float.as_integer_ratio() Return a pair of integers whose", "score": "0.7086176"}, {"id": "21071", "text": "Function: python.library.stdtypes#int.bit_length\nSnippet: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1.", "score": "0.70159036"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.700484"}, {"id": "42664", "text": "Function: numpy.reference.generated.numpy.bitwise_or\nSnippet: numpy.bitwise_or numpy.bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'bitwise_or'> Compute the bit-wise OR of two arrays element-wise. Computes the bit-wise OR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator |. Parameters x1, x2array_like Only integer and boolean types are handled. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Result. This is a scalar if both x1 and x2 are scalars. See also logical_or bitwise_and bitwise_xor binary_repr Return the binary representation of the input number as a string. Examples The number 13 has the binary representation 00001101. Likewise, 16 is represented by 00010000. The bit-wise OR of 13 and 16 is then 000111011, or 29: >>> np.bitwise_or(13, 16) 29 >>> np.binary_repr(29) '11101' >>> np.bitwise_or(32, 2) 34 >>> np.bitwise_or([33, 4], 1) array([33, 5]) >>> np.bitwise_or([33, 4], [1, 2]) array([33, 6]) >>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4])) array([ 6, 5, 255]) >>> np.array([2, 5, 255]) | np.array([4, 4, 4]) array([ 6, 5, 255]) >>> np.bitwise_or(np.array([2, 5, 255, 2147483647], dtype=np.int32), ... np.array([4, 4, 4, 2147483647], dtype=np.int32)) array([ 6, 5, 255, 2147483647]) >>> np.bitwise_or([True, True], [False, True]) array([ True, True]) The | operator can be used as a shorthand for np.bitwise_or on ndarrays. >>> x1 = np.array([2, 5, 255]) >>> x2 = np.array([4, 4, 4]) >>> x1 | x2 array([ 6, 5, 255])", "score": "0.69574"}]}
{"task_id": "mbpp_212", "code": "import math  \r\ndef fourth_Power_Sum(n): \r\n    sum = 0\r\n    for i in range(1,n+1) : \r\n        sum = sum + (i*i*i*i) \r\n    return sum", "test_list": ["assert fourth_Power_Sum(2) == 17", "assert fourth_Power_Sum(4) == 354", "assert fourth_Power_Sum(6) == 2275"], "context": "Write a python function to find the sum of fourth power of n natural numbers.", "function_name": "import math  \r\ndef fourth_Power_Sum(n):", "gold_generation": "sum = 0\r\n    for i in range(1,n+1) : \r\n        sum = sum + (i*i*i*i) \r\n    return sum", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6586471"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6563983"}, {"id": "21787", "text": "Function: python.library.math#math.comb\nSnippet: math.comb(n, k) Return the number of ways to choose k items from n items without repetition and without order. Evaluates to n! / (k! * (n - k)!) when k <= n and evaluates to zero when k > n. Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of the expression (1 + x) ** n. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.64976835"}, {"id": "22281", "text": "Function: python.library.numbers#numbers.Rational.numerator\nSnippet: numerator Abstract.", "score": "0.6489741"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6485945"}]}
{"task_id": "mbpp_213", "code": "def concatenate_strings(test_tup1, test_tup2):\r\n  res = tuple(ele1 + ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "test_list": ["assert concatenate_strings((\"Manjeet\", \"Nikhil\", \"Akshat\"), (\" Singh\", \" Meherwal\", \" Garg\")) == ('Manjeet Singh', 'Nikhil Meherwal', 'Akshat Garg')", "assert concatenate_strings((\"Shaik\", \"Ayesha\", \"Sanya\"), (\" Dawood\", \" Begum\", \" Singh\")) == ('Shaik Dawood', 'Ayesha Begum', 'Sanya Singh')", "assert concatenate_strings((\"Harpreet\", \"Priyanka\", \"Muskan\"), (\"Kour\", \" Agarwal\", \"Sethi\")) == ('HarpreetKour', 'Priyanka Agarwal', 'MuskanSethi')"], "context": "Write a function to perform the concatenation of two string tuples.", "function_name": "def concatenate_strings(test_tup1, test_tup2):", "gold_generation": "res = tuple(ele1 + ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res)", "ctxs": [{"id": "25737", "text": "Function: python.library.stdtypes\nSnippet: a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str objects, you can build a list and use str.join() at the end or else write to an io.StringIO instance and retrieve its value when complete if concatenating bytes objects, you can similarly use bytes.join() or io.BytesIO, or you can do in-place concatenation with a bytearray object. bytearray objects are mutable and have an efficient overallocation mechanism if concatenating tuple objects, extend a list instead for other types, investigate the relevant class documentation Some sequence types (such as range) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition. index raises ValueError when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using s[i:j].index(x), only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. Immutable Sequence Types The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the hash() built-in. This support allows immutable sequences, such as tuple instances, to be used as dict keys and stored in set and frozenset instances. Attempting to hash an immutable sequence that contains unhashable values will result in TypeError. Mutable Sequence Types The operations in the following table are defined on mutable sequence types. The collections.abc.MutableSequence ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, bytearray only accepts integers that meet the value restriction 0 <= x <= 255). Operation Result Notes s[i] = x item i of s is replaced by x s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t del s[i:j] same as s[i:j] = [] s[i:j:k] = t the elements of s[i:j:k] are replaced by those of t (1) del s[i:j:k] removes the elements of s[i:j:k] from the list s.append(x) appends x to the end of the sequence (same as s[len(s):len(s)] = [x]) s.clear() removes all items from s (same as del s[:]) (5) s.copy() creates a shallow copy of s (same as s[:]) (5) s.extend(t) or s += t extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t) s *= n updates s with its contents repeated n times (6) s.insert(i, x) inserts x into s at the index given by i (same as s[i:i] = [x]) s.pop([i]) retrieves the item at i and also removes it", "score": "0.7091377"}, {"id": "41634", "text": "Function: numpy.reference.generated.numpy.char.add\nSnippet: numpy.char.add char.add(x1, x2)[source] Return element-wise string concatenation for two arrays of str or unicode. Arrays x1 and x2 must have the same shape. Parameters x1array_like of str or unicode Input array. x2array_like of str or unicode Input array. Returns addndarray Output array of string_ or unicode_, depending on input types of the same shape as x1 and x2.", "score": "0.7072422"}, {"id": "24362", "text": "Function: python.library.stdtypes#str.join\nSnippet: str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method.", "score": "0.705908"}, {"id": "41672", "text": "Function: numpy.reference.generated.numpy.char.chararray.join\nSnippet: numpy.char.chararray.join method char.chararray.join(seq)[source] Return a string which is the concatenation of the strings in the sequence seq. See also char.join", "score": "0.6998317"}, {"id": "22304", "text": "Function: python.library.operator#operator.concat\nSnippet: operator.concat(a, b) operator.__concat__(a, b) Return a + b for a and b sequences.", "score": "0.6959566"}]}
{"task_id": "mbpp_214", "code": "import math\r\ndef degree_radian(radian):\r\n degree = radian*(180/math.pi)\r\n return degree", "test_list": ["assert degree_radian(90)==5156.620156177409", "assert degree_radian(60)==3437.746770784939", "assert degree_radian(120)==6875.493541569878"], "context": "Write a function to convert radians to degrees.", "function_name": "import math\r\ndef degree_radian(radian):", "gold_generation": "degree = radian*(180/math.pi)\r\n return degree", "ctxs": [{"id": "21791", "text": "Function: python.library.math#math.degrees\nSnippet: math.degrees(x) Convert angle x from radians to degrees.", "score": "0.8067648"}, {"id": "21827", "text": "Function: python.library.math#math.radians\nSnippet: math.radians(x) Convert angle x from degrees to radians.", "score": "0.7890099"}, {"id": "42735", "text": "Function: numpy.reference.generated.numpy.degrees\nSnippet: numpy.degrees numpy.degrees(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'degrees'> Convert angles from radians to degrees. Parameters xarray_like Input array in radians. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray of floats The corresponding degree values; if out was supplied this is a reference to it. This is a scalar if x is a scalar. See also rad2deg equivalent function Examples Convert a radian array to degrees >>> rad = np.arange(12.)*np.pi/6 >>> np.degrees(rad) array([ 0., 30., 60., 90., 120., 150., 180., 210., 240., 270., 300., 330.]) >>> out = np.zeros((rad.shape)) >>> r = np.degrees(rad, out) >>> np.all(r == out) True", "score": "0.75995696"}, {"id": "43121", "text": "Function: numpy.reference.generated.numpy.radians\nSnippet: numpy.radians numpy.radians(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'radians'> Convert angles from degrees to radians. Parameters xarray_like Input array in degrees. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray The corresponding radian values. This is a scalar if x is a scalar. See also deg2rad equivalent function Examples Convert a degree array to radians >>> deg = np.arange(12.) * 30. >>> np.radians(deg) array([ 0. , 0.52359878, 1.04719755, 1.57079633, 2.0943951 , 2.61799388, 3.14159265, 3.66519143, 4.1887902 , 4.71238898, 5.23598776, 5.75958653]) >>> out = np.zeros((deg.shape)) >>> ret = np.radians(deg, out) >>> ret is out True", "score": "0.7382465"}, {"id": "43120", "text": "Function: numpy.reference.generated.numpy.rad2deg\nSnippet: numpy.rad2deg numpy.rad2deg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'rad2deg'> Convert angles from radians to degrees. Parameters xarray_like Angle in radians. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray The corresponding angle in degrees. This is a scalar if x is a scalar. See also deg2rad Convert angles from degrees to radians. unwrap Remove large jumps in angle by wrapping. Notes New in version 1.3.0. rad2deg(x) is 180 * x / pi. Examples >>> np.rad2deg(np.pi/2) 90.0", "score": "0.7200141"}]}
{"task_id": "mbpp_215", "code": "def decode_list(alist):\r\n    def aux(g):\r\n        if isinstance(g, list):\r\n            return [(g[1], range(g[0]))]\r\n        else:\r\n            return [(g, [0])]\r\n    return [x for g in alist for x, R in aux(g) for i in R]", "test_list": ["assert decode_list([[2, 1], 2, 3, [2, 4], 5,1])==[1,1,2,3,4,4,5,1]", "assert decode_list(['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', [2, 'l'], 'y'])==['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', 'l', 'l', 'y']", "assert decode_list(['p', 'y', 't', 'h', 'o', 'n'])==['p', 'y', 't', 'h', 'o', 'n']"], "context": "Write a function to decode a run-length encoded given list.", "function_name": "def decode_list(alist):", "gold_generation": "def aux(g):\r\n        if isinstance(g, list):\r\n            return [(g[1], range(g[0]))]\r\n        else:\r\n            return [(g, [0])]\r\n    return [x for g in alist for x, R in aux(g) for i in R]", "ctxs": [{"id": "25737", "text": "Function: python.library.stdtypes\nSnippet: a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str objects, you can build a list and use str.join() at the end or else write to an io.StringIO instance and retrieve its value when complete if concatenating bytes objects, you can similarly use bytes.join() or io.BytesIO, or you can do in-place concatenation with a bytearray object. bytearray objects are mutable and have an efficient overallocation mechanism if concatenating tuple objects, extend a list instead for other types, investigate the relevant class documentation Some sequence types (such as range) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition. index raises ValueError when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using s[i:j].index(x), only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. Immutable Sequence Types The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the hash() built-in. This support allows immutable sequences, such as tuple instances, to be used as dict keys and stored in set and frozenset instances. Attempting to hash an immutable sequence that contains unhashable values will result in TypeError. Mutable Sequence Types The operations in the following table are defined on mutable sequence types. The collections.abc.MutableSequence ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, bytearray only accepts integers that meet the value restriction 0 <= x <= 255). Operation Result Notes s[i] = x item i of s is replaced by x s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t del s[i:j] same as s[i:j] = [] s[i:j:k] = t the elements of s[i:j:k] are replaced by those of t (1) del s[i:j:k] removes the elements of s[i:j:k] from the list s.append(x) appends x to the end of the sequence (same as s[len(s):len(s)] = [x]) s.clear() removes all items from s (same as del s[:]) (5) s.copy() creates a shallow copy of s (same as s[:]) (5) s.extend(t) or s += t extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t) s *= n updates s with its contents repeated n times (6) s.insert(i, x) inserts x into s at the index given by i (same as s[i:i] = [x]) s.pop([i]) retrieves the item at i and also removes it", "score": "0.69053066"}, {"id": "41646", "text": "Function: numpy.reference.generated.numpy.char.chararray.decode\nSnippet: numpy.char.chararray.decode method char.chararray.decode(encoding=None, errors=None)[source] Calls str.decode element-wise. See also char.decode", "score": "0.69024205"}, {"id": "18534", "text": "Function: python.library.codecs\nSnippet: decode huge files in one step. The firstline flag indicates that it would be sufficient to only return the first line, if there are decoding errors on later lines. The method should use a greedy read strategy meaning that it should read as much data as is allowed within the definition of the encoding and the given size, e.g. if optional encoding endings or state markers are available on the stream, these should be read too. readline([size[, keepends]]) Read one line from the input stream and return the decoded data. size, if given, is passed as size argument to the stream’s read() method. If keepends is false line-endings will be stripped from the lines returned. readlines([sizehint[, keepends]]) Read all lines available on the input stream and return them as a list of lines. Line-endings are implemented using the codec’s decode() method and are included in the list entries if keepends is true. sizehint, if given, is passed as the size argument to the stream’s read() method. reset() Resets the codec buffers used for keeping internal state. Note that no stream repositioning should take place. This method is primarily intended to be able to recover from decoding errors. In addition to the above methods, the StreamReader must also inherit all other methods and attributes from the underlying stream. StreamReaderWriter Objects The StreamReaderWriter is a convenience class that allows wrapping streams which work in both read and write modes. The design is such that one can use the factory functions returned by the lookup() function to construct the instance. class codecs.StreamReaderWriter(stream, Reader, Writer, errors='strict') Creates a StreamReaderWriter instance. stream must be a file-like object. Reader and Writer must be factory functions or classes providing the StreamReader and StreamWriter interface resp. Error handling is done in the same way as defined for the stream readers and writers. StreamReaderWriter instances define the combined interfaces of StreamReader and StreamWriter classes. They inherit all other methods and attributes from the underlying stream. StreamRecoder Objects The StreamRecoder translates data from one encoding to another, which is sometimes useful when dealing with different encoding environments. The design is such that one can use the factory functions returned by the lookup() function to construct the instance. class codecs.StreamRecoder(stream, encode, decode, Reader, Writer, errors='strict') Creates a StreamRecoder instance which implements a two-way conversion: encode and decode work on the frontend — the data visible to code calling read() and write(), while Reader and Writer work on the backend — the data in stream. You can use these objects to do transparent transcodings, e.g., from Latin-1 to UTF-8 and back. The stream argument must be a file-like object. The encode and decode arguments must adhere to the Codec interface. Reader and Writer must be factory functions or classes providing objects of the StreamReader and StreamWriter interface respectively. Error handling is done in the same way as defined for the stream readers and writers. StreamRecoder instances define the combined interfaces of StreamReader and StreamWriter classes. They inherit all other methods and attributes", "score": "0.6899824"}, {"id": "41771", "text": "Function: numpy.reference.generated.numpy.chararray.decode\nSnippet: numpy.chararray.decode method chararray.decode(encoding=None, errors=None)[source] Calls str.decode element-wise. See also char.decode", "score": "0.68978226"}, {"id": "18552", "text": "Function: python.library.codecs#codecs.Codec.decode\nSnippet: Codec.decode(input[, errors]) Decodes the object input and returns a tuple (output object, length consumed). For instance, for a text encoding, decoding converts a bytes object encoded using a particular character set encoding to a string object. For text encodings and bytes-to-bytes codecs, input must be a bytes object or one which provides the read-only buffer interface – for example, buffer objects and memory mapped files. The errors argument defines the error handling to apply. It defaults to 'strict' handling. The method may not store state in the Codec instance. Use StreamReader for codecs which have to keep state in order to make decoding efficient. The decoder must be able to handle zero length input and return an empty object of the output object type in this situation.", "score": "0.6883487"}]}
{"task_id": "mbpp_216", "code": "def check_subset_list(list1, list2): \r\n    l1, l2 = list1[0], list2[0] \r\n    exist = True\r\n    for i in list2: \r\n        if i not in list1: \r\n            exist = False\r\n    return exist ", "test_list": ["assert check_subset_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],[[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]])==False", "assert check_subset_list([[2, 3, 1], [4, 5], [6, 8]],[[4, 5], [6, 8]])==True", "assert check_subset_list([['a', 'b'], ['e'], ['c', 'd']],[['g']])==False"], "context": "Write a function to check if a nested list is a subset of another nested list.", "function_name": "def check_subset_list(list1, list2):", "gold_generation": "l1, l2 = list1[0], list2[0] \r\n    exist = True\r\n    for i in list2: \r\n        if i not in list1: \r\n            exist = False\r\n    return exist", "ctxs": [{"id": "20225", "text": "Function: python.library.stdtypes#frozenset.issubset\nSnippet: issubset(other) set <= other Test whether every element in the set is in other.", "score": "0.716481"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.7054833"}, {"id": "24587", "text": "Function: python.library.symtable#symtable.SymbolTable.is_nested\nSnippet: is_nested() Return True if the block is a nested class or function.", "score": "0.70201087"}, {"id": "20226", "text": "Function: python.library.stdtypes#frozenset.issuperset\nSnippet: issuperset(other) set >= other Test whether every element in other is in the set.", "score": "0.69112676"}, {"id": "997", "text": "Function: tensorflow.compat.v1.nest\nSnippet: Module: tf.compat.v1.nest Public API for tf.nest namespace. Functions assert_same_structure(...): Asserts that two structures are nested in the same way. flatten(...): Returns a flat list from a given nested structure. is_nested(...): Returns true if its input is a collections.abc.Sequence (except strings). map_structure(...): Applies func to each entry in structure and returns a new structure. pack_sequence_as(...): Returns a given flattened sequence packed into a given structure.", "score": "0.684676"}]}
{"task_id": "mbpp_217", "code": "def first_Repeated_Char(str): \r\n    h = {}\r\n    for ch in str:\r\n        if ch in h: \r\n            return ch;\r\n        else: \r\n            h[ch] = 0\r\n    return '\\0'", "test_list": ["assert first_Repeated_Char(\"Google\") == \"o\"", "assert first_Repeated_Char(\"data\") == \"a\"", "assert first_Repeated_Char(\"python\") == '\\0'"], "context": "Write a python function to find the first repeated character in a given string.", "function_name": "def first_Repeated_Char(str):", "gold_generation": "h = {}\r\n    for ch in str:\r\n        if ch in h: \r\n            return ch;\r\n        else: \r\n            h[ch] = 0\r\n    return '\\0'", "ctxs": [{"id": "23301", "text": "Function: python.library.re\nSnippet: repetitions as possible. For example, a{3,5} will match from 3 to 5 'a' characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, a{4,}b will match 'aaaab' or a thousand 'a' characters followed by a 'b', but not 'aaab'. The comma may not be omitted or the modifier would be confused with the previously described form. {m,n}? Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous qualifier. For example, on the 6-character string 'aaaaaa', a{3,5} will match 5 'a' characters, while a{3,5}? will only match 3 characters. \\ Either escapes special characters (permitting you to match characters like '*', '?', and so forth), or signals a special sequence; special sequences are discussed below. If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions. [] Used to indicate a set of characters. In a set: Characters can be listed individually, e.g. [amk] will match 'a', 'm', or 'k'. Ranges of characters can be indicated by giving two characters and separating them by a '-', for example [a-z] will match any lowercase ASCII letter, [0-5][0-9] will match all the two-digits numbers from 00 to 59, and [0-9A-Fa-f] will match any hexadecimal digit. If - is escaped (e.g. [a\\-z]) or if it’s placed as the first or last character (e.g. [-a] or [a-]), it will match a literal '-'. Special characters lose their special meaning inside sets. For example, [(+*)] will match any of the literal characters '(', '+', '*', or ')'. Character classes such as \\w or \\S (defined below) are also accepted inside a set, although the characters they match depends on whether ASCII or LOCALE mode is in force. Characters that are not within a range can be matched by complementing the set. If the first character of the set is '^', all the characters that are not in the set will be matched. For example, [^5] will match any character except '5', and [^^] will match any character except '^'. ^ has no special meaning if it’s not the first character in the set. To match a literal ']' inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both [()[\\]{}] and []()[{}] will both match a parenthesis. Support of nested sets and set operations as in Unicode Technical Standard #18 might be added in the future. This would change the syntax, so to facilitate this change", "score": "0.70059794"}, {"id": "23310", "text": "Function: python.library.re\nSnippet: for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\" Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). Pattern.fullmatch(string[, pos[, endpos]]) If the whole string matches this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o[gh]\") >>> pattern.fullmatch(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.fullmatch(\"ogre\") # No match as not the full string matches. >>> pattern.fullmatch(\"doggie\", 1, 3) # Matches within given limits. <re.Match object; span=(1, 3), match='og'> New in version 3.4. Pattern.split(string, maxsplit=0) Identical to the split() function, using the compiled pattern. Pattern.findall(string[, pos[, endpos]]) Similar to the findall() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.finditer(string[, pos[, endpos]]) Similar to the finditer() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.sub(repl, string, count=0) Identical to the sub() function, using the compiled pattern. Pattern.subn(repl, string, count=0) Identical to the subn() function, using the compiled pattern. Pattern.flags The regex", "score": "0.6975673"}, {"id": "23361", "text": "Function: python.library.re#re.Pattern.search\nSnippet: Pattern.search(string[, pos[, endpos]]) Scan through string looking for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\"", "score": "0.69255424"}, {"id": "41724", "text": "Function: numpy.reference.generated.numpy.char.find\nSnippet: numpy.char.find char.find(a, sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. Calls str.find element-wise. For each element, return the lowest index in the string where substring sub is found, such that sub is contained in the range [start, end]. Parameters aarray_like of str or unicode substr or unicode start, endint, optional Optional arguments start and end are interpreted as in slice notation. Returns outndarray or int Output array of ints. Returns -1 if sub is not found. See also str.find", "score": "0.6924973"}, {"id": "25743", "text": "Function: python.library.stdtypes\nSnippet: on). To expand the string, the current column is set to zero and the string is examined character by character. If the character is a tab (\\t), one or more space characters are inserted in the result until the current column is equal to the next tab position. (The tab character itself is not copied.) If the character is a newline (\\n) or return (\\r), it is copied and the current column is reset to zero. Any other character is copied unchanged and the current column is incremented by one regardless of how the character is represented when printed. >>> '01\\t012\\t0123\\t01234'.expandtabs() '01 012 0123 01234' >>> '01\\t012\\t0123\\t01234'.expandtabs(4) '01 012 0123 01234' str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True str.format(*args, **kwargs) Perform a string formatting operation. The string on which this method is called can contain literal text or replacement fields delimited by braces {}. Each replacement field contains either the numeric index of a positional argument, or the name of a keyword argument. Returns a copy of the string where each replacement field is replaced with the string value of the corresponding argument. >>> \"The sum of 1 + 2 is {0}\".format(1+2) 'The sum of 1 + 2 is 3' See Format String Syntax for a description of the various formatting options that can be specified in format strings. Note When formatting a number (int, float, complex, decimal.Decimal and subclasses) with the n type (ex: '{:n}'.format(1234)), the function temporarily sets the LC_CTYPE locale to the LC_NUMERIC locale to decode decimal_point and thousands_sep fields of localeconv() if they are non-ASCII or longer than 1 byte, and the LC_NUMERIC locale is different than the LC_CTYPE locale. This temporary change affects other threads. Changed in version 3.7: When formatting a number with the n type, the function sets temporarily the LC_CTYPE locale to the LC_NUMERIC locale in some cases. str.format_map(mapping) Similar to str.format(**mapping), except that mapping is used directly and not copied to a dict. This is useful if for example mapping is a dict subclass: >>> class Default(dict): ... def __missing__(self, key): ... return key ... >>> '{name} was born in {country}'.format_map(Default(name='Guido')) 'Guido was born in country' New in version 3.2. str.index(sub[, start[, end]]) Like find(), but raise ValueError when the substring is not found. str.isalnum() Return True if all characters in the string are alphanumeric and there is at least one character, False otherwise. A character c is alphanumeric if one of the following returns True: c.isalpha(), c.isdecimal(), c.isdigit(), or c.isnumeric(). str.isalpha() Return True if all characters in the string are alphabetic and there is at least one character, False otherwise. Alphabetic characters are those characters", "score": "0.6901441"}]}
{"task_id": "mbpp_218", "code": "import math   \r\ndef min_Operations(A,B):  \r\n    if (A > B): \r\n        swap(A,B)  \r\n    B = B // math.gcd(A,B);  \r\n    return B - 1", "test_list": ["assert min_Operations(2,4) == 1", "assert min_Operations(4,10) == 4", "assert min_Operations(1,4) == 3"], "context": "Write a python function to find the minimum operations required to make two numbers equal.", "function_name": "import math   \r\ndef min_Operations(A,B):", "gold_generation": "if (A > B): \r\n        swap(A,B)  \r\n    B = B // math.gcd(A,B);  \r\n    return B - 1", "ctxs": [{"id": "19492", "text": "Function: python.library.decimal#decimal.Context.min\nSnippet: min(x, y) Compares two values numerically and returns the minimum.", "score": "0.7193593"}, {"id": "19448", "text": "Function: python.library.decimal#decimal.Context\nSnippet: operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x - y * n, where n is the integer nearest the exact value of x / y (if the result is 0 then its sign will be the sign of x). rotate(x, y) Returns a rotated copy of x, y times. same_quantum(x, y) Returns True if the two operands have the same exponent. scaleb(x, y) Returns the first operand after adding the second value its exp. shift(x, y) Returns a shifted copy of x, y times. sqrt(x) Square root of a non-negative number to context precision. subtract(x, y) Return the difference between x and y. to_eng_string(x) Convert to a string, using engineering", "score": "0.71249306"}, {"id": "22396", "text": "Function: python.library.operator#operator.__sub__\nSnippet: operator.sub(a, b) operator.__sub__(a, b) Return a - b.", "score": "0.70249516"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.69597334"}, {"id": "22350", "text": "Function: python.library.operator#operator.sub\nSnippet: operator.sub(a, b) operator.__sub__(a, b) Return a - b.", "score": "0.6950863"}]}
{"task_id": "mbpp_219", "code": "\r\ndef extract_min_max(test_tup, K):\r\n  res = []\r\n  test_tup = list(test_tup)\r\n  temp = sorted(test_tup)\r\n  for idx, val in enumerate(temp):\r\n    if idx < K or idx >= len(temp) - K:\r\n      res.append(val)\r\n  res = tuple(res)\r\n  return (res) ", "test_list": ["assert extract_min_max((5, 20, 3, 7, 6, 8), 2) == (3, 5, 8, 20)", "assert extract_min_max((4, 5, 6, 1, 2, 7), 3) == (1, 2, 4, 5, 6, 7)", "assert extract_min_max((2, 3, 4, 8, 9, 11, 7), 4) == (2, 3, 4, 7, 8, 9, 11)"], "context": "Write a function to extract maximum and minimum k elements in the given tuple.", "function_name": "\r\ndef extract_min_max(test_tup, K):", "gold_generation": "res = []\r\n  test_tup = list(test_tup)\r\n  temp = sorted(test_tup)\r\n  for idx, val in enumerate(temp):\r\n    if idx < K or idx >= len(temp) - K:\r\n      res.append(val)\r\n  res = tuple(res)\r\n  return (res)", "ctxs": [{"id": "18128", "text": "Function: python.library.audioop#audioop.minmax\nSnippet: audioop.minmax(fragment, width) Return a tuple consisting of the minimum and maximum values of all samples in the sound fragment.", "score": "0.6960443"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.66957724"}, {"id": "5418", "text": "Function: tensorflow.tpu.experimental.embedding.adam\nSnippet: of scalar values (min, max) to set a separate maximum or minimum. If one of the two entries is None, then there will be no clipping that direction.", "score": "0.6676315"}, {"id": "42615", "text": "Function: numpy.reference.generated.numpy.amax\nSnippet: >>> np.amax([5], initial=6) 6 >>> max([5], default=6) 5", "score": "0.6659962"}, {"id": "20489", "text": "Function: python.library.heapq#heapq.nsmallest\nSnippet: heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n].", "score": "0.66554314"}]}
{"task_id": "mbpp_220", "code": "import re\r\ndef replace_max_specialchar(text,n):\r\n return (re.sub(\"[ ,.]\", \":\", text, n))", "test_list": ["assert replace_max_specialchar('Python language, Programming language.',2)==('Python:language: Programming language.')", "assert replace_max_specialchar('a b c,d e f',3)==('a:b:c:d e f')", "assert replace_max_specialchar('ram reshma,ram rahim',1)==('ram:reshma,ram rahim')"], "context": "Write a function to replace maximum n occurrences of spaces, commas, or dots with a colon.", "function_name": "import re\r\ndef replace_max_specialchar(text,n):", "gold_generation": "return (re.sub(\"[ ,.]\", \":\", text, n))", "ctxs": [{"id": "24398", "text": "Function: python.library.string\nSnippet: characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", "score": "0.6869688"}, {"id": "23369", "text": "Function: python.library.re#re.sub\nSnippet: re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern are replaced only when not adjacent to a previous empty match, so sub('x*', '-', 'abxd') returns '-a-b--d-'. In string-type repl arguments, in addition to the character escapes and backreferences described above, \\g<name> will use the substring matched by the group named name, as defined by the (?P<name>...) syntax. \\g<number> uses the corresponding group number; \\g<2> is therefore equivalent to \\2, but isn’t ambiguous in a replacement such as \\g<2>0. \\20 would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character '0'. The backreference \\g<0> substitutes in the entire substring matched by the RE. Changed in version 3.1: Added the optional flags argument. Changed in version 3.5: Unmatched groups are replaced with an empty string. Changed in version 3.6: Unknown escapes in pattern consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Unknown escapes in repl consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Empty matches for the pattern are replaced when adjacent to a previous non-empty match.", "score": "0.6655082"}, {"id": "23301", "text": "Function: python.library.re\nSnippet: repetitions as possible. For example, a{3,5} will match from 3 to 5 'a' characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, a{4,}b will match 'aaaab' or a thousand 'a' characters followed by a 'b', but not 'aaab'. The comma may not be omitted or the modifier would be confused with the previously described form. {m,n}? Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous qualifier. For example, on the 6-character string 'aaaaaa', a{3,5} will match 5 'a' characters, while a{3,5}? will only match 3 characters. \\ Either escapes special characters (permitting you to match characters like '*', '?', and so forth), or signals a special sequence; special sequences are discussed below. If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions. [] Used to indicate a set of characters. In a set: Characters can be listed individually, e.g. [amk] will match 'a', 'm', or 'k'. Ranges of characters can be indicated by giving two characters and separating them by a '-', for example [a-z] will match any lowercase ASCII letter, [0-5][0-9] will match all the two-digits numbers from 00 to 59, and [0-9A-Fa-f] will match any hexadecimal digit. If - is escaped (e.g. [a\\-z]) or if it’s placed as the first or last character (e.g. [-a] or [a-]), it will match a literal '-'. Special characters lose their special meaning inside sets. For example, [(+*)] will match any of the literal characters '(', '+', '*', or ')'. Character classes such as \\w or \\S (defined below) are also accepted inside a set, although the characters they match depends on whether ASCII or LOCALE mode is in force. Characters that are not within a range can be matched by complementing the set. If the first character of the set is '^', all the characters that are not in the set will be matched. For example, [^5] will match any character except '5', and [^^] will match any character except '^'. ^ has no special meaning if it’s not the first character in the set. To match a literal ']' inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both [()[\\]{}] and []()[{}] will both match a parenthesis. Support of nested sets and set operations as in Unicode Technical Standard #18 might be added in the future. This would change the syntax, so to facilitate this change", "score": "0.663105"}, {"id": "41652", "text": "Function: numpy.reference.generated.numpy.char.chararray.expandtabs\nSnippet: numpy.char.chararray.expandtabs method char.chararray.expandtabs(tabsize=8)[source] Return a copy of each string element where all tab characters are replaced by one or more spaces. See also char.expandtabs", "score": "0.65949386"}, {"id": "41776", "text": "Function: numpy.reference.generated.numpy.chararray.expandtabs\nSnippet: numpy.chararray.expandtabs method chararray.expandtabs(tabsize=8)[source] Return a copy of each string element where all tab characters are replaced by one or more spaces. See also char.expandtabs", "score": "0.6593656"}]}
{"task_id": "mbpp_221", "code": "def first_even(nums):\r\n    first_even = next((el for el in nums if el%2==0),-1)\r\n    return first_even", "test_list": ["assert first_even ([1, 3, 5, 7, 4, 1, 6, 8]) == 4", "assert first_even([2, 3, 4]) == 2", "assert first_even([5, 6, 7]) == 6"], "context": "Write a python function to find the first even number in a given list of numbers.", "function_name": "def first_even(nums):", "gold_generation": "first_even = next((el for el in nums if el%2==0),-1)\r\n    return first_even", "ctxs": [{"id": "19597", "text": "Function: python.library.decimal#decimal.ROUND_HALF_EVEN\nSnippet: decimal.ROUND_HALF_EVEN Round to nearest with ties going to nearest even integer.", "score": "0.686291"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.661996"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.65558064"}, {"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.6524043"}, {"id": "21776", "text": "Function: python.library.math\nSnippet: (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9. Note that frexp() and modf() have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 2**52 necessarily has no fractional bits. Power and logarithmic functions math.exp(x) Return e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). math.expm1(x) Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision: >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.0000050000069649e-05 >>> expm1(1e-5) # result accurate to full precision 1.0000050000166668e-05 New in version 3.2. math.log(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). math.log1p(x) Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. math.log2(x) Return the base-2 logarithm of x. This is usually more accurate than log(x, 2). New in version 3.3. See also int.bit_length() returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. math.log10(x) Return the base-10 logarithm of x. This is usually more accurate than log(x, 10). math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", "score": "0.65030974"}]}
{"task_id": "mbpp_222", "code": "def check_type(test_tuple):\r\n  res = True\r\n  for ele in test_tuple:\r\n    if not isinstance(ele, type(test_tuple[0])):\r\n      res = False\r\n      break\r\n  return (res) ", "test_list": ["assert check_type((5, 6, 7, 3, 5, 6) ) == True", "assert check_type((1, 2, \"4\") ) == False", "assert check_type((3, 2, 1, 4, 5) ) == True"], "context": "Write a function to check if all the elements in tuple have same data type or not.", "function_name": "def check_type(test_tuple):", "gold_generation": "res = True\r\n  for ele in test_tuple:\r\n    if not isinstance(ele, type(test_tuple[0])):\r\n      res = False\r\n      break\r\n  return (res)", "ctxs": [{"id": "43379", "text": "Function: numpy.reference.generated.numpy.polynomial.hermite.hermite.has_sametype\nSnippet: numpy.polynomial.hermite.Hermite.has_sametype method polynomial.hermite.Hermite.has_sametype(other)[source] Check if types match. New in version 1.7.0. Parameters otherobject Class instance. Returns boolboolean True if other is same class as self", "score": "0.73092353"}, {"id": "43608", "text": "Function: numpy.reference.generated.numpy.polynomial.polynomial.polynomial.has_sametype\nSnippet: numpy.polynomial.polynomial.Polynomial.has_sametype method polynomial.polynomial.Polynomial.has_sametype(other)[source] Check if types match. New in version 1.7.0. Parameters otherobject Class instance. Returns boolboolean True if other is same class as self", "score": "0.72644687"}, {"id": "43456", "text": "Function: numpy.reference.generated.numpy.polynomial.hermite_e.hermitee.has_sametype\nSnippet: numpy.polynomial.hermite_e.HermiteE.has_sametype method polynomial.hermite_e.HermiteE.has_sametype(other)[source] Check if types match. New in version 1.7.0. Parameters otherobject Class instance. Returns boolboolean True if other is same class as self", "score": "0.7257936"}, {"id": "43543", "text": "Function: numpy.reference.generated.numpy.polynomial.legendre.legendre.has_sametype\nSnippet: numpy.polynomial.legendre.Legendre.has_sametype method polynomial.legendre.Legendre.has_sametype(other)[source] Check if types match. New in version 1.7.0. Parameters otherobject Class instance. Returns boolboolean True if other is same class as self", "score": "0.72306985"}, {"id": "20225", "text": "Function: python.library.stdtypes#frozenset.issubset\nSnippet: issubset(other) set <= other Test whether every element in the set is in other.", "score": "0.72154784"}]}
{"task_id": "mbpp_223", "code": "def is_majority(arr, n, x):\r\n\ti = binary_search(arr, 0, n-1, x)\r\n\tif i == -1:\r\n\t\treturn False\r\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\r\n\t\treturn True\r\n\telse:\r\n\t\treturn False\r\ndef binary_search(arr, low, high, x):\r\n\tif high >= low:\r\n\t\tmid = (low + high)//2 \r\n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\r\n\t\t\treturn mid\r\n\t\telif x > arr[mid]:\r\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\r\n\t\telse:\r\n\t\t\treturn binary_search(arr, low, (mid -1), x)\r\n\treturn -1", "test_list": ["assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True", "assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False", "assert is_majority([1, 1, 1, 2, 2], 5, 1) == True"], "context": "Write a function to check for majority element in the given sorted array.", "function_name": "def is_majority(arr, n, x):", "gold_generation": "i = binary_search(arr, 0, n-1, x)\r\n\tif i == -1:\r\n\t\treturn False\r\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\r\n\t\treturn True\r\n\telse:\r\n\t\treturn False\r\ndef binary_search(arr, low, high, x):\r\n\tif high >= low:\r\n\t\tmid = (low + high)//2 \r\n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\r\n\t\t\treturn mid\r\n\t\telif x > arr[mid]:\r\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\r\n\t\telse:\r\n\t\t\treturn binary_search(arr, low, (mid -1), x)\r\n\treturn -1", "ctxs": [{"id": "20478", "text": "Function: python.library.heapq\nSnippet: key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters. heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n]. heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n]. The latter two functions perform best for smaller values of n. For larger values, it is more efficient to use the sorted() function. Also, when n==1, it is more efficient to use the built-in min() and max() functions. If repeated usage of these functions is required, consider turning the iterable into an actual heap. Basic Examples A heapsort can be implemented by pushing all values onto a heap and then popping off the smallest values one at a time: >>> def heapsort(iterable): ... h = [] ... for value in iterable: ... heappush(h, value) ... return [heappop(h) for i in range(len(h))] ... >>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] This is similar to sorted(iterable), but unlike sorted(), this implementation is not stable. Heap elements can be tuples. This is useful for assigning comparison values (such as task priorities) alongside the main record being tracked: >>> h = [] >>> heappush(h, (5, 'write code')) >>> heappush(h, (7, 'release product')) >>> heappush(h, (1, 'write spec')) >>> heappush(h, (3, 'create tests')) >>> heappop(h) (1, 'write spec') Priority Queue Implementation Notes A priority queue is common use for a heap, and it presents several implementation challenges: Sort stability: how do you get two tasks with equal priorities to be returned in the order they were originally added? Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order. If the priority of a task changes, how do you move it to a new position in the heap? Or if a pending task needs to be deleted, how do you find it and remove it from the queue? A solution to the first two challenges is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were", "score": "0.6635648"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.66022336"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6576078"}, {"id": "43864", "text": "Function: numpy.reference.generated.numpy.recarray.partition\nSnippet: numpy.recarray.partition method recarray.partition(kth, axis=- 1, kind='introselect', order=None) Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array. All elements smaller than the kth element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined. New in version 1.8.0. Parameters kthint or sequence of ints Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. Deprecated since version 1.22.0: Passing booleans as index is deprecated. axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘introselect’}, optional Selection algorithm. Default is ‘introselect’. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.partition Return a parititioned copy of an array. argpartition Indirect partition. sort Full sort. Notes See np.partition for notes on the different algorithms. Examples >>> a = np.array([3, 4, 2, 1]) >>> a.partition(3) >>> a array([2, 1, 3, 4]) >>> a.partition((1, 3)) >>> a array([1, 2, 3, 4])", "score": "0.65050334"}, {"id": "43173", "text": "Function: numpy.reference.generated.numpy.searchsorted\nSnippet: numpy.searchsorted numpy.searchsorted(a, v, side='left', sorter=None)[source] Find indices where elements should be inserted to maintain order. Find the indices into a sorted array a such that, if the corresponding elements in v were inserted before the indices, the order of a would be preserved. Assuming that a is sorted: side returned index i satisfies left a[i-1] < v <= a[i] right a[i-1] <= v < a[i] Parameters a1-D array_like Input array. If sorter is None, then it must be sorted in ascending order, otherwise sorter must be an array of indices that sort it. varray_like Values to insert into a. side{‘left’, ‘right’}, optional If ‘left’, the index of the first suitable location found is given. If ‘right’, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of a). sorter1-D array_like, optional Optional array of integer indices that sort array a into ascending order. They are typically the result of argsort. New in version 1.7.0. Returns indicesint or array of ints Array of insertion points with the same shape as v, or an integer if v is a scalar. See also sort Return a sorted copy of an array. histogram Produce histogram from 1-D data. Notes Binary search is used to find the required insertion points. As of NumPy 1.4.0 searchsorted works with real/complex arrays containing nan values. The enhanced sort order is documented in sort. This function uses the same algorithm as the builtin python bisect.bisect_left (side='left') and bisect.bisect_right (side='right') functions, which is also vectorized in the v argument. Examples >>> np.searchsorted([1,2,3,4,5], 3) 2 >>> np.searchsorted([1,2,3,4,5], 3, side='right') 3 >>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3]) array([0, 5, 1, 2])", "score": "0.6483004"}]}
{"task_id": "mbpp_224", "code": "def count_Set_Bits(n): \r\n    count = 0\r\n    while (n): \r\n        count += n & 1\r\n        n >>= 1\r\n    return count ", "test_list": ["assert count_Set_Bits(2) == 1", "assert count_Set_Bits(4) == 1", "assert count_Set_Bits(6) == 2"], "context": "Write a python function to count set bits of a given number.", "function_name": "def count_Set_Bits(n):", "gold_generation": "count = 0\r\n    while (n): \r\n        count += n & 1\r\n        n >>= 1\r\n    return count", "ctxs": [{"id": "13465", "text": "Function: pygame.ref.mask#pygame.mask.Mask.count\nSnippet: count() Returns the number of set bits count() -> bits Returns: the number of set bits in the mask Return type: int", "score": "0.780257"}, {"id": "21071", "text": "Function: python.library.stdtypes#int.bit_length\nSnippet: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1.", "score": "0.72033346"}, {"id": "25732", "text": "Function: python.library.stdtypes\nSnippet: there were an infinite number of sign bits. Additional Methods on Integer Types The int type implements the numbers.Integral abstract base class. In addition, it provides a few more methods: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1. int.to_bytes(length, byteorder, *, signed=False) Return an array of bytes representing an integer. >>> (1024).to_bytes(2, byteorder='big') b'\\x04\\x00' >>> (1024).to_bytes(10, byteorder='big') b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00' >>> (-1024).to_bytes(10, byteorder='big', signed=True) b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00' >>> x = 1000 >>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little') b'\\xe8\\x03' The integer is represented using length bytes. An OverflowError is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument determines whether two’s complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. The default value for signed is False. New in version 3.2. classmethod int.from_bytes(bytes, byteorder, *, signed=False) Return the integer represented by the given array of bytes. >>> int.from_bytes(b'\\x00\\x10', byteorder='big') 16 >>> int.from_bytes(b'\\x00\\x10', byteorder='little') 4096 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True) -1024 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False) 64512 >>> int.from_bytes([255, 0, 0], byteorder='big') 16711680 The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. New in version 3.2. int.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original integer and with a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. New in version 3.8. Additional Methods on Float The float type implements the numbers.Real abstract base class. float also has the following additional methods. float.as_integer_ratio() Return a pair of integers whose", "score": "0.70386887"}, {"id": "23488", "text": "Function: python.library.secrets#secrets.randbits\nSnippet: secrets.randbits(k) Return an int with k random bits.", "score": "0.6918216"}, {"id": "25566", "text": "Function: python.library.tracemalloc#tracemalloc.Statistic.count\nSnippet: count Number of memory blocks (int).", "score": "0.67916375"}]}
{"task_id": "mbpp_225", "code": "def find_Min(arr,low,high): \r\n    while (low < high): \r\n        mid = low + (high - low) // 2;   \r\n        if (arr[mid] == arr[high]): \r\n            high -= 1; \r\n        elif (arr[mid] > arr[high]): \r\n            low = mid + 1; \r\n        else: \r\n            high = mid; \r\n    return arr[high]; ", "test_list": ["assert find_Min([1,2,3,4,5],0,4) == 1", "assert find_Min([4,6,8],0,2) == 4", "assert find_Min([2,3,5,7,9],0,4) == 2"], "context": "Write a python function to find the minimum element in a sorted and rotated array.", "function_name": "def find_Min(arr,low,high):", "gold_generation": "while (low < high): \r\n        mid = low + (high - low) // 2;   \r\n        if (arr[mid] == arr[high]): \r\n            high -= 1; \r\n        elif (arr[mid] > arr[high]): \r\n            low = mid + 1; \r\n        else: \r\n            high = mid; \r\n    return arr[high];", "ctxs": [{"id": "43859", "text": "Function: numpy.reference.generated.numpy.recarray.min\nSnippet: numpy.recarray.min method recarray.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the minimum along a given axis. Refer to numpy.amin for full documentation. See also numpy.amin equivalent function", "score": "0.714745"}, {"id": "13013", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos#sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.7124024"}, {"id": "21889", "text": "Function: python.library.functions#min\nSnippet: min(iterable, *[, key, default]) min(arg1, arg2, *args[, key]) Return the smallest item in an iterable or the smallest of two or more arguments. If one positional argument is provided, it should be an iterable. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.70876503"}, {"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.7085309"}, {"id": "12778", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.707705"}]}
{"task_id": "mbpp_226", "code": "def odd_values_string(str):\r\n  result = \"\" \r\n  for i in range(len(str)):\r\n    if i % 2 == 0:\r\n      result = result + str[i]\r\n  return result", "test_list": ["assert odd_values_string('abcdef') == 'ace'", "assert odd_values_string('python') == 'pto'", "assert odd_values_string('data') == 'dt'"], "context": "Write a python function to remove the characters which have odd index values of a given string.", "function_name": "def odd_values_string(str):", "gold_generation": "result = \"\" \r\n  for i in range(len(str)):\r\n    if i % 2 == 0:\r\n      result = result + str[i]\r\n  return result", "ctxs": [{"id": "41823", "text": "Function: numpy.reference.generated.numpy.chararray.strip\nSnippet: numpy.chararray.strip method chararray.strip(chars=None)[source] For each element in self, return a copy with the leading and trailing characters removed. See also char.strip", "score": "0.7055268"}, {"id": "41702", "text": "Function: numpy.reference.generated.numpy.char.chararray.strip\nSnippet: numpy.char.chararray.strip method char.chararray.strip(chars=None)[source] For each element in self, return a copy with the leading and trailing characters removed. See also char.strip", "score": "0.7040115"}, {"id": "16533", "text": "Function: pandas.reference.series\nSnippet: of strings in the Series/Index. Series.str.rpartition([sep, expand]) Split the string at the last occurrence of sep. Series.str.rstrip([to_strip]) Remove trailing characters. Series.str.slice([start, stop, step]) Slice substrings from each element in the Series or Index. Series.str.slice_replace([start, stop, repl]) Replace a positional slice of a string with another value. Series.str.split([pat, n, expand, regex]) Split strings around given separator/delimiter. Series.str.rsplit([pat, n, expand]) Split strings around given separator/delimiter. Series.str.startswith(pat[, na]) Test if the start of each string element matches a pattern. Series.str.strip([to_strip]) Remove leading and trailing characters. Series.str.swapcase() Convert strings in the Series/Index to be swapcased. Series.str.title() Convert strings in the Series/Index to titlecase. Series.str.translate(table) Map all characters in the string through the given mapping table. Series.str.upper() Convert strings in the Series/Index to uppercase. Series.str.wrap(width, **kwargs) Wrap strings in Series/Index at specified line width. Series.str.zfill(width) Pad strings in the Series/Index by prepending '0' characters. Series.str.isalnum() Check whether all characters in each string are alphanumeric. Series.str.isalpha() Check whether all characters in each string are alphabetic. Series.str.isdigit() Check whether all characters in each string are digits. Series.str.isspace() Check whether all characters in each string are whitespace. Series.str.islower() Check whether all characters in each string are lowercase. Series.str.isupper() Check whether all characters in each string are uppercase. Series.str.istitle() Check whether all characters in each string are titlecase. Series.str.isnumeric() Check whether all characters in each string are numeric. Series.str.isdecimal() Check whether all characters in each string are decimal. Series.str.get_dummies([sep]) Return DataFrame of dummy/indicator variables for Series. Categorical accessor Categorical-dtype specific methods and attributes are available under the Series.cat accessor. Series.cat.categories The categories of this categorical. Series.cat.ordered Whether the categories have an ordered relationship. Series.cat.codes Return Series of codes as well as the index. Series.cat.rename_categories(*args, **kwargs) Rename categories. Series.cat.reorder_categories(*args, **kwargs) Reorder categories as specified in new_categories. Series.cat.add_categories(*args, **kwargs) Add new categories. Series.cat.remove_categories(*args, **kwargs) Remove the specified categories. Series.cat.remove_unused_categories(*args, ...) Remove categories which are not used. Series.cat.set_categories(*args, **kwargs) Set the categories to the specified new_categories. Series.cat.as_ordered(*args, **kwargs) Set the Categorical to be ordered. Series.cat.as_unordered(*args, **kwargs) Set the Categorical to be unordered. Sparse accessor Sparse-dtype specific methods and attributes are provided under the Series.sparse accessor. Series.sparse.npoints The number of non- fill_value points. Series.sparse.density The percent of non- fill_value points, as decimal. Series.sparse.fill_value Elements in data that are fill_value are not stored. Series.sparse.sp_values An ndarray containing the non- fill_value values. Series.sparse.from_coo(A[, dense_index]) Create a Series with sparse values from a scipy.sparse.coo_matrix. Series.sparse.to_coo([row_levels, ...]) Create a scipy.sparse.coo_matrix from a Series with MultiIndex. Flags Flags refer to attributes of the pandas object. Properties of the dataset (like the date is was recorded, the URL it was accessed from, etc.) should be stored in Series.attrs. Flags(obj, *, allows_duplicate_labels) Flags that apply to pandas objects. Metadata Series.attrs is a dictionary for storing global metadata for this Series. Warning Series.attrs is considered experimental and may change without warning. Series.attrs Dictionary of global attributes of this dataset. Plotting Series.plot is both a callable method and a namespace attribute for specific plotting methods of the form Series.plot.<kind>. Series.plot([kind, ax, figsize, ....]) Series plotting accessor and method Series.plot.area([x, y]) Draw a", "score": "0.70029986"}, {"id": "24376", "text": "Function: python.library.stdtypes#str.rstrip\nSnippet: str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty'", "score": "0.6931979"}, {"id": "25756", "text": "Function: python.library.stdtypes\nSnippet: binary sequence of byte values to remove may be any bytes-like object. See removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> b'Monty Python'.rstrip(b' Python') b'M' >>> b'Monty Python'.removesuffix(b' Python') b'Monty' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3'] bytes.strip([chars]) bytearray.strip([chars]) Return a copy of the sequence with specified leading and trailing bytes removed. The chars argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters. If omitted or None, the chars argument defaults to removing ASCII whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> b' spacious '.strip() b'spacious' >>> b'www.example.com'.strip(b'cmowz.') b'example' The binary sequence of byte values to remove may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.capitalize() bytearray.capitalize() Return a copy of the sequence with each byte interpreted as an ASCII character, and the first byte capitalized and the rest", "score": "0.69038415"}]}
{"task_id": "mbpp_227", "code": "def min_of_three(a,b,c): \r\n      if (a <= b) and (a <= c): \r\n        smallest = a \r\n      elif (b <= a) and (b <= c): \r\n        smallest = b \r\n      else: \r\n        smallest = c \r\n      return smallest ", "test_list": ["assert min_of_three(10,20,0)==0", "assert min_of_three(19,15,18)==15", "assert min_of_three(-10,-20,-30)==-30"], "context": "Write a function to find minimum of three numbers.", "function_name": "def min_of_three(a,b,c):", "gold_generation": "if (a <= b) and (a <= c): \r\n        smallest = a \r\n      elif (b <= a) and (b <= c): \r\n        smallest = b \r\n      else: \r\n        smallest = c \r\n      return smallest", "ctxs": [{"id": "19492", "text": "Function: python.library.decimal#decimal.Context.min\nSnippet: min(x, y) Compares two values numerically and returns the minimum.", "score": "0.70310736"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.69723094"}, {"id": "43859", "text": "Function: numpy.reference.generated.numpy.recarray.min\nSnippet: numpy.recarray.min method recarray.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the minimum along a given axis. Refer to numpy.amin for full documentation. See also numpy.amin equivalent function", "score": "0.66679084"}, {"id": "42533", "text": "Function: numpy.reference.generated.numpy.ndarray.min\nSnippet: numpy.ndarray.min method ndarray.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the minimum along a given axis. Refer to numpy.amin for full documentation. See also numpy.amin equivalent function", "score": "0.6598969"}, {"id": "21813", "text": "Function: python.library.math#math.lcm\nSnippet: math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9.", "score": "0.65593934"}]}
{"task_id": "mbpp_228", "code": "def all_Bits_Set_In_The_Given_Range(n,l,r):  \r\n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \r\n    new_num = n & num\r\n    if (new_num == 0): \r\n        return True\r\n    return False", "test_list": ["assert all_Bits_Set_In_The_Given_Range(4,1,2) == True", "assert all_Bits_Set_In_The_Given_Range(17,2,4) == True", "assert all_Bits_Set_In_The_Given_Range(39,4,6) == False"], "context": "Write a python function to check whether all the bits are unset in the given range or not.", "function_name": "def all_Bits_Set_In_The_Given_Range(n,l,r):", "gold_generation": "num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \r\n    new_num = n & num\r\n    if (new_num == 0): \r\n        return True\r\n    return False", "ctxs": [{"id": "20225", "text": "Function: python.library.stdtypes#frozenset.issubset\nSnippet: issubset(other) set <= other Test whether every element in the set is in other.", "score": "0.69673216"}, {"id": "20226", "text": "Function: python.library.stdtypes#frozenset.issuperset\nSnippet: issuperset(other) set >= other Test whether every element in other is in the set.", "score": "0.6947226"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.68505985"}, {"id": "20215", "text": "Function: python.library.stdtypes#frozenset\nSnippet: and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem.", "score": "0.6763356"}, {"id": "23564", "text": "Function: python.library.stdtypes#set\nSnippet: and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem.", "score": "0.6762461"}]}
{"task_id": "mbpp_229", "code": "def re_arrange_array(arr, n):\r\n  j=0\r\n  for i in range(0, n):\r\n    if (arr[i] < 0):\r\n      temp = arr[i]\r\n      arr[i] = arr[j]\r\n      arr[j] = temp\r\n      j = j + 1\r\n  return arr", "test_list": ["assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]", "assert re_arrange_array([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]", "assert re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]"], "context": "Write a function to re-arrange the elements of the given array so that all negative elements appear before positive ones.", "function_name": "def re_arrange_array(arr, n):", "gold_generation": "j=0\r\n  for i in range(0, n):\r\n    if (arr[i] < 0):\r\n      temp = arr[i]\r\n      arr[i] = arr[j]\r\n      arr[j] = temp\r\n      j = j + 1\r\n  return arr", "ctxs": [{"id": "17639", "text": "Function: python.library.array#array.array.insert\nSnippet: array.insert(i, x) Insert a new item with value x in the array before position i. Negative values are treated as being relative to the end of the array.", "score": "0.70551455"}, {"id": "17643", "text": "Function: python.library.array#array.array.reverse\nSnippet: array.reverse() Reverse the order of the items in the array.", "score": "0.6834476"}, {"id": "43864", "text": "Function: numpy.reference.generated.numpy.recarray.partition\nSnippet: numpy.recarray.partition method recarray.partition(kth, axis=- 1, kind='introselect', order=None) Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array. All elements smaller than the kth element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined. New in version 1.8.0. Parameters kthint or sequence of ints Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. Deprecated since version 1.22.0: Passing booleans as index is deprecated. axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘introselect’}, optional Selection algorithm. Default is ‘introselect’. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.partition Return a parititioned copy of an array. argpartition Indirect partition. sort Full sort. Notes See np.partition for notes on the different algorithms. Examples >>> a = np.array([3, 4, 2, 1]) >>> a.partition(3) >>> a array([2, 1, 3, 4]) >>> a.partition((1, 3)) >>> a array([1, 2, 3, 4])", "score": "0.67675734"}, {"id": "42550", "text": "Function: numpy.reference.generated.numpy.ndarray.partition\nSnippet: numpy.ndarray.partition method ndarray.partition(kth, axis=- 1, kind='introselect', order=None) Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array. All elements smaller than the kth element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined. New in version 1.8.0. Parameters kthint or sequence of ints Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. Deprecated since version 1.22.0: Passing booleans as index is deprecated. axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘introselect’}, optional Selection algorithm. Default is ‘introselect’. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.partition Return a parititioned copy of an array. argpartition Indirect partition. sort Full sort. Notes See np.partition for notes on the different algorithms. Examples >>> a = np.array([3, 4, 2, 1]) >>> a.partition(3) >>> a array([2, 1, 3, 4]) >>> a.partition((1, 3)) >>> a array([1, 2, 3, 4])", "score": "0.66186225"}, {"id": "42414", "text": "Function: numpy.reference.generated.numpy.matrix.partition\nSnippet: numpy.matrix.partition method matrix.partition(kth, axis=- 1, kind='introselect', order=None) Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array. All elements smaller than the kth element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined. New in version 1.8.0. Parameters kthint or sequence of ints Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. Deprecated since version 1.22.0: Passing booleans as index is deprecated. axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘introselect’}, optional Selection algorithm. Default is ‘introselect’. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.partition Return a parititioned copy of an array. argpartition Indirect partition. sort Full sort. Notes See np.partition for notes on the different algorithms. Examples >>> a = np.array([3, 4, 2, 1]) >>> a.partition(3) >>> a array([2, 1, 3, 4]) >>> a.partition((1, 3)) >>> a array([1, 2, 3, 4])", "score": "0.6549037"}]}
{"task_id": "mbpp_230", "code": "def replace_blank(str1,char):\r\n str2 = str1.replace(' ', char)\r\n return str2", "test_list": ["assert replace_blank(\"hello people\",'@')==(\"hello@people\")", "assert replace_blank(\"python program language\",'$')==(\"python$program$language\")", "assert replace_blank(\"blank space\",\"-\")==(\"blank-space\")"], "context": "Write a function to replace blank spaces with any character in a string.", "function_name": "def replace_blank(str1,char):", "gold_generation": "str2 = str1.replace(' ', char)\r\n return str2", "ctxs": [{"id": "24398", "text": "Function: python.library.string\nSnippet: characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", "score": "0.7169276"}, {"id": "41683", "text": "Function: numpy.reference.generated.numpy.char.chararray.replace\nSnippet: numpy.char.chararray.replace method char.chararray.replace(old, new, count=None)[source] For each element in self, return a copy of the string with all occurrences of substring old replaced by new. See also char.replace", "score": "0.6970896"}, {"id": "41747", "text": "Function: numpy.reference.generated.numpy.char.replace\nSnippet: numpy.char.replace char.replace(a, old, new, count=None)[source] For each element in a, return a copy of the string with all occurrences of substring old replaced by new. Calls str.replace element-wise. Parameters aarray-like of str or unicode old, newstr or unicode countint, optional If the optional argument count is given, only the first count occurrences are replaced. Returns outndarray Output array of str or unicode, depending on input type See also str.replace", "score": "0.69411874"}, {"id": "41805", "text": "Function: numpy.reference.generated.numpy.chararray.replace\nSnippet: numpy.chararray.replace method chararray.replace(old, new, count=None)[source] For each element in self, return a copy of the string with all occurrences of substring old replaced by new. See also char.replace", "score": "0.6878061"}, {"id": "24373", "text": "Function: python.library.stdtypes#str.rjust\nSnippet: str.rjust(width[, fillchar]) Return the string right justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s).", "score": "0.68362933"}]}
{"task_id": "mbpp_231", "code": "def max_sum(tri, n): \r\n\tif n > 1: \r\n\t\ttri[1][1] = tri[1][1]+tri[0][0] \r\n\t\ttri[1][0] = tri[1][0]+tri[0][0] \r\n\tfor i in range(2, n): \r\n\t\ttri[i][0] = tri[i][0] + tri[i-1][0] \r\n\t\ttri[i][i] = tri[i][i] + tri[i-1][i-1] \r\n\t\tfor j in range(1, i): \r\n\t\t\tif tri[i][j]+tri[i-1][j-1] >= tri[i][j]+tri[i-1][j]: \r\n\t\t\t\ttri[i][j] = tri[i][j] + tri[i-1][j-1] \r\n\t\t\telse: \r\n\t\t\t\ttri[i][j] = tri[i][j]+tri[i-1][j] \r\n\treturn (max(tri[n-1]))", "test_list": ["assert max_sum([[1], [2,1], [3,3,2]], 3) == 6", "assert max_sum([[1], [1, 2], [4, 1, 12]], 3) == 15 ", "assert max_sum([[2], [3,2], [13,23,12]], 3) == 28"], "context": "Write a function to find the maximum sum in the given right triangle of numbers.", "function_name": "def max_sum(tri, n):", "gold_generation": "if n > 1: \r\n\t\ttri[1][1] = tri[1][1]+tri[0][0] \r\n\t\ttri[1][0] = tri[1][0]+tri[0][0] \r\n\tfor i in range(2, n): \r\n\t\ttri[i][0] = tri[i][0] + tri[i-1][0] \r\n\t\ttri[i][i] = tri[i][i] + tri[i-1][i-1] \r\n\t\tfor j in range(1, i): \r\n\t\t\tif tri[i][j]+tri[i-1][j-1] >= tri[i][j]+tri[i-1][j]: \r\n\t\t\t\ttri[i][j] = tri[i][j] + tri[i-1][j-1] \r\n\t\t\telse: \r\n\t\t\t\ttri[i][j] = tri[i][j]+tri[i-1][j] \r\n\treturn (max(tri[n-1]))", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6443926"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.64166117"}, {"id": "42345", "text": "Function: numpy.reference.generated.numpy.ma.sum\nSnippet: numpy.ma.sum ma.sum(self, axis=None, dtype=None, out=None, keepdims=<no value>) = <numpy.ma.core._frommethod object> Return the sum of the array elements over the given axis. Masked elements are set to 0 internally. Refer to numpy.sum for full documentation. See also numpy.ndarray.sum corresponding function for ndarrays numpy.sum equivalent function Examples >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4) >>> x masked_array( data=[[1, --, 3], [--, 5, --], [7, --, 9]], mask=[[False, True, False], [ True, False, True], [False, True, False]], fill_value=999999) >>> x.sum() 25 >>> x.sum(axis=1) masked_array(data=[4, 5, 16], mask=[False, False, False], fill_value=999999) >>> x.sum(axis=0) masked_array(data=[8, 5, 12], mask=[False, False, False], fill_value=999999) >>> print(type(x.sum(axis=0, dtype=np.int64)[0])) <class 'numpy.int64'>", "score": "0.6411844"}, {"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.63817793"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.63783264"}]}
{"task_id": "mbpp_232", "code": "import heapq\r\ndef larg_nnum(list1,n):\r\n largest=heapq.nlargest(n,list1)\r\n return largest", "test_list": ["assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2)==[100,90]", "assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],5)==[100,90,80,70,60]", "assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],3)==[100,90,80]"], "context": "Write a function to get the n largest items from a dataset.", "function_name": "import heapq\r\ndef larg_nnum(list1,n):", "gold_generation": "largest=heapq.nlargest(n,list1)\r\n return largest", "ctxs": [{"id": "15240", "text": "Function: pandas.reference.api.pandas.series.nlargest\nSnippet: pandas.Series.nlargest Series.nlargest(n=5, keep='first')[source] Return the largest n elements. Parameters n:int, default 5 Return this many descending sorted values. keep:{‘first’, ‘last’, ‘all’}, default ‘first’ When there are duplicate values that cannot all fit in a Series of n elements: first : return the first n occurrences in order of appearance. last : return the last n occurrences in reverse order of appearance. all : keep all occurrences. This can result in a Series of size larger than n. Returns Series The n largest values in the Series, sorted in decreasing order. See also Series.nsmallest Get the n smallest elements. Series.sort_values Sort Series by values. Series.head Return the first n rows. Notes Faster than .sort_values(ascending=False).head(n) for small n relative to the size of the Series object. Examples >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000, ... \"Malta\": 434000, \"Maldives\": 434000, ... \"Brunei\": 434000, \"Iceland\": 337000, ... \"Nauru\": 11300, \"Tuvalu\": 11300, ... \"Anguilla\": 11300, \"Montserrat\": 5200} >>> s = pd.Series(countries_population) >>> s Italy 59000000 France 65000000 Malta 434000 Maldives 434000 Brunei 434000 Iceland 337000 Nauru 11300 Tuvalu 11300 Anguilla 11300 Montserrat 5200 dtype: int64 The n largest elements where n=5 by default. >>> s.nlargest() France 65000000 Italy 59000000 Malta 434000 Maldives 434000 Brunei 434000 dtype: int64 The n largest elements where n=3. Default keep value is ‘first’ so Malta will be kept. >>> s.nlargest(3) France 65000000 Italy 59000000 Malta 434000 dtype: int64 The n largest elements where n=3 and keeping the last duplicates. Brunei will be kept since it is the last with value 434000 based on the index order. >>> s.nlargest(3, keep='last') France 65000000 Italy 59000000 Brunei 434000 dtype: int64 The n largest elements where n=3 with all duplicates kept. Note that the returned Series has five elements due to the three duplicates. >>> s.nlargest(3, keep='all') France 65000000 Italy 59000000 Malta 434000 Maldives 434000 Brunei 434000 dtype: int64", "score": "0.7318605"}, {"id": "14180", "text": "Function: pandas.reference.api.pandas.core.groupby.seriesgroupby.nlargest\nSnippet: pandas.core.groupby.SeriesGroupBy.nlargest SeriesGroupBy.nlargest(n=5, keep='first')[source] Return the largest n elements. Parameters n:int, default 5 Return this many descending sorted values. keep:{‘first’, ‘last’, ‘all’}, default ‘first’ When there are duplicate values that cannot all fit in a Series of n elements: first : return the first n occurrences in order of appearance. last : return the last n occurrences in reverse order of appearance. all : keep all occurrences. This can result in a Series of size larger than n. Returns Series The n largest values in the Series, sorted in decreasing order. See also Series.nsmallest Get the n smallest elements. Series.sort_values Sort Series by values. Series.head Return the first n rows. Notes Faster than .sort_values(ascending=False).head(n) for small n relative to the size of the Series object. Examples >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000, ... \"Malta\": 434000, \"Maldives\": 434000, ... \"Brunei\": 434000, \"Iceland\": 337000, ... \"Nauru\": 11300, \"Tuvalu\": 11300, ... \"Anguilla\": 11300, \"Montserrat\": 5200} >>> s = pd.Series(countries_population) >>> s Italy 59000000 France 65000000 Malta 434000 Maldives 434000 Brunei 434000 Iceland 337000 Nauru 11300 Tuvalu 11300 Anguilla 11300 Montserrat 5200 dtype: int64 The n largest elements where n=5 by default. >>> s.nlargest() France 65000000 Italy 59000000 Malta 434000 Maldives 434000 Brunei 434000 dtype: int64 The n largest elements where n=3. Default keep value is ‘first’ so Malta will be kept. >>> s.nlargest(3) France 65000000 Italy 59000000 Malta 434000 dtype: int64 The n largest elements where n=3 and keeping the last duplicates. Brunei will be kept since it is the last with value 434000 based on the index order. >>> s.nlargest(3, keep='last') France 65000000 Italy 59000000 Brunei 434000 dtype: int64 The n largest elements where n=3 with all duplicates kept. Note that the returned Series has five elements due to the three duplicates. >>> s.nlargest(3, keep='all') France 65000000 Italy 59000000 Malta 434000 Maldives 434000 Brunei 434000 dtype: int64", "score": "0.7262844"}, {"id": "20488", "text": "Function: python.library.heapq#heapq.nlargest\nSnippet: heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n].", "score": "0.7190237"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.6883639"}, {"id": "14413", "text": "Function: pandas.reference.api.pandas.dataframe.nlargest\nSnippet: pandas.DataFrame.nlargest DataFrame.nlargest(n, columns, keep='first')[source] Return the first n rows ordered by columns in descending order. Return the first n rows with the largest values in columns, in descending order. The columns that are not specified are returned as well, but not used for ordering. This method is equivalent to df.sort_values(columns, ascending=False).head(n), but more performant. Parameters n:int Number of rows to return. columns:label or list of labels Column label(s) to order by. keep:{‘first’, ‘last’, ‘all’}, default ‘first’ Where there are duplicate values: first : prioritize the first occurrence(s) last : prioritize the last occurrence(s) all : do not drop any duplicates, even it means selecting more than n items. Returns DataFrame The first n rows ordered by the given columns in descending order. See also DataFrame.nsmallest Return the first n rows ordered by columns in ascending order. DataFrame.sort_values Sort DataFrame by the values. DataFrame.head Return the first n rows without re-ordering. Notes This function cannot be used with all column types. For example, when specifying columns with object or category dtypes, TypeError is raised. Examples >>> df = pd.DataFrame({'population': [59000000, 65000000, 434000, ... 434000, 434000, 337000, 11300, ... 11300, 11300], ... 'GDP': [1937894, 2583560 , 12011, 4520, 12128, ... 17036, 182, 38, 311], ... 'alpha-2': [\"IT\", \"FR\", \"MT\", \"MV\", \"BN\", ... \"IS\", \"NR\", \"TV\", \"AI\"]}, ... index=[\"Italy\", \"France\", \"Malta\", ... \"Maldives\", \"Brunei\", \"Iceland\", ... \"Nauru\", \"Tuvalu\", \"Anguilla\"]) >>> df population GDP alpha-2 Italy 59000000 1937894 IT France 65000000 2583560 FR Malta 434000 12011 MT Maldives 434000 4520 MV Brunei 434000 12128 BN Iceland 337000 17036 IS Nauru 11300 182 NR Tuvalu 11300 38 TV Anguilla 11300 311 AI In the following example, we will use nlargest to select the three rows having the largest values in column “population”. >>> df.nlargest(3, 'population') population GDP alpha-2 France 65000000 2583560 FR Italy 59000000 1937894 IT Malta 434000 12011 MT When using keep='last', ties are resolved in reverse order: >>> df.nlargest(3, 'population', keep='last') population GDP alpha-2 France 65000000 2583560 FR Italy 59000000 1937894 IT Brunei 434000 12128 BN When using keep='all', all duplicate items are maintained: >>> df.nlargest(3, 'population', keep='all') population GDP alpha-2 France 65000000 2583560 FR Italy 59000000 1937894 IT Malta 434000 12011 MT Maldives 434000 4520 MV Brunei 434000 12128 BN To order by the largest values in column “population” and then “GDP”, we can specify multiple columns like in the next example. >>> df.nlargest(3, ['population', 'GDP']) population GDP alpha-2 France 65000000 2583560 FR Italy 59000000 1937894 IT Brunei 434000 12128 BN", "score": "0.68776107"}]}
{"task_id": "mbpp_233", "code": "def lateralsuface_cylinder(r,h):\r\n  lateralsurface= 2*3.1415*r*h\r\n  return lateralsurface", "test_list": ["assert lateralsuface_cylinder(10,5)==314.15000000000003", "assert lateralsuface_cylinder(4,5)==125.66000000000001", "assert lateralsuface_cylinder(4,10)==251.32000000000002"], "context": "Write a function to find the lateral surface area of a cylinder.", "function_name": "def lateralsuface_cylinder(r,h):", "gold_generation": "lateralsurface= 2*3.1415*r*h\r\n  return lateralsurface", "ctxs": [{"id": "33487", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: barbs_doc='\\nPlot a 2D field of barbs.\\n\\nCall signature::\\n\\n barbs([X, Y], U, V, [C], **kw)\\n\\nWhere *X*, *Y* define the barb locations, *U*, *V* define the barb\\ndirections, and *C* optionally sets the color.\\n\\nAll arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked\\n*X*, *Y* are not supported at present.\\n\\nBarbs are traditionally used in meteorology as a way to plot the speed\\nand direction of wind observations, but can technically be used to\\nplot any two dimensional vector quantity. As opposed to arrows, which\\ngive vector magnitude by the length of the arrow, the barbs give more\\nquantitative information about the vector magnitude by putting slanted\\nlines or a triangle for various increments in magnitude, as show\\nschematically below::\\n\\n : /\\\\ \\\\\\n : / \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : ------------------------------\\n\\nThe largest increment is given by a triangle (or \"flag\"). After those\\ncome full lines (barbs). The smallest increment is a half line. There\\nis only, of course, ever at most 1 half line. If the magnitude is\\nsmall and only needs a single half-line and no full lines or\\ntriangles, the half-line is offset from the end of the barb so that it\\ncan be easily distinguished from barbs with a single full line. The\\nmagnitude for the barb shown above would nominally be 65, using the\\nstandard increments of 50, 10, and 5.\\n\\nSee also https://en.wikipedia.org/wiki/Wind_barb.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the barb locations. See *pivot* for how the\\n barbs are drawn to the x, y positions.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y components of the barb shaft.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If", "score": "0.65620536"}, {"id": "16631", "text": "Function: skimage.api.skimage.draw\nSnippet: ellipsoid_stats skimage.draw.ellipsoid_stats(a, b, c) [source] Calculates analytical surface area and volume for ellipsoid with semimajor axes aligned with grid dimensions of specified spacing. Parameters afloat Length of semimajor axis aligned with x-axis. bfloat Length of semimajor axis aligned with y-axis. cfloat Length of semimajor axis aligned with z-axis. Returns volfloat Calculated volume of ellipsoid. surffloat Calculated surface area of ellipsoid. line skimage.draw.line(r0, c0, r1, c1) [source] Generate line pixel coordinates. Parameters r0, c0int Starting position (row, column). r1, c1int End position (row, column). Returns rr, cc(N,) ndarray of int Indices of pixels that belong to the line. May be used to directly index into an array, e.g. img[rr, cc] = 1. Notes Anti-aliased line generator is available with line_aa. Examples >>> from skimage.draw import line >>> img = np.zeros((10, 10), dtype=np.uint8) >>> rr, cc = line(1, 1, 8, 8) >>> img[rr, cc] = 1 >>> img array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8) line_aa skimage.draw.line_aa(r0, c0, r1, c1) [source] Generate anti-aliased line pixel coordinates. Parameters r0, c0int Starting position (row, column). r1, c1int End position (row, column). Returns rr, cc, val(N,) ndarray (int, int, float) Indices of pixels (rr, cc) and intensity values (val). img[rr, cc] = val. References 1 A Rasterizing Algorithm for Drawing Curves, A. Zingl, 2012 http://members.chello.at/easyfilter/Bresenham.pdf Examples >>> from skimage.draw import line_aa >>> img = np.zeros((10, 10), dtype=np.uint8) >>> rr, cc, val = line_aa(1, 1, 8, 8) >>> img[rr, cc] = val * 255 >>> img array([[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [ 0, 255, 74, 0, 0, 0, 0, 0, 0, 0], [ 0, 74, 255, 74, 0, 0, 0, 0, 0, 0], [ 0, 0, 74, 255, 74, 0, 0, 0, 0, 0], [ 0, 0, 0, 74, 255, 74, 0, 0, 0, 0], [ 0, 0, 0, 0, 74, 255, 74, 0, 0, 0], [ 0, 0, 0, 0, 0, 74, 255, 74, 0, 0], [ 0, 0, 0, 0, 0, 0, 74, 255, 74, 0], [ 0, 0, 0, 0, 0, 0, 0, 74, 255, 0], [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8) line_nd skimage.draw.line_nd(start, stop, *, endpoint=False, integer=True) [source] Draw a single-pixel thick line in n dimensions. The line produced will be ndim-connected. That is, two subsequent pixels in the line will be either direct or diagonal neighbours in n dimensions. Parameters startarray-like, shape (N,) The start coordinates of the line. stoparray-like, shape (N,) The end coordinates", "score": "0.6540595"}, {"id": "16645", "text": "Function: skimage.api.skimage.draw#skimage.draw.ellipsoid_stats\nSnippet: skimage.draw.ellipsoid_stats(a, b, c) [source] Calculates analytical surface area and volume for ellipsoid with semimajor axes aligned with grid dimensions of specified spacing. Parameters afloat Length of semimajor axis aligned with x-axis. bfloat Length of semimajor axis aligned with y-axis. cfloat Length of semimajor axis aligned with z-axis. Returns volfloat Calculated volume of ellipsoid. surffloat Calculated surface area of ellipsoid.", "score": "0.6419053"}, {"id": "25627", "text": "Function: python.library.turtle#turtle.dot\nSnippet: turtle.dot(size=None, *color) Parameters size – an integer >= 1 (if given) color – a colorstring or a numeric color tuple Draw a circular dot with diameter size, using color. If size is not given, the maximum of pensize+4 and 2*pensize is used. >>> turtle.home() >>> turtle.dot() >>> turtle.fd(50); turtle.dot(20, \"blue\"); turtle.fd(50) >>> turtle.position() (100.00,-0.00) >>> turtle.heading() 0.0", "score": "0.63150287"}, {"id": "13179", "text": "Function: pygame.ref.draw\nSnippet: the given surface. The line has a thickness of one pixel and the endpoints have a height and width of one pixel each. The way a line and it's endpoints are drawn: If both endpoints are equal, only a single pixel is drawn (after rounding floats to nearest integer). Otherwise if the line is not steep (i.e. if the length along the x-axis is greater than the height along the y-axis): For each endpoint: If x, the endpoint's x-coordinate, is a whole number find which pixels would be covered by it and draw them. Otherwise: Calculate the position of the nearest point with a whole number for it's x-coordinate, when extending the line past the endpoint. Find which pixels would be covered and how much by that point. If the endpoint is the left one, multiply the coverage by (1 - the decimal part of x). Otherwise multiply the coverage by the decimal part of x. Then draw those pixels. e.g.: The left endpoint of the line ((1, 1.3), (5, 3)) would cover 70% of the pixel (1, 1) and 30% of the pixel (1, 2) while the right one would cover 100% of the pixel (5, 3). The left endpoint of the line ((1.2, 1.4), (4.6, 3.1)) would cover 56% (i.e. 0.8 * 70%) of the pixel (1, 1) and 24% (i.e. 0.8 * 30%) of the pixel (1, 2) while the right one would cover 42% (i.e. 0.6 * 70%) of the pixel (5, 3) and 18% (i.e. 0.6 * 30%) of the pixel (5, 4) while the right Then for each point between the endpoints, along the line, whose x-coordinate is a whole number: Find which pixels would be covered and how much by that point and draw them. e.g.: The points along the line ((1, 1), (4, 2.5)) would be (2, 1.5) and (3, 2) and would cover 50% of the pixel (2, 1), 50% of the pixel (2, 2) and 100% of the pixel (3, 2). The points along the line ((1.2, 1.4), (4.6, 3.1)) would be (2, 1.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)), (3, 2.3) (covering 70% of the pixel (3, 2) and 30% of the pixel (3, 3)) and (4, 2.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)) Otherwise do the same for steep lines as for non-steep lines except along the y-axis instead of the x-axis (using y instead of x, top instead of left and bottom instead of right). Note Regarding float values for coordinates, a point with coordinate consisting of two whole numbers is considered being right in the center of said pixel (and having a height and width of 1 pixel would therefore completely cover it), while a point with coordinate where one (or both) of the numbers have non-zero decimal parts would be partially covering two (or four if both numbers have decimal parts) adjacent pixels, e.g. the point (1.4, 2) covers", "score": "0.63007385"}]}
{"task_id": "mbpp_234", "code": "def volume_cube(l):\r\n  volume = l * l * l\r\n  return volume", "test_list": ["assert volume_cube(3)==27", "assert volume_cube(2)==8", "assert volume_cube(5)==125"], "context": "Write a function to find the volume of a cube.", "function_name": "def volume_cube(l):", "gold_generation": "volume = l * l * l\r\n  return volume", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.63437057"}, {"id": "32543", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.axes3d.axes3d#mpl_toolkits.mplot3d.axes3d.Axes3D.unit_cube\nSnippet: unit_cube(vals=None)[source]", "score": "0.6275803"}, {"id": "32541", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.axes3d.axes3d#mpl_toolkits.mplot3d.axes3d.Axes3D.tunit_cube\nSnippet: tunit_cube(vals=None, M=None)[source]", "score": "0.62333715"}, {"id": "42994", "text": "Function: numpy.reference.arrays.scalars#numpy.longcomplex\nSnippet: numpy.longcomplex[source] alias of numpy.clongdouble", "score": "0.61403084"}, {"id": "17020", "text": "Function: skimage.api.skimage.measure#skimage.measure.marching_cubes_classic\nSnippet: skimage.measure.marching_cubes_classic(volume, level=None, spacing=(1.0, 1.0, 1.0), gradient_direction='descent') [source] Classic marching cubes algorithm to find surfaces in 3d volumetric data. Note that the marching_cubes() algorithm is recommended over this algorithm, because it’s faster and produces better results. Parameters volume(M, N, P) array of doubles Input data volume to find isosurfaces. Will be cast to np.float64. levelfloat Contour value to search for isosurfaces in volume. If not given or None, the average of the min and max of vol is used. spacinglength-3 tuple of floats Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in volume. gradient_directionstring Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object Returns verts(V, 3) array Spatial coordinates for V unique mesh vertices. Coordinate order matches input volume (M, N, P). If allow_degenerate is set to True, then the presence of degenerate triangles in the mesh can make this array have duplicate vertices. faces(F, 3) array Define triangular faces via referencing vertex indices from verts. This algorithm specifically outputs triangles, so each face has exactly three indices. See also skimage.measure.marching_cubes skimage.measure.mesh_surface_area Notes The marching cubes algorithm is implemented as described in [1]. A simple explanation is available here: http://users.polytech.unice.fr/~lingrand/MarchingCubes/algo.html There are several known ambiguous cases in the marching cubes algorithm. Using point labeling as in [1], Figure 4, as shown: v8 ------ v7 / | / | y / | / | ^ z v4 ------ v3 | | / | v5 ----|- v6 |/ (note: NOT right handed!) | / | / ----> x | / | / v1 ------ v2 Most notably, if v4, v8, v2, and v6 are all >= level (or any generalization of this case) two parallel planes are generated by this algorithm, separating v4 and v8 from v2 and v6. An equally valid interpretation would be a single connected thin surface enclosing all four points. This is the best known ambiguity, though there are others. This algorithm does not attempt to resolve such ambiguities; it is a naive implementation of marching cubes as in [1], but may be a good beginning for work with more recent techniques (Dual Marching Cubes, Extended Marching Cubes, Cubic Marching Squares, etc.). Because of interactions between neighboring cubes, the isosurface(s) generated by this algorithm are NOT guaranteed to be closed, particularly for complicated contours. Furthermore, this algorithm does not guarantee a single contour will be returned. Indeed, ALL isosurfaces which cross level will be found, regardless of connectivity. The output is a triangular mesh consisting of a set of unique vertices and connecting triangles. The order of these vertices and triangles in the output list is determined by the position of the smallest x,y,z (in lexicographical order) coordinate in the contour. This is a side-effect of how the input array is traversed, but can be relied upon. The generated mesh", "score": "0.6135027"}]}
{"task_id": "mbpp_235", "code": "def even_bit_set_number(n): \r\n    count = 0;res = 0;temp = n \r\n    while(temp > 0): \r\n        if (count % 2 == 1): \r\n            res |= (1 << count)\r\n        count+=1\r\n        temp >>= 1\r\n    return (n | res) ", "test_list": ["assert even_bit_set_number(10) == 10", "assert even_bit_set_number(20) == 30", "assert even_bit_set_number(30) == 30"], "context": "Write a python function to set all even bits of a given number.", "function_name": "def even_bit_set_number(n):", "gold_generation": "count = 0;res = 0;temp = n \r\n    while(temp > 0): \r\n        if (count % 2 == 1): \r\n            res |= (1 << count)\r\n        count+=1\r\n        temp >>= 1\r\n    return (n | res)", "ctxs": [{"id": "19597", "text": "Function: python.library.decimal#decimal.ROUND_HALF_EVEN\nSnippet: decimal.ROUND_HALF_EVEN Round to nearest with ties going to nearest even integer.", "score": "0.70976293"}, {"id": "25732", "text": "Function: python.library.stdtypes\nSnippet: there were an infinite number of sign bits. Additional Methods on Integer Types The int type implements the numbers.Integral abstract base class. In addition, it provides a few more methods: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1. int.to_bytes(length, byteorder, *, signed=False) Return an array of bytes representing an integer. >>> (1024).to_bytes(2, byteorder='big') b'\\x04\\x00' >>> (1024).to_bytes(10, byteorder='big') b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00' >>> (-1024).to_bytes(10, byteorder='big', signed=True) b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00' >>> x = 1000 >>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little') b'\\xe8\\x03' The integer is represented using length bytes. An OverflowError is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument determines whether two’s complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. The default value for signed is False. New in version 3.2. classmethod int.from_bytes(bytes, byteorder, *, signed=False) Return the integer represented by the given array of bytes. >>> int.from_bytes(b'\\x00\\x10', byteorder='big') 16 >>> int.from_bytes(b'\\x00\\x10', byteorder='little') 4096 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True) -1024 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False) 64512 >>> int.from_bytes([255, 0, 0], byteorder='big') 16711680 The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. New in version 3.2. int.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original integer and with a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. New in version 3.8. Additional Methods on Float The float type implements the numbers.Real abstract base class. float also has the following additional methods. float.as_integer_ratio() Return a pair of integers whose", "score": "0.68153495"}, {"id": "21071", "text": "Function: python.library.stdtypes#int.bit_length\nSnippet: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1.", "score": "0.68061674"}, {"id": "23488", "text": "Function: python.library.secrets#secrets.randbits\nSnippet: secrets.randbits(k) Return an int with k random bits.", "score": "0.6735014"}, {"id": "7760", "text": "Function: torch.tensors#torch.Tensor.bitwise_xor_\nSnippet: bitwise_xor_() → Tensor In-place version of bitwise_xor()", "score": "0.6627191"}]}
{"task_id": "mbpp_236", "code": "def No_of_Triangle(N,K):\r\n    if (N < K):\r\n        return -1;\r\n    else:\r\n        Tri_up = 0;\r\n        Tri_up = ((N - K + 1) *(N - K + 2)) // 2;\r\n        Tri_down = 0;\r\n        Tri_down = ((N - 2 * K + 1) *(N - 2 * K + 2)) // 2;\r\n        return Tri_up + Tri_down;", "test_list": ["assert No_of_Triangle(4,2) == 7", "assert No_of_Triangle(4,3) == 3", "assert No_of_Triangle(1,3) == -1"], "context": "Write a python function to count the maximum number of equilateral triangles that can be formed within a given equilateral triangle.", "function_name": "def No_of_Triangle(N,K):", "gold_generation": "if (N < K):\r\n        return -1;\r\n    else:\r\n        Tri_up = 0;\r\n        Tri_up = ((N - K + 1) *(N - K + 2)) // 2;\r\n        Tri_down = 0;\r\n        Tri_down = ((N - 2 * K + 1) *(N - 2 * K + 2)) // 2;\r\n        return Tri_up + Tri_down;", "ctxs": [{"id": "14324", "text": "Function: pandas.reference.api.pandas.dataframe.div\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.67181087"}, {"id": "14480", "text": "Function: pandas.reference.api.pandas.dataframe.rtruediv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6631898"}, {"id": "14476", "text": "Function: pandas.reference.api.pandas.dataframe.rpow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6630753"}, {"id": "14440", "text": "Function: pandas.reference.api.pandas.dataframe.pow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6620331"}, {"id": "18671", "text": "Function: python.library.collections#collections.deque.maxlen\nSnippet: maxlen Maximum size of a deque or None if unbounded. New in version 3.1.", "score": "0.65942484"}]}
{"task_id": "mbpp_237", "code": "from collections import Counter \r\ndef check_occurences(test_list):\r\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\r\n  return  (res) ", "test_list": ["assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] ) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}", "assert check_occurences([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)] ) == {(2, 4): 2, (3, 6): 2, (4, 7): 1}", "assert check_occurences([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)] ) == {(2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1}"], "context": "Write a function to check the occurrences of records which occur similar times in the given tuples.", "function_name": "from collections import Counter \r\ndef check_occurences(test_list):", "gold_generation": "res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\r\n  return  (res)", "ctxs": [{"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6691493"}, {"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.66337025"}, {"id": "21302", "text": "Function: python.library.itertools#itertools.combinations_with_replacement\nSnippet: itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1.", "score": "0.661128"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.660811"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.65837586"}]}
{"task_id": "mbpp_238", "code": "def number_of_substrings(str): \r\n\tstr_len = len(str); \r\n\treturn int(str_len * (str_len + 1) / 2); ", "test_list": ["assert number_of_substrings(\"abc\") == 6", "assert number_of_substrings(\"abcd\") == 10", "assert number_of_substrings(\"abcde\") == 15"], "context": "Write a python function to count number of non-empty substrings of a given string.", "function_name": "def number_of_substrings(str):", "gold_generation": "str_len = len(str); \r\n\treturn int(str_len * (str_len + 1) / 2);", "ctxs": [{"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.7917168"}, {"id": "41643", "text": "Function: numpy.reference.generated.numpy.char.chararray.count\nSnippet: numpy.char.chararray.count method char.chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.75664663"}, {"id": "41768", "text": "Function: numpy.reference.generated.numpy.chararray.count\nSnippet: numpy.chararray.count method chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.7491658"}, {"id": "41718", "text": "Function: numpy.reference.generated.numpy.char.count\nSnippet: numpy.char.count char.count(a, sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. Calls str.count element-wise. Parameters aarray_like of str or unicode substr or unicode The substring to search for. start, endint, optional Optional arguments start and end are interpreted as slice notation to specify the range in which to count. Returns outndarray Output array of ints. See also str.count Examples >>> c = np.array(['aAaAaA', ' aA ', 'abBABba']) >>> c array(['aAaAaA', ' aA ', 'abBABba'], dtype='<U7') >>> np.char.count(c, 'A') array([3, 1, 1]) >>> np.char.count(c, 'aA') array([3, 1, 0]) >>> np.char.count(c, 'A', start=1, end=4) array([2, 1, 1]) >>> np.char.count(c, 'A', start=1, end=3) array([1, 0, 0])", "score": "0.7437534"}, {"id": "18304", "text": "Function: python.library.stdtypes#bytes.count\nSnippet: bytes.count(sub[, start[, end]]) bytearray.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.72483486"}]}
{"task_id": "mbpp_239", "code": "def get_total_number_of_sequences(m,n): \r\n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tif i==0 or j==0: \r\n\t\t\t\tT[i][j]=0\r\n\t\t\telif i<j: \r\n\t\t\t\tT[i][j]=0\r\n\t\t\telif j==1: \r\n\t\t\t\tT[i][j]=i \r\n\t\t\telse: \r\n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \r\n\treturn T[m][n]", "test_list": ["assert get_total_number_of_sequences(10, 4) == 4", "assert get_total_number_of_sequences(5, 2) == 6", "assert get_total_number_of_sequences(16, 3) == 84"], "context": "Write a function to find the number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m.", "function_name": "def get_total_number_of_sequences(m,n):", "gold_generation": "T=[[0 for i in range(n+1)] for i in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tif i==0 or j==0: \r\n\t\t\t\tT[i][j]=0\r\n\t\t\telif i<j: \r\n\t\t\t\tT[i][j]=0\r\n\t\t\telif j==1: \r\n\t\t\t\tT[i][j]=i \r\n\t\t\telse: \r\n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \r\n\treturn T[m][n]", "ctxs": [{"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.7038739"}, {"id": "19648", "text": "Function: python.library.difflib#difflib.SequenceMatcher.get_matching_blocks\nSnippet: get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]", "score": "0.6818205"}, {"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.68118083"}, {"id": "19651", "text": "Function: python.library.difflib#difflib.SequenceMatcher.ratio\nSnippet: ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5", "score": "0.67951477"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6770902"}]}
{"task_id": "mbpp_240", "code": "def replace_list(list1,list2):\r\n list1[-1:] = list2\r\n replace_list=list1\r\n return replace_list\r\n", "test_list": ["assert replace_list([1, 3, 5, 7, 9, 10],[2, 4, 6, 8])==[1, 3, 5, 7, 9, 2, 4, 6, 8]", "assert replace_list([1,2,3,4,5],[5,6,7,8])==[1,2,3,4,5,6,7,8]", "assert replace_list([\"red\",\"blue\",\"green\"],[\"yellow\"])==[\"red\",\"blue\",\"yellow\"]"], "context": "Write a function to replace the last element of the list with another list.", "function_name": "def replace_list(list1,list2):", "gold_generation": "list1[-1:] = list2\r\n replace_list=list1\r\n return replace_list", "ctxs": [{"id": "41683", "text": "Function: numpy.reference.generated.numpy.char.chararray.replace\nSnippet: numpy.char.chararray.replace method char.chararray.replace(old, new, count=None)[source] For each element in self, return a copy of the string with all occurrences of substring old replaced by new. See also char.replace", "score": "0.67792535"}, {"id": "15759", "text": "Function: pandas.reference.api.pandas.tseries.offsets.byearend.copy\nSnippet: pandas.tseries.offsets.BYearEnd.copy BYearEnd.copy()", "score": "0.6722086"}, {"id": "41805", "text": "Function: numpy.reference.generated.numpy.chararray.replace\nSnippet: numpy.chararray.replace method chararray.replace(old, new, count=None)[source] For each element in self, return a copy of the string with all occurrences of substring old replaced by new. See also char.replace", "score": "0.67061645"}, {"id": "25738", "text": "Function: python.library.stdtypes\nSnippet: from s (2) s.remove(x) remove the first item from s where s[i] is equal to x (3) s.reverse() reverses the items of s in place (4) Notes: t must have the same length as the slice it is replacing. The optional argument i defaults to -1, so that by default the last item is removed and returned. remove() raises ValueError when x is not found in s. The reverse() method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence. clear() and copy() are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as dict and set). copy() is not part of the collections.abc.MutableSequence ABC, but most concrete mutable sequence classes provide it. New in version 3.3: clear() and copy() methods. The value n is an integer, or an object implementing __index__(). Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for s * n under Common Sequence Operations. Lists Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). class list([iterable]) Lists may be constructed in several ways: Using a pair of square brackets to denote the empty list: [] Using square brackets, separating items with commas: [a], [a, b, c] Using a list comprehension: [x for x in iterable] Using the type constructor: list() or list(iterable) The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to iterable[:]. For example, list('abc') returns ['a', 'b', 'c'] and list( (1, 2, 3) ) returns [1, 2, 3]. If no argument is given, the constructor creates a new empty list, []. Many other operations also produce lists, including the sorted() built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is", "score": "0.6666848"}, {"id": "21302", "text": "Function: python.library.itertools#itertools.combinations_with_replacement\nSnippet: itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1.", "score": "0.66168505"}]}
{"task_id": "mbpp_241", "code": "def array_3d(m,n,o):\r\n array_3d = [[ ['*' for col in range(m)] for col in range(n)] for row in range(o)]\r\n return array_3d", "test_list": ["assert array_3d(6,4,3)==[[['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']]]", "assert array_3d(5,3,4)==[[['*', '*', '*', '*', '*'], ['*', '*', '*', '*','*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'],['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']]]", "assert array_3d(1,2,3)==[[['*'],['*']],[['*'],['*']],[['*'],['*']]]"], "context": "Write a function to generate a 3d array having each element as '*'.", "function_name": "def array_3d(m,n,o):", "gold_generation": "array_3d = [[ ['*' for col in range(m)] for col in range(n)] for row in range(o)]\r\n return array_3d", "ctxs": [{"id": "43079", "text": "Function: numpy.reference.generated.numpy.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.70227075"}, {"id": "43147", "text": "Function: numpy.reference.generated.numpy.recarray\nSnippet: Peak to peak (maximum - minimum) value along a given axis. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. reshape(shape[, order]) Returns an array containing the same data with a new shape. resize(new_shape[, refcheck]) Change shape and size of array in-place. round([decimals, out]) Return a with each element rounded to the given number of decimals. searchsorted(v[, side, sorter]) Find indices where elements of v should be inserted in a to maintain order. setfield(val, dtype[, offset]) Put a value into a specified place in a field defined by a data-type. setflags([write, align, uic]) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. sort([axis, kind, order]) Sort an array in-place. squeeze([axis]) Remove axes of length one from a. std([axis, dtype, out, ddof, keepdims, where]) Returns the standard deviation of the array elements along given axis. sum([axis, dtype, out, keepdims, initial, where]) Return the sum of the array elements over the given axis. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. tobytes([order]) Construct Python bytes containing the raw data bytes in the array. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. trace([offset, axis1, axis2, dtype, out]) Return the sum along diagonals of the array. transpose(*axes) Returns a view of the array with axes transposed. var([axis, dtype, out, ddof, keepdims, where]) Returns the variance of the array elements, along given axis. view([dtype][, type]) New view of array with the same data. dot field", "score": "0.695418"}, {"id": "43054", "text": "Function: numpy.reference.generated.numpy.ndarray\nSnippet: array elements over the given axis. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. tobytes([order]) Construct Python bytes containing the raw data bytes in the array. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. trace([offset, axis1, axis2, dtype, out]) Return the sum along diagonals of the array. transpose(*axes) Returns a view of the array with axes transposed. var([axis, dtype, out, ddof, keepdims, where]) Returns the variance of the array elements, along given axis. view([dtype][, type]) New view of array with the same data. dot", "score": "0.68327665"}, {"id": "42691", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: same data with a new shape. resize(new_shape[, refcheck]) Change shape and size of array in-place. rfind(sub[, start, end]) For each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. rindex(sub[, start, end]) Like rfind, but raises ValueError when the substring sub is not found. rjust(width[, fillchar]) Return an array with the elements of self right-justified in a string of length width. rsplit([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. rstrip([chars]) For each element in self, return a copy with the trailing characters removed. searchsorted(v[, side, sorter]) Find indices where elements of v should be inserted in a to maintain order. setfield(val, dtype[, offset]) Put a value into a specified place in a field defined by a data-type. setflags([write, align, uic]) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. sort([axis, kind, order]) Sort an array in-place. split([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. splitlines([keepends]) For each element in self, return a list of the lines in the element, breaking at line boundaries. squeeze([axis]) Remove axes of length one from a. startswith(prefix[, start, end]) Returns a boolean array which is True where the string element in self starts with prefix, otherwise False. strip([chars]) For each element in self, return a copy with the leading and trailing characters removed. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. swapcase() For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. title() For each element in self, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. translate(table[, deletechars]) For each element in self, return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table. transpose(*axes) Returns a view of the array with axes transposed. upper() Return an array with the elements of self converted to uppercase. view([dtype][, type]) New view of array with the same data. zfill(width) Return the numeric string left-filled with zeros in a string of length width.", "score": "0.6786754"}, {"id": "42688", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: same data with a new shape. resize(new_shape[, refcheck]) Change shape and size of array in-place. rfind(sub[, start, end]) For each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. rindex(sub[, start, end]) Like rfind, but raises ValueError when the substring sub is not found. rjust(width[, fillchar]) Return an array with the elements of self right-justified in a string of length width. rsplit([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. rstrip([chars]) For each element in self, return a copy with the trailing characters removed. searchsorted(v[, side, sorter]) Find indices where elements of v should be inserted in a to maintain order. setfield(val, dtype[, offset]) Put a value into a specified place in a field defined by a data-type. setflags([write, align, uic]) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. sort([axis, kind, order]) Sort an array in-place. split([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. splitlines([keepends]) For each element in self, return a list of the lines in the element, breaking at line boundaries. squeeze([axis]) Remove axes of length one from a. startswith(prefix[, start, end]) Returns a boolean array which is True where the string element in self starts with prefix, otherwise False. strip([chars]) For each element in self, return a copy with the leading and trailing characters removed. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. swapcase() For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. title() For each element in self, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. translate(table[, deletechars]) For each element in self, return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table. transpose(*axes) Returns a view of the array with axes transposed. upper() Return an array with the elements of self converted to uppercase. view([dtype][, type]) New view of array with the same data. zfill(width) Return the numeric string left-filled with zeros in a string of length width.", "score": "0.67703754"}]}
{"task_id": "mbpp_242", "code": "def count_charac(str1):\r\n total = 0\r\n for i in str1:\r\n    total = total + 1\r\n return total", "test_list": ["assert count_charac(\"python programming\")==18", "assert count_charac(\"language\")==8", "assert count_charac(\"words\")==5"], "context": "Write a function to count total characters in a string.", "function_name": "def count_charac(str1):", "gold_generation": "total = 0\r\n for i in str1:\r\n    total = total + 1\r\n return total", "ctxs": [{"id": "21151", "text": "Function: python.library.io#io.TextIOBase.write\nSnippet: write(s) Write the string s to the stream and return the number of characters written.", "score": "0.7348317"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.7091968"}, {"id": "41718", "text": "Function: numpy.reference.generated.numpy.char.count\nSnippet: numpy.char.count char.count(a, sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. Calls str.count element-wise. Parameters aarray_like of str or unicode substr or unicode The substring to search for. start, endint, optional Optional arguments start and end are interpreted as slice notation to specify the range in which to count. Returns outndarray Output array of ints. See also str.count Examples >>> c = np.array(['aAaAaA', ' aA ', 'abBABba']) >>> c array(['aAaAaA', ' aA ', 'abBABba'], dtype='<U7') >>> np.char.count(c, 'A') array([3, 1, 1]) >>> np.char.count(c, 'aA') array([3, 1, 0]) >>> np.char.count(c, 'A', start=1, end=4) array([2, 1, 1]) >>> np.char.count(c, 'A', start=1, end=3) array([1, 0, 0])", "score": "0.68997383"}, {"id": "41643", "text": "Function: numpy.reference.generated.numpy.char.chararray.count\nSnippet: numpy.char.chararray.count method char.chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.68457085"}, {"id": "25743", "text": "Function: python.library.stdtypes\nSnippet: on). To expand the string, the current column is set to zero and the string is examined character by character. If the character is a tab (\\t), one or more space characters are inserted in the result until the current column is equal to the next tab position. (The tab character itself is not copied.) If the character is a newline (\\n) or return (\\r), it is copied and the current column is reset to zero. Any other character is copied unchanged and the current column is incremented by one regardless of how the character is represented when printed. >>> '01\\t012\\t0123\\t01234'.expandtabs() '01 012 0123 01234' >>> '01\\t012\\t0123\\t01234'.expandtabs(4) '01 012 0123 01234' str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True str.format(*args, **kwargs) Perform a string formatting operation. The string on which this method is called can contain literal text or replacement fields delimited by braces {}. Each replacement field contains either the numeric index of a positional argument, or the name of a keyword argument. Returns a copy of the string where each replacement field is replaced with the string value of the corresponding argument. >>> \"The sum of 1 + 2 is {0}\".format(1+2) 'The sum of 1 + 2 is 3' See Format String Syntax for a description of the various formatting options that can be specified in format strings. Note When formatting a number (int, float, complex, decimal.Decimal and subclasses) with the n type (ex: '{:n}'.format(1234)), the function temporarily sets the LC_CTYPE locale to the LC_NUMERIC locale to decode decimal_point and thousands_sep fields of localeconv() if they are non-ASCII or longer than 1 byte, and the LC_NUMERIC locale is different than the LC_CTYPE locale. This temporary change affects other threads. Changed in version 3.7: When formatting a number with the n type, the function sets temporarily the LC_CTYPE locale to the LC_NUMERIC locale in some cases. str.format_map(mapping) Similar to str.format(**mapping), except that mapping is used directly and not copied to a dict. This is useful if for example mapping is a dict subclass: >>> class Default(dict): ... def __missing__(self, key): ... return key ... >>> '{name} was born in {country}'.format_map(Default(name='Guido')) 'Guido was born in country' New in version 3.2. str.index(sub[, start[, end]]) Like find(), but raise ValueError when the substring is not found. str.isalnum() Return True if all characters in the string are alphanumeric and there is at least one character, False otherwise. A character c is alphanumeric if one of the following returns True: c.isalpha(), c.isdecimal(), c.isdigit(), or c.isnumeric(). str.isalpha() Return True if all characters in the string are alphabetic and there is at least one character, False otherwise. Alphabetic characters are those characters", "score": "0.681314"}]}
{"task_id": "mbpp_243", "code": "def sort_on_occurence(lst): \r\n\tdct = {} \r\n\tfor i, j in lst: \r\n\t\tdct.setdefault(i, []).append(j) \r\n\treturn ([(i, *dict.fromkeys(j), len(j)) \r\n\t\t\t\tfor i, j in dct.items()]) ", "test_list": ["assert sort_on_occurence([(1, 'Jake'), (2, 'Bob'), (1, 'Cara')]) == [(1, 'Jake', 'Cara', 2), (2, 'Bob', 1)]", "assert sort_on_occurence([('b', 'ball'), ('a', 'arm'), ('b', 'b'), ('a', 'ant')]) == [('b', 'ball', 'b', 2), ('a', 'arm', 'ant', 2)]", "assert sort_on_occurence([(2, 'Mark'), (3, 'Maze'), (2, 'Sara')]) == [(2, 'Mark', 'Sara', 2), (3, 'Maze', 1)]"], "context": "Write a function to sort the given list based on the occurrence of first element of tuples.", "function_name": "def sort_on_occurence(lst):", "gold_generation": "dct = {} \r\n\tfor i, j in lst: \r\n\t\tdct.setdefault(i, []).append(j) \r\n\treturn ([(i, *dict.fromkeys(j), len(j)) \r\n\t\t\t\tfor i, j in dct.items()])", "ctxs": [{"id": "25739", "text": "Function: python.library.stdtypes\nSnippet: a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort. Tuples Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a set or dict instance). class tuple([iterable]) Tuples may be constructed in a number of ways: Using a pair of parentheses to denote the empty tuple: () Using a trailing comma for a singleton tuple: a, or (a,) Separating items with commas: a, b, c or (a, b, c) Using the tuple() built-in: tuple() or tuple(iterable) The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, tuple('abc') returns ('a', 'b', 'c') and tuple( [1, 2, 3] ) returns (1, 2, 3). If no argument is given, the constructor creates a new empty tuple, (). Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, f(a, b, c) is a function call with three arguments, while f((a, b, c)) is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, collections.namedtuple() may be a more appropriate choice than a simple tuple object. Ranges The range type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops. class range(stop) class range(start, stop[, step]) The arguments to the range constructor must be integers (either built-in int or any object that implements the __index__ special method). If the step argument is omitted, it defaults to 1. If the start argument is", "score": "0.7172728"}, {"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.6965023"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6947259"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6865034"}, {"id": "21301", "text": "Function: python.library.itertools#itertools.combinations\nSnippet: itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6834528"}]}
{"task_id": "mbpp_244", "code": "import math  \r\ndef next_Perfect_Square(N): \r\n    nextN = math.floor(math.sqrt(N)) + 1\r\n    return nextN * nextN ", "test_list": ["assert next_Perfect_Square(35) == 36", "assert next_Perfect_Square(6) == 9", "assert next_Perfect_Square(9) == 16"], "context": "Write a python function to find the next perfect square greater than a given number.", "function_name": "import math  \r\ndef next_Perfect_Square(N):", "gold_generation": "nextN = math.floor(math.sqrt(N)) + 1\r\n    return nextN * nextN", "ctxs": [{"id": "21822", "text": "Function: python.library.math#math.nextafter\nSnippet: math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9.", "score": "0.725129"}, {"id": "19497", "text": "Function: python.library.decimal#decimal.Context.next_plus\nSnippet: next_plus(x) Returns the smallest representable number larger than x.", "score": "0.71803635"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.70500046"}, {"id": "19496", "text": "Function: python.library.decimal#decimal.Context.next_minus\nSnippet: next_minus(x) Returns the largest representable number smaller than x.", "score": "0.6897189"}, {"id": "19559", "text": "Function: python.library.decimal#decimal.Decimal.next_plus\nSnippet: next_plus(context=None) Return the smallest number representable in the given context (or in the current thread’s context if no context is given) that is larger than the given operand.", "score": "0.6896819"}]}
{"task_id": "mbpp_245", "code": "def max_sum(arr, n): \r\n\tMSIBS = arr[:] \r\n\tfor i in range(n): \r\n\t\tfor j in range(0, i): \r\n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \r\n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \r\n\tMSDBS = arr[:] \r\n\tfor i in range(1, n + 1): \r\n\t\tfor j in range(1, i): \r\n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \r\n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \r\n\tmax_sum = float(\"-Inf\") \r\n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \r\n\t\tmax_sum = max(max_sum, i + j - k) \r\n\treturn max_sum", "test_list": ["assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9], 9) == 194", "assert max_sum([80, 60, 30, 40, 20, 10], 6) == 210", "assert max_sum([2, 3 ,14, 16, 21, 23, 29, 30], 8) == 138"], "context": "Write a function to find the maximum sum of bi-tonic sub-sequence for the given array.", "function_name": "def max_sum(arr, n):", "gold_generation": "MSIBS = arr[:] \r\n\tfor i in range(n): \r\n\t\tfor j in range(0, i): \r\n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \r\n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \r\n\tMSDBS = arr[:] \r\n\tfor i in range(1, n + 1): \r\n\t\tfor j in range(1, i): \r\n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \r\n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \r\n\tmax_sum = float(\"-Inf\") \r\n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \r\n\t\tmax_sum = max(max_sum, i + j - k) \r\n\treturn max_sum", "ctxs": [{"id": "42808", "text": "Function: numpy.reference.generated.numpy.einsum_path\nSnippet: numpy.einsum_path numpy.einsum_path(subscripts, *operands, optimize='greedy')[source] Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays. Parameters subscriptsstr Specifies the subscripts for summation. *operandslist of array_like These are the arrays for the operation. optimize{bool, list, tuple, ‘greedy’, ‘optimal’} Choose the type of path. If a tuple is provided, the second argument is assumed to be the maximum intermediate size created. If only a single argument is provided the largest input or output array size is used as a maximum intermediate size. if a list is given that starts with einsum_path, uses this as the contraction path if False no optimization is taken if True defaults to the ‘greedy’ algorithm ‘optimal’ An algorithm that combinatorially explores all possible ways of contracting the listed tensors and choosest the least costly path. Scales exponentially with the number of terms in the contraction. ‘greedy’ An algorithm that chooses the best pair contraction at each step. Effectively, this algorithm searches the largest inner, Hadamard, and then outer products at each step. Scales cubically with the number of terms in the contraction. Equivalent to the ‘optimal’ path for most contractions. Default is ‘greedy’. Returns pathlist of tuples A list representation of the einsum path. string_reprstr A printable representation of the einsum path. See also einsum, linalg.multi_dot Notes The resulting path indicates which terms of the input contraction should be contracted first, the result of this contraction is then appended to the end of the contraction list. This list can then be iterated over until all intermediate contractions are complete. Examples We can begin with a chain dot example. In this case, it is optimal to contract the b and c tensors first as represented by the first element of the path (1, 2). The resulting tensor is added to the end of the contraction and the remaining contraction (0, 1) is then completed. >>> np.random.seed(123) >>> a = np.random.rand(2, 2) >>> b = np.random.rand(2, 5) >>> c = np.random.rand(5, 2) >>> path_info = np.einsum_path('ij,jk,kl->il', a, b, c, optimize='greedy') >>> print(path_info[0]) ['einsum_path', (1, 2), (0, 1)] >>> print(path_info[1]) Complete contraction: ij,jk,kl->il # may vary Naive scaling: 4 Optimized scaling: 3 Naive FLOP count: 1.600e+02 Optimized FLOP count: 5.600e+01 Theoretical speedup: 2.857 Largest intermediate: 4.000e+00 elements ------------------------------------------------------------------------- scaling current remaining ------------------------------------------------------------------------- 3 kl,jk->jl ij,jl->il 3 jl,ij->il il->il A more complex index transformation example. >>> I = np.random.rand(10, 10, 10, 10) >>> C = np.random.rand(10, 10) >>> path_info = np.einsum_path('ea,fb,abcd,gc,hd->efgh', C, C, I, C, C, ... optimize='greedy') >>> print(path_info[0]) ['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)] >>> print(path_info[1]) Complete contraction: ea,fb,abcd,gc,hd->efgh # may vary Naive scaling: 8 Optimized scaling: 5 Naive FLOP count: 8.000e+08 Optimized FLOP count: 8.000e+05 Theoretical speedup: 1000.000 Largest intermediate: 1.000e+04 elements -------------------------------------------------------------------------- scaling current remaining -------------------------------------------------------------------------- 5 abcd,ea->bcde fb,gc,hd,bcde->efgh 5 bcde,fb->cdef gc,hd,cdef->efgh 5 cdef,gc->defg hd,defg->efgh 5 defg,hd->efgh efgh->efgh", "score": "0.67420936"}, {"id": "43147", "text": "Function: numpy.reference.generated.numpy.recarray\nSnippet: Peak to peak (maximum - minimum) value along a given axis. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. reshape(shape[, order]) Returns an array containing the same data with a new shape. resize(new_shape[, refcheck]) Change shape and size of array in-place. round([decimals, out]) Return a with each element rounded to the given number of decimals. searchsorted(v[, side, sorter]) Find indices where elements of v should be inserted in a to maintain order. setfield(val, dtype[, offset]) Put a value into a specified place in a field defined by a data-type. setflags([write, align, uic]) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. sort([axis, kind, order]) Sort an array in-place. squeeze([axis]) Remove axes of length one from a. std([axis, dtype, out, ddof, keepdims, where]) Returns the standard deviation of the array elements along given axis. sum([axis, dtype, out, keepdims, initial, where]) Return the sum of the array elements over the given axis. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. tobytes([order]) Construct Python bytes containing the raw data bytes in the array. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. trace([offset, axis1, axis2, dtype, out]) Return the sum along diagonals of the array. transpose(*axes) Returns a view of the array with axes transposed. var([axis, dtype, out, ddof, keepdims, where]) Returns the variance of the array elements, along given axis. view([dtype][, type]) New view of array with the same data. dot field", "score": "0.6680345"}, {"id": "42807", "text": "Function: numpy.reference.generated.numpy.einsum\nSnippet: 64], [13, 40, 67, 94]]) >>> np.einsum('k...,jk', a, b) array([[10, 28, 46, 64], [13, 40, 67, 94]]) Chained array operations. For more complicated contractions, speed ups might be achieved by repeatedly computing a ‘greedy’ path or pre-computing the ‘optimal’ path and repeatedly applying it, using an einsum_path insertion (since version 1.12.0). Performance improvements can be particularly significant with larger arrays: >>> a = np.ones(64).reshape(2,4,8) Basic einsum: ~1520ms (benchmarked on 3.1GHz Intel i5.) >>> for iteration in range(500): ... _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a) Sub-optimal einsum (due to repeated path calculation time): ~330ms >>> for iteration in range(500): ... _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal') Greedy einsum (faster optimal path approximation): ~160ms >>> for iteration in range(500): ... _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='greedy') Optimal einsum (best usage pattern in some use cases): ~110ms >>> path = np.einsum_path('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')[0] >>> for iteration in range(500): ... _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize=path)", "score": "0.665732"}, {"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.66339374"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6549205"}]}
{"task_id": "mbpp_246", "code": "def babylonian_squareroot(number):\r\n    if(number == 0):\r\n        return 0;\r\n    g = number/2.0;\r\n    g2 = g + 1;\r\n    while(g != g2):\r\n        n = number/ g;\r\n        g2 = g;\r\n        g = (g + n)/2;\r\n    return g;", "test_list": ["assert babylonian_squareroot(10)==3.162277660168379", "assert babylonian_squareroot(2)==1.414213562373095", "assert babylonian_squareroot(9)==3.0"], "context": "Write a function for computing square roots using the babylonian method.", "function_name": "def babylonian_squareroot(number):", "gold_generation": "if(number == 0):\r\n        return 0;\r\n    g = number/2.0;\r\n    g2 = g + 1;\r\n    while(g != g2):\r\n        n = number/ g;\r\n        g2 = g;\r\n        g = (g + n)/2;\r\n    return g;", "ctxs": [{"id": "21831", "text": "Function: python.library.math#math.sqrt\nSnippet: math.sqrt(x) Return the square root of x.", "score": "0.7104584"}, {"id": "21777", "text": "Function: python.library.math\nSnippet: Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers. math.sqrt(x) Return the square root of x. Trigonometric functions math.acos(x) Return the arc cosine of x, in radians. The result is between 0 and pi. math.asin(x) Return the arc sine of x, in radians. The result is between -pi/2 and pi/2. math.atan(x) Return the arc tangent of x, in radians. The result is between -pi/2 and pi/2. math.atan2(y, x) Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4. math.cos(x) Return the cosine of x radians. math.dist(p, q) Return the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Roughly equivalent to: sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q))) New in version 3.8. math.hypot(*coordinates) Return the Euclidean norm, sqrt(sum(x**2 for x in coordinates)). This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point (x, y), this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, sqrt(x*x + y*y). Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. math.sin(x) Return the sine of x radians. math.tan(x) Return the tangent of x radians. Angular conversion math.degrees(x) Convert angle x from radians to degrees. math.radians(x) Convert angle x from degrees to radians. Hyperbolic functions Hyperbolic functions are analogs of trigonometric functions that are based on hyperbolas instead of circles. math.acosh(x) Return the inverse hyperbolic cosine of x. math.asinh(x) Return the inverse hyperbolic sine of x. math.atanh(x) Return the inverse hyperbolic tangent of x. math.cosh(x) Return the hyperbolic cosine of x. math.sinh(x) Return the hyperbolic sine of x. math.tanh(x) Return the hyperbolic tangent of x. Special functions math.erf(x) Return the error function at x. The erf() function can be used to compute traditional statistical functions such as the cumulative standard normal distribution: def phi(x): 'Cumulative distribution function for the standard normal distribution' return (1.0 + erf(x / sqrt(2.0))) / 2.0 New in version 3.2. math.erfc(x) Return the complementary error function at x. The complementary error function is defined as 1.0 - erf(x). It is used for large values of x where a subtraction from one would cause a loss of significance. New in version 3.2. math.gamma(x) Return the Gamma function at x. New in version 3.2. math.lgamma(x) Return the natural logarithm of the absolute value of the Gamma function at x. New in version 3.2. Constants math.pi The mathematical constant π =", "score": "0.7092178"}, {"id": "42053", "text": "Function: numpy.reference.generated.numpy.lib.scimath.sqrt\nSnippet: numpy.lib.scimath.sqrt lib.scimath.sqrt(x)[source] Compute the square root of x. For negative input elements, a complex value is returned (unlike numpy.sqrt which returns NaN). Parameters xarray_like The input value(s). Returns outndarray or scalar The square root of x. If x was a scalar, so is out, otherwise an array is returned. See also numpy.sqrt Examples For real, non-negative inputs this works just like numpy.sqrt: >>> np.emath.sqrt(1) 1.0 >>> np.emath.sqrt([1, 4]) array([1., 2.]) But it automatically handles negative inputs: >>> np.emath.sqrt(-1) 1j >>> np.emath.sqrt([-1,4]) array([0.+1.j, 2.+0.j])", "score": "0.69536185"}, {"id": "18484", "text": "Function: python.library.cmath#cmath.sqrt\nSnippet: cmath.sqrt(x) Return the square root of x. This has the same branch cut as log().", "score": "0.68780464"}, {"id": "19570", "text": "Function: python.library.decimal#decimal.Decimal.sqrt\nSnippet: sqrt(context=None) Return the square root of the argument to full precision.", "score": "0.6847911"}]}
{"task_id": "mbpp_247", "code": "def lps(str): \r\n\tn = len(str) \r\n\tL = [[0 for x in range(n)] for x in range(n)] \r\n\tfor i in range(n): \r\n\t\tL[i][i] = 1\r\n\tfor cl in range(2, n+1): \r\n\t\tfor i in range(n-cl+1): \r\n\t\t\tj = i+cl-1\r\n\t\t\tif str[i] == str[j] and cl == 2: \r\n\t\t\t\tL[i][j] = 2\r\n\t\t\telif str[i] == str[j]: \r\n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\r\n\t\t\telse: \r\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \r\n\treturn L[0][n-1]", "test_list": ["assert lps(\"TENS FOR TENS\") == 5 ", "assert lps(\"CARDIO FOR CARDS\") == 7", "assert lps(\"PART OF THE JOURNEY IS PART\") == 9 "], "context": "Write a function to find the longest palindromic subsequence in the given string.", "function_name": "def lps(str):", "gold_generation": "n = len(str) \r\n\tL = [[0 for x in range(n)] for x in range(n)] \r\n\tfor i in range(n): \r\n\t\tL[i][i] = 1\r\n\tfor cl in range(2, n+1): \r\n\t\tfor i in range(n-cl+1): \r\n\t\t\tj = i+cl-1\r\n\t\t\tif str[i] == str[j] and cl == 2: \r\n\t\t\t\tL[i][j] = 2\r\n\t\t\telif str[i] == str[j]: \r\n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\r\n\t\t\telse: \r\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \r\n\treturn L[0][n-1]", "ctxs": [{"id": "19646", "text": "Function: python.library.difflib#difflib.SequenceMatcher.find_longest_match\nSnippet: find_longest_match(alo=0, ahi=None, blo=0, bhi=None) Find longest matching block in a[alo:ahi] and b[blo:bhi]. If isjunk was omitted or None, find_longest_match() returns (i, j, k) such that a[i:i+k] is equal to b[j:j+k], where alo <= i <= i+k <= ahi and blo <= j <= j+k <= bhi. For all (i', j', k') meeting those conditions, the additional conditions k >= k', i <= i', and if i == i', j <= j' are also met. In other words, of all maximal matching blocks, return one that starts earliest in a, and of all those maximal matching blocks that start earliest in a, return the one that starts earliest in b. >>> s = SequenceMatcher(None, \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=0, b=4, size=5) If isjunk was provided, first the longest matching block is determined as above, but with the additional restriction that no junk element appears in the block. Then that block is extended as far as possible by matching (only) junk elements on both sides. So the resulting block never matches on junk except as identical junk happens to be adjacent to an interesting match. Here’s the same example as before, but considering blanks to be junk. That prevents ' abcd' from matching the ' abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments.", "score": "0.7107598"}, {"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.6854017"}, {"id": "24346", "text": "Function: python.library.stdtypes#str.find\nSnippet: str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True", "score": "0.68437415"}, {"id": "18308", "text": "Function: python.library.stdtypes#bytes.find\nSnippet: bytes.find(sub[, start[, end]]) bytearray.find(sub[, start[, end]]) Return the lowest index in the data where the subsequence sub is found, such that sub is contained in the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> b'Py' in b'Python' True Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.6798059"}, {"id": "18264", "text": "Function: python.library.stdtypes#bytearray.find\nSnippet: bytes.find(sub[, start[, end]]) bytearray.find(sub[, start[, end]]) Return the lowest index in the data where the subsequence sub is found, such that sub is contained in the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> b'Py' in b'Python' True Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.678045"}]}
{"task_id": "mbpp_248", "code": "def harmonic_sum(n):\r\n  if n < 2:\r\n    return 1\r\n  else:\r\n    return 1 / n + (harmonic_sum(n - 1)) ", "test_list": ["assert harmonic_sum(7) == 2.5928571428571425", "assert harmonic_sum(4) == 2.083333333333333", "assert harmonic_sum(19) == 3.547739657143682"], "context": "Write a function to calculate the harmonic sum of n-1.", "function_name": "def harmonic_sum(n):", "gold_generation": "if n < 2:\r\n    return 1\r\n  else:\r\n    return 1 / n + (harmonic_sum(n - 1))", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6955326"}, {"id": "41966", "text": "Function: numpy.reference.generated.numpy.fft.fft2\nSnippet: +0.j ]])", "score": "0.683802"}, {"id": "24306", "text": "Function: python.library.statistics#statistics.harmonic_mean\nSnippet: statistics.harmonic_mean(data) Return the harmonic mean of data, a sequence or iterable of real-valued numbers. The harmonic mean, sometimes called the subcontrary mean, is the reciprocal of the arithmetic mean() of the reciprocals of the data. For example, the harmonic mean of three values a, b and c will be equivalent to 3/(1/a + 1/b + 1/c). If one of the values is zero, the result will be zero. The harmonic mean is a type of average, a measure of the central location of the data. It is often appropriate when averaging rates or ratios, for example speeds. Suppose a car travels 10 km at 40 km/hr, then another 10 km at 60 km/hr. What is the average speed? >>> harmonic_mean([40, 60]) 48.0 Suppose an investor purchases an equal value of shares in each of three companies, with P/E (price/earning) ratios of 2.5, 3 and 10. What is the average P/E ratio for the investor’s portfolio? >>> harmonic_mean([2.5, 3, 10]) # For an equal investment portfolio. 3.6 StatisticsError is raised if data is empty, or any element is less than zero. The current algorithm has an early-out when it encounters a zero in the input. This means that the subsequent inputs are not tested for validity. (This behavior may change in the future.) New in version 3.6.", "score": "0.66396725"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.65805006"}, {"id": "24297", "text": "Function: python.library.statistics\nSnippet: population mean μ. statistics.fmean(data) Convert data to floats and compute the arithmetic mean. This runs faster than the mean() function and it always returns a float. The data may be a sequence or iterable. If the input dataset is empty, raises a StatisticsError. >>> fmean([3.5, 4.0, 5.25]) 4.25 New in version 3.8. statistics.geometric_mean(data) Convert data to floats and compute the geometric mean. The geometric mean indicates the central tendency or typical value of the data using the product of the values (as opposed to the arithmetic mean which uses their sum). Raises a StatisticsError if the input dataset is empty, if it contains a zero, or if it contains a negative value. The data may be a sequence or iterable. No special efforts are made to achieve exact results. (However, this may change in the future.) >>> round(geometric_mean([54, 24, 36]), 1) 36.0 New in version 3.8. statistics.harmonic_mean(data) Return the harmonic mean of data, a sequence or iterable of real-valued numbers. The harmonic mean, sometimes called the subcontrary mean, is the reciprocal of the arithmetic mean() of the reciprocals of the data. For example, the harmonic mean of three values a, b and c will be equivalent to 3/(1/a + 1/b + 1/c). If one of the values is zero, the result will be zero. The harmonic mean is a type of average, a measure of the central location of the data. It is often appropriate when averaging rates or ratios, for example speeds. Suppose a car travels 10 km at 40 km/hr, then another 10 km at 60 km/hr. What is the average speed? >>> harmonic_mean([40, 60]) 48.0 Suppose an investor purchases an equal value of shares in each of three companies, with P/E (price/earning) ratios of 2.5, 3 and 10. What is the average P/E ratio for the investor’s portfolio? >>> harmonic_mean([2.5, 3, 10]) # For an equal investment portfolio. 3.6 StatisticsError is raised if data is empty, or any element is less than zero. The current algorithm has an early-out when it encounters a zero in the input. This means that the subsequent inputs are not tested for validity. (This behavior may change in the future.) New in version 3.6. statistics.median(data) Return the median (middle value) of numeric data, using the common “mean of middle two” method. If data is empty, StatisticsError is raised. data can be a sequence or iterable. The median is a robust measure of central location and is less affected by the presence of outliers. When the number of data points is odd, the middle data point is returned: >>> median([1, 3, 5]) 3 When the number of data points is even, the median is interpolated by taking the average of the two middle values: >>> median([1, 3, 5, 7]) 4.0 This is suited for when your data is discrete, and you don’t mind that the median may not be an actual data point. If the data is ordinal (supports order operations) but not numeric (doesn’t support addition), consider using median_low() or median_high() instead.", "score": "0.6539333"}]}
{"task_id": "mbpp_249", "code": "def intersection_array(array_nums1,array_nums2):\r\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \r\n return result", "test_list": ["assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[1, 2, 4, 8, 9])==[1, 2, 8, 9]", "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[3,5,7,9])==[3,5,7,9]", "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[10,20,30,40])==[10]"], "context": "Write a function to find the intersection of two arrays using lambda function.", "function_name": "def intersection_array(array_nums1,array_nums2):", "gold_generation": "result = list(filter(lambda x: x in array_nums1, array_nums2)) \r\n return result", "ctxs": [{"id": "42908", "text": "Function: numpy.reference.generated.numpy.intersect1d\nSnippet: numpy.intersect1d numpy.intersect1d(ar1, ar2, assume_unique=False, return_indices=False)[source] Find the intersection of two arrays. Return the sorted, unique values that are in both of the input arrays. Parameters ar1, ar2array_like Input arrays. Will be flattened if not already 1D. assume_uniquebool If True, the input arrays are both assumed to be unique, which can speed up the calculation. If True but ar1 or ar2 are not unique, incorrect results and out-of-bounds indices could result. Default is False. return_indicesbool If True, the indices which correspond to the intersection of the two arrays are returned. The first instance of a value is used if there are multiple. Default is False. New in version 1.15.0. Returns intersect1dndarray Sorted 1D array of common and unique elements. comm1ndarray The indices of the first occurrences of the common values in ar1. Only provided if return_indices is True. comm2ndarray The indices of the first occurrences of the common values in ar2. Only provided if return_indices is True. See also numpy.lib.arraysetops Module with a number of other functions for performing set operations on arrays. Examples >>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1]) array([1, 3]) To intersect more than two arrays, use functools.reduce: >>> from functools import reduce >>> reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2])) array([3]) To return the indices of the values common to the input arrays along with the intersected values: >>> x = np.array([1, 1, 2, 3, 4]) >>> y = np.array([2, 1, 4, 6]) >>> xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True) >>> x_ind, y_ind (array([0, 2, 4]), array([1, 0, 2])) >>> xy, x[x_ind], y[y_ind] (array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))", "score": "0.69295925"}, {"id": "36349", "text": "Function: django.ref.contrib.gis.functions#django.contrib.gis.db.models.functions.Intersection\nSnippet: class Intersection(expr1, expr2, **extra)", "score": "0.68180835"}, {"id": "34138", "text": "Function: matplotlib.transformations#matplotlib.transforms.BboxBase.intersection\nSnippet: staticintersection(bbox1, bbox2)[source] Return the intersection of bbox1 and bbox2 if they intersect, or None if they don't.", "score": "0.67482406"}, {"id": "20222", "text": "Function: python.library.stdtypes#frozenset.intersection\nSnippet: intersection(*others) set & other & ... Return a new set with elements common to the set and all others.", "score": "0.67472637"}, {"id": "36531", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.OGRGeometry.intersection\nSnippet: intersection()", "score": "0.6744113"}]}
{"task_id": "mbpp_250", "code": "def count_X(tup, x): \r\n    count = 0\r\n    for ele in tup: \r\n        if (ele == x): \r\n            count = count + 1\r\n    return count ", "test_list": ["assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),4) == 0", "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),10) == 3", "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),8) == 4"], "context": "Write a python function to count the occcurences of an element in a tuple.", "function_name": "def count_X(tup, x):", "gold_generation": "count = 0\r\n    for ele in tup: \r\n        if (ele == x): \r\n            count = count + 1\r\n    return count", "ctxs": [{"id": "22306", "text": "Function: python.library.operator#operator.countOf\nSnippet: operator.countOf(a, b) Return the number of occurrences of b in a.", "score": "0.7429035"}, {"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.7161802"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.71103203"}, {"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.6966585"}, {"id": "18611", "text": "Function: python.library.collections\nSnippet: Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6}) New in version 3.2. The usual dictionary methods are available for Counter objects except for two which work differently for counters. fromkeys(iterable) This class method is not implemented for Counter objects. update([iterable-or-mapping]) Elements are counted from an iterable or added-in from another mapping (or counter). Like dict.update() but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of (key, value) pairs. Common patterns for working with Counter objects: sum(c.values()) # total of all counts c.clear() # reset all counts list(c) # list unique elements set(c) # convert to a set dict(c) # convert to a regular dictionary c.items() # convert to a list of (elem, cnt) pairs Counter(dict(list_of_pairs)) # convert from a list of (elem, cnt) pairs c.most_common()[:-n-1:-1] # n least common elements +c # remove zero and negative counts Several mathematical operations are provided for combining Counter objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. Intersection and union return the minimum and maximum of corresponding counts. Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less. >>> c = Counter(a=3, b=1) >>> d = Counter(a=1, b=2) >>> c + d # add two counters together: c[x] + d[x] Counter({'a': 4, 'b': 3}) >>> c - d # subtract (keeping only positive counts) Counter({'a': 2}) >>> c & d # intersection: min(c[x], d[x]) Counter({'a': 1, 'b': 1}) >>> c | d # union: max(c[x], d[x]) Counter({'a': 3, 'b': 2}) Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter. >>> c = Counter(a=2, b=-4) >>> +c Counter({'a': 2}) >>> -c Counter({'b': 4}) New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations. Note Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values. To help with those use cases, this section documents the minimum range and type restrictions. The Counter class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you could store anything in the value field. The most_common() method requires only that the values be orderable. For in-place operations such as c[key] += 1, the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for update() and subtract() which allow negative and zero", "score": "0.69607097"}]}
{"task_id": "mbpp_251", "code": "def insert_element(list,element):\r\n list = [v for elt in list for v in (element, elt)]\r\n return list", "test_list": ["assert insert_element(['Red', 'Green', 'Black'] ,'c')==['c', 'Red', 'c', 'Green', 'c', 'Black'] ", "assert insert_element(['python', 'java'] ,'program')==['program', 'python', 'program', 'java'] ", "assert insert_element(['happy', 'sad'] ,'laugh')==['laugh', 'happy', 'laugh', 'sad'] "], "context": "Write a function to insert an element before each element of a list.", "function_name": "def insert_element(list,element):", "gold_generation": "list = [v for elt in list for v in (element, elt)]\r\n return list", "ctxs": [{"id": "17639", "text": "Function: python.library.array#array.array.insert\nSnippet: array.insert(i, x) Insert a new item with value x in the array before position i. Negative values are treated as being relative to the end of the array.", "score": "0.7236675"}, {"id": "26739", "text": "Function: python.library.xml.dom#xml.dom.Node.insertBefore\nSnippet: Node.insertBefore(newChild, refChild) Insert a new child node before an existing child. It must be the case that refChild is a child of this node; if not, ValueError is raised. newChild is returned. If refChild is None, it inserts newChild at the end of the children’s list.", "score": "0.6977497"}, {"id": "7156", "text": "Function: torch.generated.torch.nn.modulelist#torch.nn.ModuleList.insert\nSnippet: insert(index, module) [source] Insert a given module before a given index in the list. Parameters index (int) – index to insert. module (nn.Module) – module to insert", "score": "0.6820739"}, {"id": "42900", "text": "Function: numpy.reference.generated.numpy.insert\nSnippet: numpy.insert numpy.insert(arr, obj, values, axis=None)[source] Insert values along the given axis before the given indices. Parameters arrarray_like Input array. objint, slice or sequence of ints Object that defines the index or indices before which values is inserted. New in version 1.8.0. Support for multiple insertions when obj is a single scalar or a sequence with one element (similar to calling insert multiple times). valuesarray_like Values to insert into arr. If the type of values is different from that of arr, values is converted to the type of arr. values should be shaped so that arr[...,obj,...] = values is legal. axisint, optional Axis along which to insert values. If axis is None then arr is flattened first. Returns outndarray A copy of arr with values inserted. Note that insert does not occur in-place: a new array is returned. If axis is None, out is a flattened array. See also append Append elements at the end of an array. concatenate Join a sequence of arrays along an existing axis. delete Delete elements from an array. Notes Note that for higher dimensional inserts obj=0 behaves very different from obj=[0] just like arr[:,0,:] = values is different from arr[:,[0],:] = values. Examples >>> a = np.array([[1, 1], [2, 2], [3, 3]]) >>> a array([[1, 1], [2, 2], [3, 3]]) >>> np.insert(a, 1, 5) array([1, 5, 1, ..., 2, 3, 3]) >>> np.insert(a, 1, 5, axis=1) array([[1, 5, 1], [2, 5, 2], [3, 5, 3]]) Difference between sequence and scalars: >>> np.insert(a, [1], [[1],[2],[3]], axis=1) array([[1, 1, 1], [2, 2, 2], [3, 3, 3]]) >>> np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1), ... np.insert(a, [1], [[1],[2],[3]], axis=1)) True >>> b = a.flatten() >>> b array([1, 1, 2, 2, 3, 3]) >>> np.insert(b, [2, 2], [5, 6]) array([1, 1, 5, ..., 2, 3, 3]) >>> np.insert(b, slice(2, 4), [5, 6]) array([1, 1, 5, ..., 2, 3, 3]) >>> np.insert(b, [2, 2], [7.13, False]) # type casting array([1, 1, 7, ..., 2, 3, 3]) >>> x = np.arange(8).reshape(2, 4) >>> idx = (1, 3) >>> np.insert(x, idx, 999, axis=1) array([[ 0, 999, 1, 2, 999, 3], [ 4, 999, 5, 6, 999, 7]])", "score": "0.67703986"}, {"id": "6555", "text": "Function: torch.fx#torch.fx.Node.prepend\nSnippet: prepend(x) [source] Insert x before this node in the list of nodes in the graph. Example: Before: p -> self bx -> x -> ax After: p -> x -> self bx -> ax Parameters x (Node) – The node to put before this node. Must be a member of the same graph.", "score": "0.67403096"}]}
{"task_id": "mbpp_252", "code": "import cmath  \r\ndef convert(numbers):    \r\n  num = cmath.polar(numbers)  \r\n  return (num) ", "test_list": ["assert convert(1) == (1.0, 0.0)", "assert convert(4) == (4.0,0.0)", "assert convert(5) == (5.0,0.0)"], "context": "Write a python function to convert complex numbers to polar coordinates.", "function_name": "import cmath  \r\ndef convert(numbers):", "gold_generation": "num = cmath.polar(numbers)  \r\n  return (num)", "ctxs": [{"id": "18455", "text": "Function: python.library.cmath\nSnippet: cmath — Mathematical functions for complex numbers This module provides access to mathematical functions for complex numbers. The functions in this module accept integers, floating-point numbers or complex numbers as arguments. They will also accept any Python object that has either a __complex__() or a __float__() method: these methods are used to convert the object to a complex or floating-point number, respectively, and the function is then applied to the result of the conversion. Note On platforms with hardware and system-level support for signed zeros, functions involving branch cuts are continuous on both sides of the branch cut: the sign of the zero distinguishes one side of the branch cut from the other. On platforms that do not support signed zeros the continuity is as specified below. Conversions to and from polar coordinates A Python complex number z is stored internally using rectangular or Cartesian coordinates. It is completely determined by its real part z.real and its imaginary part z.imag. In other words: z == z.real + z.imag*1j Polar coordinates give an alternative way to represent a complex number. In polar coordinates, a complex number z is defined by the modulus r and the phase angle phi. The modulus r is the distance from z to the origin, while the phase phi is the counterclockwise angle, measured in radians, from the positive x-axis to the line segment that joins the origin to z. The following functions can be used to convert from the native rectangular coordinates to polar coordinates and back. cmath.phase(x) Return the phase of x (also known as the argument of x), as a float. phase(x) is equivalent to math.atan2(x.imag, x.real). The result lies in the range [-π, π], and the branch cut for this operation lies along the negative real axis, continuous from above. On systems with support for signed zeros (which includes most systems in current use), this means that the sign of the result is the same as the sign of x.imag, even when x.imag is zero: >>> phase(complex(-1.0, 0.0)) 3.141592653589793 >>> phase(complex(-1.0, -0.0)) -3.141592653589793 Note The modulus (absolute value) of a complex number x can be computed using the built-in abs() function. There is no separate cmath module function for this operation. cmath.polar(x) Return the representation of x in polar coordinates. Returns a pair (r, phi) where r is the modulus of x and phi is the phase of x. polar(x) is equivalent to (abs(x), phase(x)). cmath.rect(r, phi) Return the complex number x with polar coordinates r and phi. Equivalent to r * (math.cos(phi) + math.sin(phi)*1j). Power and logarithmic functions cmath.exp(x) Return e raised to the power x, where e is the base of natural logarithms. cmath.log(x[, base]) Returns the logarithm of x to the given base. If the base is not specified, returns the natural logarithm of x. There is one branch cut, from 0 along the negative real axis to -∞, continuous from above. cmath.log10(x) Return the base-10 logarithm of x. This has the same branch cut as log(). cmath.sqrt(x) Return the", "score": "0.76783174"}, {"id": "18481", "text": "Function: python.library.cmath#cmath.rect\nSnippet: cmath.rect(r, phi) Return the complex number x with polar coordinates r and phi. Equivalent to r * (math.cos(phi) + math.sin(phi)*1j).", "score": "0.7447187"}, {"id": "7523", "text": "Function: torch.generated.torch.polar#torch.polar\nSnippet: torch.polar(abs, angle, *, out=None) → Tensor Constructs a complex tensor whose elements are Cartesian coordinates corresponding to the polar coordinates with absolute value abs and angle angle. out=abs⋅cos⁡(angle)+abs⋅sin⁡(angle)⋅j\\text{out} = \\text{abs} \\cdot \\cos(\\text{angle}) + \\text{abs} \\cdot \\sin(\\text{angle}) \\cdot j Parameters abs (Tensor) – The absolute value the complex tensor. Must be float or double. angle (Tensor) – The angle of the complex tensor. Must be same dtype as abs. Keyword Arguments out (Tensor) – If the inputs are torch.float32, must be torch.complex64. If the inputs are torch.float64, must be torch.complex128. Example:: >>> import numpy as np >>> abs = torch.tensor([1, 2], dtype=torch.float64) >>> angle = torch.tensor([np.pi / 2, 5 * np.pi / 4], dtype=torch.float64) >>> z = torch.polar(abs, angle) >>> z tensor([(0.0000+1.0000j), (-1.4142-1.4142j)], dtype=torch.complex128)", "score": "0.73569643"}, {"id": "18480", "text": "Function: python.library.cmath#cmath.polar\nSnippet: cmath.polar(x) Return the representation of x in polar coordinates. Returns a pair (r, phi) where r is the modulus of x and phi is the phase of x. polar(x) is equivalent to (abs(x), phase(x)).", "score": "0.71791404"}, {"id": "13493", "text": "Function: pygame.ref.math#pygame.math.Vector2.as_polar\nSnippet: as_polar() returns a tuple with radial distance and azimuthal angle. as_polar() -> (r, phi) Returns a tuple (r, phi) where r is the radial distance, and phi is the azimuthal angle.", "score": "0.7119422"}]}
{"task_id": "mbpp_253", "code": "def count_integer(list1):\r\n    ctr = 0\r\n    for i in list1:\r\n        if isinstance(i, int):\r\n            ctr = ctr + 1\r\n    return ctr", "test_list": ["assert count_integer([1,2,'abc',1.2]) == 2", "assert count_integer([1,2,3]) == 3", "assert count_integer([1,1.2,4,5.1]) == 2"], "context": "Write a python function to count integers from a given list.", "function_name": "def count_integer(list1):", "gold_generation": "ctr = 0\r\n    for i in list1:\r\n        if isinstance(i, int):\r\n            ctr = ctr + 1\r\n    return ctr", "ctxs": [{"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.6999488"}, {"id": "21304", "text": "Function: python.library.itertools#itertools.count\nSnippet: itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments.", "score": "0.6979399"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.6922596"}, {"id": "18611", "text": "Function: python.library.collections\nSnippet: Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6}) New in version 3.2. The usual dictionary methods are available for Counter objects except for two which work differently for counters. fromkeys(iterable) This class method is not implemented for Counter objects. update([iterable-or-mapping]) Elements are counted from an iterable or added-in from another mapping (or counter). Like dict.update() but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of (key, value) pairs. Common patterns for working with Counter objects: sum(c.values()) # total of all counts c.clear() # reset all counts list(c) # list unique elements set(c) # convert to a set dict(c) # convert to a regular dictionary c.items() # convert to a list of (elem, cnt) pairs Counter(dict(list_of_pairs)) # convert from a list of (elem, cnt) pairs c.most_common()[:-n-1:-1] # n least common elements +c # remove zero and negative counts Several mathematical operations are provided for combining Counter objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. Intersection and union return the minimum and maximum of corresponding counts. Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less. >>> c = Counter(a=3, b=1) >>> d = Counter(a=1, b=2) >>> c + d # add two counters together: c[x] + d[x] Counter({'a': 4, 'b': 3}) >>> c - d # subtract (keeping only positive counts) Counter({'a': 2}) >>> c & d # intersection: min(c[x], d[x]) Counter({'a': 1, 'b': 1}) >>> c | d # union: max(c[x], d[x]) Counter({'a': 3, 'b': 2}) Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter. >>> c = Counter(a=2, b=-4) >>> +c Counter({'a': 2}) >>> -c Counter({'b': 4}) New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations. Note Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values. To help with those use cases, this section documents the minimum range and type restrictions. The Counter class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you could store anything in the value field. The most_common() method requires only that the values be orderable. For in-place operations such as c[key] += 1, the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for update() and subtract() which allow negative and zero", "score": "0.69100654"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.68686146"}]}
{"task_id": "mbpp_254", "code": "import re\r\ndef words_ae(text):\r\n list = re.findall(\"[ae]\\w+\", text)\r\n return list", "test_list": ["assert words_ae(\"python programe\")==['ame']", "assert words_ae(\"python programe language\")==['ame','anguage']", "assert words_ae(\"assert statement\")==['assert', 'atement']"], "context": "Write a function to find all words starting with 'a' or 'e' in a given string.", "function_name": "import re\r\ndef words_ae(text):", "gold_generation": "list = re.findall(\"[ae]\\w+\", text)\r\n return list", "ctxs": [{"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.6926531"}, {"id": "23310", "text": "Function: python.library.re\nSnippet: for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\" Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). Pattern.fullmatch(string[, pos[, endpos]]) If the whole string matches this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o[gh]\") >>> pattern.fullmatch(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.fullmatch(\"ogre\") # No match as not the full string matches. >>> pattern.fullmatch(\"doggie\", 1, 3) # Matches within given limits. <re.Match object; span=(1, 3), match='og'> New in version 3.4. Pattern.split(string, maxsplit=0) Identical to the split() function, using the compiled pattern. Pattern.findall(string[, pos[, endpos]]) Similar to the findall() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.finditer(string[, pos[, endpos]]) Similar to the finditer() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.sub(repl, string, count=0) Identical to the sub() function, using the compiled pattern. Pattern.subn(repl, string, count=0) Identical to the subn() function, using the compiled pattern. Pattern.flags The regex", "score": "0.6773745"}, {"id": "41724", "text": "Function: numpy.reference.generated.numpy.char.find\nSnippet: numpy.char.find char.find(a, sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. Calls str.find element-wise. For each element, return the lowest index in the string where substring sub is found, such that sub is contained in the range [start, end]. Parameters aarray_like of str or unicode substr or unicode start, endint, optional Optional arguments start and end are interpreted as in slice notation. Returns outndarray or int Output array of ints. Returns -1 if sub is not found. See also str.find", "score": "0.67511165"}, {"id": "23361", "text": "Function: python.library.re#re.Pattern.search\nSnippet: Pattern.search(string[, pos[, endpos]]) Scan through string looking for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\"", "score": "0.6742959"}, {"id": "24346", "text": "Function: python.library.stdtypes#str.find\nSnippet: str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True", "score": "0.6667011"}]}
{"task_id": "mbpp_255", "code": "from itertools import combinations_with_replacement \r\ndef combinations_colors(l, n):\r\n    return list(combinations_with_replacement(l,n))\r", "test_list": ["assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],1)==[('Red',), ('Green',), ('Blue',)]", "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],2)==[('Red', 'Red'), ('Red', 'Green'), ('Red', 'Blue'), ('Green', 'Green'), ('Green', 'Blue'), ('Blue', 'Blue')]", "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],3)==[('Red', 'Red', 'Red'), ('Red', 'Red', 'Green'), ('Red', 'Red', 'Blue'), ('Red', 'Green', 'Green'), ('Red', 'Green', 'Blue'), ('Red', 'Blue', 'Blue'), ('Green', 'Green', 'Green'), ('Green', 'Green', 'Blue'), ('Green', 'Blue', 'Blue'), ('Blue', 'Blue', 'Blue')]"], "context": "Write a function to choose specified number of colours from three different colours and generate all the combinations with repetitions.", "function_name": "from itertools import combinations_with_replacement \r\ndef combinations_colors(l, n):", "gold_generation": "return list(combinations_with_replacement(l,n))", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.7014178"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6864568"}, {"id": "43678", "text": "Function: numpy.reference.random.generated.numpy.random.generator.multivariate_hypergeometric\nSnippet: typical inputs to decide which works best. New in version 1.18.0. Examples >>> colors = [16, 8, 4] >>> seed = 4861946401452 >>> gen = np.random.Generator(np.random.PCG64(seed)) >>> gen.multivariate_hypergeometric(colors, 6) array([5, 0, 1]) >>> gen.multivariate_hypergeometric(colors, 6, size=3) array([[5, 0, 1], [2, 2, 2], [3, 3, 0]]) >>> gen.multivariate_hypergeometric(colors, 6, size=(2, 2)) array([[[3, 2, 1], [3, 2, 1]], [[4, 1, 1], [3, 2, 1]]])", "score": "0.68492365"}, {"id": "5662", "text": "Function: torch.generated.torch.combinations#torch.combinations\nSnippet: torch.combinations(input, r=2, with_replacement=False) → seq Compute combinations of length rr of the given tensor. The behavior is similar to python’s itertools.combinations when with_replacement is set to False, and itertools.combinations_with_replacement when with_replacement is set to True. Parameters input (Tensor) – 1D vector. r (int, optional) – number of elements to combine with_replacement (boolean, optional) – whether to allow duplication in combination Returns A tensor equivalent to converting all the input tensors into lists, do itertools.combinations or itertools.combinations_with_replacement on these lists, and finally convert the resulting list into tensor. Return type Tensor Example: >>> a = [1, 2, 3] >>> list(itertools.combinations(a, r=2)) [(1, 2), (1, 3), (2, 3)] >>> list(itertools.combinations(a, r=3)) [(1, 2, 3)] >>> list(itertools.combinations_with_replacement(a, r=2)) [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)] >>> tensor_a = torch.tensor(a) >>> torch.combinations(tensor_a) tensor([[1, 2], [1, 3], [2, 3]]) >>> torch.combinations(tensor_a, r=3) tensor([[1, 2, 3]]) >>> torch.combinations(tensor_a, with_replacement=True) tensor([[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]])", "score": "0.68288624"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6772877"}]}
{"task_id": "mbpp_256", "code": "def count_Primes_nums(n):\r\n    ctr = 0\r\n    for num in range(n):\r\n        if num <= 1:\r\n            continue\r\n        for i in range(2,num):\r\n            if (num % i) == 0:\r\n                break\r\n        else:\r\n            ctr += 1\r\n    return ctr", "test_list": ["assert count_Primes_nums(5) == 2", "assert count_Primes_nums(10) == 4", "assert count_Primes_nums(100) == 25"], "context": "Write a python function to count the number of prime numbers less than a given non-negative number.", "function_name": "def count_Primes_nums(n):", "gold_generation": "ctr = 0\r\n    for num in range(n):\r\n        if num <= 1:\r\n            continue\r\n        for i in range(2,num):\r\n            if (num % i) == 0:\r\n                break\r\n        else:\r\n            ctr += 1\r\n    return ctr", "ctxs": [{"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.6715851"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6690722"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6665114"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.64971626"}, {"id": "6236", "text": "Function: torch.distributions#torch.distributions.negative_binomial.NegativeBinomial.support\nSnippet: support = IntegerGreaterThan(lower_bound=0)", "score": "0.6477582"}]}
{"task_id": "mbpp_257", "code": "def swap_numbers(a,b):\r\n temp = a\r\n a = b\r\n b = temp\r\n return (a,b)", "test_list": ["assert swap_numbers(10,20)==(20,10)", "assert swap_numbers(15,17)==(17,15)", "assert swap_numbers(100,200)==(200,100)"], "context": "Write a function to swap two numbers.", "function_name": "def swap_numbers(a,b):", "gold_generation": "temp = a\r\n a = b\r\n b = temp\r\n return (a,b)", "ctxs": [{"id": "14910", "text": "Function: pandas.reference.api.pandas.multiindex.swaplevel\nSnippet: pandas.MultiIndex.swaplevel MultiIndex.swaplevel(i=- 2, j=- 1)[source] Swap level i with level j. Calling this method does not change the ordering of the values. Parameters i:int, str, default -2 First level of index to be swapped. Can pass level name as string. Type of parameters can be mixed. j:int, str, default -1 Second level of index to be swapped. Can pass level name as string. Type of parameters can be mixed. Returns MultiIndex A new MultiIndex. See also Series.swaplevel Swap levels i and j in a MultiIndex. Dataframe.swaplevel Swap levels i and j in a MultiIndex on a particular axis. Examples >>> mi = pd.MultiIndex(levels=[['a', 'b'], ['bb', 'aa']], ... codes=[[0, 0, 1, 1], [0, 1, 0, 1]]) >>> mi MultiIndex([('a', 'bb'), ('a', 'aa'), ('b', 'bb'), ('b', 'aa')], ) >>> mi.swaplevel(0, 1) MultiIndex([('bb', 'a'), ('aa', 'a'), ('bb', 'b'), ('aa', 'b')], )", "score": "0.69389296"}, {"id": "19507", "text": "Function: python.library.decimal#decimal.Context.rotate\nSnippet: rotate(x, y) Returns a rotated copy of x, y times.", "score": "0.6651007"}, {"id": "15381", "text": "Function: pandas.reference.api.pandas.series.swaplevel\nSnippet: pandas.Series.swaplevel Series.swaplevel(i=- 2, j=- 1, copy=True)[source] Swap levels i and j in a MultiIndex. Default is to swap the two innermost levels of the index. Parameters i, j:int or str Levels of the indices to be swapped. Can pass level name as string. copy:bool, default True Whether to copy underlying data. Returns Series Series with levels swapped in MultiIndex. Examples >>> s = pd.Series( ... [\"A\", \"B\", \"A\", \"C\"], ... index=[ ... [\"Final exam\", \"Final exam\", \"Coursework\", \"Coursework\"], ... [\"History\", \"Geography\", \"History\", \"Geography\"], ... [\"January\", \"February\", \"March\", \"April\"], ... ], ... ) >>> s Final exam History January A Geography February B Coursework History March A Geography April C dtype: object In the following example, we will swap the levels of the indices. Here, we will swap the levels column-wise, but levels can be swapped row-wise in a similar manner. Note that column-wise is the default behaviour. By not supplying any arguments for i and j, we swap the last and second to last indices. >>> s.swaplevel() Final exam January History A February Geography B Coursework March History A April Geography C dtype: object By supplying one argument, we can choose which index to swap the last index with. We can for example swap the first index with the last one as follows. >>> s.swaplevel(0) January History Final exam A February Geography Final exam B March History Coursework A April Geography Coursework C dtype: object We can also define explicitly which indices we want to swap by supplying values for both i and j. Here, we for example swap the first and second indices. >>> s.swaplevel(0, 1) History Final exam January A Geography Final exam February B History Coursework March A Geography Coursework April C dtype: object", "score": "0.6640552"}, {"id": "22327", "text": "Function: python.library.operator#operator.irshift\nSnippet: operator.irshift(a, b) operator.__irshift__(a, b) a = irshift(a, b) is equivalent to a >>= b.", "score": "0.6629218"}, {"id": "19566", "text": "Function: python.library.decimal#decimal.Decimal.rotate\nSnippet: rotate(other, context=None) Return the result of rotating the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to rotate. If the second operand is positive then rotation is to the left; otherwise rotation is to the right. The coefficient of the first operand is padded on the left with zeros to length precision if necessary. The sign and exponent of the first operand are unchanged.", "score": "0.66191185"}]}
{"task_id": "mbpp_258", "code": "def count_odd(array_nums):\r\n   count_odd = len(list(filter(lambda x: (x%2 != 0) , array_nums)))\r\n   return count_odd", "test_list": ["assert count_odd([1, 2, 3, 5, 7, 8, 10])==4", "assert count_odd([10,15,14,13,-18,12,-20])==2", "assert count_odd([1, 2, 4, 8, 9])==2"], "context": "Write a function to find number of odd elements in the given list using lambda function.", "function_name": "def count_odd(array_nums):", "gold_generation": "count_odd = len(list(filter(lambda x: (x%2 != 0) , array_nums)))\r\n   return count_odd", "ctxs": [{"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.6969371"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6668036"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.66320133"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6619963"}, {"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.657481"}]}
{"task_id": "mbpp_259", "code": "def maximize_elements(test_tup1, test_tup2):\r\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "test_list": ["assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))", "assert maximize_elements(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((7, 8), (5, 10), (3, 10), (8, 11))", "assert maximize_elements(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((8, 9), (6, 11), (4, 11), (9, 12))"], "context": "Write a function to maximize the given two tuples.", "function_name": "def maximize_elements(test_tup1, test_tup2):", "gold_generation": "res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res)", "ctxs": [{"id": "5418", "text": "Function: tensorflow.tpu.experimental.embedding.adam\nSnippet: of scalar values (min, max) to set a separate maximum or minimum. If one of the two entries is None, then there will be no clipping that direction.", "score": "0.6621352"}, {"id": "7980", "text": "Function: torch.tensors#torch.Tensor.maximum\nSnippet: maximum(other) → Tensor See torch.maximum()", "score": "0.6540891"}, {"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.644505"}, {"id": "5768", "text": "Function: torch.generated.torch.cummax#torch.cummax\nSnippet: torch.cummax(input, dim, *, out=None) -> (Tensor, LongTensor) Returns a namedtuple (values, indices) where values is the cumulative maximum of elements of input in the dimension dim. And indices is the index location of each maximum value found in the dimension dim. yi=max(x1,x2,x3,…,xi)y_i = max(x_1, x_2, x_3, \\dots, x_i) Parameters input (Tensor) – the input tensor. dim (int) – the dimension to do the operation over Keyword Arguments out (tuple, optional) – the result tuple of two output tensors (values, indices) Example: >>> a = torch.randn(10) >>> a tensor([-0.3449, -1.5447, 0.0685, -1.5104, -1.1706, 0.2259, 1.4696, -1.3284, 1.9946, -0.8209]) >>> torch.cummax(a, dim=0) torch.return_types.cummax( values=tensor([-0.3449, -0.3449, 0.0685, 0.0685, 0.0685, 0.2259, 1.4696, 1.4696, 1.9946, 1.9946]), indices=tensor([0, 0, 2, 2, 2, 5, 6, 6, 8, 8]))", "score": "0.6331829"}, {"id": "7792", "text": "Function: torch.tensors#torch.Tensor.cummax\nSnippet: cummax(dim) -> (Tensor, Tensor) See torch.cummax()", "score": "0.6327188"}]}
{"task_id": "mbpp_260", "code": "def newman_prime(n): \r\n\tif n == 0 or n == 1: \r\n\t\treturn 1\r\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)", "test_list": ["assert newman_prime(3) == 7 ", "assert newman_prime(4) == 17", "assert newman_prime(5) == 41"], "context": "Write a function to find the nth newman–shanks–williams prime number.", "function_name": "def newman_prime(n):", "gold_generation": "if n == 0 or n == 1: \r\n\t\treturn 1\r\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)", "ctxs": [{"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.661276"}, {"id": "43079", "text": "Function: numpy.reference.generated.numpy.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.63879234"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.62525624"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6252426"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6234987"}]}
{"task_id": "mbpp_261", "code": "def division_elements(test_tup1, test_tup2):\r\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "test_list": ["assert division_elements((10, 4, 6, 9),(5, 2, 3, 3)) == (2, 2, 2, 3)", "assert division_elements((12, 6, 8, 16),(6, 3, 4, 4)) == (2, 2, 2, 4)", "assert division_elements((20, 14, 36, 18),(5, 7, 6, 9)) == (4, 2, 6, 2)"], "context": "Write a function to perform mathematical division operation across the given tuples.", "function_name": "def division_elements(test_tup1, test_tup2):", "gold_generation": "res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res)", "ctxs": [{"id": "42794", "text": "Function: numpy.reference.generated.numpy.divide\nSnippet: numpy.divide numpy.divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'true_divide'> Returns a true division of the inputs, element-wise. Unlike ‘floor division’, true division adjusts the output type to present the best answer, regardless of input types. Parameters x1array_like Dividend array. x2array_like Divisor array. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar This is a scalar if both x1 and x2 are scalars. Notes In Python, // is the floor division operator and / the true division operator. The true_divide(x1, x2) function is equivalent to true division in Python. Examples >>> x = np.arange(5) >>> np.true_divide(x, 4) array([ 0. , 0.25, 0.5 , 0.75, 1. ]) >>> x/4 array([ 0. , 0.25, 0.5 , 0.75, 1. ]) >>> x//4 array([0, 0, 0, 0, 1]) The / operator can be used as a shorthand for np.true_divide on ndarrays. >>> x = np.arange(5) >>> x / 4 array([0. , 0.25, 0.5 , 0.75, 1. ])", "score": "0.7020864"}, {"id": "19466", "text": "Function: python.library.decimal#decimal.Context.divide\nSnippet: divide(x, y) Return x divided by y.", "score": "0.69327104"}, {"id": "42840", "text": "Function: numpy.reference.generated.numpy.floor_divide\nSnippet: numpy.floor_divide numpy.floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'floor_divide'> Return the largest integer smaller or equal to the division of the inputs. It is equivalent to the Python // operator and pairs with the Python % (remainder), function so that a = a % b + b * (a // b) up to roundoff. Parameters x1array_like Numerator. x2array_like Denominator. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray y = floor(x1/x2) This is a scalar if both x1 and x2 are scalars. See also remainder Remainder complementary to floor_divide. divmod Simultaneous floor division and remainder. divide Standard division. floor Round a number to the nearest integer toward minus infinity. ceil Round a number to the nearest integer toward infinity. Examples >>> np.floor_divide(7,3) 2 >>> np.floor_divide([1., 2., 3., 4.], 2.5) array([ 0., 0., 1., 1.]) The // operator can be used as a shorthand for np.floor_divide on ndarrays. >>> x1 = np.array([1., 2., 3., 4.]) >>> x1 // 2.5 array([0., 0., 1., 1.])", "score": "0.6915134"}, {"id": "43239", "text": "Function: numpy.reference.generated.numpy.true_divide\nSnippet: numpy.true_divide numpy.true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'true_divide'> Returns a true division of the inputs, element-wise. Unlike ‘floor division’, true division adjusts the output type to present the best answer, regardless of input types. Parameters x1array_like Dividend array. x2array_like Divisor array. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar This is a scalar if both x1 and x2 are scalars. Notes In Python, // is the floor division operator and / the true division operator. The true_divide(x1, x2) function is equivalent to true division in Python. Examples >>> x = np.arange(5) >>> np.true_divide(x, 4) array([ 0. , 0.25, 0.5 , 0.75, 1. ]) >>> x/4 array([ 0. , 0.25, 0.5 , 0.75, 1. ]) >>> x//4 array([0, 0, 0, 0, 1]) The / operator can be used as a shorthand for np.true_divide on ndarrays. >>> x = np.arange(5) >>> x / 4 array([0. , 0.25, 0.5 , 0.75, 1. ])", "score": "0.68822896"}, {"id": "19467", "text": "Function: python.library.decimal#decimal.Context.divide_int\nSnippet: divide_int(x, y) Return x divided by y, truncated to an integer.", "score": "0.67567223"}]}
{"task_id": "mbpp_262", "code": "def split_two_parts(list1, L):\r\n    return list1[:L], list1[L:]", "test_list": ["assert split_two_parts([1,1,2,3,4,4,5,1],3)==([1, 1, 2], [3, 4, 4, 5, 1])", "assert split_two_parts(['a', 'b', 'c', 'd'],2)==(['a', 'b'], ['c', 'd'])", "assert split_two_parts(['p', 'y', 't', 'h', 'o', 'n'],4)==(['p', 'y', 't', 'h'], ['o', 'n'])"], "context": "Write a function to split a given list into two parts where the length of the first part of the list is given.", "function_name": "def split_two_parts(list1, L):", "gold_generation": "return list1[:L], list1[L:]", "ctxs": [{"id": "18335", "text": "Function: python.library.stdtypes#bytes.split\nSnippet: bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3']", "score": "0.6821199"}, {"id": "18291", "text": "Function: python.library.stdtypes#bytearray.split\nSnippet: bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3']", "score": "0.68023604"}, {"id": "24377", "text": "Function: python.library.stdtypes#str.split\nSnippet: str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3']", "score": "0.6783558"}, {"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.6767125"}, {"id": "18944", "text": "Function: python.library.ctypes#ctypes.Array._length_\nSnippet: _length_ A positive integer specifying the number of elements in the array. Out-of-range subscripts result in an IndexError. Will be returned by len().", "score": "0.66032183"}]}
{"task_id": "mbpp_263", "code": "def merge_dict(d1,d2):\r\n d = d1.copy()\r\n d.update(d2)\r\n return d", "test_list": ["assert merge_dict({'a': 100, 'b': 200},{'x': 300, 'y': 200})=={'x': 300, 'y': 200, 'a': 100, 'b': 200}", "assert merge_dict({'a':900,'b':900,'d':900},{'a':900,'b':900,'d':900})=={'a':900,'b':900,'d':900,'a':900,'b':900,'d':900}", "assert merge_dict({'a':10,'b':20},{'x':30,'y':40})=={'x':30,'y':40,'a':10,'b':20}"], "context": "Write a function to merge two dictionaries.", "function_name": "def merge_dict(d1,d2):", "gold_generation": "d = d1.copy()\r\n d.update(d2)\r\n return d", "ctxs": [{"id": "14306", "text": "Function: pandas.reference.api.pandas.dataframe.combine\nSnippet: pandas.DataFrame.combine DataFrame.combine(other, func, fill_value=None, overwrite=True)[source] Perform column-wise combine with another DataFrame. Combines a DataFrame with other DataFrame using func to element-wise combine columns. The row and column indexes of the resulting DataFrame will be the union of the two. Parameters other:DataFrame The DataFrame to merge column-wise. func:function Function that takes two series as inputs and return a Series or a scalar. Used to merge the two dataframes column by columns. fill_value:scalar value, default None The value to fill NaNs with prior to passing any column to the merge func. overwrite:bool, default True If True, columns in self that do not exist in other will be overwritten with NaNs. Returns DataFrame Combination of the provided DataFrames. See also DataFrame.combine_first Combine two DataFrame objects and default to non-null values in frame calling the method. Examples Combine using a simple function that chooses the smaller column. >>> df1 = pd.DataFrame({'A': [0, 0], 'B': [4, 4]}) >>> df2 = pd.DataFrame({'A': [1, 1], 'B': [3, 3]}) >>> take_smaller = lambda s1, s2: s1 if s1.sum() < s2.sum() else s2 >>> df1.combine(df2, take_smaller) A B 0 0 3 1 0 3 Example using a true element-wise combine function. >>> df1 = pd.DataFrame({'A': [5, 0], 'B': [2, 4]}) >>> df2 = pd.DataFrame({'A': [1, 1], 'B': [3, 3]}) >>> df1.combine(df2, np.minimum) A B 0 1 2 1 0 3 Using fill_value fills Nones prior to passing the column to the merge function. >>> df1 = pd.DataFrame({'A': [0, 0], 'B': [None, 4]}) >>> df2 = pd.DataFrame({'A': [1, 1], 'B': [3, 3]}) >>> df1.combine(df2, take_smaller, fill_value=-5) A B 0 0 -5.0 1 0 4.0 However, if the same element in both dataframes is None, that None is preserved >>> df1 = pd.DataFrame({'A': [0, 0], 'B': [None, 4]}) >>> df2 = pd.DataFrame({'A': [1, 1], 'B': [None, 3]}) >>> df1.combine(df2, take_smaller, fill_value=-5) A B 0 0 -5.0 1 0 3.0 Example that demonstrates the use of overwrite and behavior when the axis differ between the dataframes. >>> df1 = pd.DataFrame({'A': [0, 0], 'B': [4, 4]}) >>> df2 = pd.DataFrame({'B': [3, 3], 'C': [-10, 1], }, index=[1, 2]) >>> df1.combine(df2, take_smaller) A B C 0 NaN NaN NaN 1 NaN 3.0 -10.0 2 NaN 3.0 1.0 >>> df1.combine(df2, take_smaller, overwrite=False) A B C 0 0.0 NaN NaN 1 0.0 3.0 -10.0 2 NaN 3.0 1.0 Demonstrating the preference of the passed in dataframe. >>> df2 = pd.DataFrame({'B': [3, 3], 'C': [1, 1], }, index=[1, 2]) >>> df2.combine(df1, take_smaller) A B C 0 0.0 NaN NaN 1 0.0 3.0 NaN 2 NaN 3.0 NaN >>> df2.combine(df1, take_smaller, overwrite=False) A B C 0 0.0 NaN NaN 1 0.0 3.0 1.0 2 NaN 3.0 1.0", "score": "0.67600006"}, {"id": "20487", "text": "Function: python.library.heapq#heapq.merge\nSnippet: heapq.merge(*iterables, key=None, reverse=False) Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an iterator over the sorted values. Similar to sorted(itertools.chain(*iterables)) but returns an iterable, does not pull the data into memory all at once, and assumes that each of the input streams is already sorted (smallest to largest). Has two optional arguments which must be specified as keyword arguments. key specifies a key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters.", "score": "0.67131114"}, {"id": "42965", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.join_by\nSnippet: numpy.lib.recfunctions.join_by(key, r1, r2, jointype='inner', r1postfix='1', r2postfix='2', defaults=None, usemask=True, asrecarray=False)[source] Join arrays r1 and r2 on key key. The key should be either a string or a sequence of string corresponding to the fields used to join the array. An exception is raised if the key field cannot be found in the two input arrays. Neither r1 nor r2 should have any duplicates along key: the presence of duplicates will make the output quite unreliable. Note that duplicates are not looked for by the algorithm. Parameters key{string, sequence} A string or a sequence of strings corresponding to the fields used for comparison. r1, r2arrays Structured arrays. jointype{‘inner’, ‘outer’, ‘leftouter’}, optional If ‘inner’, returns the elements common to both r1 and r2. If ‘outer’, returns the common elements as well as the elements of r1 not in r2 and the elements of not in r2. If ‘leftouter’, returns the common elements and the elements of r1 not in r2. r1postfixstring, optional String appended to the names of the fields of r1 that are present in r2 but absent of the key. r2postfixstring, optional String appended to the names of the fields of r2 that are present in r1 but absent of the key. defaults{dictionary}, optional Dictionary mapping field names to the corresponding default values. usemask{True, False}, optional Whether to return a MaskedArray (or MaskedRecords is asrecarray==True) or a ndarray. asrecarray{False, True}, optional Whether to return a recarray (or MaskedRecords if usemask==True) or just a flexible-type ndarray. Notes The output is sorted along the key. A temporary array is formed by dropping the fields not in the key for the two arrays and concatenating the result. This array is then sorted, and the common entries selected. The output is constructed by filling the fields with the selected entries. Matching is not preserved if there are some duplicates…", "score": "0.6694179"}, {"id": "42953", "text": "Function: numpy.user.basics.rec\nSnippet: the two arrays and concatenating the result. This array is then sorted, and the common entries selected. The output is constructed by filling the fields with the selected entries. Matching is not preserved if there are some duplicates… numpy.lib.recfunctions.merge_arrays(seqarrays, fill_value=- 1, flatten=False, usemask=False, asrecarray=False)[source] Merge arrays field by field. Parameters seqarrayssequence of ndarrays Sequence of arrays fill_value{float}, optional Filling value used to pad missing data on the shorter arrays. flatten{False, True}, optional Whether to collapse nested fields. usemask{False, True}, optional Whether to return a masked array or not. asrecarray{False, True}, optional Whether to return a recarray (MaskedRecords) or not. Notes Without a mask, the missing value will be filled with something, depending on what its corresponding type: -1 for integers -1.0 for floating point numbers '-' for characters '-1' for strings True for boolean values XXX: I just obtained these values empirically Examples >>> from numpy.lib import recfunctions as rfn >>> rfn.merge_arrays((np.array([1, 2]), np.array([10., 20., 30.]))) array([( 1, 10.), ( 2, 20.), (-1, 30.)], dtype=[('f0', '<i8'), ('f1', '<f8')]) >>> rfn.merge_arrays((np.array([1, 2], dtype=np.int64), ... np.array([10., 20., 30.])), usemask=False) array([(1, 10.0), (2, 20.0), (-1, 30.0)], dtype=[('f0', '<i8'), ('f1', '<f8')]) >>> rfn.merge_arrays((np.array([1, 2]).view([('a', np.int64)]), ... np.array([10., 20., 30.])), ... usemask=False, asrecarray=True) rec.array([( 1, 10.), ( 2, 20.), (-1, 30.)], dtype=[('a', '<i8'), ('f1', '<f8')]) numpy.lib.recfunctions.rec_append_fields(base, names, data, dtypes=None)[source] Add new fields to an existing array. The names of the fields are given with the names arguments, the corresponding values with the data arguments. If a single field is appended, names, data and dtypes do not have to be lists but just values. Parameters basearray Input array to extend. namesstring, sequence String or sequence of strings corresponding to the names of the new fields. dataarray or sequence of arrays Array or sequence of arrays storing the fields to add to the base. dtypessequence of datatypes, optional Datatype or sequence of datatypes. If None, the datatypes are estimated from the data. Returns appended_arraynp.recarray See also append_fields numpy.lib.recfunctions.rec_drop_fields(base, drop_names)[source] Returns a new numpy.recarray with fields in drop_names dropped. numpy.lib.recfunctions.rec_join(key, r1, r2, jointype='inner', r1postfix='1', r2postfix='2', defaults=None)[source] Join arrays r1 and r2 on keys. Alternative to join_by, that always returns a np.recarray. See also join_by equivalent function numpy.lib.recfunctions.recursive_fill_fields(input, output)[source] Fills fields from output with fields from input, with support for nested structures. Parameters inputndarray Input array. outputndarray Output array. Notes output should be at least the same size as input Examples >>> from numpy.lib import recfunctions as rfn >>> a = np.array([(1, 10.), (2, 20.)], dtype=[('A', np.int64), ('B', np.float64)]) >>> b = np.zeros((3,), dtype=a.dtype) >>> rfn.recursive_fill_fields(a, b) array([(1, 10.), (2, 20.), (0, 0.)], dtype=[('A', '<i8'), ('B', '<f8')]) numpy.lib.recfunctions.rename_fields(base, namemapper)[source] Rename the fields from a flexible-datatype ndarray or recarray. Nested fields are supported. Parameters basendarray Input array whose fields must be modified. namemapperdictionary Dictionary mapping old field names to their new version. Examples >>> from numpy.lib import recfunctions as rfn >>> a = np.array([(1, (2, [3.0, 30.])), (4, (5, [6.0, 60.]))], ... dtype=[('a', int),('b', [('ba', float), ('bb', (float, 2))])]) >>> rfn.rename_fields(a, {'a':'A', 'bb':'BB'}) array([(1, (2., [ 3., 30.])), (4, (5.,", "score": "0.66830564"}, {"id": "42761", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.dict_append\nSnippet: numpy.distutils.misc_util.dict_append(d, **kws)[source]", "score": "0.6635064"}]}
{"task_id": "mbpp_264", "code": "def dog_age(h_age):\r\n if h_age < 0:\r\n \texit()\r\n elif h_age <= 2:\r\n\t d_age = h_age * 10.5\r\n else:\r\n\t d_age = 21 + (h_age - 2)*4\r\n return d_age", "test_list": ["assert dog_age(12)==61", "assert dog_age(15)==73", "assert dog_age(24)==109"], "context": "Write a function to calculate a dog's age in dog's years.", "function_name": "def dog_age(h_age):", "gold_generation": "if h_age < 0:\r\n \texit()\r\n elif h_age <= 2:\r\n\t d_age = h_age * 10.5\r\n else:\r\n\t d_age = 21 + (h_age - 2)*4\r\n return d_age", "ctxs": [{"id": "13927", "text": "Function: pandas.user_guide.cookbook\nSnippet: 8 False 1 dog S 10 False 2 cat M 11 False 3 fish M 1 False 4 dog M 20 False 5 cat L 12 True 6 cat L 12 True # List the size of the animals with the highest weight. In [106]: df.groupby(\"animal\").apply(lambda subf: subf[\"size\"][subf[\"weight\"].idxmax()]) Out[106]: animal cat L dog M fish M dtype: object Using get_group In [107]: gb = df.groupby([\"animal\"]) In [108]: gb.get_group(\"cat\") Out[108]: animal size weight adult 0 cat S 8 False 2 cat M 11 False 5 cat L 12 True 6 cat L 12 True Apply to different items in a group In [109]: def GrowUp(x): .....: avg_weight = sum(x[x[\"size\"] == \"S\"].weight * 1.5) .....: avg_weight += sum(x[x[\"size\"] == \"M\"].weight * 1.25) .....: avg_weight += sum(x[x[\"size\"] == \"L\"].weight) .....: avg_weight /= len(x) .....: return pd.Series([\"L\", avg_weight, True], index=[\"size\", \"weight\", \"adult\"]) .....: In [110]: expected_df = gb.apply(GrowUp) In [111]: expected_df Out[111]: size weight adult animal cat L 12.4375 True dog L 20.0000 True fish L 1.2500 True Expanding apply In [112]: S = pd.Series([i / 100.0 for i in range(1, 11)]) In [113]: def cum_ret(x, y): .....: return x * (1 + y) .....: In [114]: def red(x): .....: return functools.reduce(cum_ret, x, 1.0) .....: In [115]: S.expanding().apply(red, raw=True) Out[115]: 0 1.010000 1 1.030200 2 1.061106 3 1.103550 4 1.158728 5 1.228251 6 1.314229 7 1.419367 8 1.547110 9 1.701821 dtype: float64 Replacing some values with mean of the rest of a group In [116]: df = pd.DataFrame({\"A\": [1, 1, 2, 2], \"B\": [1, -1, 1, 2]}) In [117]: gb = df.groupby(\"A\") In [118]: def replace(g): .....: mask = g < 0 .....: return g.where(mask, g[~mask].mean()) .....: In [119]: gb.transform(replace) Out[119]: B 0 1.0 1 -1.0 2 1.5 3 1.5 Sort groups by aggregated data In [120]: df = pd.DataFrame( .....: { .....: \"code\": [\"foo\", \"bar\", \"baz\"] * 2, .....: \"data\": [0.16, -0.21, 0.33, 0.45, -0.59, 0.62], .....: \"flag\": [False, True] * 3, .....: } .....: ) .....: In [121]: code_groups = df.groupby(\"code\") In [122]: agg_n_sort_order = code_groups[[\"data\"]].transform(sum).sort_values(by=\"data\") In [123]: sorted_df = df.loc[agg_n_sort_order.index] In [124]: sorted_df Out[124]: code data flag 1 bar -0.21 True 4 bar -0.59 False 0 foo 0.16 False 3 foo 0.45 True 2 baz 0.33 False 5 baz 0.62 True Create multiple aggregated columns In [125]: rng = pd.date_range(start=\"2014-10-07\", periods=10, freq=\"2min\") In [126]: ts = pd.Series(data=list(range(10)), index=rng) In [127]: def MyCust(x): .....: if len(x) > 2: .....: return x[1] * 1.234 .....: return pd.NaT .....: In [128]: mhc = {\"Mean\": np.mean, \"Max\": np.max, \"Custom\": MyCust} In [129]: ts.resample(\"5min\").apply(mhc) Out[129]: Mean Max Custom 2014-10-07 00:00:00 1.0 2 1.234 2014-10-07 00:05:00 3.5 4 NaT 2014-10-07 00:10:00 6.0 7 7.404 2014-10-07 00:15:00 8.5 9 NaT In [130]: ts Out[130]: 2014-10-07 00:00:00 0 2014-10-07 00:02:00 1 2014-10-07 00:04:00 2 2014-10-07 00:06:00 3 2014-10-07 00:08:00 4 2014-10-07 00:10:00 5 2014-10-07 00:12:00 6 2014-10-07 00:14:00 7 2014-10-07 00:16:00 8 2014-10-07 00:18:00 9 Freq: 2T, dtype: int64 Create a value counts column and reassign back to the DataFrame In [131]: df = pd.DataFrame( .....: {\"Color\": \"Red Red", "score": "0.67301303"}, {"id": "15149", "text": "Function: pandas.reference.api.pandas.series.dt.qyear\nSnippet: pandas.Series.dt.qyear Series.dt.qyear", "score": "0.6401224"}, {"id": "15554", "text": "Function: pandas.reference.api.pandas.timestamp.year\nSnippet: pandas.Timestamp.year Timestamp.year", "score": "0.63070804"}, {"id": "16463", "text": "Function: pandas.reference.api.pandas.tseries.offsets.yearbegin.__call__\nSnippet: pandas.tseries.offsets.YearBegin.__call__ YearBegin.__call__(*args, **kwargs) Call self as a function.", "score": "0.6290818"}, {"id": "12719", "text": "Function: sklearn.modules.generated.sklearn.metrics.pairwise_distances_chunked\nSnippet: neigh, avg_dist >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func) >>> neigh, avg_dist = next(gen) >>> neigh [array([0, 3]), array([1]), array([2]), array([0, 3]), array([4])] >>> avg_dist array([0.039..., 0. , 0. , 0.039..., 0. ]) Where r is defined per sample, we need to make use of start: >>> r = [.2, .4, .4, .3, .1] >>> def reduce_func(D_chunk, start): ... neigh = [np.flatnonzero(d < r[i]) ... for i, d in enumerate(D_chunk, start)] ... return neigh >>> neigh = next(pairwise_distances_chunked(X, reduce_func=reduce_func)) >>> neigh [array([0, 3]), array([0, 1]), array([2]), array([0, 3]), array([4])] Force row-by-row generation by reducing working_memory: >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func, ... working_memory=0) >>> next(gen) [array([0, 3])] >>> next(gen) [array([0, 1])]", "score": "0.62782305"}]}
{"task_id": "mbpp_265", "code": "def list_split(S, step):\r\n    return [S[i::step] for i in range(step)]", "test_list": ["assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'],3)==[['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']] ", "assert list_split([1,2,3,4,5,6,7,8,9,10,11,12,13,14],3)==[[1,4,7,10,13], [2,5,8,11,14], [3,6,9,12]] ", "assert list_split(['python','java','C','C++','DBMS','SQL'],2)==[['python', 'C', 'DBMS'], ['java', 'C++', 'SQL']] "], "context": "Write a function to split a list for every nth element.", "function_name": "def list_split(S, step):", "gold_generation": "return [S[i::step] for i in range(step)]", "ctxs": [{"id": "41754", "text": "Function: numpy.reference.generated.numpy.char.split\nSnippet: numpy.char.split char.split(a, sep=None, maxsplit=None)[source] For each element in a, return a list of the words in the string, using sep as the delimiter string. Calls str.split element-wise. Parameters aarray_like of str or unicode sepstr or unicode, optional If sep is not specified or None, any whitespace string is a separator. maxsplitint, optional If maxsplit is given, at most maxsplit splits are done. Returns outndarray Array of list objects See also str.split, rsplit", "score": "0.7014504"}, {"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.697601"}, {"id": "24377", "text": "Function: python.library.stdtypes#str.split\nSnippet: str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3']", "score": "0.6971669"}, {"id": "41752", "text": "Function: numpy.reference.generated.numpy.char.rsplit\nSnippet: numpy.char.rsplit char.rsplit(a, sep=None, maxsplit=None)[source] For each element in a, return a list of the words in the string, using sep as the delimiter string. Calls str.rsplit element-wise. Except for splitting from the right, rsplit behaves like split. Parameters aarray_like of str or unicode sepstr or unicode, optional If sep is not specified or None, any whitespace string is a separator. maxsplitint, optional If maxsplit is given, at most maxsplit splits are done, the rightmost ones. Returns outndarray Array of list objects See also str.rsplit, split", "score": "0.6929274"}, {"id": "18291", "text": "Function: python.library.stdtypes#bytearray.split\nSnippet: bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3']", "score": "0.690658"}]}
{"task_id": "mbpp_266", "code": "def lateralsurface_cube(l):\r\n  LSA = 4 * (l * l)\r\n  return LSA", "test_list": ["assert lateralsurface_cube(5)==100", "assert lateralsurface_cube(9)==324", "assert lateralsurface_cube(10)==400"], "context": "Write a function to find the lateral surface area of a cube.", "function_name": "def lateralsurface_cube(l):", "gold_generation": "LSA = 4 * (l * l)\r\n  return LSA", "ctxs": [{"id": "17024", "text": "Function: skimage.api.skimage.measure#skimage.measure.mesh_surface_area\nSnippet: skimage.measure.mesh_surface_area(verts, faces) [source] Compute surface area, given vertices & triangular faces Parameters verts(V, 3) array of floats Array containing (x, y, z) coordinates for V unique mesh vertices. faces(F, 3) array of ints List of length-3 lists of integers, referencing vertex coordinates as provided in verts Returns areafloat Surface area of mesh. Units now [coordinate units] ** 2. See also skimage.measure.marching_cubes skimage.measure.marching_cubes_classic Notes The arguments expected by this function are the first two outputs from skimage.measure.marching_cubes. For unit correct output, ensure correct spacing was passed to skimage.measure.marching_cubes. This algorithm works properly only if the faces provided are all triangles.", "score": "0.6552196"}, {"id": "17021", "text": "Function: skimage.api.skimage.measure#skimage.measure.marching_cubes_classic\nSnippet: guarantees coherent orientation as of version 0.12. To quantify the area of an isosurface generated by this algorithm, pass outputs directly into skimage.measure.mesh_surface_area. References 1(1,2,3) Lorensen, William and Harvey E. Cline. Marching Cubes: A High Resolution 3D Surface Construction Algorithm. Computer Graphics (SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170). DOI:10.1145/37401.37422", "score": "0.6541511"}, {"id": "17018", "text": "Function: skimage.api.skimage.measure#skimage.measure.marching_cubes\nSnippet: skimage.measure.marching_cubes(volume, level=None, *, spacing=(1.0, 1.0, 1.0), gradient_direction='descent', step_size=1, allow_degenerate=True, method='lewiner', mask=None) [source] Marching cubes algorithm to find surfaces in 3d volumetric data. In contrast with Lorensen et al. approach [2], Lewiner et al. algorithm is faster, resolves ambiguities, and guarantees topologically correct results. Therefore, this algorithm generally a better choice. Parameters volume(M, N, P) array Input data volume to find isosurfaces. Will internally be converted to float32 if necessary. levelfloat, optional Contour value to search for isosurfaces in volume. If not given or None, the average of the min and max of vol is used. spacinglength-3 tuple of floats, optional Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in volume. gradient_directionstring, optional Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite, considering the left-hand rule. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object step_sizeint, optional Step size in voxels. Default 1. Larger steps yield faster but coarser results. The result will always be topologically correct though. allow_degeneratebool, optional Whether to allow degenerate (i.e. zero-area) triangles in the end-result. Default True. If False, degenerate triangles are removed, at the cost of making the algorithm slower. method: str, optional One of ‘lewiner’, ‘lorensen’ or ‘_lorensen’. Specify witch of Lewiner et al. or Lorensen et al. method will be used. The ‘_lorensen’ flag correspond to an old implementation that will be deprecated in version 0.19. mask(M, N, P) array, optional Boolean array. The marching cube algorithm will be computed only on True elements. This will save computational time when interfaces are located within certain region of the volume M, N, P-e.g. the top half of the cube-and also allow to compute finite surfaces-i.e. open surfaces that do not end at the border of the cube. Returns verts(V, 3) array Spatial coordinates for V unique mesh vertices. Coordinate order matches input volume (M, N, P). If allow_degenerate is set to True, then the presence of degenerate triangles in the mesh can make this array have duplicate vertices. faces(F, 3) array Define triangular faces via referencing vertex indices from verts. This algorithm specifically outputs triangles, so each face has exactly three indices. normals(V, 3) array The normal direction at each vertex, as calculated from the data. values(V, ) array Gives a measure for the maximum value of the data in the local region near each vertex. This can be used by visualization tools to apply a colormap to the mesh. See also skimage.measure.mesh_surface_area skimage.measure.find_contours Notes The algorithm [1] is an improved version of Chernyaev’s Marching Cubes 33 algorithm. It is an efficient algorithm that relies on heavy use of lookup tables to handle the many different cases, keeping the algorithm relatively easy. This implementation is written in Cython, ported from Lewiner’s C++ implementation. To quantify the area of an isosurface generated by this algorithm, pass verts and faces to skimage.measure.mesh_surface_area. Regarding visualization of algorithm", "score": "0.6448386"}, {"id": "17022", "text": "Function: skimage.api.skimage.measure#skimage.measure.marching_cubes_lewiner\nSnippet: skimage.measure.marching_cubes_lewiner(volume, level=None, spacing=(1.0, 1.0, 1.0), gradient_direction='descent', step_size=1, allow_degenerate=True, use_classic=False, mask=None) [source] Lewiner marching cubes algorithm to find surfaces in 3d volumetric data. In contrast to marching_cubes_classic(), this algorithm is faster, resolves ambiguities, and guarantees topologically correct results. Therefore, this algorithm generally a better choice, unless there is a specific need for the classic algorithm. Parameters volume(M, N, P) array Input data volume to find isosurfaces. Will internally be converted to float32 if necessary. levelfloat Contour value to search for isosurfaces in volume. If not given or None, the average of the min and max of vol is used. spacinglength-3 tuple of floats Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in volume. gradient_directionstring Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite, considering the left-hand rule. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object step_sizeint Step size in voxels. Default 1. Larger steps yield faster but coarser results. The result will always be topologically correct though. allow_degeneratebool Whether to allow degenerate (i.e. zero-area) triangles in the end-result. Default True. If False, degenerate triangles are removed, at the cost of making the algorithm slower. use_classicbool If given and True, the classic marching cubes by Lorensen (1987) is used. This option is included for reference purposes. Note that this algorithm has ambiguities and is not guaranteed to produce a topologically correct result. The results with using this option are not generally the same as the marching_cubes_classic() function. mask(M, N, P) array Boolean array. The marching cube algorithm will be computed only on True elements. This will save computational time when interfaces are located within certain region of the volume M, N, P-e.g. the top half of the cube-and also allow to compute finite surfaces-i.e. open surfaces that do not end at the border of the cube. Returns verts(V, 3) array Spatial coordinates for V unique mesh vertices. Coordinate order matches input volume (M, N, P). If allow_degenerate is set to True, then the presence of degenerate triangles in the mesh can make this array have duplicate vertices. faces(F, 3) array Define triangular faces via referencing vertex indices from verts. This algorithm specifically outputs triangles, so each face has exactly three indices. normals(V, 3) array The normal direction at each vertex, as calculated from the data. values(V, ) array Gives a measure for the maximum value of the data in the local region near each vertex. This can be used by visualization tools to apply a colormap to the mesh. See also skimage.measure.marching_cubes skimage.measure.mesh_surface_area Notes The algorithm [1] is an improved version of Chernyaev’s Marching Cubes 33 algorithm. It is an efficient algorithm that relies on heavy use of lookup tables to handle the many different cases, keeping the algorithm relatively easy. This implementation is written in Cython, ported from Lewiner’s C++ implementation. To quantify the area of an isosurface generated by", "score": "0.63836396"}, {"id": "16974", "text": "Function: skimage.api.skimage.measure\nSnippet: x = np.eye(3).astype(int) >>> print(x) [[1 0 0] [0 1 0] [0 0 1]] >>> print(label(x, connectivity=1)) [[1 0 0] [0 2 0] [0 0 3]] >>> print(label(x, connectivity=2)) [[1 0 0] [0 1 0] [0 0 1]] >>> print(label(x, background=-1)) [[1 2 2] [2 1 2] [2 2 1]] >>> x = np.array([[1, 0, 0], ... [1, 1, 5], ... [0, 0, 0]]) >>> print(label(x)) [[1 0 0] [1 1 2] [0 0 0]] Examples using skimage.measure.label Measure region properties Euler number Segment human cells (in mitosis) marching_cubes skimage.measure.marching_cubes(volume, level=None, *, spacing=(1.0, 1.0, 1.0), gradient_direction='descent', step_size=1, allow_degenerate=True, method='lewiner', mask=None) [source] Marching cubes algorithm to find surfaces in 3d volumetric data. In contrast with Lorensen et al. approach [2], Lewiner et al. algorithm is faster, resolves ambiguities, and guarantees topologically correct results. Therefore, this algorithm generally a better choice. Parameters volume(M, N, P) array Input data volume to find isosurfaces. Will internally be converted to float32 if necessary. levelfloat, optional Contour value to search for isosurfaces in volume. If not given or None, the average of the min and max of vol is used. spacinglength-3 tuple of floats, optional Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in volume. gradient_directionstring, optional Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite, considering the left-hand rule. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object step_sizeint, optional Step size in voxels. Default 1. Larger steps yield faster but coarser results. The result will always be topologically correct though. allow_degeneratebool, optional Whether to allow degenerate (i.e. zero-area) triangles in the end-result. Default True. If False, degenerate triangles are removed, at the cost of making the algorithm slower. method: str, optional One of ‘lewiner’, ‘lorensen’ or ‘_lorensen’. Specify witch of Lewiner et al. or Lorensen et al. method will be used. The ‘_lorensen’ flag correspond to an old implementation that will be deprecated in version 0.19. mask(M, N, P) array, optional Boolean array. The marching cube algorithm will be computed only on True elements. This will save computational time when interfaces are located within certain region of the volume M, N, P-e.g. the top half of the cube-and also allow to compute finite surfaces-i.e. open surfaces that do not end at the border of the cube. Returns verts(V, 3) array Spatial coordinates for V unique mesh vertices. Coordinate order matches input volume (M, N, P). If allow_degenerate is set to True, then the presence of degenerate triangles in the mesh can make this array have duplicate vertices. faces(F, 3) array Define triangular faces via referencing vertex indices from verts. This algorithm specifically outputs triangles, so each face has exactly three indices. normals(V, 3) array The normal direction at each vertex, as calculated from the data. values(V, ) array Gives a measure for the maximum value of the data in the local region near each", "score": "0.63728195"}]}
{"task_id": "mbpp_267", "code": "def square_Sum(n):  \r\n    return int(n*(4*n*n-1)/3) ", "test_list": ["assert square_Sum(2) == 10", "assert square_Sum(3) == 35", "assert square_Sum(4) == 84"], "context": "Write a python function to find the sum of squares of first n odd natural numbers.", "function_name": "def square_Sum(n):", "gold_generation": "return int(n*(4*n*n-1)/3)", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6647993"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6645082"}, {"id": "43202", "text": "Function: numpy.reference.generated.numpy.square\nSnippet: numpy.square numpy.square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'square'> Return the element-wise square of the input. Parameters xarray_like Input data. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Element-wise x*x, of the same shape and dtype as x. This is a scalar if x is a scalar. See also numpy.linalg.matrix_power sqrt power Examples >>> np.square([-1j, 1]) array([-1.-0.j, 1.+0.j])", "score": "0.6588474"}, {"id": "21812", "text": "Function: python.library.math#math.isqrt\nSnippet: math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8.", "score": "0.65133417"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.64870214"}]}
{"task_id": "mbpp_268", "code": "def find_star_num(n): \r\n\treturn (6 * n * (n - 1) + 1) ", "test_list": ["assert find_star_num(3) == 37", "assert find_star_num(4) == 73", "assert find_star_num(5) == 121"], "context": "Write a function to find the n'th star number.", "function_name": "def find_star_num(n):", "gold_generation": "return (6 * n * (n - 1) + 1)", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.66939104"}, {"id": "21313", "text": "Function: python.library.itertools#itertools.starmap\nSnippet: itertools.starmap(function, iterable) Make an iterator that computes the function using arguments obtained from the iterable. Used instead of map() when argument parameters are already grouped in tuples from a single iterable (the data has been “pre-zipped”). The difference between map() and starmap() parallels the distinction between function(a,b) and function(*c). Roughly equivalent to: def starmap(function, iterable): # starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000 for args in iterable: yield function(*args)", "score": "0.64342165"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.64290446"}, {"id": "25463", "text": "Function: python.library.token#token.STAR\nSnippet: token.STAR Token value for \"*\".", "score": "0.6424451"}, {"id": "23654", "text": "Function: python.library.signal#signal.NSIG\nSnippet: signal.NSIG One more than the number of the highest signal number.", "score": "0.6388456"}]}
{"task_id": "mbpp_269", "code": "def ascii_value(k):\r\n  ch=k\r\n  return ord(ch)", "test_list": ["assert ascii_value('A')==65", "assert ascii_value('R')==82", "assert ascii_value('S')==83"], "context": "Write a function to find the ascii value of a character.", "function_name": "def ascii_value(k):", "gold_generation": "ch=k\r\n  return ord(ch)", "ctxs": [{"id": "19056", "text": "Function: python.library.curses.ascii#curses.ascii.ascii\nSnippet: curses.ascii.ascii(c) Return the ASCII value corresponding to the low 7 bits of c.", "score": "0.7170849"}, {"id": "17650", "text": "Function: python.library.functions#ascii\nSnippet: ascii(object) As repr(), return a string containing a printable representation of an object, but escape the non-ASCII characters in the string returned by repr() using \\x, \\u or \\U escapes. This generates a string similar to that returned by repr() in Python 2.", "score": "0.70356333"}, {"id": "24401", "text": "Function: python.library.string#string.ascii_uppercase\nSnippet: string.ascii_uppercase The uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. This value is not locale-dependent and will not change.", "score": "0.70067984"}, {"id": "19054", "text": "Function: python.library.curses.ascii\nSnippet: 8-bit character corresponding to the given ASCII character (the character bit value is bitwise-ored with 0x80). The following function takes either a single-character string or integer value; it returns a string. curses.ascii.unctrl(c) Return a string representation of the ASCII character c. If c is printable, this string is the character itself. If the character is a control character (0x00–0x1f) the string consists of a caret ('^') followed by the corresponding uppercase letter. If the character is an ASCII delete (0x7f) the string is '^?'. If the character has its meta bit (0x80) set, the meta bit is stripped, the preceding rules applied, and '!' prepended to the result. curses.ascii.controlnames A 33-element string array that contains the ASCII mnemonics for the thirty-two ASCII control characters from 0 (NUL) to 0x1f (US), in order, plus the mnemonic SP for the space character.", "score": "0.70025134"}, {"id": "18216", "text": "Function: python.library.binascii\nSnippet: binascii — Convert between binary and ASCII The binascii module contains a number of methods to convert between binary and various ASCII-encoded binary representations. Normally, you will not use these functions directly but use wrapper modules like uu, base64, or binhex instead. The binascii module contains low-level functions written in C for greater speed that are used by the higher-level modules. Note a2b_* functions accept Unicode strings containing only ASCII characters. Other functions only accept bytes-like objects (such as bytes, bytearray and other objects that support the buffer protocol). Changed in version 3.3: ASCII-only unicode strings are now accepted by the a2b_* functions. The binascii module defines the following functions: binascii.a2b_uu(string) Convert a single line of uuencoded data back to binary and return the binary data. Lines normally contain 45 (binary) bytes, except for the last line. Line data may be followed by whitespace. binascii.b2a_uu(data, *, backtick=False) Convert binary data to a line of ASCII characters, the return value is the converted line, including a newline char. The length of data should be at most 45. If backtick is true, zeros are represented by '`' instead of spaces. Changed in version 3.7: Added the backtick parameter. binascii.a2b_base64(string) Convert a block of base64 data back to binary and return the binary data. More than one line may be passed at a time. binascii.b2a_base64(data, *, newline=True) Convert binary data to a line of ASCII characters in base64 coding. The return value is the converted line, including a newline char if newline is true. The output of this function conforms to RFC 3548. Changed in version 3.6: Added the newline parameter. binascii.a2b_qp(data, header=False) Convert a block of quoted-printable data back to binary and return the binary data. More than one line may be passed at a time. If the optional argument header is present and true, underscores will be decoded as spaces. binascii.b2a_qp(data, quotetabs=False, istext=True, header=False) Convert binary data to a line(s) of ASCII characters in quoted-printable encoding. The return value is the converted line(s). If the optional argument quotetabs is present and true, all tabs and spaces will be encoded. If the optional argument istext is present and true, newlines are not encoded but trailing whitespace will be encoded. If the optional argument header is present and true, spaces will be encoded as underscores per RFC 1522. If the optional argument header is present and false, newline characters will be encoded as well; otherwise linefeed conversion might corrupt the binary data stream. binascii.a2b_hqx(string) Convert binhex4 formatted ASCII data to binary, without doing RLE-decompression. The string should contain a complete number of binary bytes, or (in case of the last portion of the binhex4 data) have the remaining bits zero. Deprecated since version 3.9. binascii.rledecode_hqx(data) Perform RLE-decompression on the data, as per the binhex4 standard. The algorithm uses 0x90 after a byte as a repeat indicator, followed by a count. A count of 0 specifies a byte value of 0x90. The routine returns the decompressed data, unless data input data ends in an", "score": "0.6990353"}]}
{"task_id": "mbpp_270", "code": "def sum_even_and_even_index(arr,n):  \r\n    i = 0\r\n    sum = 0\r\n    for i in range(0,n,2): \r\n        if (arr[i] % 2 == 0) : \r\n            sum += arr[i]  \r\n    return sum", "test_list": ["assert sum_even_and_even_index([5, 6, 12, 1, 18, 8],6) == 30", "assert sum_even_and_even_index([3, 20, 17, 9, 2, 10, 18, 13, 6, 18],10) == 26", "assert sum_even_and_even_index([5, 6, 12, 1],4) == 12"], "context": "Write a python function to find the sum of even numbers at even positions.", "function_name": "def sum_even_and_even_index(arr,n):", "gold_generation": "i = 0\r\n    sum = 0\r\n    for i in range(0,n,2): \r\n        if (arr[i] % 2 == 0) : \r\n            sum += arr[i]  \r\n    return sum", "ctxs": [{"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.6755522"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.6750965"}, {"id": "19597", "text": "Function: python.library.decimal#decimal.ROUND_HALF_EVEN\nSnippet: decimal.ROUND_HALF_EVEN Round to nearest with ties going to nearest even integer.", "score": "0.67222404"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.6665263"}, {"id": "21803", "text": "Function: python.library.math#math.fsum\nSnippet: math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation.", "score": "0.66612524"}]}
{"task_id": "mbpp_271", "code": "def even_Power_Sum(n): \r\n    sum = 0; \r\n    for i in range(1,n+1): \r\n        j = 2*i; \r\n        sum = sum + (j*j*j*j*j); \r\n    return sum; ", "test_list": ["assert even_Power_Sum(2) == 1056", "assert even_Power_Sum(3) == 8832", "assert even_Power_Sum(1) == 32"], "context": "Write a python function to find the sum of fifth power of first n even natural numbers.", "function_name": "def even_Power_Sum(n):", "gold_generation": "sum = 0; \r\n    for i in range(1,n+1): \r\n        j = 2*i; \r\n        sum = sum + (j*j*j*j*j); \r\n    return sum;", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.66532075"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6576388"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6566329"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.6503096"}, {"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.6502433"}]}
{"task_id": "mbpp_272", "code": "def rear_extract(test_list):\r\n  res = [lis[-1] for lis in test_list]\r\n  return (res) ", "test_list": ["assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]", "assert rear_extract([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]", "assert rear_extract([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]"], "context": "Write a function to perfom the rear element extraction from list of tuples records.", "function_name": "def rear_extract(test_list):", "gold_generation": "res = [lis[-1] for lis in test_list]\r\n  return (res)", "ctxs": [{"id": "43899", "text": "Function: numpy.reference.generated.numpy.record.base\nSnippet: numpy.record.base attribute record.base base object", "score": "0.6938507"}, {"id": "41864", "text": "Function: numpy.reference.generated.numpy.core.records.fromrecords\nSnippet: numpy.core.records.fromrecords core.records.fromrecords(recList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None)[source] Create a recarray from a list of records in text form. Parameters recListsequence data in the same field may be heterogeneous - they will be promoted to the highest data type. dtypedata-type, optional valid dtype for all arrays shapeint or tuple of ints, optional shape of each array. formats, names, titles, aligned, byteorder : If dtype is None, these arguments are passed to numpy.format_parser to construct a dtype. See that function for detailed documentation. If both formats and dtype are None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing. Returns np.recarray record array consisting of given recList rows. Examples >>> r=np.core.records.fromrecords([(456,'dbe',1.2),(2,'de',1.3)], ... names='col1,col2,col3') >>> print(r[0]) (456, 'dbe', 1.2) >>> r.col1 array([456, 2]) >>> r.col2 array(['dbe', 'de'], dtype='<U3') >>> import pickle >>> pickle.loads(pickle.dumps(r)) rec.array([(456, 'dbe', 1.2), ( 2, 'de', 1.3)], dtype=[('col1', '<i8'), ('col2', '<U3'), ('col3', '<f8')])", "score": "0.6925433"}, {"id": "25502", "text": "Function: python.library.traceback#traceback.format_list\nSnippet: traceback.format_list(extracted_list) Given a list of tuples or FrameSummary objects as returned by extract_tb() or extract_stack(), return a list of strings ready for printing. Each string in the resulting list corresponds to the item with the same index in the argument list. Each string ends in a newline; the strings may contain internal newlines as well, for those items whose source text line is not None.", "score": "0.6896441"}, {"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.6894052"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.68919545"}]}
{"task_id": "mbpp_273", "code": "def substract_elements(test_tup1, test_tup2):\r\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\r\n  return (res) ", "test_list": ["assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)", "assert substract_elements((11, 2, 3), (24, 45 ,16)) == (-13, -43, -13)", "assert substract_elements((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)"], "context": "Write a function to substract the contents of one tuple with corresponding index of other tuple.", "function_name": "def substract_elements(test_tup1, test_tup2):", "gold_generation": "res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\r\n  return (res)", "ctxs": [{"id": "22396", "text": "Function: python.library.operator#operator.__sub__\nSnippet: operator.sub(a, b) operator.__sub__(a, b) Return a - b.", "score": "0.68697566"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.68048567"}, {"id": "22350", "text": "Function: python.library.operator#operator.sub\nSnippet: operator.sub(a, b) operator.__sub__(a, b) Return a - b.", "score": "0.67697126"}, {"id": "18611", "text": "Function: python.library.collections\nSnippet: Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6}) New in version 3.2. The usual dictionary methods are available for Counter objects except for two which work differently for counters. fromkeys(iterable) This class method is not implemented for Counter objects. update([iterable-or-mapping]) Elements are counted from an iterable or added-in from another mapping (or counter). Like dict.update() but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of (key, value) pairs. Common patterns for working with Counter objects: sum(c.values()) # total of all counts c.clear() # reset all counts list(c) # list unique elements set(c) # convert to a set dict(c) # convert to a regular dictionary c.items() # convert to a list of (elem, cnt) pairs Counter(dict(list_of_pairs)) # convert from a list of (elem, cnt) pairs c.most_common()[:-n-1:-1] # n least common elements +c # remove zero and negative counts Several mathematical operations are provided for combining Counter objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. Intersection and union return the minimum and maximum of corresponding counts. Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less. >>> c = Counter(a=3, b=1) >>> d = Counter(a=1, b=2) >>> c + d # add two counters together: c[x] + d[x] Counter({'a': 4, 'b': 3}) >>> c - d # subtract (keeping only positive counts) Counter({'a': 2}) >>> c & d # intersection: min(c[x], d[x]) Counter({'a': 1, 'b': 1}) >>> c | d # union: max(c[x], d[x]) Counter({'a': 3, 'b': 2}) Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter. >>> c = Counter(a=2, b=-4) >>> +c Counter({'a': 2}) >>> -c Counter({'b': 4}) New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations. Note Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values. To help with those use cases, this section documents the minimum range and type restrictions. The Counter class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you could store anything in the value field. The most_common() method requires only that the values be orderable. For in-place operations such as c[key] += 1, the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for update() and subtract() which allow negative and zero", "score": "0.6702819"}, {"id": "15594", "text": "Function: pandas.reference.api.pandas.tseries.offsets.bquarterend.apply_index\nSnippet: pandas.tseries.offsets.BQuarterEnd.apply_index BQuarterEnd.apply_index(other)", "score": "0.6702564"}]}
{"task_id": "mbpp_274", "code": "import math  \r\ndef even_binomial_Coeff_Sum( n): \r\n    return (1 << (n - 1)) ", "test_list": ["assert even_binomial_Coeff_Sum(4) == 8", "assert even_binomial_Coeff_Sum(6) == 32", "assert even_binomial_Coeff_Sum(2) == 2"], "context": "Write a python function to find sum of even index binomial coefficients.", "function_name": "import math  \r\ndef even_binomial_Coeff_Sum( n):", "gold_generation": "return (1 << (n - 1))", "ctxs": [{"id": "21787", "text": "Function: python.library.math#math.comb\nSnippet: math.comb(n, k) Return the number of ways to choose k items from n items without repetition and without order. Evaluates to n! / (k! * (n - k)!) when k <= n and evaluates to zero when k > n. Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of the expression (1 + x) ** n. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6838495"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6672899"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.66692805"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.6656301"}, {"id": "43580", "text": "Function: numpy.reference.generated.numpy.polynomial.polynomial.polyadd\nSnippet: numpy.polynomial.polynomial.polyadd polynomial.polynomial.polyadd(c1, c2)[source] Add one polynomial to another. Returns the sum of two polynomials c1 + c2. The arguments are sequences of coefficients from lowest order term to highest, i.e., [1,2,3] represents the polynomial 1 + 2*x + 3*x**2. Parameters c1, c2array_like 1-D arrays of polynomial coefficients ordered from low to high. Returns outndarray The coefficient array representing their sum. See also polysub, polymulx, polymul, polydiv, polypow Examples >>> from numpy.polynomial import polynomial as P >>> c1 = (1,2,3) >>> c2 = (3,2,1) >>> sum = P.polyadd(c1,c2); sum array([4., 4., 4.]) >>> P.polyval(2, sum) # 4 + 4(2) + 4(2**2) 28.0", "score": "0.6605443"}]}
{"task_id": "mbpp_275", "code": "import math as mt \r\ndef get_Position(a,n,m): \r\n    for i in range(n): \r\n        a[i] = (a[i] // m + (a[i] % m != 0))  \r\n    result,maxx = -1,-1\r\n    for i in range(n - 1,-1,-1): \r\n        if (maxx < a[i]): \r\n            maxx = a[i] \r\n            result = i \r\n    return result + 1", "test_list": ["assert get_Position([2,5,4],3,2) == 2", "assert get_Position([4,3],2,2) == 2", "assert get_Position([1,2,3,4],4,1) == 4"], "context": "Write a python function to find the position of the last removed element from the given array.", "function_name": "import math as mt \r\ndef get_Position(a,n,m):", "gold_generation": "for i in range(n): \r\n        a[i] = (a[i] // m + (a[i] % m != 0))  \r\n    result,maxx = -1,-1\r\n    for i in range(n - 1,-1,-1): \r\n        if (maxx < a[i]): \r\n            maxx = a[i] \r\n            result = i \r\n    return result + 1", "ctxs": [{"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.7543986"}, {"id": "17641", "text": "Function: python.library.array#array.array.pop\nSnippet: array.pop([i]) Removes the item with the index i from the array and returns it. The optional argument defaults to -1, so that by default the last item is removed and returned.", "score": "0.7394855"}, {"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.70637965"}, {"id": "41778", "text": "Function: numpy.reference.generated.numpy.chararray.find\nSnippet: numpy.chararray.find method chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.6927582"}, {"id": "43873", "text": "Function: numpy.reference.generated.numpy.recarray.searchsorted\nSnippet: numpy.recarray.searchsorted method recarray.searchsorted(v, side='left', sorter=None) Find indices where elements of v should be inserted in a to maintain order. For full documentation, see numpy.searchsorted See also numpy.searchsorted equivalent function", "score": "0.6882473"}]}
{"task_id": "mbpp_276", "code": "def volume_cylinder(r,h):\r\n  volume=3.1415*r*r*h\r\n  return volume", "test_list": ["assert volume_cylinder(10,5)==1570.7500000000002", "assert volume_cylinder(4,5)==251.32000000000002", "assert volume_cylinder(4,10)==502.64000000000004"], "context": "Write a function to find the volume of a cylinder.", "function_name": "def volume_cylinder(r,h):", "gold_generation": "volume=3.1415*r*r*h\r\n  return volume", "ctxs": [{"id": "25627", "text": "Function: python.library.turtle#turtle.dot\nSnippet: turtle.dot(size=None, *color) Parameters size – an integer >= 1 (if given) color – a colorstring or a numeric color tuple Draw a circular dot with diameter size, using color. If size is not given, the maximum of pensize+4 and 2*pensize is used. >>> turtle.home() >>> turtle.dot() >>> turtle.fd(50); turtle.dot(20, \"blue\"); turtle.fd(50) >>> turtle.position() (100.00,-0.00) >>> turtle.heading() 0.0", "score": "0.6418282"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.63284653"}, {"id": "33487", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: barbs_doc='\\nPlot a 2D field of barbs.\\n\\nCall signature::\\n\\n barbs([X, Y], U, V, [C], **kw)\\n\\nWhere *X*, *Y* define the barb locations, *U*, *V* define the barb\\ndirections, and *C* optionally sets the color.\\n\\nAll arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked\\n*X*, *Y* are not supported at present.\\n\\nBarbs are traditionally used in meteorology as a way to plot the speed\\nand direction of wind observations, but can technically be used to\\nplot any two dimensional vector quantity. As opposed to arrows, which\\ngive vector magnitude by the length of the arrow, the barbs give more\\nquantitative information about the vector magnitude by putting slanted\\nlines or a triangle for various increments in magnitude, as show\\nschematically below::\\n\\n : /\\\\ \\\\\\n : / \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : ------------------------------\\n\\nThe largest increment is given by a triangle (or \"flag\"). After those\\ncome full lines (barbs). The smallest increment is a half line. There\\nis only, of course, ever at most 1 half line. If the magnitude is\\nsmall and only needs a single half-line and no full lines or\\ntriangles, the half-line is offset from the end of the barb so that it\\ncan be easily distinguished from barbs with a single full line. The\\nmagnitude for the barb shown above would nominally be 65, using the\\nstandard increments of 50, 10, and 5.\\n\\nSee also https://en.wikipedia.org/wiki/Wind_barb.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the barb locations. See *pivot* for how the\\n barbs are drawn to the x, y positions.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y components of the barb shaft.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If", "score": "0.62772954"}, {"id": "25668", "text": "Function: python.library.turtle#turtle.pensize\nSnippet: turtle.pensize(width=None) turtle.width(width=None) Parameters width – a positive number Set the line thickness to width or return it. If resizemode is set to “auto” and turtleshape is a polygon, that polygon is drawn with the same line thickness. If no argument is given, the current pensize is returned. >>> turtle.pensize() 1 >>> turtle.pensize(10) # from here on lines of width 10 are drawn", "score": "0.6248644"}, {"id": "25592", "text": "Function: python.library.turtle\nSnippet: steps – an integer (or None) Draw a circle with given radius. The center is radius units left of the turtle; extent – an angle – determines which part of the circle is drawn. If extent is not given, draw the entire circle. If extent is not a full circle, one endpoint of the arc is the current pen position. Draw the arc in counterclockwise direction if radius is positive, otherwise in clockwise direction. Finally the direction of the turtle is changed by the amount of extent. As the circle is approximated by an inscribed regular polygon, steps determines the number of steps to use. If not given, it will be calculated automatically. May be used to draw regular polygons. >>> turtle.home() >>> turtle.position() (0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(50) >>> turtle.position() (-0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(120, 180) # draw a semicircle >>> turtle.position() (0.00,240.00) >>> turtle.heading() 180.0 turtle.dot(size=None, *color) Parameters size – an integer >= 1 (if given) color – a colorstring or a numeric color tuple Draw a circular dot with diameter size, using color. If size is not given, the maximum of pensize+4 and 2*pensize is used. >>> turtle.home() >>> turtle.dot() >>> turtle.fd(50); turtle.dot(20, \"blue\"); turtle.fd(50) >>> turtle.position() (100.00,-0.00) >>> turtle.heading() 0.0 turtle.stamp() Stamp a copy of the turtle shape onto the canvas at the current turtle position. Return a stamp_id for that stamp, which can be used to delete it by calling clearstamp(stamp_id). >>> turtle.color(\"blue\") >>> turtle.stamp() 11 >>> turtle.fd(50) turtle.clearstamp(stampid) Parameters stampid – an integer, must be return value of previous stamp() call Delete stamp with given stampid. >>> turtle.position() (150.00,-0.00) >>> turtle.color(\"blue\") >>> astamp = turtle.stamp() >>> turtle.fd(50) >>> turtle.position() (200.00,-0.00) >>> turtle.clearstamp(astamp) >>> turtle.position() (200.00,-0.00) turtle.clearstamps(n=None) Parameters n – an integer (or None) Delete all or first/last n of turtle’s stamps. If n is None, delete all stamps, if n > 0 delete first n stamps, else if n < 0 delete last n stamps. >>> for i in range(8): ... turtle.stamp(); turtle.fd(30) 13 14 15 16 17 18 19 20 >>> turtle.clearstamps(2) >>> turtle.clearstamps(-2) >>> turtle.clearstamps() turtle.undo() Undo (repeatedly) the last turtle action(s). Number of available undo actions is determined by the size of the undobuffer. >>> for i in range(4): ... turtle.fd(50); turtle.lt(80) ... >>> for i in range(8): ... turtle.undo() turtle.speed(speed=None) Parameters speed – an integer in the range 0..10 or a speedstring (see below) Set the turtle’s speed to an integer value in the range 0..10. If no argument is given, return current speed. If input is a number greater than 10 or smaller than 0.5, speed is set to 0. Speedstrings are mapped to speedvalues as follows: “fastest”: 0 “fast”: 10 “normal”: 6 “slow”: 3 “slowest”: 1 Speeds from 1 to 10 enforce increasingly faster animation of line drawing and turtle turning. Attention: speed = 0 means that no animation takes place. forward/back makes turtle jump and likewise left/right make the turtle turn instantly. >>> turtle.speed() 3 >>> turtle.speed('normal') >>> turtle.speed() 6 >>> turtle.speed(9) >>> turtle.speed() 9", "score": "0.62092996"}]}
{"task_id": "mbpp_277", "code": "def dict_filter(dict,n):\r\n result = {key:value for (key, value) in dict.items() if value >=n}\r\n return result", "test_list": ["assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},170)=={'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}", "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},180)=={ 'Alden Cantrell': 180, 'Pierre Cox': 190}", "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},190)=={ 'Pierre Cox': 190}"], "context": "Write a function to filter a dictionary based on values.", "function_name": "def dict_filter(dict,n):", "gold_generation": "result = {key:value for (key, value) in dict.items() if value >=n}\r\n return result", "ctxs": [{"id": "20195", "text": "Function: python.library.fnmatch#fnmatch.filter\nSnippet: fnmatch.filter(names, pattern) Construct a list from those elements of the iterable names that match pattern. It is the same as [n for n in names if fnmatch(n, pattern)], but implemented more efficiently.", "score": "0.6886666"}, {"id": "20187", "text": "Function: python.library.functions#filter\nSnippet: filter(function, iterable) Construct an iterator from those elements of iterable for which function returns true. iterable may be either a sequence, a container which supports iteration, or an iterator. If function is None, the identity function is assumed, that is, all elements of iterable that are false are removed. Note that filter(function, iterable) is equivalent to the generator expression (item for item in iterable if function(item)) if function is not None and (item for item in iterable if item) if function is None. See itertools.filterfalse() for the complementary function that returns elements of iterable for which function returns false.", "score": "0.6770735"}, {"id": "19611", "text": "Function: python.library.stdtypes#dict.clear\nSnippet: clear() Remove all items from the dictionary.", "score": "0.675328"}, {"id": "20282", "text": "Function: python.library.functions\nSnippet: local dictionary, respectively, which may be useful to pass around for use as the second and third argument to exec(). Note The default locals act as described for function locals() below: modifications to the default locals dictionary should not be attempted. Pass an explicit locals dictionary if you need to see effects of the code on locals after function exec() returns. filter(function, iterable) Construct an iterator from those elements of iterable for which function returns true. iterable may be either a sequence, a container which supports iteration, or an iterator. If function is None, the identity function is assumed, that is, all elements of iterable that are false are removed. Note that filter(function, iterable) is equivalent to the generator expression (item for item in iterable if function(item)) if function is not None and (item for item in iterable if item) if function is None. See itertools.filterfalse() for the complementary function that returns elements of iterable for which function returns false. class float([x]) Return a floating point number constructed from a number or string x. If the argument is a string, it should contain a decimal number, optionally preceded by a sign, and optionally embedded in whitespace. The optional sign may be '+' or '-'; a '+' sign has no effect on the value produced. The argument may also be a string representing a NaN (not-a-number), or a positive or negative infinity. More precisely, the input must conform to the following grammar after leading and trailing whitespace characters are removed: sign ::= \"+\" | \"-\" infinity ::= \"Infinity\" | \"inf\" nan ::= \"nan\" numeric_value ::= floatnumber | infinity | nan numeric_string ::= [sign] numeric_value Here floatnumber is the form of a Python floating-point literal, described in Floating point literals. Case is not significant, so, for example, “inf”, “Inf”, “INFINITY” and “iNfINity” are all acceptable spellings for positive infinity. Otherwise, if the argument is an integer or a floating point number, a floating point number with the same value (within Python’s floating point precision) is returned. If the argument is outside the range of a Python float, an OverflowError will be raised. For a general Python object x, float(x) delegates to x.__float__(). If __float__() is not defined then it falls back to __index__(). If no argument is given, 0.0 is returned. Examples: >>> float('+1.23') 1.23 >>> float(' -12345\\n') -12345.0 >>> float('1e-003') 0.001 >>> float('+1E6') 1000000.0 >>> float('-Infinity') -inf The float type is described in Numeric Types — int, float, complex. Changed in version 3.6: Grouping digits with underscores as in code literals is allowed. Changed in version 3.7: x is now a positional-only parameter. Changed in version 3.8: Falls back to __index__() if __float__() is not defined. format(value[, format_spec]) Convert a value to a “formatted” representation, as controlled by format_spec. The interpretation of format_spec will depend on the type of the value argument, however there is a standard formatting syntax that is used by most built-in types: Format Specification Mini-Language. The default format_spec is an empty string which usually gives the same", "score": "0.6748923"}, {"id": "25768", "text": "Function: python.library.stdtypes\nSnippet: The example above shows part of the implementation of collections.Counter. A different __missing__ method is used by collections.defaultdict. d[key] = value Set d[key] to value. del d[key] Remove d[key] from d. Raises a KeyError if key is not in the map. key in d Return True if d has a key key, else False. key not in d Equivalent to not key in d. iter(d) Return an iterator over the keys of the dictionary. This is a shortcut for iter(d.keys()). clear() Remove all items from the dictionary. copy() Return a shallow copy of the dictionary. classmethod fromkeys(iterable[, value]) Create a new dictionary with keys from iterable and values set to value. fromkeys() is a class method that returns a new dictionary. value defaults to None. All of the values refer to just a single instance, so it generally doesn’t make sense for value to be a mutable object such as an empty list. To get distinct values, use a dict comprehension instead. get(key[, default]) Return the value for key if key is in the dictionary, else default. If default is not given, it defaults to None, so that this method never raises a KeyError. items() Return a new view of the dictionary’s items ((key, value) pairs). See the documentation of view objects. keys() Return a new view of the dictionary’s keys. See the documentation of view objects. pop(key[, default]) If key is in the dictionary, remove it and return its value, else return default. If default is not given and key is not in the dictionary, a KeyError is raised. popitem() Remove and return a (key, value) pair from the dictionary. Pairs are returned in LIFO order. popitem() is useful to destructively iterate over a dictionary, as often used in set algorithms. If the dictionary is empty, calling popitem() raises a KeyError. Changed in version 3.7: LIFO order is now guaranteed. In prior versions, popitem() would return an arbitrary key/value pair. reversed(d) Return a reverse iterator over the keys of the dictionary. This is a shortcut for reversed(d.keys()). New in version 3.8. setdefault(key[, default]) If key is in the dictionary, return its value. If not, insert key with a value of default and return default. default defaults to None. update([other]) Update the dictionary with the key/value pairs from other, overwriting existing keys. Return None. update() accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those key/value pairs: d.update(red=1, blue=2). values() Return a new view of the dictionary’s values. See the documentation of view objects. An equality comparison between one dict.values() view and another will always return False. This also applies when comparing dict.values() to itself: >>> d = {'a': 1} >>> d.values() == d.values() False d | other Create a new dictionary with the merged keys and values of d and other, which must both be dictionaries. The values of other take priority when d and other share keys.", "score": "0.67198217"}]}
{"task_id": "mbpp_278", "code": "def count_first_elements(test_tup):\r\n  for count, ele in enumerate(test_tup):\r\n    if isinstance(ele, tuple):\r\n      break\r\n  return (count) ", "test_list": ["assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3", "assert count_first_elements((2, 9, (5, 7), 11) ) == 2", "assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4"], "context": "Write a function to find the element count that occurs before the record in the given tuple.", "function_name": "def count_first_elements(test_tup):", "gold_generation": "for count, ele in enumerate(test_tup):\r\n    if isinstance(ele, tuple):\r\n      break\r\n  return (count)", "ctxs": [{"id": "43939", "text": "Function: numpy.reference.generated.numpy.record.size\nSnippet: numpy.record.size attribute record.size The number of elements in the gentype.", "score": "0.6987362"}, {"id": "22306", "text": "Function: python.library.operator#operator.countOf\nSnippet: operator.countOf(a, b) Return the number of occurrences of b in a.", "score": "0.6979493"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.69069946"}, {"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.68316346"}, {"id": "18304", "text": "Function: python.library.stdtypes#bytes.count\nSnippet: bytes.count(sub[, start[, end]]) bytearray.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.68107396"}]}
{"task_id": "mbpp_279", "code": "def is_num_decagonal(n): \r\n\treturn 4 * n * n - 3 * n ", "test_list": ["assert is_num_decagonal(3) == 27", "assert is_num_decagonal(7) == 175", "assert is_num_decagonal(10) == 370"], "context": "Write a function to find the nth decagonal number.", "function_name": "def is_num_decagonal(n):", "gold_generation": "return 4 * n * n - 3 * n", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6952771"}, {"id": "35797", "text": "Function: django.ref.models.database-functions#django.db.models.functions.NthValue\nSnippet: class NthValue(expression, nth=1, **extra)", "score": "0.6798379"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6697195"}, {"id": "14324", "text": "Function: pandas.reference.api.pandas.dataframe.div\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.66489625"}, {"id": "43169", "text": "Function: numpy.reference.generated.numpy.savetxt\nSnippet: delimiter=',') # X is an array >>> np.savetxt('test.out', (x,y,z)) # x,y,z equal sized 1D arrays >>> np.savetxt('test.out', x, fmt='%1.4e') # use exponential notation", "score": "0.66404974"}]}
{"task_id": "mbpp_280", "code": "def sequential_search(dlist, item):\r\n    pos = 0\r\n    found = False\r\n    while pos < len(dlist) and not found:\r\n        if dlist[pos] == item:\r\n            found = True\r\n        else:\r\n            pos = pos + 1\r\n    return found, pos", "test_list": ["assert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)", "assert sequential_search([12, 32, 45, 62, 35, 47, 44, 61],61) == (True, 7)", "assert sequential_search([9, 10, 17, 19, 22, 39, 48, 56],48) == (True, 6)"], "context": "Write a function to search an element in the given array by using sequential search.", "function_name": "def sequential_search(dlist, item):", "gold_generation": "pos = 0\r\n    found = False\r\n    while pos < len(dlist) and not found:\r\n        if dlist[pos] == item:\r\n            found = True\r\n        else:\r\n            pos = pos + 1\r\n    return found, pos", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.6933451"}, {"id": "43873", "text": "Function: numpy.reference.generated.numpy.recarray.searchsorted\nSnippet: numpy.recarray.searchsorted method recarray.searchsorted(v, side='left', sorter=None) Find indices where elements of v should be inserted in a to maintain order. For full documentation, see numpy.searchsorted See also numpy.searchsorted equivalent function", "score": "0.6870355"}, {"id": "41778", "text": "Function: numpy.reference.generated.numpy.chararray.find\nSnippet: numpy.chararray.find method chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.6827049"}, {"id": "25754", "text": "Function: python.library.stdtypes\nSnippet: bytes or bytearray objects. The separator to search for may be any bytes-like object. bytes.replace(old, new[, count]) bytearray.replace(old, new[, count]) Return a copy of the sequence with all occurrences of subsequence old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. The subsequence to search for and its replacement may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.rfind(sub[, start[, end]]) bytearray.rfind(sub[, start[, end]]) Return the highest index in the sequence where the subsequence sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence. bytes.rindex(sub[, start[, end]]) bytearray.rindex(sub[, start[, end]]) Like rfind() but raises ValueError when the subsequence sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence. bytes.rpartition(sep) bytearray.rpartition(sep) Split the sequence at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself or its bytearray copy, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty bytes or bytearray objects, followed by a copy of the original sequence. The separator to search for may be any bytes-like object. bytes.startswith(prefix[, start[, end]]) bytearray.startswith(prefix[, start[, end]]) Return True if the binary data starts with the specified prefix, otherwise return False. prefix can also be a tuple of prefixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. The prefix(es) to search for may be any bytes-like object. bytes.translate(table, /, delete=b'') bytearray.translate(table, /, delete=b'') Return a copy of the bytes or bytearray object where all bytes occurring in the optional argument delete are removed, and the remaining bytes have been mapped through the given translation table, which must be a bytes object of length 256. You can use the bytes.maketrans() method to create a translation table. Set the table argument to None for translations that only delete characters: >>> b'read this short text'.translate(None, b'aeiou') b'rd ths shrt txt' Changed in version 3.6: delete is now supported as a keyword argument. The following methods on bytes and bytearray objects have default behaviours that assume the use of ASCII compatible binary formats, but can still be used with arbitrary binary data by passing appropriate arguments. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.center(width[, fillbyte]) bytearray.center(width[, fillbyte]) Return a copy of the object centered in", "score": "0.68263155"}, {"id": "18264", "text": "Function: python.library.stdtypes#bytearray.find\nSnippet: bytes.find(sub[, start[, end]]) bytearray.find(sub[, start[, end]]) Return the lowest index in the data where the subsequence sub is found, such that sub is contained in the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> b'Py' in b'Python' True Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.68096036"}]}
{"task_id": "mbpp_281", "code": "def all_unique(test_list):\r\n    if len(test_list) > len(set(test_list)):\r\n        return False\r\n    return True", "test_list": ["assert all_unique([1,2,3]) == True", "assert all_unique([1,2,1,2]) == False", "assert all_unique([1,2,3,4,5]) == True"], "context": "Write a python function to check if the elements of a given list are unique or not.", "function_name": "def all_unique(test_list):", "gold_generation": "if len(test_list) > len(set(test_list)):\r\n        return False\r\n    return True", "ctxs": [{"id": "14723", "text": "Function: pandas.reference.api.pandas.index.is_unique\nSnippet: pandas.Index.is_unique Index.is_unique Return if the index has unique values.", "score": "0.7448126"}, {"id": "15208", "text": "Function: pandas.reference.api.pandas.series.is_unique\nSnippet: pandas.Series.is_unique propertySeries.is_unique Return boolean if values in the object are unique. Returns bool", "score": "0.72092724"}, {"id": "43260", "text": "Function: numpy.reference.generated.numpy.unique\nSnippet: the unique values: >>> a = np.array(['a', 'b', 'b', 'c', 'a']) >>> u, indices = np.unique(a, return_index=True) >>> u array(['a', 'b', 'c'], dtype='<U1') >>> indices array([0, 1, 3]) >>> a[indices] array(['a', 'b', 'c'], dtype='<U1') Reconstruct the input array from the unique values and inverse: >>> a = np.array([1, 2, 6, 4, 2, 3, 2]) >>> u, indices = np.unique(a, return_inverse=True) >>> u array([1, 2, 3, 4, 6]) >>> indices array([0, 1, 4, 3, 1, 2, 1]) >>> u[indices] array([1, 2, 6, 4, 2, 3, 2]) Reconstruct the input values from the unique values and counts: >>> a = np.array([1, 2, 6, 4, 2, 3, 2]) >>> values, counts = np.unique(a, return_counts=True) >>> values array([1, 2, 3, 4, 6]) >>> counts array([1, 3, 1, 1, 1]) >>> np.repeat(values, counts) array([1, 2, 2, 2, 3, 4, 6]) # original order not preserved", "score": "0.70706683"}, {"id": "20109", "text": "Function: python.library.enum#enum.unique\nSnippet: @enum.unique", "score": "0.7035997"}, {"id": "43259", "text": "Function: numpy.reference.generated.numpy.unique\nSnippet: numpy.unique numpy.unique(ar, return_index=False, return_inverse=False, return_counts=False, axis=None)[source] Find the unique elements of an array. Returns the sorted unique elements of an array. There are three optional outputs in addition to the unique elements: the indices of the input array that give the unique values the indices of the unique array that reconstruct the input array the number of times each unique value comes up in the input array Parameters ararray_like Input array. Unless axis is specified, this will be flattened if it is not already 1-D. return_indexbool, optional If True, also return the indices of ar (along the specified axis, if provided, or in the flattened array) that result in the unique array. return_inversebool, optional If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct ar. return_countsbool, optional If True, also return the number of times each unique item appears in ar. New in version 1.9.0. axisint or None, optional The axis to operate on. If None, ar will be flattened. If an integer, the subarrays indexed by the given axis will be flattened and treated as the elements of a 1-D array with the dimension of the given axis, see the notes for more details. Object arrays or structured arrays that contain objects are not supported if the axis kwarg is used. The default is None. New in version 1.13.0. Returns uniquendarray The sorted unique values. unique_indicesndarray, optional The indices of the first occurrences of the unique values in the original array. Only provided if return_index is True. unique_inversendarray, optional The indices to reconstruct the original array from the unique array. Only provided if return_inverse is True. unique_countsndarray, optional The number of times each of the unique values comes up in the original array. Only provided if return_counts is True. New in version 1.9.0. See also numpy.lib.arraysetops Module with a number of other functions for performing set operations on arrays. repeat Repeat elements of an array. Notes When an axis is specified the subarrays indexed by the axis are sorted. This is done by making the specified axis the first dimension of the array (move the axis to the first dimension to keep the order of the other axes) and then flattening the subarrays in C order. The flattened subarrays are then viewed as a structured type with each element given a label, with the effect that we end up with a 1-D array of structured types that can be treated in the same way as any other 1-D array. The result is that the flattened subarrays are sorted in lexicographic order starting with the first element. Examples >>> np.unique([1, 1, 2, 2, 3, 3]) array([1, 2, 3]) >>> a = np.array([[1, 1], [2, 3]]) >>> np.unique(a) array([1, 2, 3]) Return the unique rows of a 2D array >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]]) >>> np.unique(a, axis=0) array([[1, 0, 0], [2, 3, 4]]) Return the indices of the original array that give", "score": "0.69984925"}]}
{"task_id": "mbpp_282", "code": "def sub_list(nums1,nums2):\r\n  result = map(lambda x, y: x - y, nums1, nums2)\r\n  return list(result)", "test_list": ["assert sub_list([1, 2, 3],[4,5,6])==[-3,-3,-3]", "assert sub_list([1,2],[3,4])==[-2,-2]", "assert sub_list([90,120],[50,70])==[40,50]"], "context": "Write a function to substaract two lists using map and lambda function.", "function_name": "def sub_list(nums1,nums2):", "gold_generation": "result = map(lambda x, y: x - y, nums1, nums2)\r\n  return list(result)", "ctxs": [{"id": "18611", "text": "Function: python.library.collections\nSnippet: Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6}) New in version 3.2. The usual dictionary methods are available for Counter objects except for two which work differently for counters. fromkeys(iterable) This class method is not implemented for Counter objects. update([iterable-or-mapping]) Elements are counted from an iterable or added-in from another mapping (or counter). Like dict.update() but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of (key, value) pairs. Common patterns for working with Counter objects: sum(c.values()) # total of all counts c.clear() # reset all counts list(c) # list unique elements set(c) # convert to a set dict(c) # convert to a regular dictionary c.items() # convert to a list of (elem, cnt) pairs Counter(dict(list_of_pairs)) # convert from a list of (elem, cnt) pairs c.most_common()[:-n-1:-1] # n least common elements +c # remove zero and negative counts Several mathematical operations are provided for combining Counter objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. Intersection and union return the minimum and maximum of corresponding counts. Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less. >>> c = Counter(a=3, b=1) >>> d = Counter(a=1, b=2) >>> c + d # add two counters together: c[x] + d[x] Counter({'a': 4, 'b': 3}) >>> c - d # subtract (keeping only positive counts) Counter({'a': 2}) >>> c & d # intersection: min(c[x], d[x]) Counter({'a': 1, 'b': 1}) >>> c | d # union: max(c[x], d[x]) Counter({'a': 3, 'b': 2}) Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter. >>> c = Counter(a=2, b=-4) >>> +c Counter({'a': 2}) >>> -c Counter({'b': 4}) New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations. Note Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values. To help with those use cases, this section documents the minimum range and type restrictions. The Counter class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you could store anything in the value field. The most_common() method requires only that the values be orderable. For in-place operations such as c[key] += 1, the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for update() and subtract() which allow negative and zero", "score": "0.6688463"}, {"id": "18648", "text": "Function: python.library.collections#collections.ChainMap\nSnippet: class collections.ChainMap(*maps) A ChainMap groups multiple dicts or other mappings together to create a single, updateable view. If no maps are specified, a single empty dictionary is provided so that a new chain always has at least one mapping. The underlying mappings are stored in a list. That list is public and can be accessed or updated using the maps attribute. There is no other state. Lookups search the underlying mappings successively until a key is found. In contrast, writes, updates, and deletions only operate on the first mapping. A ChainMap incorporates the underlying mappings by reference. So, if one of the underlying mappings gets updated, those changes will be reflected in ChainMap. All of the usual dictionary methods are supported. In addition, there is a maps attribute, a method for creating new subcontexts, and a property for accessing all but the first mapping: maps A user updateable list of mappings. The list is ordered from first-searched to last-searched. It is the only stored state and can be modified to change which mappings are searched. The list should always contain at least one mapping. new_child(m=None) Returns a new ChainMap containing a new map followed by all of the maps in the current instance. If m is specified, it becomes the new map at the front of the list of mappings; if not specified, an empty dict is used, so that a call to d.new_child() is equivalent to: ChainMap({}, *d.maps). This method is used for creating subcontexts that can be updated without altering values in any of the parent mappings. Changed in version 3.4: The optional m parameter was added. parents Property returning a new ChainMap containing all of the maps in the current instance except the first one. This is useful for skipping the first map in the search. Use cases are similar to those for the nonlocal keyword used in nested scopes. The use cases also parallel those for the built-in super() function. A reference to d.parents is equivalent to: ChainMap(*d.maps[1:]). Note, the iteration order of a ChainMap() is determined by scanning the mappings last to first: >>> baseline = {'music': 'bach', 'art': 'rembrandt'} >>> adjustments = {'art': 'van gogh', 'opera': 'carmen'} >>> list(ChainMap(adjustments, baseline)) ['music', 'art', 'opera'] This gives the same ordering as a series of dict.update() calls starting with the last mapping: >>> combined = baseline.copy() >>> combined.update(adjustments) >>> list(combined) ['music', 'art', 'opera'] Changed in version 3.9: Added support for | and |= operators, specified in PEP 584.", "score": "0.6604464"}, {"id": "21765", "text": "Function: python.library.functions#map\nSnippet: map(function, iterable, ...) Return an iterator that applies function to every item of iterable, yielding the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterator stops when the shortest iterable is exhausted. For cases where the function inputs are already arranged into argument tuples, see itertools.starmap().", "score": "0.6581733"}, {"id": "18661", "text": "Function: python.library.collections#collections.deque\nSnippet: class collections.deque([iterable[, maxlen]]) Returns a new deque object initialized left-to-right (using append()) with data from iterable. If iterable is not specified, the new deque is empty. Deques are a generalization of stacks and queues (the name is pronounced “deck” and is short for “double-ended queue”). Deques support thread-safe, memory efficient appends and pops from either side of the deque with approximately the same O(1) performance in either direction. Though list objects support similar operations, they are optimized for fast fixed-length operations and incur O(n) memory movement costs for pop(0) and insert(0, v) operations which change both the size and position of the underlying data representation. If maxlen is not specified or is None, deques may grow to an arbitrary length. Otherwise, the deque is bounded to the specified maximum length. Once a bounded length deque is full, when new items are added, a corresponding number of items are discarded from the opposite end. Bounded length deques provide functionality similar to the tail filter in Unix. They are also useful for tracking transactions and other pools of data where only the most recent activity is of interest. Deque objects support the following methods: append(x) Add x to the right side of the deque. appendleft(x) Add x to the left side of the deque. clear() Remove all elements from the deque leaving it with length 0. copy() Create a shallow copy of the deque. New in version 3.5. count(x) Count the number of deque elements equal to x. New in version 3.2. extend(iterable) Extend the right side of the deque by appending elements from the iterable argument. extendleft(iterable) Extend the left side of the deque by appending elements from iterable. Note, the series of left appends results in reversing the order of elements in the iterable argument. index(x[, start[, stop]]) Return the position of x in the deque (at or after index start and before index stop). Returns the first match or raises ValueError if not found. New in version 3.5. insert(i, x) Insert x into the deque at position i. If the insertion would cause a bounded deque to grow beyond maxlen, an IndexError is raised. New in version 3.5. pop() Remove and return an element from the right side of the deque. If no elements are present, raises an IndexError. popleft() Remove and return an element from the left side of the deque. If no elements are present, raises an IndexError. remove(value) Remove the first occurrence of value. If not found, raises a ValueError. reverse() Reverse the elements of the deque in-place and then return None. New in version 3.2. rotate(n=1) Rotate the deque n steps to the right. If n is negative, rotate to the left. When the deque is not empty, rotating one step to the right is equivalent to d.appendleft(d.pop()), and rotating one step to the left is equivalent to d.append(d.popleft()). Deque objects also provide one read-only attribute: maxlen Maximum size of a deque or None if unbounded. New in version 3.1.", "score": "0.65323013"}, {"id": "20286", "text": "Function: python.library.functions\nSnippet: values of local and free variables used by the interpreter. map(function, iterable, ...) Return an iterator that applies function to every item of iterable, yielding the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterator stops when the shortest iterable is exhausted. For cases where the function inputs are already arranged into argument tuples, see itertools.starmap(). max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None. class memoryview(obj) Return a “memory view” object created from the given argument. See Memory Views for more information. min(iterable, *[, key, default]) min(arg1, arg2, *args[, key]) Return the smallest item in an iterable or the smallest of two or more arguments. If one positional argument is provided, it should be an iterable. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None. next(iterator[, default]) Retrieve the next item from the iterator by calling its __next__() method. If default is given, it is returned if the iterator is exhausted, otherwise StopIteration is raised. class object Return a new featureless object. object is a base for all classes. It has the methods that are common to all instances of Python classes. This function does not accept any arguments. Note object does not have a __dict__, so you can’t assign arbitrary attributes to an instance of the object class. oct(x) Convert an integer number to an octal string prefixed with “0o”. The result is a valid Python expression. If x", "score": "0.65311766"}]}
{"task_id": "mbpp_283", "code": "def validate(n): \r\n    for i in range(10): \r\n        temp = n;  \r\n        count = 0; \r\n        while (temp): \r\n            if (temp % 10 == i): \r\n                count+=1;  \r\n            if (count > i): \r\n                return False\r\n            temp //= 10; \r\n    return True", "test_list": ["assert validate(1234) == True", "assert validate(51241) == False", "assert validate(321) == True"], "context": "Write a python function to check whether the frequency of each digit is less than or equal to the digit itself.", "function_name": "def validate(n):", "gold_generation": "for i in range(10): \r\n        temp = n;  \r\n        count = 0; \r\n        while (temp): \r\n            if (temp % 10 == i): \r\n                count+=1;  \r\n            if (count > i): \r\n                return False\r\n            temp //= 10; \r\n    return True", "ctxs": [{"id": "14927", "text": "Function: pandas.reference.api.pandas.period.freq\nSnippet: pandas.Period.freq Period.freq", "score": "0.7062704"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.695212"}, {"id": "15446", "text": "Function: pandas.reference.api.pandas.timedelta.freq\nSnippet: pandas.Timedelta.freq Timedelta.freq", "score": "0.69143933"}, {"id": "15497", "text": "Function: pandas.reference.api.pandas.timestamp.freq\nSnippet: pandas.Timestamp.freq Timestamp.freq", "score": "0.6815988"}, {"id": "15131", "text": "Function: pandas.reference.api.pandas.series.dt.freq\nSnippet: pandas.Series.dt.freq Series.dt.freq", "score": "0.68156064"}]}
{"task_id": "mbpp_284", "code": "def check_element(list,element):\r\n  check_element=all(v== element for v in list)\r\n  return check_element", "test_list": ["assert check_element([\"green\", \"orange\", \"black\", \"white\"],'blue')==False", "assert check_element([1,2,3,4],7)==False", "assert check_element([\"green\", \"green\", \"green\", \"green\"],'green')==True"], "context": "Write a function to check whether all items of a list are equal to a given string.", "function_name": "def check_element(list,element):", "gold_generation": "check_element=all(v== element for v in list)\r\n  return check_element", "ctxs": [{"id": "17577", "text": "Function: python.library.functions#all\nSnippet: all(iterable) Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to: def all(iterable): for element in iterable: if not element: return False return True", "score": "0.7218923"}, {"id": "42786", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.is_string\nSnippet: numpy.distutils.misc_util.is_string(s)[source]", "score": "0.7005857"}, {"id": "17578", "text": "Function: python.library.functions#any\nSnippet: any(iterable) Return True if any element of the iterable is true. If the iterable is empty, return False. Equivalent to: def any(iterable): for element in iterable: if element: return True return False", "score": "0.69980204"}, {"id": "17646", "text": "Function: python.library.array#array.array.tolist\nSnippet: array.tolist() Convert the array to an ordinary list with the same items.", "score": "0.6966891"}, {"id": "26089", "text": "Function: python.library.unittest#unittest.TestCase.assertListEqual\nSnippet: assertListEqual(first, second, msg=None) assertTupleEqual(first, second, msg=None) Tests that two lists or tuples are equal. If not, an error message is constructed that shows only the differences between the two. An error is also raised if either of the parameters are of the wrong type. These methods are used by default when comparing lists or tuples with assertEqual(). New in version 3.1.", "score": "0.6881913"}]}
{"task_id": "mbpp_285", "code": "import re\r\ndef text_match_two_three(text):\r\n        patterns = 'ab{2,3}'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')", "test_list": ["assert text_match_two_three(\"ac\")==('Not matched!')", "assert text_match_two_three(\"dc\")==('Not matched!')", "assert text_match_two_three(\"abbbba\")==('Found a match!')"], "context": "Write a function that matches a string that has an a followed by two to three 'b'.", "function_name": "import re\r\ndef text_match_two_three(text):", "gold_generation": "patterns = 'ab{2,3}'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')", "ctxs": [{"id": "23301", "text": "Function: python.library.re\nSnippet: repetitions as possible. For example, a{3,5} will match from 3 to 5 'a' characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, a{4,}b will match 'aaaab' or a thousand 'a' characters followed by a 'b', but not 'aaab'. The comma may not be omitted or the modifier would be confused with the previously described form. {m,n}? Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous qualifier. For example, on the 6-character string 'aaaaaa', a{3,5} will match 5 'a' characters, while a{3,5}? will only match 3 characters. \\ Either escapes special characters (permitting you to match characters like '*', '?', and so forth), or signals a special sequence; special sequences are discussed below. If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions. [] Used to indicate a set of characters. In a set: Characters can be listed individually, e.g. [amk] will match 'a', 'm', or 'k'. Ranges of characters can be indicated by giving two characters and separating them by a '-', for example [a-z] will match any lowercase ASCII letter, [0-5][0-9] will match all the two-digits numbers from 00 to 59, and [0-9A-Fa-f] will match any hexadecimal digit. If - is escaped (e.g. [a\\-z]) or if it’s placed as the first or last character (e.g. [-a] or [a-]), it will match a literal '-'. Special characters lose their special meaning inside sets. For example, [(+*)] will match any of the literal characters '(', '+', '*', or ')'. Character classes such as \\w or \\S (defined below) are also accepted inside a set, although the characters they match depends on whether ASCII or LOCALE mode is in force. Characters that are not within a range can be matched by complementing the set. If the first character of the set is '^', all the characters that are not in the set will be matched. For example, [^5] will match any character except '5', and [^^] will match any character except '^'. ^ has no special meaning if it’s not the first character in the set. To match a literal ']' inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both [()[\\]{}] and []()[{}] will both match a parenthesis. Support of nested sets and set operations as in Unicode Technical Standard #18 might be added in the future. This would change the syntax, so to facilitate this change", "score": "0.70986074"}, {"id": "23300", "text": "Function: python.library.re\nSnippet: For further information and a gentler presentation, consult the Regular Expression HOWTO. Regular expressions can contain both special and ordinary characters. Most ordinary characters, like 'A', 'a', or '0', are the simplest regular expressions; they simply match themselves. You can concatenate ordinary characters, so last matches the string 'last'. (In the rest of this section, we’ll write RE’s in this special style, usually without quotes, and strings to be matched 'in single quotes'.) Some characters, like '|' or '(', are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. Repetition qualifiers (*, +, ?, {m,n}, etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix ?, and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression (?:a{6})* matches any multiple of six 'a' characters. The special characters are: . (Dot.) In the default mode, this matches any character except a newline. If the DOTALL flag has been specified, this matches any character including a newline. ^ (Caret.) Matches the start of the string, and in MULTILINE mode also matches immediately after each newline. $ Matches the end of the string or just before the newline at the end of the string, and in MULTILINE mode also matches before a newline. foo matches both ‘foo’ and ‘foobar’, while the regular expression foo$ matches only ‘foo’. More interestingly, searching for foo.$ in 'foo1\\nfoo2\\n' matches ‘foo2’ normally, but ‘foo1’ in MULTILINE mode; searching for a single $ in 'foo\\n' will find two (empty) matches: one just before the newline, and one at the end of the string. * Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. ab* will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s. + Causes the resulting RE to match 1 or more repetitions of the preceding RE. ab+ will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’. ? Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. ab? will match either ‘a’ or ‘ab’. *?, +?, ?? The '*', '+', and '?' qualifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE <.*> is matched against '<a> b <c>', it will match the entire string, and not just '<a>'. Adding ? after the qualifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using the RE <.*?> will match only '<a>'. {m} Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, a{6} will match exactly six 'a' characters, but not five. {m,n} Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many", "score": "0.6981738"}, {"id": "23304", "text": "Function: python.library.re\nSnippet: Similar to positive lookbehind assertions, the contained pattern must only match strings of some fixed length. Patterns which start with negative lookbehind assertions may match at the beginning of the string being searched. (?(id/name)yes-pattern|no-pattern) Will try to match with yes-pattern if the group with given id or name exists, and with no-pattern if it doesn’t. no-pattern is optional and can be omitted. For example, (<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$) is a poor email matching pattern, which will match with '<user@host.com>' as well as 'user@host.com', but not with '<user@host.com' nor 'user@host.com>'. The special sequences consist of '\\' and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, \\$ matches the character '$'. \\number Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, (.+) \\1 matches 'the the' or '55 55', but not 'thethe' (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the '[' and ']' of a character class, all numeric escapes are treated as characters. \\A Matches only at the start of the string. \\b Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of word characters. Note that formally, \\b is defined as the boundary between a \\w and a \\W character (or vice versa), or between \\w and the beginning/end of the string. This means that r'\\bfoo\\b' matches 'foo', 'foo.', '(foo)', 'bar foo baz' but not 'foobar' or 'foo3'. By default Unicode alphanumerics are the ones used in Unicode patterns, but this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. Inside a character range, \\b represents the backspace character, for compatibility with Python’s string literals. \\B Matches the empty string, but only when it is not at the beginning or end of a word. This means that r'py\\B' matches 'python', 'py3', 'py2', but not 'py', 'py.', or 'py!'. \\B is just the opposite of \\b, so word characters in Unicode patterns are Unicode alphanumerics or the underscore, although this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. \\d For Unicode (str) patterns: Matches any Unicode decimal digit (that is, any character in Unicode character category [Nd]). This includes [0-9], and also many other digit characters. If the ASCII flag is used only [0-9] is matched. For 8-bit (bytes) patterns: Matches any decimal digit; this is equivalent to [0-9]. \\D Matches any character which is not a decimal digit. This is the opposite of \\d. If the", "score": "0.68348545"}, {"id": "23309", "text": "Function: python.library.re\nSnippet: are replaced only when not adjacent to a previous empty match, so sub('x*', '-', 'abxd') returns '-a-b--d-'. In string-type repl arguments, in addition to the character escapes and backreferences described above, \\g<name> will use the substring matched by the group named name, as defined by the (?P<name>...) syntax. \\g<number> uses the corresponding group number; \\g<2> is therefore equivalent to \\2, but isn’t ambiguous in a replacement such as \\g<2>0. \\20 would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character '0'. The backreference \\g<0> substitutes in the entire substring matched by the RE. Changed in version 3.1: Added the optional flags argument. Changed in version 3.5: Unmatched groups are replaced with an empty string. Changed in version 3.6: Unknown escapes in pattern consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Unknown escapes in repl consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Empty matches for the pattern are replaced when adjacent to a previous non-empty match. re.subn(pattern, repl, string, count=0, flags=0) Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Changed in version 3.1: Added the optional flags argument. Changed in version 3.5: Unmatched groups are replaced with an empty string. re.escape(pattern) Escape special characters in pattern. This is useful if you want to match an arbitrary literal string that may have regular expression metacharacters in it. For example: >>> print(re.escape('http://www.python.org')) http://www\\.python\\.org >>> legal_chars = string.ascii_lowercase + string.digits + \"!#$%&'*+-.^_`|~:\" >>> print('[%s]+' % re.escape(legal_chars)) [abcdefghijklmnopqrstuvwxyz0123456789!\\#\\$%\\&'\\*\\+\\-\\.\\^_`\\|\\~:]+ >>> operators = ['+', '-', '*', '/', '**'] >>> print('|'.join(map(re.escape, sorted(operators, reverse=True)))) /|\\-|\\+|\\*\\*|\\* This function must not be used for the replacement string in sub() and subn(), only backslashes should be escaped. For example: >>> digits_re = r'\\d+' >>> sample = '/usr/sbin/sendmail - 0 errors, 12 warnings' >>> print(re.sub(digits_re, digits_re.replace('\\\\', r'\\\\'), sample)) /usr/sbin/sendmail - \\d+ errors, \\d+ warnings Changed in version 3.3: The '_' character is no longer escaped. Changed in version 3.7: Only characters that can have special meaning in a regular expression are escaped. As a result, '!', '\"', '%', \"'\", ',', '/', ':', ';', '<', '=', '>', '@', and \"`\" are no longer escaped. re.purge() Clear the regular expression cache. exception re.error(msg, pattern=None, pos=None) Exception raised when a string passed to one of the functions here is not a valid regular expression (for example, it might contain unmatched parentheses) or when some other error occurs during compilation or matching. It is never an error if a string contains no match for a pattern. The error instance has the following additional attributes: msg The unformatted error message. pattern The regular expression pattern. pos The index in pattern where compilation failed (may be None). lineno The line corresponding to pos (may be None). colno The column corresponding to pos (may be None). Changed in version 3.5: Added additional attributes. Regular Expression Objects Compiled regular expression objects support the following methods and attributes: Pattern.search(string[, pos[, endpos]]) Scan through string looking", "score": "0.67560613"}, {"id": "23341", "text": "Function: python.library.re#re.Match.group\nSnippet: Match.group([group1, ...]) Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an IndexError exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is None. If a group is contained in a part of the pattern that matched multiple times, the last match is returned. >>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\") >>> m.group(0) # The entire match 'Isaac Newton' >>> m.group(1) # The first parenthesized subgroup. 'Isaac' >>> m.group(2) # The second parenthesized subgroup. 'Newton' >>> m.group(1, 2) # Multiple arguments give us a tuple. ('Isaac', 'Newton') If the regular expression uses the (?P<name>...) syntax, the groupN arguments may also be strings identifying groups by their group name. If a string argument is not used as a group name in the pattern, an IndexError exception is raised. A moderately complicated example: >>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm Reynolds\") >>> m.group('first_name') 'Malcolm' >>> m.group('last_name') 'Reynolds' Named groups can also be referred to by their index: >>> m.group(1) 'Malcolm' >>> m.group(2) 'Reynolds' If a group matches multiple times, only the last match is accessible: >>> m = re.match(r\"(..)+\", \"a1b2c3\") # Matches 3 times. >>> m.group(1) # Returns only the last match. 'c3'", "score": "0.6733595"}]}
{"task_id": "mbpp_286", "code": "def max_sub_array_sum_repeated(a, n, k): \r\n\tmax_so_far = -2147483648\r\n\tmax_ending_here = 0\r\n\tfor i in range(n*k): \r\n\t\tmax_ending_here = max_ending_here + a[i%n] \r\n\t\tif (max_so_far < max_ending_here): \r\n\t\t\tmax_so_far = max_ending_here \r\n\t\tif (max_ending_here < 0): \r\n\t\t\tmax_ending_here = 0\r\n\treturn max_so_far", "test_list": ["assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30", "assert max_sub_array_sum_repeated([-1, 10, 20], 3, 2) == 59", "assert max_sub_array_sum_repeated([-1, -2, -3], 3, 3) == -1"], "context": "Write a function to find the largest sum of contiguous array in the modified array which is formed by repeating the given array k times.", "function_name": "def max_sub_array_sum_repeated(a, n, k):", "gold_generation": "max_so_far = -2147483648\r\n\tmax_ending_here = 0\r\n\tfor i in range(n*k): \r\n\t\tmax_ending_here = max_ending_here + a[i%n] \r\n\t\tif (max_so_far < max_ending_here): \r\n\t\t\tmax_so_far = max_ending_here \r\n\t\tif (max_ending_here < 0): \r\n\t\t\tmax_ending_here = 0\r\n\treturn max_so_far", "ctxs": [{"id": "42807", "text": "Function: numpy.reference.generated.numpy.einsum\nSnippet: 64], [13, 40, 67, 94]]) >>> np.einsum('k...,jk', a, b) array([[10, 28, 46, 64], [13, 40, 67, 94]]) Chained array operations. For more complicated contractions, speed ups might be achieved by repeatedly computing a ‘greedy’ path or pre-computing the ‘optimal’ path and repeatedly applying it, using an einsum_path insertion (since version 1.12.0). Performance improvements can be particularly significant with larger arrays: >>> a = np.ones(64).reshape(2,4,8) Basic einsum: ~1520ms (benchmarked on 3.1GHz Intel i5.) >>> for iteration in range(500): ... _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a) Sub-optimal einsum (due to repeated path calculation time): ~330ms >>> for iteration in range(500): ... _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal') Greedy einsum (faster optimal path approximation): ~160ms >>> for iteration in range(500): ... _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='greedy') Optimal einsum (best usage pattern in some use cases): ~110ms >>> path = np.einsum_path('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')[0] >>> for iteration in range(500): ... _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize=path)", "score": "0.6539291"}, {"id": "21316", "text": "Function: python.library.itertools#itertools.zip_longest\nSnippet: itertools.zip_longest(*iterables, fillvalue=None) Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. Roughly equivalent to: def zip_longest(*args, fillvalue=None): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- iterators = [iter(it) for it in args] num_active = len(iterators) if not num_active: return while True: values = [] for i, it in enumerate(iterators): try: value = next(it) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values.append(value) yield tuple(values) If one of the iterables is potentially infinite, then the zip_longest() function should be wrapped with something that limits the number of calls (for example islice() or takewhile()). If not specified, fillvalue defaults to None.", "score": "0.64632857"}, {"id": "42123", "text": "Function: numpy.reference.generated.numpy.ma.cumsum\nSnippet: numpy.ma.cumsum ma.cumsum(self, axis=None, dtype=None, out=None) = <numpy.ma.core._frommethod object> Return the cumulative sum of the array elements over the given axis. Masked values are set to 0 internally during the computation. However, their position is saved, and the result will be masked at the same locations. Refer to numpy.cumsum for full documentation. See also numpy.ndarray.cumsum corresponding function for ndarrays numpy.cumsum equivalent function Notes The mask is lost if out is not a valid ma.MaskedArray ! Arithmetic is modular when using integer types, and no error is raised on overflow. Examples >>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0]) >>> marr.cumsum() masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33], mask=[False, False, False, True, True, True, False, False, False, False], fill_value=999999)", "score": "0.642115"}, {"id": "43147", "text": "Function: numpy.reference.generated.numpy.recarray\nSnippet: Peak to peak (maximum - minimum) value along a given axis. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. reshape(shape[, order]) Returns an array containing the same data with a new shape. resize(new_shape[, refcheck]) Change shape and size of array in-place. round([decimals, out]) Return a with each element rounded to the given number of decimals. searchsorted(v[, side, sorter]) Find indices where elements of v should be inserted in a to maintain order. setfield(val, dtype[, offset]) Put a value into a specified place in a field defined by a data-type. setflags([write, align, uic]) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. sort([axis, kind, order]) Sort an array in-place. squeeze([axis]) Remove axes of length one from a. std([axis, dtype, out, ddof, keepdims, where]) Returns the standard deviation of the array elements along given axis. sum([axis, dtype, out, keepdims, initial, where]) Return the sum of the array elements over the given axis. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. tobytes([order]) Construct Python bytes containing the raw data bytes in the array. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. trace([offset, axis1, axis2, dtype, out]) Return the sum along diagonals of the array. transpose(*axes) Returns a view of the array with axes transposed. var([axis, dtype, out, ddof, keepdims, where]) Returns the variance of the array elements, along given axis. view([dtype][, type]) New view of array with the same data. dot field", "score": "0.64180326"}, {"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.6415436"}]}
{"task_id": "mbpp_287", "code": "def square_Sum(n):  \r\n    return int(2*n*(n+1)*(2*n+1)/3)", "test_list": ["assert square_Sum(2) == 20", "assert square_Sum(3) == 56", "assert square_Sum(4) == 120"], "context": "Write a python function to find the sum of squares of first n even natural numbers.", "function_name": "def square_Sum(n):", "gold_generation": "return int(2*n*(n+1)*(2*n+1)/3)", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.66626084"}, {"id": "43202", "text": "Function: numpy.reference.generated.numpy.square\nSnippet: numpy.square numpy.square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'square'> Return the element-wise square of the input. Parameters xarray_like Input data. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Element-wise x*x, of the same shape and dtype as x. This is a scalar if x is a scalar. See also numpy.linalg.matrix_power sqrt power Examples >>> np.square([-1j, 1]) array([-1.-0.j, 1.+0.j])", "score": "0.66205525"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6589514"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.65470856"}, {"id": "21812", "text": "Function: python.library.math#math.isqrt\nSnippet: math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8.", "score": "0.6510297"}]}
{"task_id": "mbpp_288", "code": "def modular_inverse(arr, N, P):\r\n\tcurrent_element = 0\r\n\tfor i in range(0, N):\r\n\t\tif ((arr[i] * arr[i]) % P == 1):\r\n\t\t\tcurrent_element = current_element + 1\r\n\treturn current_element", "test_list": ["assert modular_inverse([ 1, 6, 4, 5 ], 4, 7) == 2", "assert modular_inverse([1, 3, 8, 12, 12], 5, 13) == 3", "assert modular_inverse([2, 3, 4, 5], 4, 6) == 1"], "context": "Write a function to count array elements having modular inverse under given prime number p equal to itself.", "function_name": "def modular_inverse(arr, N, P):", "gold_generation": "current_element = 0\r\n\tfor i in range(0, N):\r\n\t\tif ((arr[i] * arr[i]) % P == 1):\r\n\t\t\tcurrent_element = current_element + 1\r\n\treturn current_element", "ctxs": [{"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.67256093"}, {"id": "42240", "text": "Function: numpy.reference.generated.numpy.ma.maskedarray.__xor__\nSnippet: numpy.ma.MaskedArray.__xor__ method ma.MaskedArray.__xor__(value, /) Return self^value.", "score": "0.66733265"}, {"id": "8202", "text": "Function: torch.generated.torch.unique_consecutive#torch.unique_consecutive\nSnippet: torch.unique_consecutive(*args, **kwargs) Eliminates all but the first element from every consecutive group of equivalent elements. Note This function is different from torch.unique() in the sense that this function only eliminates consecutive duplicate values. This semantics is similar to std::unique in C++. Parameters input (Tensor) – the input tensor return_inverse (bool) – Whether to also return the indices for where elements in the original input ended up in the returned unique list. return_counts (bool) – Whether to also return the counts for each unique element. dim (int) – the dimension to apply unique. If None, the unique of the flattened input is returned. default: None Returns A tensor or a tuple of tensors containing output (Tensor): the output list of unique scalar elements. inverse_indices (Tensor): (optional) if return_inverse is True, there will be an additional returned tensor (same shape as input) representing the indices for where elements in the original input map to in the output; otherwise, this function will only return a single tensor. counts (Tensor): (optional) if return_counts is True, there will be an additional returned tensor (same shape as output or output.size(dim), if dim was specified) representing the number of occurrences for each unique value or tensor. Return type (Tensor, Tensor (optional), Tensor (optional)) Example: >>> x = torch.tensor([1, 1, 2, 2, 3, 1, 1, 2]) >>> output = torch.unique_consecutive(x) >>> output tensor([1, 2, 3, 1, 2]) >>> output, inverse_indices = torch.unique_consecutive(x, return_inverse=True) >>> output tensor([1, 2, 3, 1, 2]) >>> inverse_indices tensor([0, 0, 1, 1, 2, 3, 3, 4]) >>> output, counts = torch.unique_consecutive(x, return_counts=True) >>> output tensor([1, 2, 3, 1, 2]) >>> counts tensor([2, 2, 1, 2, 1])", "score": "0.6628698"}, {"id": "20290", "text": "Function: python.library.functions\nSnippet: integer representing the Unicode code point of that character. For example, ord('a') returns the integer 97 and ord('€') (Euro sign) returns 8364. This is the inverse of chr(). pow(base, exp[, mod]) Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp. The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10**2 returns 100, but 10**-2 returns 0.01. For int operands base and exp, if mod is present, mod must also be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod. In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod. Here’s an example of computing an inverse for 38 modulo 97: >>> pow(38, -1, mod=97) 23 >>> 23 * 38 % 97 == 1 True Changed in version 3.8: For int operands, the three-argument form of pow now allows the second argument to be negative, permitting computation of modular inverses. Changed in version 3.8: Allow keyword arguments. Formerly, only positional arguments were supported. print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False) Print objects to the text stream file, separated by sep and followed by end. sep, end, file and flush, if present, must be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end. The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Since printed arguments are converted to text strings, print() cannot be used with binary mode file objects. For these, use file.write(...) instead. Whether output is buffered is usually determined by file, but if the flush keyword argument is true, the stream is forcibly flushed. Changed in version 3.3: Added the flush keyword argument. class property(fget=None, fset=None, fdel=None, doc=None) Return a property attribute. fget is a function for getting an attribute value. fset is a function for setting an attribute value. fdel is a function for deleting an attribute value. And doc creates a docstring for the attribute. A typical use is to define a managed attribute x: class C: def __init__(self): self._x = None def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") If c is an instance of C, c.x", "score": "0.65695035"}, {"id": "23150", "text": "Function: python.library.functions#pow\nSnippet: pow(base, exp[, mod]) Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp. The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10**2 returns 100, but 10**-2 returns 0.01. For int operands base and exp, if mod is present, mod must also be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod. In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod. Here’s an example of computing an inverse for 38 modulo 97: >>> pow(38, -1, mod=97) 23 >>> 23 * 38 % 97 == 1 True Changed in version 3.8: For int operands, the three-argument form of pow now allows the second argument to be negative, permitting computation of modular inverses. Changed in version 3.8: Allow keyword arguments. Formerly, only positional arguments were supported.", "score": "0.6501692"}]}
{"task_id": "mbpp_289", "code": "def odd_Days(N): \r\n    hund1 = N // 100\r\n    hund4 = N // 400\r\n    leap = N >> 2\r\n    ordd = N - leap \r\n    if (hund1): \r\n        ordd += hund1 \r\n        leap -= hund1 \r\n    if (hund4): \r\n        ordd -= hund4 \r\n        leap += hund4 \r\n    days = ordd + leap * 2\r\n    odd = days % 7\r\n    return odd ", "test_list": ["assert odd_Days(100) == 5", "assert odd_Days(50) ==6", "assert odd_Days(75) == 2"], "context": "Write a python function to calculate the number of odd days in a given year.", "function_name": "def odd_Days(N):", "gold_generation": "hund1 = N // 100\r\n    hund4 = N // 400\r\n    leap = N >> 2\r\n    ordd = N - leap \r\n    if (hund1): \r\n        ordd += hund1 \r\n        leap -= hund1 \r\n    if (hund4): \r\n        ordd -= hund4 \r\n        leap += hund4 \r\n    days = ordd + leap * 2\r\n    odd = days % 7\r\n    return odd", "ctxs": [{"id": "19302", "text": "Function: python.library.datetime#datetime.date.day\nSnippet: date.day Between 1 and the number of days in the given month of the given year.", "score": "0.73785585"}, {"id": "19328", "text": "Function: python.library.datetime#datetime.datetime.day\nSnippet: datetime.day Between 1 and the number of days in the given month of the given year.", "score": "0.726069"}, {"id": "18395", "text": "Function: python.library.calendar#calendar.leapdays\nSnippet: calendar.leapdays(y1, y2) Returns the number of leap years in the range from y1 to y2 (exclusive), where y1 and y2 are years. This function works for ranges spanning a century change.", "score": "0.7153349"}, {"id": "16480", "text": "Function: pandas.reference.api.pandas.tseries.offsets.yearbegin.n\nSnippet: pandas.tseries.offsets.YearBegin.n YearBegin.n", "score": "0.71237475"}, {"id": "19320", "text": "Function: python.library.datetime#datetime.date.year\nSnippet: date.year Between MINYEAR and MAXYEAR inclusive.", "score": "0.7083185"}]}
{"task_id": "mbpp_290", "code": "def max_length(list1):\r\n    max_length = max(len(x) for x in  list1 )  \r\n    max_list = max((x) for x in   list1)\r\n    return(max_length, max_list)", "test_list": ["assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])", "assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])", "assert max_length([[5], [15,20,25]])==(3, [15,20,25])"], "context": "Write a function to find the list of lists with maximum length.", "function_name": "def max_length(list1):", "gold_generation": "max_length = max(len(x) for x in  list1 )  \r\n    max_list = max((x) for x in   list1)\r\n    return(max_length, max_list)", "ctxs": [{"id": "18671", "text": "Function: python.library.collections#collections.deque.maxlen\nSnippet: maxlen Maximum size of a deque or None if unbounded. New in version 3.1.", "score": "0.6980543"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.68939507"}, {"id": "21316", "text": "Function: python.library.itertools#itertools.zip_longest\nSnippet: itertools.zip_longest(*iterables, fillvalue=None) Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. Roughly equivalent to: def zip_longest(*args, fillvalue=None): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- iterators = [iter(it) for it in args] num_active = len(iterators) if not num_active: return while True: values = [] for i, it in enumerate(iterators): try: value = next(it) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values.append(value) yield tuple(values) If one of the iterables is potentially infinite, then the zip_longest() function should be wrapped with something that limits the number of calls (for example islice() or takewhile()). If not specified, fillvalue defaults to None.", "score": "0.68079644"}, {"id": "20457", "text": "Function: python.library.hashlib#hashlib.blake2b.MAX_KEY_SIZE\nSnippet: blake2b.MAX_KEY_SIZE", "score": "0.6797281"}, {"id": "23417", "text": "Function: python.library.reprlib#reprlib.Repr.maxlist\nSnippet: Repr.maxdict Repr.maxlist Repr.maxtuple Repr.maxset Repr.maxfrozenset Repr.maxdeque Repr.maxarray Limits on the number of entries represented for the named object type. The default is 4 for maxdict, 5 for maxarray, and 6 for the others.", "score": "0.67930377"}]}
{"task_id": "mbpp_291", "code": "def count_no_of_ways(n, k): \r\n\tdp = [0] * (n + 1) \r\n\ttotal = k \r\n\tmod = 1000000007\r\n\tdp[1] = k \r\n\tdp[2] = k * k\t \r\n\tfor i in range(3,n+1): \r\n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \r\n\treturn dp[n]", "test_list": ["assert count_no_of_ways(2, 4) == 16", "assert count_no_of_ways(3, 2) == 6", "assert count_no_of_ways(4, 4) == 228"], "context": "Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.", "function_name": "def count_no_of_ways(n, k):", "gold_generation": "dp = [0] * (n + 1) \r\n\ttotal = k \r\n\tmod = 1000000007\r\n\tdp[1] = k \r\n\tdp[2] = k * k\t \r\n\tfor i in range(3,n+1): \r\n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \r\n\treturn dp[n]", "ctxs": [{"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.64643586"}, {"id": "33484", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs\nSnippet: barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If this is not set (and *C* has\\n not either) then *flagcolor* will be set to match *barbcolor* so that the\\n barb has a uniform color. If *C* has been set, *flagcolor* has no effect.\\n\\nsizes : dict, optional\\n A dictionary of coefficients specifying the ratio of a given\\n feature to the length of the barb. Only those values one wishes to\\n override need to be included. These features include:\\n\\n - \\'spacing\\' - space between features (flags, full/half barbs)\\n - \\'height\\' - height (distance from shaft to top) of a flag or full barb\\n - \\'width\\' - width of a flag, twice the width of a full barb\\n - \\'emptybarb\\' - radius of the circle used for low magnitudes\\n\\nfill_empty : bool, default: False\\n Whether the empty barbs (circles) that are drawn should be filled with\\n the flag color. If they are not filled, the center is transparent.\\n\\nrounding : bool, default: True\\n Whether the vector magnitude should be rounded when allocating barb\\n components. If True, the magnitude is rounded to the nearest multiple\\n of the half-barb increment. If False, the magnitude is simply truncated\\n to the next lowest multiple.\\n\\nbarb_increments : dict, optional\\n A dictionary of increments specifying values to associate with\\n different parts of the barb. Only those values one wishes to\\n override need to be included.\\n\\n - \\'half\\' - half barbs (Default is 5)\\n - \\'full\\' - full barbs (Default is 10)\\n - \\'flag\\' - flags (default is 50)\\n\\nflip_barb : bool or array-like of bool, default: False\\n Whether the lines and flags should point opposite to normal.\\n Normal behavior is for the barbs and lines to point right (comes from wind\\n barbs having these features point towards low pressure in the Northern\\n Hemisphere).\\n\\n A single value is applied to all barbs. Individual barbs can be flipped by\\n passing a bool array of the same size as *U* and *V*.\\n\\nReturns\\n-------\\nbarbs : `~matplotlib.quiver.Barbs`\\n\\nOther Parameters\\n----------------\\ndata : indexable object, optional\\n DATA_PARAMETER_PLACEHOLDER\\n\\n**kwargs\\n The barbs can further be customized using `.PolyCollection` keyword\\n arguments:\\n\\n \\n .. table::\\n :class: property-table\\n\\n ================================================================================================= =====================================================================================================\\n Property Description \\n ================================================================================================= =====================================================================================================\\n", "score": "0.63828635"}, {"id": "33501", "text": "Function: matplotlib._as_gen.matplotlib.quiver.quiver#matplotlib.quiver.Quiver.quiver_doc\nSnippet: quiver_doc=\"\\nPlot a 2D field of arrows.\\n\\nCall signature::\\n\\n quiver([X, Y], U, V, [C], **kw)\\n\\n*X*, *Y* define the arrow locations, *U*, *V* define the arrow directions, and\\n*C* optionally sets the color.\\n\\nEach arrow is internally represented by a filled polygon with a default edge\\nlinewidth of 0. As a result, an arrow is rather a filled area, not a line with\\na head, and `.PolyCollection` properties like *linewidth*, *linestyle*,\\n*facecolor*, etc. act accordingly.\\n\\n**Arrow size**\\n\\nThe default settings auto-scales the length of the arrows to a reasonable size.\\nTo change this behavior see the *scale* and *scale_units* parameters.\\n\\n**Arrow shape**\\n\\nThe defaults give a slightly swept-back arrow; to make the head a\\ntriangle, make *headaxislength* the same as *headlength*. To make the\\narrow more pointed, reduce *headwidth* or increase *headlength* and\\n*headaxislength*. To make the head smaller relative to the shaft,\\nscale down all the head parameters. You will probably do best to leave\\nminshaft alone.\\n\\n**Arrow outline**\\n\\n*linewidths* and *edgecolors* can be used to customize the arrow\\noutlines.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the arrow locations.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y direction components of the arrow vectors.\\n\\n They must have the same number of elements, matching the number of arrow\\n locations. *U* and *V* may be masked. Only locations unmasked in\\n *U*, *V*, and *C* will be drawn.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the arrow colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *color* instead. The size of *C* must match the number of arrow\\n locations.\\n\\nunits : {'width', 'height', 'dots', 'inches', 'x', 'y', 'xy'}, default: 'width'\\n The arrow dimensions (except for *length*) are measured in multiples of\\n this unit.\\n\\n The following values are supported:\\n\\n - 'width', 'height': The width or height of the axis.\\n - 'dots', 'inches': Pixels or inches based on the figure dpi.\\n - 'x', 'y', 'xy': *X*, *Y* or :math:`\\\\sqrt{X^2 + Y^2}` in data units.\\n\\n The arrows scale differently depending on the units. For\\n 'x' or 'y', the arrows get larger as one zooms in; for other\\n units, the arrow size is independent of the zoom state. For\\n 'width or 'height', the arrow size increases with the width and\\n height of the axes, respectively, when the window is resized;\\n for 'dots' or 'inches', resizing does not change the arrows.\\n\\nangles : {'uv', 'xy'} or array-like, default: 'uv'\\n Method for determining the angle of the arrows.\\n\\n - 'uv': The arrow axis aspect ratio is 1 so that\\n if *U* == *V* the orientation of the arrow on the plot is 45 degrees\\n counter-clockwise from the horizontal axis (positive to the right).\\n\\n Use this if the arrows", "score": "0.6209119"}, {"id": "13179", "text": "Function: pygame.ref.draw\nSnippet: the given surface. The line has a thickness of one pixel and the endpoints have a height and width of one pixel each. The way a line and it's endpoints are drawn: If both endpoints are equal, only a single pixel is drawn (after rounding floats to nearest integer). Otherwise if the line is not steep (i.e. if the length along the x-axis is greater than the height along the y-axis): For each endpoint: If x, the endpoint's x-coordinate, is a whole number find which pixels would be covered by it and draw them. Otherwise: Calculate the position of the nearest point with a whole number for it's x-coordinate, when extending the line past the endpoint. Find which pixels would be covered and how much by that point. If the endpoint is the left one, multiply the coverage by (1 - the decimal part of x). Otherwise multiply the coverage by the decimal part of x. Then draw those pixels. e.g.: The left endpoint of the line ((1, 1.3), (5, 3)) would cover 70% of the pixel (1, 1) and 30% of the pixel (1, 2) while the right one would cover 100% of the pixel (5, 3). The left endpoint of the line ((1.2, 1.4), (4.6, 3.1)) would cover 56% (i.e. 0.8 * 70%) of the pixel (1, 1) and 24% (i.e. 0.8 * 30%) of the pixel (1, 2) while the right one would cover 42% (i.e. 0.6 * 70%) of the pixel (5, 3) and 18% (i.e. 0.6 * 30%) of the pixel (5, 4) while the right Then for each point between the endpoints, along the line, whose x-coordinate is a whole number: Find which pixels would be covered and how much by that point and draw them. e.g.: The points along the line ((1, 1), (4, 2.5)) would be (2, 1.5) and (3, 2) and would cover 50% of the pixel (2, 1), 50% of the pixel (2, 2) and 100% of the pixel (3, 2). The points along the line ((1.2, 1.4), (4.6, 3.1)) would be (2, 1.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)), (3, 2.3) (covering 70% of the pixel (3, 2) and 30% of the pixel (3, 3)) and (4, 2.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)) Otherwise do the same for steep lines as for non-steep lines except along the y-axis instead of the x-axis (using y instead of x, top instead of left and bottom instead of right). Note Regarding float values for coordinates, a point with coordinate consisting of two whole numbers is considered being right in the center of said pixel (and having a height and width of 1 pixel would therefore completely cover it), while a point with coordinate where one (or both) of the numbers have non-zero decimal parts would be partially covering two (or four if both numbers have decimal parts) adjacent pixels, e.g. the point (1.4, 2) covers", "score": "0.6193155"}, {"id": "33488", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: this is not set (and *C* has\\n not either) then *flagcolor* will be set to match *barbcolor* so that the\\n barb has a uniform color. If *C* has been set, *flagcolor* has no effect.\\n\\nsizes : dict, optional\\n A dictionary of coefficients specifying the ratio of a given\\n feature to the length of the barb. Only those values one wishes to\\n override need to be included. These features include:\\n\\n - \\'spacing\\' - space between features (flags, full/half barbs)\\n - \\'height\\' - height (distance from shaft to top) of a flag or full barb\\n - \\'width\\' - width of a flag, twice the width of a full barb\\n - \\'emptybarb\\' - radius of the circle used for low magnitudes\\n\\nfill_empty : bool, default: False\\n Whether the empty barbs (circles) that are drawn should be filled with\\n the flag color. If they are not filled, the center is transparent.\\n\\nrounding : bool, default: True\\n Whether the vector magnitude should be rounded when allocating barb\\n components. If True, the magnitude is rounded to the nearest multiple\\n of the half-barb increment. If False, the magnitude is simply truncated\\n to the next lowest multiple.\\n\\nbarb_increments : dict, optional\\n A dictionary of increments specifying values to associate with\\n different parts of the barb. Only those values one wishes to\\n override need to be included.\\n\\n - \\'half\\' - half barbs (Default is 5)\\n - \\'full\\' - full barbs (Default is 10)\\n - \\'flag\\' - flags (default is 50)\\n\\nflip_barb : bool or array-like of bool, default: False\\n Whether the lines and flags should point opposite to normal.\\n Normal behavior is for the barbs and lines to point right (comes from wind\\n barbs having these features point towards low pressure in the Northern\\n Hemisphere).\\n\\n A single value is applied to all barbs. Individual barbs can be flipped by\\n passing a bool array of the same size as *U* and *V*.\\n\\nReturns\\n-------\\nbarbs : `~matplotlib.quiver.Barbs`\\n\\nOther Parameters\\n----------------\\ndata : indexable object, optional\\n DATA_PARAMETER_PLACEHOLDER\\n\\n**kwargs\\n The barbs can further be customized using `.PolyCollection` keyword\\n arguments:\\n\\n \\n .. table::\\n :class: property-table\\n\\n ================================================================================================= =====================================================================================================\\n Property Description \\n ================================================================================================= =====================================================================================================\\n :meth:`agg_filter <matplotlib.artist.Artist.set_agg_filter>` a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array\\n :meth:`alpha <matplotlib.collections.Collection.set_alpha>` array-like or scalar or None \\n :meth:`animated <matplotlib.artist.Artist.set_animated>` bool \\n :meth:`antialiased <matplotlib.collections.Collection.set_antialiased>` or aa or antialiaseds bool or list of bools \\n :meth:`array <matplotlib.cm.ScalarMappable.set_array>` array-like or None \\n :meth:`capstyle <matplotlib.collections.Collection.set_capstyle>` `.CapStyle` or {\\'butt\\', \\'projecting\\', \\'round\\'} \\n :meth:`clim <matplotlib.cm.ScalarMappable.set_clim>` (vmin: float, vmax: float) \\n :meth:`clip_box <matplotlib.artist.Artist.set_clip_box>` `.Bbox` \\n :meth:`clip_on <matplotlib.artist.Artist.set_clip_on>` bool \\n :meth:`clip_path <matplotlib.artist.Artist.set_clip_path>` Patch or (Path, Transform) or None \\n :meth:`cmap <matplotlib.cm.ScalarMappable.set_cmap>` `.Colormap` or str or None \\n :meth:`color <matplotlib.collections.Collection.set_color>` color or list of rgba tuples \\n :meth:`edgecolor <matplotlib.collections.Collection.set_edgecolor>` or ec or edgecolors color or list of colors or \\'face\\' \\n :meth:`facecolor <matplotlib.collections.Collection.set_facecolor>` or facecolors or fc color or list of colors \\n :meth:`figure <matplotlib.artist.Artist.set_figure>` `.Figure` \\n :meth:`gid <matplotlib.artist.Artist.set_gid>` str \\n :meth:`hatch <matplotlib.collections.Collection.set_hatch>` {\\'/\\', \\'\\\\\\\\\\', \\'|\\', \\'-\\', \\'+\\', \\'x\\', \\'o\\', \\'O\\', \\'.\\', \\'*\\'} \\n :meth:`in_layout <matplotlib.artist.Artist.set_in_layout>` bool \\n :meth:`joinstyle <matplotlib.collections.Collection.set_joinstyle>` `.JoinStyle` or {\\'miter\\', \\'round\\', \\'bevel\\'} \\n :meth:`label", "score": "0.6192551"}]}
{"task_id": "mbpp_292", "code": "def find(n,m):  \r\n    q = n//m \r\n    return (q)", "test_list": ["assert find(10,3) == 3", "assert find(4,2) == 2", "assert find(20,5) == 4"], "context": "Write a python function to find quotient of two numbers.", "function_name": "def find(n,m):", "gold_generation": "q = n//m \r\n    return (q)", "ctxs": [{"id": "19703", "text": "Function: python.library.functions#divmod\nSnippet: divmod(a, b) Take two (non complex) numbers as arguments and return a pair of numbers consisting of their quotient and remainder when using integer division. With mixed operand types, the rules for binary arithmetic operators apply. For integers, the result is the same as (a // b, a % b). For floating point numbers the result is (q, a % b), where q is usually math.floor(a / b) but may be 1 less than that. In any case q * b + a % b is very close to a, if a % b is non-zero it has the same sign as b, and 0 <= abs(a % b) < abs(b).", "score": "0.69142157"}, {"id": "20204", "text": "Function: python.library.fractions#fractions.Fraction.as_integer_ratio\nSnippet: as_integer_ratio() Return a tuple of two integers, whose ratio is equal to the Fraction and with a positive denominator. New in version 3.8.", "score": "0.68563193"}, {"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.68243957"}, {"id": "19495", "text": "Function: python.library.decimal#decimal.Context.multiply\nSnippet: multiply(x, y) Return the product of x and y.", "score": "0.681711"}, {"id": "22396", "text": "Function: python.library.operator#operator.__sub__\nSnippet: operator.sub(a, b) operator.__sub__(a, b) Return a - b.", "score": "0.67611897"}]}
{"task_id": "mbpp_293", "code": "import math\r\ndef otherside_rightangle(w,h):\r\n  s=math.sqrt((w*w)+(h*h))\r\n  return s", "test_list": ["assert otherside_rightangle(7,8)==10.63014581273465", "assert otherside_rightangle(3,4)==5", "assert otherside_rightangle(7,15)==16.55294535724685"], "context": "Write a function to find the third side of a right angled triangle.", "function_name": "import math\r\ndef otherside_rightangle(w,h):", "gold_generation": "s=math.sqrt((w*w)+(h*h))\r\n  return s", "ctxs": [{"id": "28428", "text": "Function: matplotlib.backend_bases_api#matplotlib.backend_bases.MouseButton.RIGHT\nSnippet: RIGHT=3[source]", "score": "0.6725609"}, {"id": "34305", "text": "Function: matplotlib.tri_api\nSnippet: matplotlib.tri Unstructured triangular grid functions. classmatplotlib.tri.Triangulation(x, y, triangles=None, mask=None)[source] An unstructured triangular grid consisting of npoints points and ntri triangles. The triangles can either be specified by the user or automatically generated using a Delaunay triangulation. Parameters x, y(npoints,) array-like Coordinates of grid points. triangles(ntri, 3) array-like of int, optional For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If not specified, the Delaunay triangulation is calculated. mask(ntri,) array-like of bool, optional Which triangles are masked out. Notes For a Triangulation to be valid it must not have duplicate points, triangles formed from colinear points, or overlapping triangles. Attributes triangles(ntri, 3) array of int For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If you want to take the mask into account, use get_masked_triangles instead. mask(ntri, 3) array of bool Masked out triangles. is_delaunaybool Whether the Triangulation is a calculated Delaunay triangulation (where triangles was not specified) or not. calculate_plane_coefficients(z)[source] Calculate plane equation coefficients for all unmasked triangles from the point (x, y) coordinates and specified z-array of shape (npoints). The returned array has shape (npoints, 3) and allows z-value at (x, y) position in triangle tri to be calculated using z = array[tri, 0] * x + array[tri, 1] * y + array[tri, 2]. propertyedges Return integer array of shape (nedges, 2) containing all edges of non-masked triangles. Each row defines an edge by it's start point index and end point index. Each edge appears only once, i.e. for an edge between points i and j, there will only be either (i, j) or (j, i). get_cpp_triangulation()[source] Return the underlying C++ Triangulation object, creating it if necessary. staticget_from_args_and_kwargs(*args, **kwargs)[source] Return a Triangulation object from the args and kwargs, and the remaining args and kwargs with the consumed values removed. There are two alternatives: either the first argument is a Triangulation object, in which case it is returned, or the args and kwargs are sufficient to create a new Triangulation to return. In the latter case, see Triangulation.__init__ for the possible args and kwargs. get_masked_triangles()[source] Return an array of triangles that are not masked. get_trifinder()[source] Return the default matplotlib.tri.TriFinder of this triangulation, creating it if necessary. This allows the same TriFinder object to be easily shared. propertyneighbors Return integer array of shape (ntri, 3) containing neighbor triangles. For each triangle, the indices of the three triangles that share the same edges, or -1 if there is no such neighboring triangle. neighbors[i, j] is the triangle that is the neighbor to the edge from point index triangles[i, j] to point index triangles[i, (j+1)%3]. set_mask(mask)[source] Set or clear the mask array. Parameters maskNone or bool array of length ntri classmatplotlib.tri.TriContourSet(ax, *args, **kwargs)[source] Bases: matplotlib.contour.ContourSet Create and store a set of contour lines or filled regions for a triangular grid. This class is typically not instantiated directly by the user but by tricontour and tricontourf. Attributes axAxes The Axes object in which the", "score": "0.6502855"}, {"id": "18245", "text": "Function: python.library.bisect#bisect.bisect_right\nSnippet: bisect.bisect_right(a, x, lo=0, hi=len(a)) bisect.bisect(a, x, lo=0, hi=len(a)) Similar to bisect_left(), but returns an insertion point which comes after (to the right of) any existing entries of x in a. The returned insertion point i partitions the array a into two halves so that all(val <= x for val in a[lo:i]) for the left side and all(val > x for val in a[i:hi]) for the right side.", "score": "0.6483221"}, {"id": "14480", "text": "Function: pandas.reference.api.pandas.dataframe.rtruediv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.64266574"}, {"id": "14476", "text": "Function: pandas.reference.api.pandas.dataframe.rpow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6414"}]}
{"task_id": "mbpp_294", "code": "def max_val(listval):\r\n     max_val = max(i for i in listval if isinstance(i, int)) \r\n     return(max_val)", "test_list": ["assert max_val(['Python', 3, 2, 4, 5, 'version'])==5", "assert max_val(['Python', 15, 20, 25])==25", "assert max_val(['Python', 30, 20, 40, 50, 'version'])==50"], "context": "Write a function to find the maximum value in a given heterogeneous list.", "function_name": "def max_val(listval):", "gold_generation": "max_val = max(i for i in listval if isinstance(i, int)) \r\n     return(max_val)", "ctxs": [{"id": "19490", "text": "Function: python.library.decimal#decimal.Context.max\nSnippet: max(x, y) Compares two values numerically and returns the maximum.", "score": "0.6914341"}, {"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.6874416"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.6825303"}, {"id": "43857", "text": "Function: numpy.reference.generated.numpy.recarray.max\nSnippet: numpy.recarray.max method recarray.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the maximum along a given axis. Refer to numpy.amax for full documentation. See also numpy.amax equivalent function", "score": "0.67454237"}, {"id": "19587", "text": "Function: python.library.decimal#decimal.MAX_PREC\nSnippet: decimal.MAX_PREC", "score": "0.6723094"}]}
{"task_id": "mbpp_295", "code": "def sum_div(number):\r\n    divisors = [1]\r\n    for i in range(2, number):\r\n        if (number % i)==0:\r\n            divisors.append(i)\r\n    return sum(divisors)", "test_list": ["assert sum_div(8)==7", "assert sum_div(12)==16", "assert sum_div(7)==1"], "context": "Write a function to return the sum of all divisors of a number.", "function_name": "def sum_div(number):", "gold_generation": "divisors = [1]\r\n    for i in range(2, number):\r\n        if (number % i)==0:\r\n            divisors.append(i)\r\n    return sum(divisors)", "ctxs": [{"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.67027956"}, {"id": "22280", "text": "Function: python.library.numbers#numbers.Rational.denominator\nSnippet: denominator Abstract.", "score": "0.66046023"}, {"id": "22281", "text": "Function: python.library.numbers#numbers.Rational.numerator\nSnippet: numerator Abstract.", "score": "0.65769583"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.6533059"}, {"id": "8058", "text": "Function: torch.tensors#torch.Tensor.remainder\nSnippet: remainder(divisor) → Tensor See torch.remainder()", "score": "0.6508189"}]}
{"task_id": "mbpp_296", "code": "def get_Inv_Count(arr,n): \r\n    inv_count = 0\r\n    for i in range(n): \r\n        for j in range(i + 1,n): \r\n            if (arr[i] > arr[j]): \r\n                inv_count += 1\r\n    return inv_count ", "test_list": ["assert get_Inv_Count([1,20,6,4,5],5) == 5", "assert get_Inv_Count([1,2,1],3) == 1", "assert get_Inv_Count([1,2,5,6,1],5) == 3"], "context": "Write a python function to count inversions in an array.", "function_name": "def get_Inv_Count(arr,n):", "gold_generation": "inv_count = 0\r\n    for i in range(n): \r\n        for j in range(i + 1,n): \r\n            if (arr[i] > arr[j]): \r\n                inv_count += 1\r\n    return inv_count", "ctxs": [{"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.70663863"}, {"id": "17643", "text": "Function: python.library.array#array.array.reverse\nSnippet: array.reverse() Reverse the order of the items in the array.", "score": "0.7024436"}, {"id": "42910", "text": "Function: numpy.reference.generated.numpy.invert\nSnippet: numpy.invert numpy.invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'invert'> Compute bit-wise inversion, or bit-wise NOT, element-wise. Computes the bit-wise NOT of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator ~. For signed integer inputs, the two’s complement is returned. In a two’s-complement system negative numbers are represented by the two’s complement of the absolute value. This is the most common method of representing signed integers on computers [1]. A N-bit two’s-complement system can represent every integer in the range \\(-2^{N-1}\\) to \\(+2^{N-1}-1\\). Parameters xarray_like Only integer and boolean types are handled. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Result. This is a scalar if x is a scalar. See also bitwise_and, bitwise_or, bitwise_xor logical_not binary_repr Return the binary representation of the input number as a string. Notes bitwise_not is an alias for invert: >>> np.bitwise_not is np.invert True References 1 Wikipedia, “Two’s complement”, https://en.wikipedia.org/wiki/Two’s_complement Examples We’ve seen that 13 is represented by 00001101. The invert or bit-wise NOT of 13 is then: >>> x = np.invert(np.array(13, dtype=np.uint8)) >>> x 242 >>> np.binary_repr(x, width=8) '11110010' The result depends on the bit-width: >>> x = np.invert(np.array(13, dtype=np.uint16)) >>> x 65522 >>> np.binary_repr(x, width=16) '1111111111110010' When using signed integer types the result is the two’s complement of the result for the unsigned type: >>> np.invert(np.array([13], dtype=np.int8)) array([-14], dtype=int8) >>> np.binary_repr(-14, width=8) '11110010' Booleans are accepted as well: >>> np.invert(np.array([True, False])) array([False, True]) The ~ operator can be used as a shorthand for np.invert on ndarrays. >>> x1 = np.array([True, False]) >>> ~x1 array([False, True])", "score": "0.69251907"}, {"id": "10570", "text": "Function: sklearn.modules.generated.sklearn.feature_extraction.text.countvectorizer#sklearn.feature_extraction.text.CountVectorizer.inverse_transform\nSnippet: inverse_transform(X) [source] Return terms per document with nonzero entries in X. Parameters X{array-like, sparse matrix} of shape (n_samples, n_features) Document-term matrix. Returns X_invlist of arrays of shape (n_samples,) List of arrays of terms.", "score": "0.6784041"}, {"id": "42830", "text": "Function: numpy.reference.generated.numpy.flip\nSnippet: numpy.flip numpy.flip(m, axis=None)[source] Reverse the order of elements in an array along the given axis. The shape of the array is preserved, but the elements are reordered. New in version 1.12.0. Parameters marray_like Input array. axisNone or int or tuple of ints, optional Axis or axes along which to flip over. The default, axis=None, will flip over all of the axes of the input array. If axis is negative it counts from the last to the first axis. If axis is a tuple of ints, flipping is performed on all of the axes specified in the tuple. Changed in version 1.15.0: None and tuples of axes are supported Returns outarray_like A view of m with the entries of axis reversed. Since a view is returned, this operation is done in constant time. See also flipud Flip an array vertically (axis=0). fliplr Flip an array horizontally (axis=1). Notes flip(m, 0) is equivalent to flipud(m). flip(m, 1) is equivalent to fliplr(m). flip(m, n) corresponds to m[...,::-1,...] with ::-1 at position n. flip(m) corresponds to m[::-1,::-1,...,::-1] with ::-1 at all positions. flip(m, (0, 1)) corresponds to m[::-1,::-1,...] with ::-1 at position 0 and position 1. Examples >>> A = np.arange(8).reshape((2,2,2)) >>> A array([[[0, 1], [2, 3]], [[4, 5], [6, 7]]]) >>> np.flip(A, 0) array([[[4, 5], [6, 7]], [[0, 1], [2, 3]]]) >>> np.flip(A, 1) array([[[2, 3], [0, 1]], [[6, 7], [4, 5]]]) >>> np.flip(A) array([[[7, 6], [5, 4]], [[3, 2], [1, 0]]]) >>> np.flip(A, (0, 2)) array([[[5, 4], [7, 6]], [[1, 0], [3, 2]]]) >>> A = np.random.randn(3,4,5) >>> np.all(np.flip(A,2) == A[:,:,::-1,...]) True", "score": "0.6762974"}]}
{"task_id": "mbpp_297", "code": "def flatten_list(list1):\r\n    result_list = []\r\n    if not list1: return result_list\r\n    stack = [list(list1)]\r\n    while stack:\r\n        c_num = stack.pop()\r\n        next = c_num.pop()\r\n        if c_num: stack.append(c_num)\r\n        if isinstance(next, list):\r\n            if next: stack.append(list(next))\r\n        else: result_list.append(next)\r\n    result_list.reverse()\r\n    return result_list ", "test_list": ["assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]", "assert flatten_list([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[10, 20, 40, 30, 56, 25, 10, 20, 33, 40]", "assert flatten_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]"], "context": "Write a function to flatten a given nested list structure.", "function_name": "def flatten_list(list1):", "gold_generation": "result_list = []\r\n    if not list1: return result_list\r\n    stack = [list(list1)]\r\n    while stack:\r\n        c_num = stack.pop()\r\n        next = c_num.pop()\r\n        if c_num: stack.append(c_num)\r\n        if isinstance(next, list):\r\n            if next: stack.append(list(next))\r\n        else: result_list.append(next)\r\n    result_list.reverse()\r\n    return result_list", "ctxs": [{"id": "3584", "text": "Function: tensorflow.nest.flatten\nSnippet: tf.nest.flatten View source on GitHub Returns a flat list from a given nested structure. View aliases Compat aliases for migration See Migration guide for more details. tf.compat.v1.nest.flatten tf.nest.flatten( structure, expand_composites=False ) If nest is not a structure , tuple (or a namedtuple), dict, or an attrs class, then returns a single-element list: [nest]. In the case of dict instances, the sequence consists of the values, sorted by key to ensure deterministic behavior. This is true also for OrderedDict instances: their sequence order is ignored, the sorting order of keys is used instead. The same convention is followed in pack_sequence_as. This correctly repacks dicts and OrderedDicts after they have been flattened, and also allows flattening an OrderedDict and then repacking it back using a corresponding plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be flattened. Users must not modify any collections used in nest while this function is running. Examples: Python dict (ordered by key): dict = { \"key3\": \"value3\", \"key1\": \"value1\", \"key2\": \"value2\" } tf.nest.flatten(dict) ['value1', 'value2', 'value3'] For a nested python tuple: tuple = ((1.0, 2.0), (3.0, 4.0, 5.0), (6.0)) tf.nest.flatten(tuple) [1.0, 2.0, 3.0, 4.0, 5.0, 6.0] Numpy array (will not flatten): array = np.array([[1, 2], [3, 4]]) tf.nest.flatten(array) [array([[1, 2], [3, 4]])] tf.Tensor (will not flatten): tensor = tf.constant([[1., 2., 3.], [4., 5., 6.], [7., 8., 9.]]) tf.nest.flatten(tensor) [<tf.Tensor: shape=(3, 3), dtype=float32, numpy= array([[1., 2., 3.], [4., 5., 6.], [7., 8., 9.]], dtype=float32)>] Args structure an arbitrarily nested structure. Note, numpy arrays are considered atoms and are not flattened. expand_composites If true, then composite tensors such as tf.sparse.SparseTensor and tf.RaggedTensor are expanded into their component tensors. Returns A Python list, the flattened version of the input. Raises TypeError The nest is or contains a dict with non-sortable keys.", "score": "0.70007455"}, {"id": "43915", "text": "Function: numpy.reference.generated.numpy.record.flatten\nSnippet: numpy.record.flatten method record.flatten() Scalar method identical to the corresponding array attribute. Please see ndarray.flatten.", "score": "0.6966554"}, {"id": "29163", "text": "Function: matplotlib.cbook_api#matplotlib.cbook.flatten\nSnippet: matplotlib.cbook.flatten(seq, scalarp=<function is_scalar_or_string>)[source] Return a generator of flattened nested containers. For example: >>> from matplotlib.cbook import flatten >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]]) >>> print(list(flatten(l))) ['John', 'Hunter', 1, 23, 42, 5, 23] By: Composite of Holger Krekel and Luther Blissett From: https://code.activestate.com/recipes/121294/ and Recipe 1.12 in cookbook", "score": "0.6939416"}, {"id": "3582", "text": "Function: tensorflow.nest\nSnippet: Module: tf.nest Public API for tf.nest namespace. Functions assert_same_structure(...): Asserts that two structures are nested in the same way. flatten(...): Returns a flat list from a given nested structure. is_nested(...): Returns true if its input is a collections.abc.Sequence (except strings). map_structure(...): Applies func to each entry in structure and returns a new structure. pack_sequence_as(...): Returns a given flattened sequence packed into a given structure.", "score": "0.6819407"}, {"id": "997", "text": "Function: tensorflow.compat.v1.nest\nSnippet: Module: tf.compat.v1.nest Public API for tf.nest namespace. Functions assert_same_structure(...): Asserts that two structures are nested in the same way. flatten(...): Returns a flat list from a given nested structure. is_nested(...): Returns true if its input is a collections.abc.Sequence (except strings). map_structure(...): Applies func to each entry in structure and returns a new structure. pack_sequence_as(...): Returns a given flattened sequence packed into a given structure.", "score": "0.6806911"}]}
{"task_id": "mbpp_298", "code": "def intersection_nested_lists(l1, l2):\r\n    result = [[n for n in lst if n in l1] for lst in l2]\r\n    return result", "test_list": ["assert intersection_nested_lists( [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],[[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]])==[[12], [7, 11], [1, 5, 8]]", "assert intersection_nested_lists([[2, 3, 1], [4, 5], [6, 8]], [[4, 5], [6, 8]])==[[], []]", "assert intersection_nested_lists(['john','amal','joel','george'],[['john'],['jack','john','mary'],['howard','john'],['jude']])==[['john'], ['john'], ['john'], []]"], "context": "Write a function to find the nested list elements which are present in another list.", "function_name": "def intersection_nested_lists(l1, l2):", "gold_generation": "result = [[n for n in lst if n in l1] for lst in l2]\r\n    return result", "ctxs": [{"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.6749046"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.666234"}, {"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.6657385"}, {"id": "19648", "text": "Function: python.library.difflib#difflib.SequenceMatcher.get_matching_blocks\nSnippet: get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]", "score": "0.6643959"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.6641076"}]}
{"task_id": "mbpp_299", "code": "from collections import defaultdict\r\ndef max_aggregate(stdata):\r\n    temp = defaultdict(int)\r\n    for name, marks in stdata:\r\n        temp[name] += marks\r\n    return max(temp.items(), key=lambda x: x[1])", "test_list": ["assert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)", "assert max_aggregate([('Juan Whelan',50),('Sabah Colley',48),('Peter Nichols',37),('Juan Whelan',22),('Sabah Colley',14)])==('Juan Whelan', 72)", "assert max_aggregate([('Juan Whelan',10),('Sabah Colley',20),('Peter Nichols',30),('Juan Whelan',40),('Sabah Colley',50)])==('Sabah Colley', 70)"], "context": "Write a function to calculate the maximum aggregate from the list of tuples.", "function_name": "from collections import defaultdict\r\ndef max_aggregate(stdata):", "gold_generation": "temp = defaultdict(int)\r\n    for name, marks in stdata:\r\n        temp[name] += marks\r\n    return max(temp.items(), key=lambda x: x[1])", "ctxs": [{"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.6929135"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.6894656"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.67548656"}, {"id": "20488", "text": "Function: python.library.heapq#heapq.nlargest\nSnippet: heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n].", "score": "0.67185044"}, {"id": "21316", "text": "Function: python.library.itertools#itertools.zip_longest\nSnippet: itertools.zip_longest(*iterables, fillvalue=None) Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. Roughly equivalent to: def zip_longest(*args, fillvalue=None): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- iterators = [iter(it) for it in args] num_active = len(iterators) if not num_active: return while True: values = [] for i, it in enumerate(iterators): try: value = next(it) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values.append(value) yield tuple(values) If one of the iterables is potentially infinite, then the zip_longest() function should be wrapped with something that limits the number of calls (for example islice() or takewhile()). If not specified, fillvalue defaults to None.", "score": "0.67159086"}]}
{"task_id": "mbpp_300", "code": "def count_binary_seq(n): \r\n\tnCr = 1\r\n\tres = 1\r\n\tfor r in range(1, n + 1): \r\n\t\tnCr = (nCr * (n + 1 - r)) / r \r\n\t\tres += nCr * nCr \r\n\treturn res ", "test_list": ["assert count_binary_seq(1) == 2.0", "assert count_binary_seq(2) == 6.0", "assert count_binary_seq(3) == 20.0"], "context": "Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.", "function_name": "def count_binary_seq(n):", "gold_generation": "nCr = 1\r\n\tres = 1\r\n\tfor r in range(1, n + 1): \r\n\t\tnCr = (nCr * (n + 1 - r)) / r \r\n\t\tres += nCr * nCr \r\n\treturn res", "ctxs": [{"id": "18260", "text": "Function: python.library.stdtypes#bytearray.count\nSnippet: bytes.count(sub[, start[, end]]) bytearray.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.6942266"}, {"id": "18304", "text": "Function: python.library.stdtypes#bytes.count\nSnippet: bytes.count(sub[, start[, end]]) bytearray.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.69123924"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.67664564"}, {"id": "19651", "text": "Function: python.library.difflib#difflib.SequenceMatcher.ratio\nSnippet: ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5", "score": "0.669463"}, {"id": "42662", "text": "Function: numpy.reference.generated.numpy.bincount\nSnippet: numpy.bincount numpy.bincount(x, /, weights=None, minlength=0) Count number of occurrences of each value in array of non-negative ints. The number of bins (of size 1) is one larger than the largest value in x. If minlength is specified, there will be at least this number of bins in the output array (though it will be longer if necessary, depending on the contents of x). Each bin gives the number of occurrences of its index value in x. If weights is specified the input array is weighted by it, i.e. if a value n is found at position i, out[n] += weight[i] instead of out[n] += 1. Parameters xarray_like, 1 dimension, nonnegative ints Input array. weightsarray_like, optional Weights, array of the same shape as x. minlengthint, optional A minimum number of bins for the output array. New in version 1.6.0. Returns outndarray of ints The result of binning the input array. The length of out is equal to np.amax(x)+1. Raises ValueError If the input is not 1-dimensional, or contains elements with negative values, or if minlength is negative. TypeError If the type of the input is float or complex. See also histogram, digitize, unique Examples >>> np.bincount(np.arange(5)) array([1, 1, 1, 1, 1]) >>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7])) array([1, 3, 1, 1, 0, 0, 0, 1]) >>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23]) >>> np.bincount(x).size == np.amax(x)+1 True The input array needs to be of integer dtype, otherwise a TypeError is raised: >>> np.bincount(np.arange(5, dtype=float)) Traceback (most recent call last): ... TypeError: Cannot cast array data from dtype('float64') to dtype('int64') according to the rule 'safe' A possible use of bincount is to perform sums over variable-size chunks of an array, using the weights keyword. >>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights >>> x = np.array([0, 1, 1, 2, 2, 2]) >>> np.bincount(x, weights=w) array([ 0.3, 0.7, 1.1])", "score": "0.6690545"}]}
{"task_id": "mbpp_301", "code": "def dict_depth(d):\r\n    if isinstance(d, dict):\r\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\r\n    return 0", "test_list": ["assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4", "assert dict_depth({'a':1, 'b': {'c':'python'}})==2", "assert dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}})==3"], "context": "Write a function to find the depth of a dictionary.", "function_name": "def dict_depth(d):", "gold_generation": "if isinstance(d, dict):\r\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\r\n    return 0", "ctxs": [{"id": "31472", "text": "Function: matplotlib.dviread#matplotlib.dviread.Tfm.depth\nSnippet: depth", "score": "0.75269264"}, {"id": "23416", "text": "Function: python.library.reprlib#reprlib.Repr.maxlevel\nSnippet: Repr.maxlevel Depth limit on the creation of recursive representations. The default is 6.", "score": "0.71727246"}, {"id": "12936", "text": "Function: sklearn.modules.generated.sklearn.tree.decisiontreeclassifier#sklearn.tree.DecisionTreeClassifier.get_depth\nSnippet: get_depth() [source] Return the depth of the decision tree. The depth of a tree is the maximum distance between the root and any leaf. Returns self.tree_.max_depthint The maximum depth of the tree.", "score": "0.7136557"}, {"id": "12982", "text": "Function: sklearn.modules.generated.sklearn.tree.extratreeclassifier#sklearn.tree.ExtraTreeClassifier.get_depth\nSnippet: get_depth() [source] Return the depth of the decision tree. The depth of a tree is the maximum distance between the root and any leaf. Returns self.tree_.max_depthint The maximum depth of the tree.", "score": "0.7107267"}, {"id": "12959", "text": "Function: sklearn.modules.generated.sklearn.tree.decisiontreeregressor#sklearn.tree.DecisionTreeRegressor.get_depth\nSnippet: get_depth() [source] Return the depth of the decision tree. The depth of a tree is the maximum distance between the root and any leaf. Returns self.tree_.max_depthint The maximum depth of the tree.", "score": "0.69537014"}]}
{"task_id": "mbpp_302", "code": "def set_Bit_Number(n): \r\n    if (n == 0): \r\n        return 0; \r\n    msb = 0; \r\n    n = int(n / 2); \r\n    while (n > 0): \r\n        n = int(n / 2); \r\n        msb += 1; \r\n    return (1 << msb)", "test_list": ["assert set_Bit_Number(6) == 4", "assert set_Bit_Number(10) == 8", "assert set_Bit_Number(18) == 16"], "context": "Write a python function to find the most significant bit number which is also a set bit.", "function_name": "def set_Bit_Number(n):", "gold_generation": "if (n == 0): \r\n        return 0; \r\n    msb = 0; \r\n    n = int(n / 2); \r\n    while (n > 0): \r\n        n = int(n / 2); \r\n        msb += 1; \r\n    return (1 << msb)", "ctxs": [{"id": "21071", "text": "Function: python.library.stdtypes#int.bit_length\nSnippet: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1.", "score": "0.71698856"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.6950009"}, {"id": "25732", "text": "Function: python.library.stdtypes\nSnippet: there were an infinite number of sign bits. Additional Methods on Integer Types The int type implements the numbers.Integral abstract base class. In addition, it provides a few more methods: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1. int.to_bytes(length, byteorder, *, signed=False) Return an array of bytes representing an integer. >>> (1024).to_bytes(2, byteorder='big') b'\\x04\\x00' >>> (1024).to_bytes(10, byteorder='big') b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00' >>> (-1024).to_bytes(10, byteorder='big', signed=True) b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00' >>> x = 1000 >>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little') b'\\xe8\\x03' The integer is represented using length bytes. An OverflowError is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument determines whether two’s complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. The default value for signed is False. New in version 3.2. classmethod int.from_bytes(bytes, byteorder, *, signed=False) Return the integer represented by the given array of bytes. >>> int.from_bytes(b'\\x00\\x10', byteorder='big') 16 >>> int.from_bytes(b'\\x00\\x10', byteorder='little') 4096 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True) -1024 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False) 64512 >>> int.from_bytes([255, 0, 0], byteorder='big') 16711680 The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. New in version 3.2. int.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original integer and with a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. New in version 3.8. Additional Methods on Float The float type implements the numbers.Real abstract base class. float also has the following additional methods. float.as_integer_ratio() Return a pair of integers whose", "score": "0.6943084"}, {"id": "13465", "text": "Function: pygame.ref.mask#pygame.mask.Mask.count\nSnippet: count() Returns the number of set bits count() -> bits Returns: the number of set bits in the mask Return type: int", "score": "0.67664045"}, {"id": "22345", "text": "Function: python.library.operator#operator.or_\nSnippet: operator.or_(a, b) operator.__or__(a, b) Return the bitwise or of a and b.", "score": "0.6737639"}]}
{"task_id": "mbpp_303", "code": "import sys \r\ndef solve(a,n):   \r\n    mx = -sys.maxsize - 1\r\n    for j in range(1,n):  \r\n        if (mx > a[j]):  \r\n            return False  \r\n        mx = max(mx,a[j - 1])    \r\n    return True", "test_list": ["assert solve([1,0,2],3) == True", "assert solve([1,2,0],3) == False", "assert solve([1,2,1],3) == True"], "context": "Write a python function to check whether the count of inversion of two types are same or not.", "function_name": "import sys \r\ndef solve(a,n):", "gold_generation": "mx = -sys.maxsize - 1\r\n    for j in range(1,n):  \r\n        if (mx > a[j]):  \r\n            return False  \r\n        mx = max(mx,a[j - 1])    \r\n    return True", "ctxs": [{"id": "19508", "text": "Function: python.library.decimal#decimal.Context.same_quantum\nSnippet: same_quantum(x, y) Returns True if the two operands have the same exponent.", "score": "0.7013223"}, {"id": "33591", "text": "Function: matplotlib.scale_api#matplotlib.scale.FuncTransform.has_inverse\nSnippet: has_inverse=True True if this transform has a corresponding inverse transform.", "score": "0.70130914"}, {"id": "43379", "text": "Function: numpy.reference.generated.numpy.polynomial.hermite.hermite.has_sametype\nSnippet: numpy.polynomial.hermite.Hermite.has_sametype method polynomial.hermite.Hermite.has_sametype(other)[source] Check if types match. New in version 1.7.0. Parameters otherobject Class instance. Returns boolboolean True if other is same class as self", "score": "0.69979584"}, {"id": "34249", "text": "Function: matplotlib.transformations#matplotlib.transforms.Transform.has_inverse\nSnippet: has_inverse=False True if this transform has a corresponding inverse transform.", "score": "0.6979935"}, {"id": "33606", "text": "Function: matplotlib.scale_api#matplotlib.scale.InvertedSymmetricalLogTransform.has_inverse\nSnippet: has_inverse=True True if this transform has a corresponding inverse transform.", "score": "0.6969143"}]}
{"task_id": "mbpp_304", "code": "def find_Element(arr,ranges,rotations,index) :  \r\n    for i in range(rotations - 1,-1,-1 ) : \r\n        left = ranges[i][0] \r\n        right = ranges[i][1] \r\n        if (left <= index and right >= index) : \r\n            if (index == left) : \r\n                index = right \r\n            else : \r\n                index = index - 1 \r\n    return arr[index] ", "test_list": ["assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3", "assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3", "assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1"], "context": "Write a python function to find element at a given index after number of rotations.", "function_name": "def find_Element(arr,ranges,rotations,index) :", "gold_generation": "for i in range(rotations - 1,-1,-1 ) : \r\n        left = ranges[i][0] \r\n        right = ranges[i][1] \r\n        if (left <= index and right >= index) : \r\n            if (index == left) : \r\n                index = right \r\n            else : \r\n                index = index - 1 \r\n    return arr[index]", "ctxs": [{"id": "24349", "text": "Function: python.library.stdtypes#str.index\nSnippet: str.index(sub[, start[, end]]) Like find(), but raise ValueError when the substring is not found.", "score": "0.6854041"}, {"id": "30892", "text": "Function: matplotlib.collections_api#matplotlib.collections.RegularPolyCollection.get_rotation\nSnippet: get_rotation()[source]", "score": "0.68505067"}, {"id": "19507", "text": "Function: python.library.decimal#decimal.Context.rotate\nSnippet: rotate(x, y) Returns a rotated copy of x, y times.", "score": "0.6843756"}, {"id": "29392", "text": "Function: matplotlib.collections_api#matplotlib.collections.AsteriskPolygonCollection.get_rotation\nSnippet: get_rotation()[source]", "score": "0.6762669"}, {"id": "18676", "text": "Function: python.library.collections#collections.deque.rotate\nSnippet: rotate(n=1) Rotate the deque n steps to the right. If n is negative, rotate to the left. When the deque is not empty, rotating one step to the right is equivalent to d.appendleft(d.pop()), and rotating one step to the left is equivalent to d.append(d.popleft()).", "score": "0.674659"}]}
{"task_id": "mbpp_305", "code": "import re\r\ndef start_withp(words):\r\n for w in words:\r\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\r\n        if m:\r\n            return m.groups()", "test_list": ["assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"])==('Python', 'PHP')", "assert start_withp([\"Python Programming\",\"Java Programming\"])==('Python','Programming')", "assert start_withp([\"Pqrst Pqr\",\"qrstuv\"])==('Pqrst','Pqr')"], "context": "Write a function to match two words from a list of words starting with letter 'p'.", "function_name": "import re\r\ndef start_withp(words):", "gold_generation": "for w in words:\r\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\r\n        if m:\r\n            return m.groups()", "ctxs": [{"id": "19634", "text": "Function: python.library.difflib#difflib.get_close_matches\nSnippet: difflib.get_close_matches(word, possibilities, n=3, cutoff=0.6) Return a list of the best “good enough” matches. word is a sequence for which close matches are desired (typically a string), and possibilities is a list of sequences against which to match word (typically a list of strings). Optional argument n (default 3) is the maximum number of close matches to return; n must be greater than 0. Optional argument cutoff (default 0.6) is a float in the range [0, 1]. Possibilities that don’t score at least that similar to word are ignored. The best (no more than n) matches among the possibilities are returned in a list, sorted by similarity score, most similar first. >>> get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy']) ['apple', 'ape'] >>> import keyword >>> get_close_matches('wheel', keyword.kwlist) ['while'] >>> get_close_matches('pineapple', keyword.kwlist) [] >>> get_close_matches('accept', keyword.kwlist) ['except']", "score": "0.68661445"}, {"id": "23310", "text": "Function: python.library.re\nSnippet: for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\" Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). Pattern.fullmatch(string[, pos[, endpos]]) If the whole string matches this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o[gh]\") >>> pattern.fullmatch(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.fullmatch(\"ogre\") # No match as not the full string matches. >>> pattern.fullmatch(\"doggie\", 1, 3) # Matches within given limits. <re.Match object; span=(1, 3), match='og'> New in version 3.4. Pattern.split(string, maxsplit=0) Identical to the split() function, using the compiled pattern. Pattern.findall(string[, pos[, endpos]]) Similar to the findall() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.finditer(string[, pos[, endpos]]) Similar to the finditer() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.sub(repl, string, count=0) Identical to the sub() function, using the compiled pattern. Pattern.subn(repl, string, count=0) Identical to the subn() function, using the compiled pattern. Pattern.flags The regex", "score": "0.681453"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.67055184"}, {"id": "23359", "text": "Function: python.library.re#re.Pattern.match\nSnippet: Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()).", "score": "0.6689758"}, {"id": "20195", "text": "Function: python.library.fnmatch#fnmatch.filter\nSnippet: fnmatch.filter(names, pattern) Construct a list from those elements of the iterable names that match pattern. It is the same as [n for n in names if fnmatch(n, pattern)], but implemented more efficiently.", "score": "0.6674732"}]}
{"task_id": "mbpp_306", "code": "def max_sum_increasing_subseq(a, n, index, k):\r\n\tdp = [[0 for i in range(n)] \r\n\t\t\tfor i in range(n)]\r\n\tfor i in range(n):\r\n\t\tif a[i] > a[0]:\r\n\t\t\tdp[0][i] = a[i] + a[0]\r\n\t\telse:\r\n\t\t\tdp[0][i] = a[i]\r\n\tfor i in range(1, n):\r\n\t\tfor j in range(n):\r\n\t\t\tif a[j] > a[i] and j > i:\r\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\r\n\t\t\t\telse:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\t\t\telse:\r\n\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\treturn dp[index][k]", "test_list": ["assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11", "assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7", "assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71"], "context": "Write a function to find the maximum sum of increasing subsequence from prefix till ith index and also including a given kth element which is after i, i.e., k > i .", "function_name": "def max_sum_increasing_subseq(a, n, index, k):", "gold_generation": "dp = [[0 for i in range(n)] \r\n\t\t\tfor i in range(n)]\r\n\tfor i in range(n):\r\n\t\tif a[i] > a[0]:\r\n\t\t\tdp[0][i] = a[i] + a[0]\r\n\t\telse:\r\n\t\t\tdp[0][i] = a[i]\r\n\tfor i in range(1, n):\r\n\t\tfor j in range(n):\r\n\t\t\tif a[j] > a[i] and j > i:\r\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\r\n\t\t\t\telse:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\t\t\telse:\r\n\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\treturn dp[index][k]", "ctxs": [{"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6851729"}, {"id": "18329", "text": "Function: python.library.stdtypes#bytes.rfind\nSnippet: bytes.rfind(sub[, start[, end]]) bytearray.rfind(sub[, start[, end]]) Return the highest index in the sequence where the subsequence sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.6842227"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.6835495"}, {"id": "21919", "text": "Function: python.library.mmap#mmap.mmap.find\nSnippet: find(sub[, start[, end]]) Returns the lowest index in the object where the subsequence sub is found, such that sub is contained in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. Returns -1 on failure. Changed in version 3.5: Writable bytes-like object is now accepted.", "score": "0.682917"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6815765"}]}
{"task_id": "mbpp_307", "code": "from copy import deepcopy\r\ndef colon_tuplex(tuplex,m,n):\r\n  tuplex_colon = deepcopy(tuplex)\r\n  tuplex_colon[m].append(n)\r\n  return tuplex_colon", "test_list": ["assert colon_tuplex((\"HELLO\", 5, [], True) ,2,50)==(\"HELLO\", 5, [50], True) ", "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,100)==((\"HELLO\", 5, [100],True))", "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,500)==(\"HELLO\", 5, [500], True)"], "context": "Write a function to get a colon of a tuple.", "function_name": "from copy import deepcopy\r\ndef colon_tuplex(tuplex,m,n):", "gold_generation": "tuplex_colon = deepcopy(tuplex)\r\n  tuplex_colon[m].append(n)\r\n  return tuplex_colon", "ctxs": [{"id": "25411", "text": "Function: python.library.token#token.COLON\nSnippet: token.COLON Token value for \":\".", "score": "0.75340134"}, {"id": "25412", "text": "Function: python.library.token#token.COLONEQUAL\nSnippet: token.COLONEQUAL Token value for \":=\".", "score": "0.7242276"}, {"id": "20392", "text": "Function: python.library.gettext#gettext.lngettext\nSnippet: gettext.lngettext(singular, plural, n)", "score": "0.68990266"}, {"id": "36544", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.OGRGeometry.tuple\nSnippet: tuple", "score": "0.677323"}, {"id": "36422", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.Envelope.tuple\nSnippet: tuple", "score": "0.67189515"}]}
{"task_id": "mbpp_308", "code": "def large_product(nums1, nums2, N):\r\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\r\n    return result", "test_list": ["assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]", "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],4)==[60, 54, 50, 48]", "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],5)==[60, 54, 50, 48, 45]"], "context": "Write a function to find the specified number of largest products from two given lists.", "function_name": "def large_product(nums1, nums2, N):", "gold_generation": "result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\r\n    return result", "ctxs": [{"id": "21311", "text": "Function: python.library.itertools#itertools.product\nSnippet: itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs.", "score": "0.6619635"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.64685804"}, {"id": "20488", "text": "Function: python.library.heapq#heapq.nlargest\nSnippet: heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n].", "score": "0.64684534"}, {"id": "21316", "text": "Function: python.library.itertools#itertools.zip_longest\nSnippet: itertools.zip_longest(*iterables, fillvalue=None) Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. Roughly equivalent to: def zip_longest(*args, fillvalue=None): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- iterators = [iter(it) for it in args] num_active = len(iterators) if not num_active: return while True: values = [] for i, it in enumerate(iterators): try: value = next(it) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values.append(value) yield tuple(values) If one of the iterables is potentially infinite, then the zip_longest() function should be wrapped with something that limits the number of calls (for example islice() or takewhile()). If not specified, fillvalue defaults to None.", "score": "0.6405882"}, {"id": "19490", "text": "Function: python.library.decimal#decimal.Context.max\nSnippet: max(x, y) Compares two values numerically and returns the maximum.", "score": "0.6394359"}]}
{"task_id": "mbpp_309", "code": "def maximum(a,b):   \r\n    if a >= b: \r\n        return a \r\n    else: \r\n        return b ", "test_list": ["assert maximum(5,10) == 10", "assert maximum(-1,-2) == -1", "assert maximum(9,7) == 9"], "context": "Write a python function to find the maximum of two numbers.", "function_name": "def maximum(a,b):", "gold_generation": "if a >= b: \r\n        return a \r\n    else: \r\n        return b", "ctxs": [{"id": "19490", "text": "Function: python.library.decimal#decimal.Context.max\nSnippet: max(x, y) Compares two values numerically and returns the maximum.", "score": "0.7509973"}, {"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.6902634"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.68114734"}, {"id": "19587", "text": "Function: python.library.decimal#decimal.MAX_PREC\nSnippet: decimal.MAX_PREC", "score": "0.6805906"}, {"id": "19586", "text": "Function: python.library.decimal#decimal.MAX_EMAX\nSnippet: decimal.MAX_EMAX", "score": "0.66227996"}]}
{"task_id": "mbpp_310", "code": "def string_to_tuple(str1):\r\n    result = tuple(x for x in str1 if not x.isspace()) \r\n    return result", "test_list": ["assert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')", "assert string_to_tuple(\"item1\")==('i', 't', 'e', 'm', '1')", "assert string_to_tuple(\"15.10\")==('1', '5', '.', '1', '0')"], "context": "Write a function to convert a given string to a tuple.", "function_name": "def string_to_tuple(str1):", "gold_generation": "result = tuple(x for x in str1 if not x.isspace()) \r\n    return result", "ctxs": [{"id": "36422", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.Envelope.tuple\nSnippet: tuple", "score": "0.69446015"}, {"id": "25588", "text": "Function: python.library.stdtypes#tuple\nSnippet: class tuple([iterable]) Tuples may be constructed in a number of ways: Using a pair of parentheses to denote the empty tuple: () Using a trailing comma for a singleton tuple: a, or (a,) Separating items with commas: a, b, c or (a, b, c) Using the tuple() built-in: tuple() or tuple(iterable) The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, tuple('abc') returns ('a', 'b', 'c') and tuple( [1, 2, 3] ) returns (1, 2, 3). If no argument is given, the constructor creates a new empty tuple, (). Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, f(a, b, c) is a function call with three arguments, while f((a, b, c)) is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations.", "score": "0.68902683"}, {"id": "36544", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.OGRGeometry.tuple\nSnippet: tuple", "score": "0.6888362"}, {"id": "18617", "text": "Function: python.library.collections\nSnippet: a new instance of the named tuple replacing specified fields with new values: >>> p = Point(x=11, y=22) >>> p._replace(x=33) Point(x=33, y=22) >>> for partnum, record in inventory.items(): ... inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now()) somenamedtuple._fields Tuple of strings listing the field names. Useful for introspection and for creating new named tuple types from existing named tuples. >>> p._fields # view the field names ('x', 'y') >>> Color = namedtuple('Color', 'red green blue') >>> Pixel = namedtuple('Pixel', Point._fields + Color._fields) >>> Pixel(11, 22, 128, 255, 0) Pixel(x=11, y=22, red=128, green=255, blue=0) somenamedtuple._field_defaults Dictionary mapping field names to default values. >>> Account = namedtuple('Account', ['type', 'balance'], defaults=[0]) >>> Account._field_defaults {'balance': 0} >>> Account('premium') Account(type='premium', balance=0) To retrieve a field whose name is stored in a string, use the getattr() function: >>> getattr(p, 'x') 11 To convert a dictionary to a named tuple, use the double-star-operator (as described in Unpacking Argument Lists): >>> d = {'x': 11, 'y': 22} >>> Point(**d) Point(x=11, y=22) Since a named tuple is a regular Python class, it is easy to add or change functionality with a subclass. Here is how to add a calculated field and a fixed-width print format: >>> class Point(namedtuple('Point', ['x', 'y'])): ... __slots__ = () ... @property ... def hypot(self): ... return (self.x ** 2 + self.y ** 2) ** 0.5 ... def __str__(self): ... return 'Point: x=%6.3f y=%6.3f hypot=%6.3f' % (self.x, self.y, self.hypot) >>> for p in Point(3, 4), Point(14, 5/7): ... print(p) Point: x= 3.000 y= 4.000 hypot= 5.000 Point: x=14.000 y= 0.714 hypot=14.018 The subclass shown above sets __slots__ to an empty tuple. This helps keep memory requirements low by preventing the creation of instance dictionaries. Subclassing is not useful for adding new, stored fields. Instead, simply create a new named tuple type from the _fields attribute: >>> Point3D = namedtuple('Point3D', Point._fields + ('z',)) Docstrings can be customized by making direct assignments to the __doc__ fields: >>> Book = namedtuple('Book', ['id', 'title', 'authors']) >>> Book.__doc__ += ': Hardcover book in active collection' >>> Book.id.__doc__ = '13-digit ISBN' >>> Book.title.__doc__ = 'Title of first printing' >>> Book.authors.__doc__ = 'List of authors sorted by last name' Changed in version 3.5: Property docstrings became writeable. See also See typing.NamedTuple for a way to add type hints for named tuples. It also provides an elegant notation using the class keyword: class Component(NamedTuple): part_number: int weight: float description: Optional[str] = None See types.SimpleNamespace() for a mutable namespace based on an underlying dictionary instead of a tuple. The dataclasses module provides a decorator and functions for automatically adding generated special methods to user-defined classes. OrderedDict objects Ordered dictionaries are just like regular dictionaries but have some extra capabilities relating to ordering operations. They have become less important now that the built-in dict class gained the ability to remember insertion order (this new behavior became guaranteed in Python 3.7). Some differences from dict still remain: The regular dict was designed to be very good at mapping operations. Tracking insertion order was secondary. The OrderedDict was designed to be", "score": "0.6820043"}, {"id": "24412", "text": "Function: python.library.string#string.Formatter.parse\nSnippet: parse(format_string) Loop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields. The values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None.", "score": "0.6796713"}]}
{"task_id": "mbpp_311", "code": "def set_left_most_unset_bit(n): \r\n    if not (n & (n + 1)): \r\n        return n \r\n    pos, temp, count = 0, n, 0 \r\n    while temp: \r\n        if not (temp & 1): \r\n            pos = count      \r\n        count += 1; temp>>=1\r\n    return (n | (1 << (pos))) ", "test_list": ["assert set_left_most_unset_bit(10) == 14", "assert set_left_most_unset_bit(12) == 14", "assert set_left_most_unset_bit(15) == 15"], "context": "Write a python function to set the left most unset bit.", "function_name": "def set_left_most_unset_bit(n):", "gold_generation": "if not (n & (n + 1)): \r\n        return n \r\n    pos, temp, count = 0, n, 0 \r\n    while temp: \r\n        if not (temp & 1): \r\n            pos = count      \r\n        count += 1; temp>>=1\r\n    return (n | (1 << (pos)))", "ctxs": [{"id": "42935", "text": "Function: numpy.reference.generated.numpy.left_shift\nSnippet: numpy.left_shift numpy.left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'left_shift'> Shift the bits of an integer to the left. Bits are shifted to the left by appending x2 0s at the right of x1. Since the internal representation of numbers is in binary format, this operation is equivalent to multiplying x1 by 2**x2. Parameters x1array_like of integer type Input values. x2array_like of integer type Number of zeros to append to x1. Has to be non-negative. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outarray of integer type Return x1 with bits shifted x2 times to the left. This is a scalar if both x1 and x2 are scalars. See also right_shift Shift the bits of an integer to the right. binary_repr Return the binary representation of the input number as a string. Examples >>> np.binary_repr(5) '101' >>> np.left_shift(5, 2) 20 >>> np.binary_repr(20) '10100' >>> np.left_shift(5, [1,2,3]) array([10, 20, 40]) Note that the dtype of the second argument may change the dtype of the result and can lead to unexpected results in some cases (see Casting Rules): >>> a = np.left_shift(np.uint8(255), 1) # Expect 254 >>> print(a, type(a)) # Unexpected result due to upcasting 510 <class 'numpy.int64'> >>> b = np.left_shift(np.uint8(255), np.uint8(1)) >>> print(b, type(b)) 254 <class 'numpy.uint8'> The << operator can be used as a shorthand for np.left_shift on ndarrays. >>> x1 = 5 >>> x2 = np.array([1, 2, 3]) >>> x1 << x2 array([10, 20, 40])", "score": "0.6839035"}, {"id": "19694", "text": "Function: python.library.dis#dis.Instruction.offset\nSnippet: offset start index of operation within bytecode sequence", "score": "0.669268"}, {"id": "18673", "text": "Function: python.library.collections#collections.deque.popleft\nSnippet: popleft() Remove and return an element from the left side of the deque. If no elements are present, raises an IndexError.", "score": "0.6624217"}, {"id": "25434", "text": "Function: python.library.token#token.LEFTSHIFT\nSnippet: token.LEFTSHIFT Token value for \"<<\".", "score": "0.661833"}, {"id": "43261", "text": "Function: numpy.reference.generated.numpy.unpackbits\nSnippet: numpy.unpackbits numpy.unpackbits(a, /, axis=None, count=None, bitorder='big') Unpacks elements of a uint8 array into a binary-valued output array. Each element of a represents a bit-field that should be unpacked into a binary-valued output array. The shape of the output array is either 1-D (if axis is None) or the same shape as the input array with unpacking done along the axis specified. Parameters andarray, uint8 type Input array. axisint, optional The dimension over which bit-unpacking is done. None implies unpacking the flattened array. countint or None, optional The number of elements to unpack along axis, provided as a way of undoing the effect of packing a size that is not a multiple of eight. A non-negative number means to only unpack count bits. A negative number means to trim off that many bits from the end. None means to unpack the entire array (the default). Counts larger than the available number of bits will add zero padding to the output. Negative counts must not exceed the available number of bits. New in version 1.17.0. bitorder{‘big’, ‘little’}, optional The order of the returned bits. ‘big’ will mimic bin(val), 3 = 0b00000011 => [0, 0, 0, 0, 0, 0, 1, 1], ‘little’ will reverse the order to [1, 1, 0, 0, 0, 0, 0, 0]. Defaults to ‘big’. New in version 1.17.0. Returns unpackedndarray, uint8 type The elements are binary-valued (0 or 1). See also packbits Packs the elements of a binary-valued array into bits in a uint8 array. Examples >>> a = np.array([[2], [7], [23]], dtype=np.uint8) >>> a array([[ 2], [ 7], [23]], dtype=uint8) >>> b = np.unpackbits(a, axis=1) >>> b array([[0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8) >>> c = np.unpackbits(a, axis=1, count=-3) >>> c array([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0]], dtype=uint8) >>> p = np.packbits(b, axis=0) >>> np.unpackbits(p, axis=0) array([[0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8) >>> np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0])) True", "score": "0.6577293"}]}
{"task_id": "mbpp_312", "code": "import math\r\ndef volume_cone(r,h):\r\n  volume = (1.0/3) * math.pi * r * r * h\r\n  return volume", "test_list": ["assert volume_cone(5,12)==314.15926535897927", "assert volume_cone(10,15)==1570.7963267948965", "assert volume_cone(19,17)==6426.651371693521"], "context": "Write a function to find the volume of a cone.", "function_name": "import math\r\ndef volume_cone(r,h):", "gold_generation": "volume = (1.0/3) * math.pi * r * r * h\r\n  return volume", "ctxs": [{"id": "33487", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: barbs_doc='\\nPlot a 2D field of barbs.\\n\\nCall signature::\\n\\n barbs([X, Y], U, V, [C], **kw)\\n\\nWhere *X*, *Y* define the barb locations, *U*, *V* define the barb\\ndirections, and *C* optionally sets the color.\\n\\nAll arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked\\n*X*, *Y* are not supported at present.\\n\\nBarbs are traditionally used in meteorology as a way to plot the speed\\nand direction of wind observations, but can technically be used to\\nplot any two dimensional vector quantity. As opposed to arrows, which\\ngive vector magnitude by the length of the arrow, the barbs give more\\nquantitative information about the vector magnitude by putting slanted\\nlines or a triangle for various increments in magnitude, as show\\nschematically below::\\n\\n : /\\\\ \\\\\\n : / \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : ------------------------------\\n\\nThe largest increment is given by a triangle (or \"flag\"). After those\\ncome full lines (barbs). The smallest increment is a half line. There\\nis only, of course, ever at most 1 half line. If the magnitude is\\nsmall and only needs a single half-line and no full lines or\\ntriangles, the half-line is offset from the end of the barb so that it\\ncan be easily distinguished from barbs with a single full line. The\\nmagnitude for the barb shown above would nominally be 65, using the\\nstandard increments of 50, 10, and 5.\\n\\nSee also https://en.wikipedia.org/wiki/Wind_barb.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the barb locations. See *pivot* for how the\\n barbs are drawn to the x, y positions.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y components of the barb shaft.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If", "score": "0.6149393"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.613116"}, {"id": "33501", "text": "Function: matplotlib._as_gen.matplotlib.quiver.quiver#matplotlib.quiver.Quiver.quiver_doc\nSnippet: quiver_doc=\"\\nPlot a 2D field of arrows.\\n\\nCall signature::\\n\\n quiver([X, Y], U, V, [C], **kw)\\n\\n*X*, *Y* define the arrow locations, *U*, *V* define the arrow directions, and\\n*C* optionally sets the color.\\n\\nEach arrow is internally represented by a filled polygon with a default edge\\nlinewidth of 0. As a result, an arrow is rather a filled area, not a line with\\na head, and `.PolyCollection` properties like *linewidth*, *linestyle*,\\n*facecolor*, etc. act accordingly.\\n\\n**Arrow size**\\n\\nThe default settings auto-scales the length of the arrows to a reasonable size.\\nTo change this behavior see the *scale* and *scale_units* parameters.\\n\\n**Arrow shape**\\n\\nThe defaults give a slightly swept-back arrow; to make the head a\\ntriangle, make *headaxislength* the same as *headlength*. To make the\\narrow more pointed, reduce *headwidth* or increase *headlength* and\\n*headaxislength*. To make the head smaller relative to the shaft,\\nscale down all the head parameters. You will probably do best to leave\\nminshaft alone.\\n\\n**Arrow outline**\\n\\n*linewidths* and *edgecolors* can be used to customize the arrow\\noutlines.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the arrow locations.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y direction components of the arrow vectors.\\n\\n They must have the same number of elements, matching the number of arrow\\n locations. *U* and *V* may be masked. Only locations unmasked in\\n *U*, *V*, and *C* will be drawn.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the arrow colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *color* instead. The size of *C* must match the number of arrow\\n locations.\\n\\nunits : {'width', 'height', 'dots', 'inches', 'x', 'y', 'xy'}, default: 'width'\\n The arrow dimensions (except for *length*) are measured in multiples of\\n this unit.\\n\\n The following values are supported:\\n\\n - 'width', 'height': The width or height of the axis.\\n - 'dots', 'inches': Pixels or inches based on the figure dpi.\\n - 'x', 'y', 'xy': *X*, *Y* or :math:`\\\\sqrt{X^2 + Y^2}` in data units.\\n\\n The arrows scale differently depending on the units. For\\n 'x' or 'y', the arrows get larger as one zooms in; for other\\n units, the arrow size is independent of the zoom state. For\\n 'width or 'height', the arrow size increases with the width and\\n height of the axes, respectively, when the window is resized;\\n for 'dots' or 'inches', resizing does not change the arrows.\\n\\nangles : {'uv', 'xy'} or array-like, default: 'uv'\\n Method for determining the angle of the arrows.\\n\\n - 'uv': The arrow axis aspect ratio is 1 so that\\n if *U* == *V* the orientation of the arrow on the plot is 45 degrees\\n counter-clockwise from the horizontal axis (positive to the right).\\n\\n Use this if the arrows", "score": "0.6106104"}, {"id": "33497", "text": "Function: matplotlib._as_gen.matplotlib.quiver.quiver\nSnippet: vector will be 0.5 inches long.\\n\\n If *scale_units* is 'width' or 'height', then the vector will be half the\\n width/height of the axes.\\n\\n If *scale_units* is 'x' then the vector will be 0.5 x-axis\\n units. To plot vectors in the x-y plane, with u and v having\\n the same units as x and y, use\\n ``angles='xy', scale_units='xy', scale=1``.\\n\\nwidth : float, optional\\n Shaft width in arrow units; default depends on choice of units,\\n above, and number of vectors; a typical starting value is about\\n 0.005 times the width of the plot.\\n\\nheadwidth : float, default: 3\\n Head width as multiple of shaft width.\\n\\nheadlength : float, default: 5\\n Head length as multiple of shaft width.\\n\\nheadaxislength : float, default: 4.5\\n Head length at shaft intersection.\\n\\nminshaft : float, default: 1\\n Length below which arrow scales, in units of head length. Do not\\n set this to less than 1, or small arrows will look terrible!\\n\\nminlength : float, default: 1\\n Minimum length as a multiple of shaft width; if an arrow length\\n is less than this, plot a dot (hexagon) of this diameter instead.\\n\\npivot : {'tail', 'mid', 'middle', 'tip'}, default: 'tail'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The arrow\\n rotates about this point.\\n\\n 'mid' is a synonym for 'middle'.\\n\\ncolor : color or color sequence, optional\\n Explicit color(s) for the arrows. If *C* has been set, *color* has no\\n effect.\\n\\n This is a synonym for the `.PolyCollection` *facecolor* parameter.\\n\\nOther Parameters\\n----------------\\ndata : indexable object, optional\\n DATA_PARAMETER_PLACEHOLDER\\n\\n**kwargs : `~matplotlib.collections.PolyCollection` properties, optional\\n All other keyword arguments are passed on to `.PolyCollection`:\\n\\n \\n .. table::\\n :class: property-table\\n\\n ================================================================================================= =====================================================================================================\\n Property Description \\n ================================================================================================= =====================================================================================================\\n :meth:`agg_filter <matplotlib.artist.Artist.set_agg_filter>` a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array\\n :meth:`alpha <matplotlib.collections.Collection.set_alpha>` array-like or scalar or None \\n :meth:`animated <matplotlib.artist.Artist.set_animated>` bool \\n :meth:`antialiased <matplotlib.collections.Collection.set_antialiased>` or aa or antialiaseds bool or list of bools \\n :meth:`array <matplotlib.cm.ScalarMappable.set_array>` array-like or None \\n :meth:`capstyle <matplotlib.collections.Collection.set_capstyle>` `.CapStyle` or {'butt', 'projecting', 'round'} \\n :meth:`clim <matplotlib.cm.ScalarMappable.set_clim>` (vmin: float, vmax: float) \\n :meth:`clip_box <matplotlib.artist.Artist.set_clip_box>` `.Bbox` \\n :meth:`clip_on <matplotlib.artist.Artist.set_clip_on>` bool \\n :meth:`clip_path <matplotlib.artist.Artist.set_clip_path>` Patch or (Path, Transform) or None \\n :meth:`cmap <matplotlib.cm.ScalarMappable.set_cmap>` `.Colormap` or str or None \\n :meth:`color <matplotlib.collections.Collection.set_color>` color or list of rgba tuples \\n :meth:`edgecolor <matplotlib.collections.Collection.set_edgecolor>` or ec or edgecolors color or list of colors or 'face' \\n :meth:`facecolor <matplotlib.collections.Collection.set_facecolor>` or facecolors or fc color or list of colors \\n :meth:`figure <matplotlib.artist.Artist.set_figure>` `.Figure` \\n :meth:`gid <matplotlib.artist.Artist.set_gid>` str \\n :meth:`hatch <matplotlib.collections.Collection.set_hatch>` {'/', '\\\\\\\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} \\n :meth:`in_layout <matplotlib.artist.Artist.set_in_layout>` bool \\n :meth:`joinstyle <matplotlib.collections.Collection.set_joinstyle>` `.JoinStyle` or {'miter', 'round', 'bevel'} \\n :meth:`label <matplotlib.artist.Artist.set_label>` object \\n :meth:`linestyle <matplotlib.collections.Collection.set_linestyle>` or dashes or linestyles or ls str or tuple or list thereof \\n :meth:`linewidth <matplotlib.collections.Collection.set_linewidth>` or linewidths or lw float or list of floats \\n :meth:`norm <matplotlib.cm.ScalarMappable.set_norm>` `.Normalize` or None \\n :meth:`offset_transform <matplotlib.collections.Collection.set_offset_transform>` `.Transform` \\n :meth:`offsets <matplotlib.collections.Collection.set_offsets>` (N, 2) or (2,) array-like \\n :meth:`path_effects <matplotlib.artist.Artist.set_path_effects>` `.AbstractPathEffect` \\n :meth:`paths <matplotlib.collections.PolyCollection.set_verts>` list of array-like \\n :meth:`picker <matplotlib.artist.Artist.set_picker>` None or bool or float or callable \\n", "score": "0.6105454"}, {"id": "42715", "text": "Function: numpy.reference.generated.numpy.cos\nSnippet: numpy.cos numpy.cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'cos'> Cosine element-wise. Parameters xarray_like Input array in radians. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray The corresponding cosine values. This is a scalar if x is a scalar. Notes If out is provided, the function writes the result into it, and returns a reference to out. (See Examples) References M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions. New York, NY: Dover, 1972. Examples >>> np.cos(np.array([0, np.pi/2, np.pi])) array([ 1.00000000e+00, 6.12303177e-17, -1.00000000e+00]) >>> >>> # Example of providing the optional output parameter >>> out1 = np.array([0], dtype='d') >>> out2 = np.cos([0.1], out1) >>> out2 is out1 True >>> >>> # Example of ValueError due to provision of shape mis-matched `out` >>> np.cos(np.zeros((3,3)),np.zeros((2,2))) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: operands could not be broadcast together with shapes (3,3) (2,2)", "score": "0.6069147"}]}
{"task_id": "mbpp_313", "code": "def pos_nos(list1):\r\n  for num in list1: \r\n    if num >= 0: \r\n       return num ", "test_list": ["assert pos_nos([-1,-2,1,2]) == 1,2", "assert pos_nos([3,4,-5]) == 3,4", "assert pos_nos([-2,-3,1]) == 1"], "context": "Write a python function to print positive numbers in a list.", "function_name": "def pos_nos(list1):", "gold_generation": "for num in list1: \r\n    if num >= 0: \r\n       return num", "ctxs": [{"id": "25740", "text": "Function: python.library.stdtypes\nSnippet: omitted, it defaults to 0. If step is zero, ValueError is raised. For a positive step, the contents of a range r are determined by the formula r[i] = start + step*i where i >= 0 and r[i] < stop. For a negative step, the contents of the range are still determined by the formula r[i] = start + step*i, but the constraints are i >= 0 and r[i] > stop. A range object will be empty if r[0] does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than sys.maxsize are permitted but some features (such as len()) may raise OverflowError. Range examples: >>> list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> list(range(0, 30, 5)) [0, 5, 10, 15, 20, 25] >>> list(range(0, 10, 3)) [0, 3, 6, 9] >>> list(range(0, -10, -1)) [0, -1, -2, -3, -4, -5, -6, -7, -8, -9] >>> list(range(0)) [] >>> list(range(1, 0)) [] Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). start The value of the start parameter (or 0 if the parameter was not supplied) stop The value of the stop parameter step The value of the step parameter (or 1 if the parameter was not supplied) The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and subranges as needed). Range objects implement the collections.abc.Sequence ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): >>> r = range(0, 20, 2) >>> r range(0, 20, 2) >>> 11 in r False >>> 10 in r True >>> r.index(10) 5 >>> r[5] 10 >>> r[:5] range(0, 10, 2) >>> r[-1] 18 Testing range objects for equality with == and != compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different start, stop and step attributes, for example range(0) == range(2, 1, 3) or range(0, 3, 2) == range(0, 4, 2).) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test int objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity). New in version 3.3: The", "score": "0.68431765"}, {"id": "42894", "text": "Function: numpy.reference.constants\nSnippet: array([False]) numpy.e Euler’s constant, base of natural logarithms, Napier’s constant. e = 2.71828182845904523536028747135266249775724709369995... See Also exp : Exponential function log : Natural logarithm References https://en.wikipedia.org/wiki/E_%28mathematical_constant%29 numpy.euler_gamma γ = 0.5772156649015328606065120900824024310421... References https://en.wikipedia.org/wiki/Euler-Mascheroni_constant numpy.inf IEEE 754 floating point representation of (positive) infinity. Returns yfloat A floating point representation of positive infinity. See Also isinf : Shows which elements are positive or negative infinity isposinf : Shows which elements are positive infinity isneginf : Shows which elements are negative infinity isnan : Shows which elements are Not a Number isfinite : Shows which elements are finite (not one of Not a Number, positive infinity and negative infinity) Notes NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Also that positive infinity is not equivalent to negative infinity. But infinity is equivalent to positive infinity. Inf, Infinity, PINF and infty are aliases for inf. Examples >>> np.inf inf >>> np.array([1]) / 0. array([ Inf]) numpy.infty IEEE 754 floating point representation of (positive) infinity. Use inf because Inf, Infinity, PINF and infty are aliases for inf. For more details, see inf. See Also inf numpy.nan IEEE 754 floating point representation of Not a Number (NaN). Returns y : A floating point representation of Not a Number. See Also isnan : Shows which elements are Not a Number. isfinite : Shows which elements are finite (not one of Not a Number, positive infinity and negative infinity) Notes NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. NaN and NAN are aliases of nan. Examples >>> np.nan nan >>> np.log(-1) nan >>> np.log([-1, 1, 2]) array([ NaN, 0. , 0.69314718]) numpy.newaxis A convenient alias for None, useful for indexing arrays. Examples >>> newaxis is None True >>> x = np.arange(3) >>> x array([0, 1, 2]) >>> x[:, newaxis] array([[0], [1], [2]]) >>> x[:, newaxis, newaxis] array([[[0]], [[1]], [[2]]]) >>> x[:, newaxis] * x array([[0, 0, 0], [0, 1, 2], [0, 2, 4]]) Outer product, same as outer(x, y): >>> y = np.arange(3, 6) >>> x[:, newaxis] * y array([[ 0, 0, 0], [ 3, 4, 5], [ 6, 8, 10]]) x[newaxis, :] is equivalent to x[newaxis] and x[None]: >>> x[newaxis, :].shape (1, 3) >>> x[newaxis].shape (1, 3) >>> x[None].shape (1, 3) >>> x[:, newaxis].shape (3, 1) numpy.pi pi = 3.1415926535897932384626433... References https://en.wikipedia.org/wiki/Pi", "score": "0.6678023"}, {"id": "23167", "text": "Function: python.library.functions#print\nSnippet: print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False) Print objects to the text stream file, separated by sep and followed by end. sep, end, file and flush, if present, must be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end. The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Since printed arguments are converted to text strings, print() cannot be used with binary mode file objects. For these, use file.write(...) instead. Whether output is buffered is usually determined by file, but if the flush keyword argument is true, the stream is forcibly flushed. Changed in version 3.3: Added the flush keyword argument.", "score": "0.6605859"}, {"id": "43105", "text": "Function: numpy.reference.generated.numpy.positive\nSnippet: numpy.positive numpy.positive(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'positive'> Numerical positive, element-wise. New in version 1.13.0. Parameters xarray_like or scalar Input array. Returns yndarray or scalar Returned array or scalar: y = +x. This is a scalar if x is a scalar. Notes Equivalent to x.copy(), but only defined for types that support arithmetic. Examples >>> x1 = np.array(([1., -1.])) >>> np.positive(x1) array([ 1., -1.]) The unary + operator can be used as a shorthand for np.positive on ndarrays. >>> x1 = np.array(([1., -1.])) >>> +x1 array([ 1., -1.])", "score": "0.66049325"}, {"id": "23294", "text": "Function: python.library.stdtypes#range\nSnippet: class range(stop) class range(start, stop[, step]) The arguments to the range constructor must be integers (either built-in int or any object that implements the __index__ special method). If the step argument is omitted, it defaults to 1. If the start argument is omitted, it defaults to 0. If step is zero, ValueError is raised. For a positive step, the contents of a range r are determined by the formula r[i] = start + step*i where i >= 0 and r[i] < stop. For a negative step, the contents of the range are still determined by the formula r[i] = start + step*i, but the constraints are i >= 0 and r[i] > stop. A range object will be empty if r[0] does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than sys.maxsize are permitted but some features (such as len()) may raise OverflowError. Range examples: >>> list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> list(range(0, 30, 5)) [0, 5, 10, 15, 20, 25] >>> list(range(0, 10, 3)) [0, 3, 6, 9] >>> list(range(0, -10, -1)) [0, -1, -2, -3, -4, -5, -6, -7, -8, -9] >>> list(range(0)) [] >>> list(range(1, 0)) [] Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). start The value of the start parameter (or 0 if the parameter was not supplied) stop The value of the stop parameter step The value of the step parameter (or 1 if the parameter was not supplied)", "score": "0.65758055"}]}
{"task_id": "mbpp_314", "code": "def max_sum_rectangular_grid(grid, n) : \r\n\tincl = max(grid[0][0], grid[1][0]) \r\n\texcl = 0\r\n\tfor i in range(1, n) : \r\n\t\texcl_new = max(excl, incl) \r\n\t\tincl = excl + max(grid[0][i], grid[1][i]) \r\n\t\texcl = excl_new \r\n\treturn max(excl, incl)", "test_list": ["assert max_sum_rectangular_grid([ [1, 4, 5], [2, 0, 0 ] ], 3) == 7", "assert max_sum_rectangular_grid([ [ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10] ], 5) == 24", "assert max_sum_rectangular_grid([ [7, 9, 11, 15, 19], [21, 25, 28, 31, 32] ], 5) == 81"], "context": "Write a function to find out the maximum sum such that no two chosen numbers are adjacent for the given rectangular grid of dimension 2 x n.", "function_name": "def max_sum_rectangular_grid(grid, n) :", "gold_generation": "incl = max(grid[0][0], grid[1][0]) \r\n\texcl = 0\r\n\tfor i in range(1, n) : \r\n\t\texcl_new = max(excl, incl) \r\n\t\tincl = excl + max(grid[0][i], grid[1][i]) \r\n\t\texcl = excl_new \r\n\treturn max(excl, incl)", "ctxs": [{"id": "43079", "text": "Function: numpy.reference.generated.numpy.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.63534105"}, {"id": "42345", "text": "Function: numpy.reference.generated.numpy.ma.sum\nSnippet: numpy.ma.sum ma.sum(self, axis=None, dtype=None, out=None, keepdims=<no value>) = <numpy.ma.core._frommethod object> Return the sum of the array elements over the given axis. Masked elements are set to 0 internally. Refer to numpy.sum for full documentation. See also numpy.ndarray.sum corresponding function for ndarrays numpy.sum equivalent function Examples >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4) >>> x masked_array( data=[[1, --, 3], [--, 5, --], [7, --, 9]], mask=[[False, True, False], [ True, False, True], [False, True, False]], fill_value=999999) >>> x.sum() 25 >>> x.sum(axis=1) masked_array(data=[4, 5, 16], mask=[False, False, False], fill_value=999999) >>> x.sum(axis=0) masked_array(data=[8, 5, 12], mask=[False, False, False], fill_value=999999) >>> print(type(x.sum(axis=0, dtype=np.int64)[0])) <class 'numpy.int64'>", "score": "0.63225"}, {"id": "42298", "text": "Function: numpy.reference.generated.numpy.ma.maskedarray.sum\nSnippet: numpy.ma.MaskedArray.sum method ma.MaskedArray.sum(axis=None, dtype=None, out=None, keepdims=<no value>)[source] Return the sum of the array elements over the given axis. Masked elements are set to 0 internally. Refer to numpy.sum for full documentation. See also numpy.ndarray.sum corresponding function for ndarrays numpy.sum equivalent function Examples >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4) >>> x masked_array( data=[[1, --, 3], [--, 5, --], [7, --, 9]], mask=[[False, True, False], [ True, False, True], [False, True, False]], fill_value=999999) >>> x.sum() 25 >>> x.sum(axis=1) masked_array(data=[4, 5, 16], mask=[False, False, False], fill_value=999999) >>> x.sum(axis=0) masked_array(data=[8, 5, 12], mask=[False, False, False], fill_value=999999) >>> print(type(x.sum(axis=0, dtype=np.int64)[0])) <class 'numpy.int64'>", "score": "0.6276359"}, {"id": "41604", "text": "Function: numpy.reference.random.parallel\nSnippet: the golden ratio this way is a classic method of constructing a low-discrepancy sequence that spreads out the states around the period optimally. You will not be able to jump enough to make those distances small enough to overlap in your lifetime. jumped can be used to produce long blocks which should be long enough to not overlap. import secrets from numpy.random import PCG64 seed = secrets.getrandbits(128) blocked_rng = [] rng = PCG64(seed) for i in range(10): blocked_rng.append(rng.jumped(i)) When using jumped, one does have to take care not to jump to a stream that was already used. In the above example, one could not later use blocked_rng[0].jumped() as it would overlap with blocked_rng[1]. Like with the independent streams, if the main process here wants to split off 10 more streams by jumping, then it needs to start with range(10, 20), otherwise it would recreate the same streams. On the other hand, if you carefully construct the streams, then you are guaranteed to have streams that do not overlap.", "score": "0.6268798"}, {"id": "43199", "text": "Function: numpy.reference.generated.numpy.spacing\nSnippet: numpy.spacing numpy.spacing(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'spacing'> Return the distance between x and the nearest adjacent number. Parameters xarray_like Values to find the spacing of. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar The spacing of values of x. This is a scalar if x is a scalar. Notes It can be considered as a generalization of EPS: spacing(np.float64(1)) == np.finfo(np.float64).eps, and there should not be any representable number between x + spacing(x) and x for any finite x. Spacing of +- inf and NaN is NaN. Examples >>> np.spacing(1) == np.finfo(np.float64).eps True", "score": "0.62499094"}]}
{"task_id": "mbpp_315", "code": "def find_Max_Len_Even(str): \r\n    n = len(str) \r\n    i = 0\r\n    currlen = 0\r\n    maxlen = 0\r\n    st = -1\r\n    while (i < n): \r\n        if (str[i] == ' '): \r\n            if (currlen % 2 == 0): \r\n                if (maxlen < currlen): \r\n                    maxlen = currlen \r\n                    st = i - currlen \r\n            currlen = 0 \r\n        else : \r\n            currlen += 1\r\n        i += 1\r\n    if (currlen % 2 == 0): \r\n        if (maxlen < currlen): \r\n            maxlen = currlen \r\n            st = i - currlen \r\n    if (st == -1): \r\n        return \"-1\" \r\n    return str[st: st + maxlen] ", "test_list": ["assert find_Max_Len_Even(\"python language\") == \"language\"", "assert find_Max_Len_Even(\"maximum even length\") == \"length\"", "assert find_Max_Len_Even(\"eve\") == \"-1\""], "context": "Write a python function to find the first maximum length of even word.", "function_name": "def find_Max_Len_Even(str):", "gold_generation": "n = len(str) \r\n    i = 0\r\n    currlen = 0\r\n    maxlen = 0\r\n    st = -1\r\n    while (i < n): \r\n        if (str[i] == ' '): \r\n            if (currlen % 2 == 0): \r\n                if (maxlen < currlen): \r\n                    maxlen = currlen \r\n                    st = i - currlen \r\n            currlen = 0 \r\n        else : \r\n            currlen += 1\r\n        i += 1\r\n    if (currlen % 2 == 0): \r\n        if (maxlen < currlen): \r\n            maxlen = currlen \r\n            st = i - currlen \r\n    if (st == -1): \r\n        return \"-1\" \r\n    return str[st: st + maxlen]", "ctxs": [{"id": "23418", "text": "Function: python.library.reprlib#reprlib.Repr.maxlong\nSnippet: Repr.maxlong Maximum number of characters in the representation for an integer. Digits are dropped from the middle. The default is 40.", "score": "0.69516826"}, {"id": "24377", "text": "Function: python.library.stdtypes#str.split\nSnippet: str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3']", "score": "0.6897728"}, {"id": "25746", "text": "Function: python.library.stdtypes\nSnippet: Return -1 on failure. str.rindex(sub[, start[, end]]) Like rfind() but raises ValueError when the substring sub is not found. str.rjust(width[, fillchar]) Return the string right justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.rpartition(sep) Split the string at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself. str.rsplit(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any whitespace string is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below. str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty' str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3'] str.splitlines([keepends]) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. This", "score": "0.68655914"}, {"id": "20457", "text": "Function: python.library.hashlib#hashlib.blake2b.MAX_KEY_SIZE\nSnippet: blake2b.MAX_KEY_SIZE", "score": "0.6751531"}, {"id": "19587", "text": "Function: python.library.decimal#decimal.MAX_PREC\nSnippet: decimal.MAX_PREC", "score": "0.67351675"}]}
{"task_id": "mbpp_316", "code": "def find_last_occurrence(A, x):\r\n    (left, right) = (0, len(A) - 1)\r\n    result = -1\r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        if x == A[mid]:\r\n            result = mid\r\n            left = mid + 1\r\n        elif x < A[mid]:\r\n            right = mid - 1\r\n        else:\r\n            left = mid + 1\r\n    return result ", "test_list": ["assert find_last_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 3", "assert find_last_occurrence([2, 3, 5, 8, 6, 6, 8, 9, 9, 9], 9) == 9", "assert find_last_occurrence([2, 2, 1, 5, 6, 6, 6, 9, 9, 9], 6) == 6"], "context": "Write a function to find the index of the last occurrence of a given number in a sorted array.", "function_name": "def find_last_occurrence(A, x):", "gold_generation": "(left, right) = (0, len(A) - 1)\r\n    result = -1\r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        if x == A[mid]:\r\n            result = mid\r\n            left = mid + 1\r\n        elif x < A[mid]:\r\n            right = mid - 1\r\n        else:\r\n            left = mid + 1\r\n    return result", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.7625897"}, {"id": "22322", "text": "Function: python.library.operator#operator.indexOf\nSnippet: operator.indexOf(a, b) Return the index of the first of occurrence of b in a.", "score": "0.7089579"}, {"id": "41778", "text": "Function: numpy.reference.generated.numpy.chararray.find\nSnippet: numpy.chararray.find method chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.68929136"}, {"id": "41654", "text": "Function: numpy.reference.generated.numpy.char.chararray.find\nSnippet: numpy.char.chararray.find method char.chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.6854158"}, {"id": "24371", "text": "Function: python.library.stdtypes#str.rfind\nSnippet: str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.", "score": "0.6832307"}]}
{"task_id": "mbpp_317", "code": "from itertools import groupby\r\ndef modified_encode(alist):\r\n        def ctr_ele(el):\r\n            if len(el)>1: return [len(el), el[0]]\r\n            else: return el[0]\r\n        return [ctr_ele(list(group)) for key, group in groupby(alist)]", "test_list": ["assert modified_encode([1,1,2,3,4,4,5,1])==[[2, 1], 2, 3, [2, 4], 5, 1]", "assert modified_encode('automatically')==['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', [2, 'l'], 'y']", "assert modified_encode('python')==['p', 'y', 't', 'h', 'o', 'n']"], "context": "Write a function to reflect the modified run-length encoding from a list.", "function_name": "from itertools import groupby\r\ndef modified_encode(alist):", "gold_generation": "def ctr_ele(el):\r\n            if len(el)>1: return [len(el), el[0]]\r\n            else: return el[0]\r\n        return [ctr_ele(list(group)) for key, group in groupby(alist)]", "ctxs": [{"id": "25737", "text": "Function: python.library.stdtypes\nSnippet: a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str objects, you can build a list and use str.join() at the end or else write to an io.StringIO instance and retrieve its value when complete if concatenating bytes objects, you can similarly use bytes.join() or io.BytesIO, or you can do in-place concatenation with a bytearray object. bytearray objects are mutable and have an efficient overallocation mechanism if concatenating tuple objects, extend a list instead for other types, investigate the relevant class documentation Some sequence types (such as range) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition. index raises ValueError when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using s[i:j].index(x), only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. Immutable Sequence Types The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the hash() built-in. This support allows immutable sequences, such as tuple instances, to be used as dict keys and stored in set and frozenset instances. Attempting to hash an immutable sequence that contains unhashable values will result in TypeError. Mutable Sequence Types The operations in the following table are defined on mutable sequence types. The collections.abc.MutableSequence ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, bytearray only accepts integers that meet the value restriction 0 <= x <= 255). Operation Result Notes s[i] = x item i of s is replaced by x s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t del s[i:j] same as s[i:j] = [] s[i:j:k] = t the elements of s[i:j:k] are replaced by those of t (1) del s[i:j:k] removes the elements of s[i:j:k] from the list s.append(x) appends x to the end of the sequence (same as s[len(s):len(s)] = [x]) s.clear() removes all items from s (same as del s[:]) (5) s.copy() creates a shallow copy of s (same as s[:]) (5) s.extend(t) or s += t extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t) s *= n updates s with its contents repeated n times (6) s.insert(i, x) inserts x into s at the index given by i (same as s[i:i] = [x]) s.pop([i]) retrieves the item at i and also removes it", "score": "0.69395745"}, {"id": "21153", "text": "Function: python.library.io#io.TextIOWrapper\nSnippet: the other hand, changing encoding after write is possible. This method does an implicit stream flush before setting the new parameters. New in version 3.7.", "score": "0.6868648"}, {"id": "41690", "text": "Function: numpy.reference.generated.numpy.char.chararray.rstrip\nSnippet: numpy.char.chararray.rstrip method char.chararray.rstrip(chars=None)[source] For each element in self, return a copy with the trailing characters removed. See also char.rstrip", "score": "0.6838392"}, {"id": "21151", "text": "Function: python.library.io#io.TextIOBase.write\nSnippet: write(s) Write the string s to the stream and return the number of characters written.", "score": "0.6835902"}, {"id": "41812", "text": "Function: numpy.reference.generated.numpy.chararray.rstrip\nSnippet: numpy.chararray.rstrip method chararray.rstrip(chars=None)[source] For each element in self, return a copy with the trailing characters removed. See also char.rstrip", "score": "0.6800605"}]}
{"task_id": "mbpp_318", "code": "def max_volume (s): \r\n    maxvalue = 0\r\n    i = 1\r\n    for i in range(s - 1): \r\n        j = 1\r\n        for j in range(s): \r\n            k = s - i - j \r\n            maxvalue = max(maxvalue, i * j * k)         \r\n    return maxvalue ", "test_list": ["assert max_volume(8) == 18", "assert max_volume(4) == 2", "assert max_volume(1) == 0"], "context": "Write a python function to find the maximum volume of a cuboid with given sum of sides.", "function_name": "def max_volume (s):", "gold_generation": "maxvalue = 0\r\n    i = 1\r\n    for i in range(s - 1): \r\n        j = 1\r\n        for j in range(s): \r\n            k = s - i - j \r\n            maxvalue = max(maxvalue, i * j * k)         \r\n    return maxvalue", "ctxs": [{"id": "20457", "text": "Function: python.library.hashlib#hashlib.blake2b.MAX_KEY_SIZE\nSnippet: blake2b.MAX_KEY_SIZE", "score": "0.6608752"}, {"id": "20462", "text": "Function: python.library.hashlib#hashlib.blake2s.MAX_KEY_SIZE\nSnippet: blake2s.MAX_KEY_SIZE", "score": "0.65843236"}, {"id": "18126", "text": "Function: python.library.audioop#audioop.max\nSnippet: audioop.max(fragment, width) Return the maximum of the absolute value of all samples in a fragment.", "score": "0.65791494"}, {"id": "5647", "text": "Function: torch.generated.torch.bucketize#torch.bucketize\nSnippet: torch.bucketize(input, boundaries, *, out_int32=False, right=False, out=None) → Tensor Returns the indices of the buckets to which each value in the input belongs, where the boundaries of the buckets are set by boundaries. Return a new tensor with the same size as input. If right is False (default), then the left boundary is closed. More formally, the returned index satisfies the following rules: right returned index satisfies False boundaries[i-1] < input[m][n]...[l][x] <= boundaries[i] True boundaries[i-1] <= input[m][n]...[l][x] < boundaries[i] Parameters input (Tensor or Scalar) – N-D tensor or a Scalar containing the search value(s). boundaries (Tensor) – 1-D tensor, must contain a monotonically increasing sequence. Keyword Arguments out_int32 (bool, optional) – indicate the output data type. torch.int32 if True, torch.int64 otherwise. Default value is False, i.e. default output data type is torch.int64. right (bool, optional) – if False, return the first suitable location that is found. If True, return the last such index. If no suitable index found, return 0 for non-numerical value (eg. nan, inf) or the size of boundaries (one pass the last index). In other words, if False, gets the lower bound index for each value in input from boundaries. If True, gets the upper bound index instead. Default value is False. out (Tensor, optional) – the output tensor, must be the same size as input if provided. Example: >>> boundaries = torch.tensor([1, 3, 5, 7, 9]) >>> boundaries tensor([1, 3, 5, 7, 9]) >>> v = torch.tensor([[3, 6, 9], [3, 6, 9]]) >>> v tensor([[3, 6, 9], [3, 6, 9]]) >>> torch.bucketize(v, boundaries) tensor([[1, 3, 4], [1, 3, 4]]) >>> torch.bucketize(v, boundaries, right=True) tensor([[2, 3, 5], [2, 3, 5]])", "score": "0.65107495"}, {"id": "20456", "text": "Function: python.library.hashlib#hashlib.blake2b.MAX_DIGEST_SIZE\nSnippet: blake2b.MAX_DIGEST_SIZE", "score": "0.6489389"}]}
{"task_id": "mbpp_319", "code": "import re\r\ndef find_long_word(text):\r\n  return (re.findall(r\"\\b\\w{5}\\b\", text))", "test_list": ["assert find_long_word('Please move back to strem') == ['strem']", "assert find_long_word('4K Ultra HD streaming player') == ['Ultra']", "assert find_long_word('Streaming Media Player') == ['Media']"], "context": "Write a function to find all five characters long word in the given string by using regex.", "function_name": "import re\r\ndef find_long_word(text):", "gold_generation": "return (re.findall(r\"\\b\\w{5}\\b\", text))", "ctxs": [{"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.6881341"}, {"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.68712014"}, {"id": "23361", "text": "Function: python.library.re#re.Pattern.search\nSnippet: Pattern.search(string[, pos[, endpos]]) Scan through string looking for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\"", "score": "0.6829029"}, {"id": "23310", "text": "Function: python.library.re\nSnippet: for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\" Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). Pattern.fullmatch(string[, pos[, endpos]]) If the whole string matches this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o[gh]\") >>> pattern.fullmatch(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.fullmatch(\"ogre\") # No match as not the full string matches. >>> pattern.fullmatch(\"doggie\", 1, 3) # Matches within given limits. <re.Match object; span=(1, 3), match='og'> New in version 3.4. Pattern.split(string, maxsplit=0) Identical to the split() function, using the compiled pattern. Pattern.findall(string[, pos[, endpos]]) Similar to the findall() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.finditer(string[, pos[, endpos]]) Similar to the finditer() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.sub(repl, string, count=0) Identical to the sub() function, using the compiled pattern. Pattern.subn(repl, string, count=0) Identical to the subn() function, using the compiled pattern. Pattern.flags The regex", "score": "0.67787915"}, {"id": "23359", "text": "Function: python.library.re#re.Pattern.match\nSnippet: Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()).", "score": "0.66637355"}]}
{"task_id": "mbpp_320", "code": "def sum_difference(n):\r\n    sumofsquares = 0\r\n    squareofsum = 0\r\n    for num in range(1, n+1):\r\n        sumofsquares += num * num\r\n        squareofsum += num\r\n    squareofsum = squareofsum ** 2\r\n    return squareofsum - sumofsquares", "test_list": ["assert sum_difference(12)==5434", "assert sum_difference(20)==41230", "assert sum_difference(54)==2151270"], "context": "Write a function to calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.", "function_name": "def sum_difference(n):", "gold_generation": "sumofsquares = 0\r\n    squareofsum = 0\r\n    for num in range(1, n+1):\r\n        sumofsquares += num * num\r\n        squareofsum += num\r\n    squareofsum = squareofsum ** 2\r\n    return squareofsum - sumofsquares", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.67140156"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.65715456"}, {"id": "19512", "text": "Function: python.library.decimal#decimal.Context.subtract\nSnippet: subtract(x, y) Return the difference between x and y.", "score": "0.6501909"}, {"id": "21812", "text": "Function: python.library.math#math.isqrt\nSnippet: math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8.", "score": "0.6501137"}, {"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.6439692"}]}
{"task_id": "mbpp_321", "code": "def find_demlo(s): \r\n\tl = len(s) \r\n\tres = \"\" \r\n\tfor i in range(1,l+1): \r\n\t\tres = res + str(i) \r\n\tfor i in range(l-1,0,-1): \r\n\t\tres = res + str(i) \r\n\treturn res \t", "test_list": ["assert find_demlo(\"111111\") == '12345654321'", "assert find_demlo(\"1111\") == '1234321'", "assert find_demlo(\"13333122222\") == '123456789101110987654321'"], "context": "Write a function to find the demlo number for the given number.", "function_name": "def find_demlo(s):", "gold_generation": "l = len(s) \r\n\tres = \"\" \r\n\tfor i in range(1,l+1): \r\n\t\tres = res + str(i) \r\n\tfor i in range(l-1,0,-1): \r\n\t\tres = res + str(i) \r\n\treturn res", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6867469"}, {"id": "21776", "text": "Function: python.library.math\nSnippet: (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9. Note that frexp() and modf() have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 2**52 necessarily has no fractional bits. Power and logarithmic functions math.exp(x) Return e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). math.expm1(x) Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision: >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.0000050000069649e-05 >>> expm1(1e-5) # result accurate to full precision 1.0000050000166668e-05 New in version 3.2. math.log(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). math.log1p(x) Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. math.log2(x) Return the base-2 logarithm of x. This is usually more accurate than log(x, 2). New in version 3.3. See also int.bit_length() returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. math.log10(x) Return the base-10 logarithm of x. This is usually more accurate than log(x, 10). math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", "score": "0.66710573"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6628115"}, {"id": "36553", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.OGRGeomType.num\nSnippet: num", "score": "0.65968513"}, {"id": "24415", "text": "Function: python.library.string#string.octdigits\nSnippet: string.octdigits The string '01234567'.", "score": "0.6571188"}]}
{"task_id": "mbpp_322", "code": "def position_min(list1):\r\n    min_val = min(list1)\r\n    min_result = [i for i, j in enumerate(list1) if j == min_val]\r\n    return min_result", "test_list": ["assert position_min([12,33,23,10,67,89,45,667,23,12,11,10,54])==[3,11]", "assert position_min([1,2,2,2,4,4,4,5,5,5,5])==[0]", "assert position_min([2,1,5,6,8,3,4,9,10,11,8,12])==[1]"], "context": "Write a function to find all index positions of the minimum values in a given list.", "function_name": "def position_min(list1):", "gold_generation": "min_val = min(list1)\r\n    min_result = [i for i, j in enumerate(list1) if j == min_val]\r\n    return min_result", "ctxs": [{"id": "13013", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos#sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.72636986"}, {"id": "12778", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.7238239"}, {"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.70622855"}, {"id": "21919", "text": "Function: python.library.mmap#mmap.mmap.find\nSnippet: find(sub[, start[, end]]) Returns the lowest index in the object where the subsequence sub is found, such that sub is contained in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. Returns -1 on failure. Changed in version 3.5: Writable bytes-like object is now accepted.", "score": "0.7037494"}, {"id": "43830", "text": "Function: numpy.reference.generated.numpy.recarray.argmin\nSnippet: numpy.recarray.argmin method recarray.argmin(axis=None, out=None) Return indices of the minimum values along the given axis. Refer to numpy.argmin for detailed documentation. See also numpy.argmin equivalent function", "score": "0.7009273"}]}
{"task_id": "mbpp_323", "code": "def right_rotate(arr, n, out_of_place, cur):\r\n\ttemp = arr[cur]\r\n\tfor i in range(cur, out_of_place, -1):\r\n\t\tarr[i] = arr[i - 1]\r\n\tarr[out_of_place] = temp\r\n\treturn arr\r\ndef re_arrange(arr, n):\r\n\tout_of_place = -1\r\n\tfor index in range(n):\r\n\t\tif (out_of_place >= 0):\r\n\t\t\tif ((arr[index] >= 0 and arr[out_of_place] < 0) or\r\n\t\t\t(arr[index] < 0 and arr[out_of_place] >= 0)):\r\n\t\t\t\tarr = right_rotate(arr, n, out_of_place, index)\r\n\t\t\t\tif (index-out_of_place > 2):\r\n\t\t\t\t\tout_of_place += 2\r\n\t\t\t\telse:\r\n\t\t\t\t\tout_of_place = - 1\r\n\t\tif (out_of_place == -1):\r\n\t\t\tif ((arr[index] >= 0 and index % 2 == 0) or\r\n\t\t\t (arr[index] < 0 and index % 2 == 1)):\r\n\t\t\t\tout_of_place = index\r\n\treturn arr", "test_list": ["assert re_arrange([-5, -2, 5, 2, 4,\t7, 1, 8, 0, -8], 10) == [-5, 5, -2, 2, -8, 4, 7, 1, 8, 0]", "assert re_arrange([1, 2, 3, -4, -1, 4], 6) == [-4, 1, -1, 2, 3, 4]", "assert re_arrange([4, 7, 9, 77, -4, 5, -3, -9], 8) == [-4, 4, -3, 7, -9, 9, 77, 5]"], "context": "Write a function to re-arrange the given array in alternating positive and negative items.", "function_name": "def right_rotate(arr, n, out_of_place, cur):", "gold_generation": "temp = arr[cur]\r\n\tfor i in range(cur, out_of_place, -1):\r\n\t\tarr[i] = arr[i - 1]\r\n\tarr[out_of_place] = temp\r\n\treturn arr\r\ndef re_arrange(arr, n):\r\n\tout_of_place = -1\r\n\tfor index in range(n):\r\n\t\tif (out_of_place >= 0):\r\n\t\t\tif ((arr[index] >= 0 and arr[out_of_place] < 0) or\r\n\t\t\t(arr[index] < 0 and arr[out_of_place] >= 0)):\r\n\t\t\t\tarr = right_rotate(arr, n, out_of_place, index)\r\n\t\t\t\tif (index-out_of_place > 2):\r\n\t\t\t\t\tout_of_place += 2\r\n\t\t\t\telse:\r\n\t\t\t\t\tout_of_place = - 1\r\n\t\tif (out_of_place == -1):\r\n\t\t\tif ((arr[index] >= 0 and index % 2 == 0) or\r\n\t\t\t (arr[index] < 0 and index % 2 == 1)):\r\n\t\t\t\tout_of_place = index\r\n\treturn arr", "ctxs": [{"id": "17639", "text": "Function: python.library.array#array.array.insert\nSnippet: array.insert(i, x) Insert a new item with value x in the array before position i. Negative values are treated as being relative to the end of the array.", "score": "0.68946797"}, {"id": "17643", "text": "Function: python.library.array#array.array.reverse\nSnippet: array.reverse() Reverse the order of the items in the array.", "score": "0.68933284"}, {"id": "42832", "text": "Function: numpy.reference.generated.numpy.flipud\nSnippet: numpy.flipud numpy.flipud(m)[source] Reverse the order of elements along axis 0 (up/down). For a 2-D array, this flips the entries in each column in the up/down direction. Rows are preserved, but appear in a different order than before. Parameters marray_like Input array. Returns outarray_like A view of m with the rows reversed. Since a view is returned, this operation is \\(\\mathcal O(1)\\). See also fliplr Flip array in the left/right direction. flip Flip array in one or more dimensions. rot90 Rotate array counterclockwise. Notes Equivalent to m[::-1, ...] or np.flip(m, axis=0). Requires the array to be at least 1-D. Examples >>> A = np.diag([1.0, 2, 3]) >>> A array([[1., 0., 0.], [0., 2., 0.], [0., 0., 3.]]) >>> np.flipud(A) array([[0., 0., 3.], [0., 2., 0.], [1., 0., 0.]]) >>> A = np.random.randn(2,3,5) >>> np.all(np.flipud(A) == A[::-1,...]) True >>> np.flipud([1,2]) array([2, 1])", "score": "0.66679716"}, {"id": "43864", "text": "Function: numpy.reference.generated.numpy.recarray.partition\nSnippet: numpy.recarray.partition method recarray.partition(kth, axis=- 1, kind='introselect', order=None) Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array. All elements smaller than the kth element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined. New in version 1.8.0. Parameters kthint or sequence of ints Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. Deprecated since version 1.22.0: Passing booleans as index is deprecated. axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘introselect’}, optional Selection algorithm. Default is ‘introselect’. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.partition Return a parititioned copy of an array. argpartition Indirect partition. sort Full sort. Notes See np.partition for notes on the different algorithms. Examples >>> a = np.array([3, 4, 2, 1]) >>> a.partition(3) >>> a array([2, 1, 3, 4]) >>> a.partition((1, 3)) >>> a array([1, 2, 3, 4])", "score": "0.6633936"}, {"id": "43229", "text": "Function: numpy.reference.generated.numpy.transpose\nSnippet: numpy.transpose numpy.transpose(a, axes=None)[source] Reverse or permute the axes of an array; returns the modified array. For an array a with two axes, transpose(a) gives the matrix transpose. Refer to numpy.ndarray.transpose for full documentation. Parameters aarray_like Input array. axestuple or list of ints, optional If specified, it must be a tuple or list which contains a permutation of [0,1,..,N-1] where N is the number of axes of a. The i’th axis of the returned array will correspond to the axis numbered axes[i] of the input. If not specified, defaults to range(a.ndim)[::-1], which reverses the order of the axes. Returns pndarray a with its axes permuted. A view is returned whenever possible. See also ndarray.transpose Equivalent method moveaxis argsort Notes Use transpose(a, argsort(axes)) to invert the transposition of tensors when using the axes keyword argument. Transposing a 1-D array returns an unchanged view of the original array. Examples >>> x = np.arange(4).reshape((2,2)) >>> x array([[0, 1], [2, 3]]) >>> np.transpose(x) array([[0, 2], [1, 3]]) >>> x = np.ones((1, 2, 3)) >>> np.transpose(x, (1, 0, 2)).shape (2, 1, 3) >>> x = np.ones((2, 3, 4, 5)) >>> np.transpose(x).shape (5, 4, 3, 2)", "score": "0.6613797"}]}
{"task_id": "mbpp_324", "code": "def sum_of_alternates(test_tuple):\r\n  sum1 = 0\r\n  sum2 = 0\r\n  for idx, ele in enumerate(test_tuple):\r\n    if idx % 2:\r\n      sum1 += ele\r\n    else:\r\n      sum2 += ele\r\n  return ((sum1),(sum2)) ", "test_list": ["assert sum_of_alternates((5, 6, 3, 6, 10, 34)) == (46, 18)", "assert sum_of_alternates((1, 2, 3, 4, 5)) == (6, 9)", "assert sum_of_alternates((6, 7, 8, 9, 4, 5)) == (21, 18)"], "context": "Write a function to extract the sum of alternate chains of tuples.", "function_name": "def sum_of_alternates(test_tuple):", "gold_generation": "sum1 = 0\r\n  sum2 = 0\r\n  for idx, ele in enumerate(test_tuple):\r\n    if idx % 2:\r\n      sum1 += ele\r\n    else:\r\n      sum2 += ele\r\n  return ((sum1),(sum2))", "ctxs": [{"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.69978154"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.69388807"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.6798708"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6789273"}, {"id": "42756", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.as_list\nSnippet: numpy.distutils.misc_util.as_list(seq)[source]", "score": "0.6704962"}]}
{"task_id": "mbpp_325", "code": "def get_Min_Squares(n):\r\n    if n <= 3:\r\n        return n;\r\n    res = n \r\n    for x in range(1,n + 1):\r\n        temp = x * x;\r\n        if temp > n:\r\n            break\r\n        else:\r\n            res = min(res,1 + get_Min_Squares(n  - temp)) \r\n    return res;", "test_list": ["assert get_Min_Squares(6) == 3", "assert get_Min_Squares(2) == 2", "assert get_Min_Squares(4) == 1"], "context": "Write a python function to find the minimum number of squares whose sum is equal to a given number.", "function_name": "def get_Min_Squares(n):", "gold_generation": "if n <= 3:\r\n        return n;\r\n    res = n \r\n    for x in range(1,n + 1):\r\n        temp = x * x;\r\n        if temp > n:\r\n            break\r\n        else:\r\n            res = min(res,1 + get_Min_Squares(n  - temp)) \r\n    return res;", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.68077946"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.67294157"}, {"id": "43995", "text": "Function: numpy.reference.generated.numpy.ufunc.reduce\nSnippet: 6], [ 8, 10]]) >>> np.add.reduce(X) # confirm: default axis value is 0 array([[ 4, 6], [ 8, 10]]) >>> np.add.reduce(X, 1) array([[ 2, 4], [10, 12]]) >>> np.add.reduce(X, 2) array([[ 1, 5], [ 9, 13]]) You can use the initial keyword argument to initialize the reduction with a different value, and where to select specific elements to include: >>> np.add.reduce([10], initial=5) 15 >>> np.add.reduce(np.ones((2, 2, 2)), axis=(0, 2), initial=10) array([14., 14.]) >>> a = np.array([10., np.nan, 10]) >>> np.add.reduce(a, where=~np.isnan(a)) 20.0 Allows reductions of empty arrays where they would normally fail, i.e. for ufuncs without an identity. >>> np.minimum.reduce([], initial=np.inf) inf >>> np.minimum.reduce([[1., 2.], [3., 4.]], initial=10., where=[True, False]) array([ 1., 10.]) >>> np.minimum.reduce([]) Traceback (most recent call last): ... ValueError: zero-size array to reduction operation minimum which has no identity", "score": "0.6652787"}, {"id": "43202", "text": "Function: numpy.reference.generated.numpy.square\nSnippet: numpy.square numpy.square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'square'> Return the element-wise square of the input. Parameters xarray_like Input data. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Element-wise x*x, of the same shape and dtype as x. This is a scalar if x is a scalar. See also numpy.linalg.matrix_power sqrt power Examples >>> np.square([-1j, 1]) array([-1.-0.j, 1.+0.j])", "score": "0.66215515"}, {"id": "19492", "text": "Function: python.library.decimal#decimal.Context.min\nSnippet: min(x, y) Compares two values numerically and returns the minimum.", "score": "0.64785224"}]}
{"task_id": "mbpp_326", "code": "from collections import defaultdict \r\n\r\ndef most_occurrences(test_list):\r\n  temp = defaultdict(int)\r\n  for sub in test_list:\r\n    for wrd in sub.split():\r\n      temp[wrd] += 1\r\n  res = max(temp, key=temp.get)\r\n  return (str(res)) ", "test_list": ["assert most_occurrences([\"UTS is best for RTF\", \"RTF love UTS\", \"UTS is best\"] ) == 'UTS'", "assert most_occurrences([\"Its been a great year\", \"this year is so worse\", \"this year is okay\"] ) == 'year'", "assert most_occurrences([\"Families can be reunited\", \"people can be reunited\", \"Tasks can be achieved \"] ) == 'can'"], "context": "Write a function to get the word with most number of occurrences in the given strings list.", "function_name": "from collections import defaultdict \r\n\r\ndef most_occurrences(test_list):", "gold_generation": "temp = defaultdict(int)\r\n  for sub in test_list:\r\n    for wrd in sub.split():\r\n      temp[wrd] += 1\r\n  res = max(temp, key=temp.get)\r\n  return (str(res))", "ctxs": [{"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.6811114"}, {"id": "19634", "text": "Function: python.library.difflib#difflib.get_close_matches\nSnippet: difflib.get_close_matches(word, possibilities, n=3, cutoff=0.6) Return a list of the best “good enough” matches. word is a sequence for which close matches are desired (typically a string), and possibilities is a list of sequences against which to match word (typically a list of strings). Optional argument n (default 3) is the maximum number of close matches to return; n must be greater than 0. Optional argument cutoff (default 0.6) is a float in the range [0, 1]. Possibilities that don’t score at least that similar to word are ignored. The best (no more than n) matches among the possibilities are returned in a list, sorted by similarity score, most similar first. >>> get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy']) ['apple', 'ape'] >>> import keyword >>> get_close_matches('wheel', keyword.kwlist) ['while'] >>> get_close_matches('pineapple', keyword.kwlist) [] >>> get_close_matches('accept', keyword.kwlist) ['except']", "score": "0.6727426"}, {"id": "18655", "text": "Function: python.library.collections#collections.Counter.most_common\nSnippet: most_common([n]) Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered in the order first encountered: >>> Counter('abracadabra').most_common(3) [('a', 5), ('b', 2), ('r', 2)]", "score": "0.6718834"}, {"id": "21316", "text": "Function: python.library.itertools#itertools.zip_longest\nSnippet: itertools.zip_longest(*iterables, fillvalue=None) Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. Roughly equivalent to: def zip_longest(*args, fillvalue=None): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- iterators = [iter(it) for it in args] num_active = len(iterators) if not num_active: return while True: values = [] for i, it in enumerate(iterators): try: value = next(it) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values.append(value) yield tuple(values) If one of the iterables is potentially infinite, then the zip_longest() function should be wrapped with something that limits the number of calls (for example islice() or takewhile()). If not specified, fillvalue defaults to None.", "score": "0.6664347"}, {"id": "20488", "text": "Function: python.library.heapq#heapq.nlargest\nSnippet: heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n].", "score": "0.66630393"}]}
{"task_id": "mbpp_327", "code": "def check_isosceles(x,y,z):\r\n  if x==y or y==z or z==x:\r\n\t   return True\r\n  else:\r\n     return False", "test_list": ["assert check_isosceles(6,8,12)==False ", "assert check_isosceles(6,6,12)==True", "assert check_isosceles(6,16,20)==False"], "context": "Write a function to print check if the triangle is isosceles or not.", "function_name": "def check_isosceles(x,y,z):", "gold_generation": "if x==y or y==z or z==x:\r\n\t   return True\r\n  else:\r\n     return False", "ctxs": [{"id": "14549", "text": "Function: pandas.reference.api.pandas.dataframe.truediv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.68439853"}, {"id": "42538", "text": "Function: numpy.user.quickstart\nSnippet: 1.25, 1.5 , 1.75, 2. ]) >>> x = np.linspace(0, 2 * pi, 100) # useful to evaluate function at lots of points >>> f = np.sin(x) See also array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange, linspace, numpy.random.Generator.rand, numpy.random.Generator.randn, fromfunction, fromfile Printing Arrays When you print an array, NumPy displays it in a similar way to nested lists, but with the following layout: the last axis is printed from left to right, the second-to-last is printed from top to bottom, the rest are also printed from top to bottom, with each slice separated from the next by an empty line. One-dimensional arrays are then printed as rows, bidimensionals as matrices and tridimensionals as lists of matrices. >>> a = np.arange(6) # 1d array >>> print(a) [0 1 2 3 4 5] >>> >>> b = np.arange(12).reshape(4, 3) # 2d array >>> print(b) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] >>> >>> c = np.arange(24).reshape(2, 3, 4) # 3d array >>> print(c) [[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]] See below to get more details on reshape. If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners: >>> print(np.arange(10000)) [ 0 1 2 ... 9997 9998 9999] >>> >>> print(np.arange(10000).reshape(100, 100)) [[ 0 1 2 ... 97 98 99] [ 100 101 102 ... 197 198 199] [ 200 201 202 ... 297 298 299] ... [9700 9701 9702 ... 9797 9798 9799] [9800 9801 9802 ... 9897 9898 9899] [9900 9901 9902 ... 9997 9998 9999]] To disable this behaviour and force NumPy to print the entire array, you can change the printing options using set_printoptions. >>> np.set_printoptions(threshold=sys.maxsize) # sys module should be imported Basic Operations Arithmetic operators on arrays apply elementwise. A new array is created and filled with the result. >>> a = np.array([20, 30, 40, 50]) >>> b = np.arange(4) >>> b array([0, 1, 2, 3]) >>> c = a - b >>> c array([20, 29, 38, 47]) >>> b**2 array([0, 1, 4, 9]) >>> 10 * np.sin(a) array([ 9.12945251, -9.88031624, 7.4511316 , -2.62374854]) >>> a < 35 array([ True, True, False, False]) Unlike in many matrix languages, the product operator * operates elementwise in NumPy arrays. The matrix product can be performed using the @ operator (in python >=3.5) or the dot function or method: >>> A = np.array([[1, 1], ... [0, 1]]) >>> B = np.array([[2, 0], ... [3, 4]]) >>> A * B # elementwise product array([[2, 0], [0, 4]]) >>> A @ B # matrix product array([[5, 4], [3, 4]]) >>> A.dot(B) # another matrix product array([[5, 4], [3, 4]]) Some operations, such as += and *=, act in place to modify an existing array rather than create a new one. >>> rg = np.random.default_rng(1) # create instance of default", "score": "0.6754532"}, {"id": "14480", "text": "Function: pandas.reference.api.pandas.dataframe.rtruediv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.67179596"}, {"id": "14476", "text": "Function: pandas.reference.api.pandas.dataframe.rpow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6690434"}, {"id": "34305", "text": "Function: matplotlib.tri_api\nSnippet: matplotlib.tri Unstructured triangular grid functions. classmatplotlib.tri.Triangulation(x, y, triangles=None, mask=None)[source] An unstructured triangular grid consisting of npoints points and ntri triangles. The triangles can either be specified by the user or automatically generated using a Delaunay triangulation. Parameters x, y(npoints,) array-like Coordinates of grid points. triangles(ntri, 3) array-like of int, optional For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If not specified, the Delaunay triangulation is calculated. mask(ntri,) array-like of bool, optional Which triangles are masked out. Notes For a Triangulation to be valid it must not have duplicate points, triangles formed from colinear points, or overlapping triangles. Attributes triangles(ntri, 3) array of int For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If you want to take the mask into account, use get_masked_triangles instead. mask(ntri, 3) array of bool Masked out triangles. is_delaunaybool Whether the Triangulation is a calculated Delaunay triangulation (where triangles was not specified) or not. calculate_plane_coefficients(z)[source] Calculate plane equation coefficients for all unmasked triangles from the point (x, y) coordinates and specified z-array of shape (npoints). The returned array has shape (npoints, 3) and allows z-value at (x, y) position in triangle tri to be calculated using z = array[tri, 0] * x + array[tri, 1] * y + array[tri, 2]. propertyedges Return integer array of shape (nedges, 2) containing all edges of non-masked triangles. Each row defines an edge by it's start point index and end point index. Each edge appears only once, i.e. for an edge between points i and j, there will only be either (i, j) or (j, i). get_cpp_triangulation()[source] Return the underlying C++ Triangulation object, creating it if necessary. staticget_from_args_and_kwargs(*args, **kwargs)[source] Return a Triangulation object from the args and kwargs, and the remaining args and kwargs with the consumed values removed. There are two alternatives: either the first argument is a Triangulation object, in which case it is returned, or the args and kwargs are sufficient to create a new Triangulation to return. In the latter case, see Triangulation.__init__ for the possible args and kwargs. get_masked_triangles()[source] Return an array of triangles that are not masked. get_trifinder()[source] Return the default matplotlib.tri.TriFinder of this triangulation, creating it if necessary. This allows the same TriFinder object to be easily shared. propertyneighbors Return integer array of shape (ntri, 3) containing neighbor triangles. For each triangle, the indices of the three triangles that share the same edges, or -1 if there is no such neighboring triangle. neighbors[i, j] is the triangle that is the neighbor to the edge from point index triangles[i, j] to point index triangles[i, (j+1)%3]. set_mask(mask)[source] Set or clear the mask array. Parameters maskNone or bool array of length ntri classmatplotlib.tri.TriContourSet(ax, *args, **kwargs)[source] Bases: matplotlib.contour.ContourSet Create and store a set of contour lines or filled regions for a triangular grid. This class is typically not instantiated directly by the user but by tricontour and tricontourf. Attributes axAxes The Axes object in which the", "score": "0.66895866"}]}
{"task_id": "mbpp_328", "code": "def rotate_left(list1,m,n):\r\n  result =  list1[m:]+list1[:n]\r\n  return result", "test_list": ["assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],3,4)==[4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4]", "assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],2,2)==[3, 4, 5, 6, 7, 8, 9, 10, 1, 2]", "assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],5,2)==[6, 7, 8, 9, 10, 1, 2]"], "context": "Write a function to rotate a given list by specified number of items to the left direction.", "function_name": "def rotate_left(list1,m,n):", "gold_generation": "result =  list1[m:]+list1[:n]\r\n  return result", "ctxs": [{"id": "18676", "text": "Function: python.library.collections#collections.deque.rotate\nSnippet: rotate(n=1) Rotate the deque n steps to the right. If n is negative, rotate to the left. When the deque is not empty, rotating one step to the right is equivalent to d.appendleft(d.pop()), and rotating one step to the left is equivalent to d.append(d.popleft()).", "score": "0.7543277"}, {"id": "18614", "text": "Function: python.library.collections\nSnippet: 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0 # http://en.wikipedia.org/wiki/Moving_average it = iter(iterable) d = deque(itertools.islice(it, n-1)) d.appendleft(0) s = sum(d) for elem in it: s += elem - d.popleft() d.append(elem) yield s / n A round-robin scheduler can be implemented with input iterators stored in a deque. Values are yielded from the active iterator in position zero. If that iterator is exhausted, it can be removed with popleft(); otherwise, it can be cycled back to the end with the rotate() method: def roundrobin(*iterables): \"roundrobin('ABC', 'D', 'EF') --> A D E B F C\" iterators = deque(map(iter, iterables)) while iterators: try: while True: yield next(iterators[0]) iterators.rotate(-1) except StopIteration: # Remove an exhausted iterator. iterators.popleft() The rotate() method provides a way to implement deque slicing and deletion. For example, a pure Python implementation of del d[n] relies on the rotate() method to position elements to be popped: def delete_nth(d, n): d.rotate(-n) d.popleft() d.rotate(n) To implement deque slicing, use a similar approach applying rotate() to bring a target element to the left side of the deque. Remove old entries with popleft(), add new entries with extend(), and then reverse the rotation. With minor variations on that approach, it is easy to implement Forth style stack manipulations such as dup, drop, swap, over, pick, rot, and roll. defaultdict objects class collections.defaultdict([default_factory[, ...]]) Returns a new dictionary-like object. defaultdict is a subclass of the built-in dict class. It overrides one method and adds one writable instance variable. The remaining functionality is the same as for the dict class and is not documented here. The first argument provides the initial value for the default_factory attribute; it defaults to None. All remaining arguments are treated the same as if they were passed to the dict constructor, including keyword arguments. defaultdict objects support the following method in addition to the standard dict operations: __missing__(key) If the default_factory attribute is None, this raises a KeyError exception with the key as argument. If default_factory is not None, it is called without arguments to provide a default value for the given key, this value is inserted in the dictionary for the key, and returned. If calling default_factory raises an exception this exception is propagated unchanged. This method is called by the __getitem__() method of the dict class when the requested key is not found; whatever it returns or raises is then returned or raised by __getitem__(). Note that __missing__() is not called for any operations besides __getitem__(). This means that get() will, like normal dictionaries, return None as a default rather than using default_factory. defaultdict objects support the following instance variable: default_factory This attribute is used by the __missing__() method; it is initialized from the first argument to the constructor, if present, or to None, if absent. Changed in version 3.9: Added merge (|) and update (|=) operators, specified in PEP 584. defaultdict Examples Using list as the default_factory, it is easy to group a sequence of key-value pairs into a dictionary of lists: >>> s = [('yellow',", "score": "0.72694653"}, {"id": "18663", "text": "Function: python.library.collections#collections.deque.appendleft\nSnippet: appendleft(x) Add x to the left side of the deque.", "score": "0.7040716"}, {"id": "42831", "text": "Function: numpy.reference.generated.numpy.fliplr\nSnippet: numpy.fliplr numpy.fliplr(m)[source] Reverse the order of elements along axis 1 (left/right). For a 2-D array, this flips the entries in each row in the left/right direction. Columns are preserved, but appear in a different order than before. Parameters marray_like Input array, must be at least 2-D. Returns fndarray A view of m with the columns reversed. Since a view is returned, this operation is \\(\\mathcal O(1)\\). See also flipud Flip array in the up/down direction. flip Flip array in one or more dimensions. rot90 Rotate array counterclockwise. Notes Equivalent to m[:,::-1] or np.flip(m, axis=1). Requires the array to be at least 2-D. Examples >>> A = np.diag([1.,2.,3.]) >>> A array([[1., 0., 0.], [0., 2., 0.], [0., 0., 3.]]) >>> np.fliplr(A) array([[0., 0., 1.], [0., 2., 0.], [3., 0., 0.]]) >>> A = np.random.randn(2,3,5) >>> np.all(np.fliplr(A) == A[:,::-1,...]) True", "score": "0.7012445"}, {"id": "18613", "text": "Function: python.library.collections\nSnippet: deque. If no elements are present, raises an IndexError. popleft() Remove and return an element from the left side of the deque. If no elements are present, raises an IndexError. remove(value) Remove the first occurrence of value. If not found, raises a ValueError. reverse() Reverse the elements of the deque in-place and then return None. New in version 3.2. rotate(n=1) Rotate the deque n steps to the right. If n is negative, rotate to the left. When the deque is not empty, rotating one step to the right is equivalent to d.appendleft(d.pop()), and rotating one step to the left is equivalent to d.append(d.popleft()). Deque objects also provide one read-only attribute: maxlen Maximum size of a deque or None if unbounded. New in version 3.1. In addition to the above, deques support iteration, pickling, len(d), reversed(d), copy.copy(d), copy.deepcopy(d), membership testing with the in operator, and subscript references such as d[0] to access the first element. Indexed access is O(1) at both ends but slows to O(n) in the middle. For fast random access, use lists instead. Starting in version 3.5, deques support __add__(), __mul__(), and __imul__(). Example: >>> from collections import deque >>> d = deque('ghi') # make a new deque with three items >>> for elem in d: # iterate over the deque's elements ... print(elem.upper()) G H I >>> d.append('j') # add a new entry to the right side >>> d.appendleft('f') # add a new entry to the left side >>> d # show the representation of the deque deque(['f', 'g', 'h', 'i', 'j']) >>> d.pop() # return and remove the rightmost item 'j' >>> d.popleft() # return and remove the leftmost item 'f' >>> list(d) # list the contents of the deque ['g', 'h', 'i'] >>> d[0] # peek at leftmost item 'g' >>> d[-1] # peek at rightmost item 'i' >>> list(reversed(d)) # list the contents of a deque in reverse ['i', 'h', 'g'] >>> 'h' in d # search the deque True >>> d.extend('jkl') # add multiple elements at once >>> d deque(['g', 'h', 'i', 'j', 'k', 'l']) >>> d.rotate(1) # right rotation >>> d deque(['l', 'g', 'h', 'i', 'j', 'k']) >>> d.rotate(-1) # left rotation >>> d deque(['g', 'h', 'i', 'j', 'k', 'l']) >>> deque(reversed(d)) # make a new deque in reverse order deque(['l', 'k', 'j', 'i', 'h', 'g']) >>> d.clear() # empty the deque >>> d.pop() # cannot pop from an empty deque Traceback (most recent call last): File \"<pyshell#6>\", line 1, in -toplevel- d.pop() IndexError: pop from an empty deque >>> d.extendleft('abc') # extendleft() reverses the input order >>> d deque(['c', 'b', 'a']) deque Recipes This section shows various approaches to working with deques. Bounded length deques provide functionality similar to the tail filter in Unix: def tail(filename, n=10): 'Return the last n lines of a file' with open(filename) as f: return deque(f, n) Another approach to using deques is to maintain a sequence of recently added elements by appending to the right and popping to the left: def moving_average(iterable, n=3): # moving_average([40,", "score": "0.69457245"}]}
{"task_id": "mbpp_329", "code": "def neg_count(list):\r\n  neg_count= 0\r\n  for num in list: \r\n    if num <= 0: \r\n      neg_count += 1\r\n  return neg_count ", "test_list": ["assert neg_count([-1,-2,3,-4,-5]) == 4", "assert neg_count([1,2,3]) == 0", "assert neg_count([1,2,-3,-10,20]) == 2"], "context": "Write a python function to count negative numbers in a list.", "function_name": "def neg_count(list):", "gold_generation": "neg_count= 0\r\n  for num in list: \r\n    if num <= 0: \r\n      neg_count += 1\r\n  return neg_count", "ctxs": [{"id": "25740", "text": "Function: python.library.stdtypes\nSnippet: omitted, it defaults to 0. If step is zero, ValueError is raised. For a positive step, the contents of a range r are determined by the formula r[i] = start + step*i where i >= 0 and r[i] < stop. For a negative step, the contents of the range are still determined by the formula r[i] = start + step*i, but the constraints are i >= 0 and r[i] > stop. A range object will be empty if r[0] does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than sys.maxsize are permitted but some features (such as len()) may raise OverflowError. Range examples: >>> list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> list(range(0, 30, 5)) [0, 5, 10, 15, 20, 25] >>> list(range(0, 10, 3)) [0, 3, 6, 9] >>> list(range(0, -10, -1)) [0, -1, -2, -3, -4, -5, -6, -7, -8, -9] >>> list(range(0)) [] >>> list(range(1, 0)) [] Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). start The value of the start parameter (or 0 if the parameter was not supplied) stop The value of the stop parameter step The value of the step parameter (or 1 if the parameter was not supplied) The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and subranges as needed). Range objects implement the collections.abc.Sequence ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): >>> r = range(0, 20, 2) >>> r range(0, 20, 2) >>> 11 in r False >>> 10 in r True >>> r.index(10) 5 >>> r[5] 10 >>> r[:5] range(0, 10, 2) >>> r[-1] 18 Testing range objects for equality with == and != compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different start, stop and step attributes, for example range(0) == range(2, 1, 3) or range(0, 3, 2) == range(0, 4, 2).) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test int objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity). New in version 3.3: The", "score": "0.6817611"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.6781807"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.6775916"}, {"id": "43061", "text": "Function: numpy.reference.generated.numpy.negative\nSnippet: numpy.negative numpy.negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'negative'> Numerical negative, element-wise. Parameters xarray_like or scalar Input array. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar Returned array or scalar: y = -x. This is a scalar if x is a scalar. Examples >>> np.negative([1.,-1.]) array([-1., 1.]) The unary - operator can be used as a shorthand for np.negative on ndarrays. >>> x1 = np.array(([1., -1.])) >>> -x1 array([-1., 1.])", "score": "0.67529535"}, {"id": "17592", "text": "Function: python.library.argparse\nSnippet: negative numbers: >>> parser = argparse.ArgumentParser(prog='PROG') >>> parser.add_argument('-x') >>> parser.add_argument('foo', nargs='?') >>> # no negative number options, so -1 is a positional argument >>> parser.parse_args(['-x', '-1']) Namespace(foo=None, x='-1') >>> # no negative number options, so -1 and -5 are positional arguments >>> parser.parse_args(['-x', '-1', '-5']) Namespace(foo='-5', x='-1') >>> parser = argparse.ArgumentParser(prog='PROG') >>> parser.add_argument('-1', dest='one') >>> parser.add_argument('foo', nargs='?') >>> # negative number options present, so -1 is an option >>> parser.parse_args(['-1', 'X']) Namespace(foo=None, one='X') >>> # negative number options present, so -2 is an option >>> parser.parse_args(['-2']) usage: PROG [-h] [-1 ONE] [foo] PROG: error: no such option: -2 >>> # negative number options present, so both -1s are options >>> parser.parse_args(['-1', '-1']) usage: PROG [-h] [-1 ONE] [foo] PROG: error: argument -1: expected one argument If you have positional arguments that must begin with - and don’t look like negative numbers, you can insert the pseudo-argument '--' which tells parse_args() that everything after that is a positional argument: >>> parser.parse_args(['--', '-f']) Namespace(foo='-f', one=None) Argument abbreviations (prefix matching) The parse_args() method by default allows long options to be abbreviated to a prefix, if the abbreviation is unambiguous (the prefix matches a unique option): >>> parser = argparse.ArgumentParser(prog='PROG') >>> parser.add_argument('-bacon') >>> parser.add_argument('-badger') >>> parser.parse_args('-bac MMM'.split()) Namespace(bacon='MMM', badger=None) >>> parser.parse_args('-bad WOOD'.split()) Namespace(bacon=None, badger='WOOD') >>> parser.parse_args('-ba BA'.split()) usage: PROG [-h] [-bacon BACON] [-badger BADGER] PROG: error: ambiguous option: -ba could match -badger, -bacon An error is produced for arguments that could produce more than one options. This feature can be disabled by setting allow_abbrev to False. Beyond sys.argv Sometimes it may be useful to have an ArgumentParser parse arguments other than those of sys.argv. This can be accomplished by passing a list of strings to parse_args(). This is useful for testing at the interactive prompt: >>> parser = argparse.ArgumentParser() >>> parser.add_argument( ... 'integers', metavar='int', type=int, choices=range(10), ... nargs='+', help='an integer in the range 0..9') >>> parser.add_argument( ... '--sum', dest='accumulate', action='store_const', const=sum, ... default=max, help='sum the integers (default: find the max)') >>> parser.parse_args(['1', '2', '3', '4']) Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4]) >>> parser.parse_args(['1', '2', '3', '4', '--sum']) Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4]) The Namespace object class argparse.Namespace Simple class used by default by parse_args() to create an object holding attributes and return it. This class is deliberately simple, just an object subclass with a readable string representation. If you prefer to have dict-like view of the attributes, you can use the standard Python idiom, vars(): >>> parser = argparse.ArgumentParser() >>> parser.add_argument('--foo') >>> args = parser.parse_args(['--foo', 'BAR']) >>> vars(args) {'foo': 'BAR'} It may also be useful to have an ArgumentParser assign attributes to an already existing object, rather than a new Namespace object. This can be achieved by specifying the namespace= keyword argument: >>> class C: ... pass ... >>> c = C() >>> parser = argparse.ArgumentParser() >>> parser.add_argument('--foo') >>> parser.parse_args(args=['--foo', 'BAR'], namespace=c) >>> c.foo 'BAR' Other utilities Sub-commands ArgumentParser.add_subparsers([title][, description][, prog][, parser_class][, action][, option_string][, dest][, required][, help][, metavar]) Many programs split up their functionality into a number of sub-commands, for example,", "score": "0.6716652"}]}
{"task_id": "mbpp_330", "code": "import re\r\ndef find_char(text):\r\n  return (re.findall(r\"\\b\\w{3,5}\\b\", text))", "test_list": ["assert find_char('For the four consumer complaints contact manager AKR reddy') == ['For', 'the', 'four', 'AKR', 'reddy']", "assert find_char('Certain service are subject to change MSR') == ['are', 'MSR']", "assert find_char('Third party legal desclaimers') == ['Third', 'party', 'legal']"], "context": "Write a function to find all three, four, five characters long words in the given string by using regex.", "function_name": "import re\r\ndef find_char(text):", "gold_generation": "return (re.findall(r\"\\b\\w{3,5}\\b\", text))", "ctxs": [{"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.7012938"}, {"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.69517505"}, {"id": "23301", "text": "Function: python.library.re\nSnippet: repetitions as possible. For example, a{3,5} will match from 3 to 5 'a' characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, a{4,}b will match 'aaaab' or a thousand 'a' characters followed by a 'b', but not 'aaab'. The comma may not be omitted or the modifier would be confused with the previously described form. {m,n}? Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous qualifier. For example, on the 6-character string 'aaaaaa', a{3,5} will match 5 'a' characters, while a{3,5}? will only match 3 characters. \\ Either escapes special characters (permitting you to match characters like '*', '?', and so forth), or signals a special sequence; special sequences are discussed below. If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions. [] Used to indicate a set of characters. In a set: Characters can be listed individually, e.g. [amk] will match 'a', 'm', or 'k'. Ranges of characters can be indicated by giving two characters and separating them by a '-', for example [a-z] will match any lowercase ASCII letter, [0-5][0-9] will match all the two-digits numbers from 00 to 59, and [0-9A-Fa-f] will match any hexadecimal digit. If - is escaped (e.g. [a\\-z]) or if it’s placed as the first or last character (e.g. [-a] or [a-]), it will match a literal '-'. Special characters lose their special meaning inside sets. For example, [(+*)] will match any of the literal characters '(', '+', '*', or ')'. Character classes such as \\w or \\S (defined below) are also accepted inside a set, although the characters they match depends on whether ASCII or LOCALE mode is in force. Characters that are not within a range can be matched by complementing the set. If the first character of the set is '^', all the characters that are not in the set will be matched. For example, [^5] will match any character except '5', and [^^] will match any character except '^'. ^ has no special meaning if it’s not the first character in the set. To match a literal ']' inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both [()[\\]{}] and []()[{}] will both match a parenthesis. Support of nested sets and set operations as in Unicode Technical Standard #18 might be added in the future. This would change the syntax, so to facilitate this change", "score": "0.67649245"}, {"id": "23361", "text": "Function: python.library.re#re.Pattern.search\nSnippet: Pattern.search(string[, pos[, endpos]]) Scan through string looking for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\"", "score": "0.67609984"}, {"id": "23315", "text": "Function: python.library.re\nSnippet: ['carefully', 'quickly'] Finding all Adverbs and their Positions If one wants more information about all matches of a pattern than the matched text, finditer() is useful as it provides match objects instead of strings. Continuing with the previous example, if a writer wanted to find all of the adverbs and their positions in some text, they would use finditer() in the following manner: >>> text = \"He was carefully disguised but captured quickly by police.\" >>> for m in re.finditer(r\"\\w+ly\", text): ... print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0))) 07-16: carefully 40-47: quickly Raw String Notation Raw string notation (r\"text\") keeps regular expressions sane. Without it, every backslash ('\\') in a regular expression would have to be prefixed with another one to escape it. For example, the two following lines of code are functionally identical: >>> re.match(r\"\\W(.)\\1\\W\", \" ff \") <re.Match object; span=(0, 4), match=' ff '> >>> re.match(\"\\\\W(.)\\\\1\\\\W\", \" ff \") <re.Match object; span=(0, 4), match=' ff '> When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, this means r\"\\\\\". Without raw string notation, one must use \"\\\\\\\\\", making the following lines of code functionally identical: >>> re.match(r\"\\\\\", r\"\\\\\") <re.Match object; span=(0, 1), match='\\\\'> >>> re.match(\"\\\\\\\\\", r\"\\\\\") <re.Match object; span=(0, 1), match='\\\\'> Writing a Tokenizer A tokenizer or scanner analyzes a string to categorize groups of characters. This is a useful first step in writing a compiler or interpreter. The text categories are specified with regular expressions. The technique is to combine those into a single master regular expression and to loop over successive matches: from typing import NamedTuple import re class Token(NamedTuple): type: str value: str line: int column: int def tokenize(code): keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'} token_specification = [ ('NUMBER', r'\\d+(\\.\\d*)?'), # Integer or decimal number ('ASSIGN', r':='), # Assignment operator ('END', r';'), # Statement terminator ('ID', r'[A-Za-z]+'), # Identifiers ('OP', r'[+\\-*/]'), # Arithmetic operators ('NEWLINE', r'\\n'), # Line endings ('SKIP', r'[ \\t]+'), # Skip over spaces and tabs ('MISMATCH', r'.'), # Any other character ] tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specification) line_num = 1 line_start = 0 for mo in re.finditer(tok_regex, code): kind = mo.lastgroup value = mo.group() column = mo.start() - line_start if kind == 'NUMBER': value = float(value) if '.' in value else int(value) elif kind == 'ID' and value in keywords: kind = value elif kind == 'NEWLINE': line_start = mo.end() line_num += 1 continue elif kind == 'SKIP': continue elif kind == 'MISMATCH': raise RuntimeError(f'{value!r} unexpected on line {line_num}') yield Token(kind, value, line_num, column) statements = ''' IF quantity THEN total := total + price * quantity; tax := price * 0.05; ENDIF; ''' for token in tokenize(statements): print(token) The tokenizer produces the following output: Token(type='IF', value='IF', line=2, column=4) Token(type='ID', value='quantity', line=2, column=7) Token(type='THEN', value='THEN', line=2, column=16) Token(type='ID', value='total', line=3, column=8) Token(type='ASSIGN', value=':=', line=3, column=14) Token(type='ID', value='total', line=3, column=17) Token(type='OP', value='+', line=3, column=23) Token(type='ID', value='price', line=3, column=25) Token(type='OP', value='*', line=3, column=31) Token(type='ID', value='quantity', line=3, column=33)", "score": "0.6712914"}]}
{"task_id": "mbpp_331", "code": "def count_unset_bits(n): \r\n    count = 0\r\n    x = 1\r\n    while(x < n + 1): \r\n        if ((x & n) == 0): \r\n            count += 1\r\n        x = x << 1\r\n    return count  ", "test_list": ["assert count_unset_bits(2) == 1", "assert count_unset_bits(4) == 2", "assert count_unset_bits(6) == 1"], "context": "Write a python function to count unset bits of a given number.", "function_name": "def count_unset_bits(n):", "gold_generation": "count = 0\r\n    x = 1\r\n    while(x < n + 1): \r\n        if ((x & n) == 0): \r\n            count += 1\r\n        x = x << 1\r\n    return count", "ctxs": [{"id": "13465", "text": "Function: pygame.ref.mask#pygame.mask.Mask.count\nSnippet: count() Returns the number of set bits count() -> bits Returns: the number of set bits in the mask Return type: int", "score": "0.71906567"}, {"id": "21071", "text": "Function: python.library.stdtypes#int.bit_length\nSnippet: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1.", "score": "0.669393"}, {"id": "24241", "text": "Function: python.library.stat#stat.ST_INO\nSnippet: stat.ST_INO Inode number.", "score": "0.6691917"}, {"id": "25732", "text": "Function: python.library.stdtypes\nSnippet: there were an infinite number of sign bits. Additional Methods on Integer Types The int type implements the numbers.Integral abstract base class. In addition, it provides a few more methods: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1. int.to_bytes(length, byteorder, *, signed=False) Return an array of bytes representing an integer. >>> (1024).to_bytes(2, byteorder='big') b'\\x04\\x00' >>> (1024).to_bytes(10, byteorder='big') b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00' >>> (-1024).to_bytes(10, byteorder='big', signed=True) b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00' >>> x = 1000 >>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little') b'\\xe8\\x03' The integer is represented using length bytes. An OverflowError is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument determines whether two’s complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. The default value for signed is False. New in version 3.2. classmethod int.from_bytes(bytes, byteorder, *, signed=False) Return the integer represented by the given array of bytes. >>> int.from_bytes(b'\\x00\\x10', byteorder='big') 16 >>> int.from_bytes(b'\\x00\\x10', byteorder='little') 4096 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True) -1024 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False) 64512 >>> int.from_bytes([255, 0, 0], byteorder='big') 16711680 The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. New in version 3.2. int.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original integer and with a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. New in version 3.8. Additional Methods on Float The float type implements the numbers.Real abstract base class. float also has the following additional methods. float.as_integer_ratio() Return a pair of integers whose", "score": "0.6675935"}, {"id": "23488", "text": "Function: python.library.secrets#secrets.randbits\nSnippet: secrets.randbits(k) Return an int with k random bits.", "score": "0.65908706"}]}
{"task_id": "mbpp_332", "code": "def char_frequency(str1):\r\n    dict = {}\r\n    for n in str1:\r\n        keys = dict.keys()\r\n        if n in keys:\r\n            dict[n] += 1\r\n        else:\r\n            dict[n] = 1\r\n    return dict", "test_list": ["assert char_frequency('python')=={'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1}", "assert char_frequency('program')=={'p': 1, 'r': 2, 'o': 1, 'g': 1, 'a': 1, 'm': 1}", "assert char_frequency('language')=={'l': 1, 'a': 2, 'n': 1, 'g': 2, 'u': 1, 'e': 1}"], "context": "Write a function to count character frequency of a given string.", "function_name": "def char_frequency(str1):", "gold_generation": "dict = {}\r\n    for n in str1:\r\n        keys = dict.keys()\r\n        if n in keys:\r\n            dict[n] += 1\r\n        else:\r\n            dict[n] = 1\r\n    return dict", "ctxs": [{"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.7048473"}, {"id": "14928", "text": "Function: pandas.reference.api.pandas.period.freqstr\nSnippet: pandas.Period.freqstr Period.freqstr Return a string representation of the frequency.", "score": "0.70283884"}, {"id": "14927", "text": "Function: pandas.reference.api.pandas.period.freq\nSnippet: pandas.Period.freq Period.freq", "score": "0.6993495"}, {"id": "21151", "text": "Function: python.library.io#io.TextIOBase.write\nSnippet: write(s) Write the string s to the stream and return the number of characters written.", "score": "0.6950619"}, {"id": "41643", "text": "Function: numpy.reference.generated.numpy.char.chararray.count\nSnippet: numpy.char.chararray.count method char.chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.6844301"}]}
{"task_id": "mbpp_333", "code": "def Sort(sub_li): \r\n    sub_li.sort(key = lambda x: x[1]) \r\n    return sub_li ", "test_list": ["assert Sort([['a', 10], ['b', 5], ['c', 20], ['d', 15]]) == [['b', 5], ['a', 10], ['d', 15], ['c', 20]]", "assert Sort([['452', 10], ['256', 5], ['100', 20], ['135', 15]]) == [['256', 5], ['452', 10], ['135', 15], ['100', 20]]", "assert Sort([['rishi', 10], ['akhil', 5], ['ramya', 20], ['gaur', 15]]) == [['akhil', 5], ['rishi', 10], ['gaur', 15], ['ramya', 20]]"], "context": "Write a python function to sort a list according to the second element in sublist.", "function_name": "def Sort(sub_li):", "gold_generation": "sub_li.sort(key = lambda x: x[1]) \r\n    return sub_li", "ctxs": [{"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.686869"}, {"id": "42938", "text": "Function: numpy.reference.generated.numpy.lexsort\nSnippet: numpy.lexsort numpy.lexsort(keys, axis=- 1) Perform an indirect stable sort using a sequence of keys. Given multiple sorting keys, which can be interpreted as columns in a spreadsheet, lexsort returns an array of integer indices that describes the sort order by multiple columns. The last key in the sequence is used for the primary sort order, the second-to-last key for the secondary sort order, and so on. The keys argument must be a sequence of objects that can be converted to arrays of the same shape. If a 2D array is provided for the keys argument, its rows are interpreted as the sorting keys and sorting is according to the last row, second last row etc. Parameters keys(k, N) array or tuple containing k (N,)-shaped sequences The k different “columns” to be sorted. The last column (or row if keys is a 2D array) is the primary sort key. axisint, optional Axis to be indirectly sorted. By default, sort over the last axis. Returns indices(N,) ndarray of ints Array of indices that sort the keys along the specified axis. See also argsort Indirect sort. ndarray.sort In-place sort. sort Return a sorted copy of an array. Examples Sort names: first by surname, then by name. >>> surnames = ('Hertz', 'Galilei', 'Hertz') >>> first_names = ('Heinrich', 'Galileo', 'Gustav') >>> ind = np.lexsort((first_names, surnames)) >>> ind array([1, 2, 0]) >>> [surnames[i] + \", \" + first_names[i] for i in ind] ['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich'] Sort two columns of numbers: >>> a = [1,5,1,4,3,4,4] # First column >>> b = [9,4,0,4,0,2,1] # Second column >>> ind = np.lexsort((b,a)) # Sort by a, then by b >>> ind array([2, 0, 4, 6, 5, 3, 1]) >>> [(a[i],b[i]) for i in ind] [(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)] Note that sorting is first according to the elements of a. Secondary sorting is according to the elements of b. A normal argsort would have yielded: >>> [(a[i],b[i]) for i in np.argsort(a)] [(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)] Structured arrays are sorted lexically by argsort: >>> x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)], ... dtype=np.dtype([('x', int), ('y', int)])) >>> np.argsort(x) # or np.argsort(x, order=('x', 'y')) array([2, 0, 4, 6, 5, 3, 1])", "score": "0.6715541"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.6681489"}, {"id": "14909", "text": "Function: pandas.reference.api.pandas.multiindex.sortlevel\nSnippet: pandas.MultiIndex.sortlevel MultiIndex.sortlevel(level=0, ascending=True, sort_remaining=True)[source] Sort MultiIndex at the requested level. The result will respect the original ordering of the associated factor at that level. Parameters level:list-like, int or str, default 0 If a string is given, must be a name of the level. If list-like must be names or ints of levels. ascending:bool, default True False to sort in descending order. Can also be a list to specify a directed ordering. sort_remaining:sort by the remaining levels after level Returns sorted_index:pd.MultiIndex Resulting index. indexer:np.ndarray[np.intp] Indices of output values in original index. Examples >>> mi = pd.MultiIndex.from_arrays([[0, 0], [2, 1]]) >>> mi MultiIndex([(0, 2), (0, 1)], ) >>> mi.sortlevel() (MultiIndex([(0, 1), (0, 2)], ), array([1, 0])) >>> mi.sortlevel(sort_remaining=False) (MultiIndex([(0, 2), (0, 1)], ), array([0, 1])) >>> mi.sortlevel(1) (MultiIndex([(0, 1), (0, 2)], ), array([1, 0])) >>> mi.sortlevel(1, ascending=False) (MultiIndex([(0, 2), (0, 1)], ), array([0, 1]))", "score": "0.66604596"}, {"id": "23949", "text": "Function: python.library.functions#sorted\nSnippet: sorted(iterable, *, key=None, reverse=False) Return a new sorted list from the items in iterable. Has two optional arguments which must be specified as keyword arguments. key specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. Use functools.cmp_to_key() to convert an old-style cmp function to a key function. The built-in sorted() function is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO.", "score": "0.6651205"}]}
{"task_id": "mbpp_334", "code": "def check_Validity(a,b,c):  \r\n    if (a + b <= c) or (a + c <= b) or (b + c <= a) : \r\n        return False\r\n    else: \r\n        return True        ", "test_list": ["assert check_Validity(1,2,3) == False", "assert check_Validity(2,3,5) == False", "assert check_Validity(7,10,5) == True"], "context": "Write a python function to check whether the triangle is valid or not if sides are given.", "function_name": "def check_Validity(a,b,c):", "gold_generation": "if (a + b <= c) or (a + c <= b) or (b + c <= a) : \r\n        return False\r\n    else: \r\n        return True", "ctxs": [{"id": "14480", "text": "Function: pandas.reference.api.pandas.dataframe.rtruediv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.705238"}, {"id": "14324", "text": "Function: pandas.reference.api.pandas.dataframe.div\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.7021698"}, {"id": "14450", "text": "Function: pandas.reference.api.pandas.dataframe.rdiv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.7013056"}, {"id": "14476", "text": "Function: pandas.reference.api.pandas.dataframe.rpow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.69756556"}, {"id": "14549", "text": "Function: pandas.reference.api.pandas.dataframe.truediv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.69705844"}]}
{"task_id": "mbpp_335", "code": "def ap_sum(a,n,d):\r\n  total = (n * (2 * a + (n - 1) * d)) / 2\r\n  return total", "test_list": ["assert ap_sum(1,5,2)==25", "assert ap_sum(2,6,4)==72", "assert ap_sum(1,4,5)==34"], "context": "Write a function to find the sum of arithmetic progression.", "function_name": "def ap_sum(a,n,d):", "gold_generation": "total = (n * (2 * a + (n - 1) * d)) / 2\r\n  return total", "ctxs": [{"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.67114806"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.67001104"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6619736"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.65814143"}, {"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.6569064"}]}
{"task_id": "mbpp_336", "code": "def check_monthnum(monthname1):\r\n  if monthname1 == \"February\":\r\n    return True\r\n  else:\r\n    return False", "test_list": ["assert check_monthnum(\"February\")==True", "assert check_monthnum(\"January\")==False", "assert check_monthnum(\"March\")==False"], "context": "Write a function to check whether the given month name contains 28 days or not.", "function_name": "def check_monthnum(monthname1):", "gold_generation": "if monthname1 == \"February\":\r\n    return True\r\n  else:\r\n    return False", "ctxs": [{"id": "15492", "text": "Function: pandas.reference.api.pandas.timestamp.days_in_month\nSnippet: pandas.Timestamp.days_in_month Timestamp.days_in_month Return the number of days in the month. Examples >>> ts = pd.Timestamp(2020, 3, 14) >>> ts.days_in_month 31", "score": "0.70836127"}, {"id": "15498", "text": "Function: pandas.reference.api.pandas.timestamp.freqstr\nSnippet: pandas.Timestamp.freqstr propertyTimestamp.freqstr Return the total number of days in the month.", "score": "0.70463693"}, {"id": "19312", "text": "Function: python.library.datetime#datetime.date.month\nSnippet: date.month Between 1 and 12 inclusive.", "score": "0.70236564"}, {"id": "15127", "text": "Function: pandas.reference.api.pandas.series.dt.days_in_month\nSnippet: pandas.Series.dt.days_in_month Series.dt.days_in_month The number of days in the month.", "score": "0.7013786"}, {"id": "14955", "text": "Function: pandas.reference.api.pandas.periodindex.days_in_month\nSnippet: pandas.PeriodIndex.days_in_month propertyPeriodIndex.days_in_month The number of days in the month.", "score": "0.70080864"}]}
{"task_id": "mbpp_337", "code": "import re\r\ndef text_match_word(text):\r\n        patterns = '\\w+\\S*$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return 'Not matched!'", "test_list": ["assert text_match_word(\"python.\")==('Found a match!')", "assert text_match_word(\"python.\")==('Found a match!')", "assert text_match_word(\"  lang  .\")==('Not matched!')"], "context": "Write a function that matches a word at the end of a string, with optional punctuation.", "function_name": "import re\r\ndef text_match_word(text):", "gold_generation": "patterns = '\\w+\\S*$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return 'Not matched!'", "ctxs": [{"id": "24417", "text": "Function: python.library.string#string.punctuation\nSnippet: string.punctuation String of ASCII characters which are considered punctuation characters in the C locale: !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~.", "score": "0.70644224"}, {"id": "23310", "text": "Function: python.library.re\nSnippet: for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\" Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). Pattern.fullmatch(string[, pos[, endpos]]) If the whole string matches this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o[gh]\") >>> pattern.fullmatch(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.fullmatch(\"ogre\") # No match as not the full string matches. >>> pattern.fullmatch(\"doggie\", 1, 3) # Matches within given limits. <re.Match object; span=(1, 3), match='og'> New in version 3.4. Pattern.split(string, maxsplit=0) Identical to the split() function, using the compiled pattern. Pattern.findall(string[, pos[, endpos]]) Similar to the findall() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.finditer(string[, pos[, endpos]]) Similar to the finditer() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.sub(repl, string, count=0) Identical to the sub() function, using the compiled pattern. Pattern.subn(repl, string, count=0) Identical to the subn() function, using the compiled pattern. Pattern.flags The regex", "score": "0.6971801"}, {"id": "23359", "text": "Function: python.library.re#re.Pattern.match\nSnippet: Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()).", "score": "0.6950621"}, {"id": "23300", "text": "Function: python.library.re\nSnippet: For further information and a gentler presentation, consult the Regular Expression HOWTO. Regular expressions can contain both special and ordinary characters. Most ordinary characters, like 'A', 'a', or '0', are the simplest regular expressions; they simply match themselves. You can concatenate ordinary characters, so last matches the string 'last'. (In the rest of this section, we’ll write RE’s in this special style, usually without quotes, and strings to be matched 'in single quotes'.) Some characters, like '|' or '(', are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. Repetition qualifiers (*, +, ?, {m,n}, etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix ?, and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression (?:a{6})* matches any multiple of six 'a' characters. The special characters are: . (Dot.) In the default mode, this matches any character except a newline. If the DOTALL flag has been specified, this matches any character including a newline. ^ (Caret.) Matches the start of the string, and in MULTILINE mode also matches immediately after each newline. $ Matches the end of the string or just before the newline at the end of the string, and in MULTILINE mode also matches before a newline. foo matches both ‘foo’ and ‘foobar’, while the regular expression foo$ matches only ‘foo’. More interestingly, searching for foo.$ in 'foo1\\nfoo2\\n' matches ‘foo2’ normally, but ‘foo1’ in MULTILINE mode; searching for a single $ in 'foo\\n' will find two (empty) matches: one just before the newline, and one at the end of the string. * Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. ab* will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s. + Causes the resulting RE to match 1 or more repetitions of the preceding RE. ab+ will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’. ? Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. ab? will match either ‘a’ or ‘ab’. *?, +?, ?? The '*', '+', and '?' qualifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE <.*> is matched against '<a> b <c>', it will match the entire string, and not just '<a>'. Adding ? after the qualifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using the RE <.*?> will match only '<a>'. {m} Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, a{6} will match exactly six 'a' characters, but not five. {m,n} Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many", "score": "0.6876486"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.68565506"}]}
{"task_id": "mbpp_338", "code": "def check_Equality(s): \r\n    return (ord(s[0]) == ord(s[len(s) - 1])); \r\ndef count_Substring_With_Equal_Ends(s): \r\n    result = 0; \r\n    n = len(s); \r\n    for i in range(n):\r\n        for j in range(1,n-i+1): \r\n            if (check_Equality(s[i:i+j])): \r\n                result+=1; \r\n    return result; ", "test_list": ["assert count_Substring_With_Equal_Ends('aba') == 4", "assert count_Substring_With_Equal_Ends('abcab') == 7", "assert count_Substring_With_Equal_Ends('abc') == 3"], "context": "Write a python function to count the number of substrings with same first and last characters.", "function_name": "def check_Equality(s):", "gold_generation": "return (ord(s[0]) == ord(s[len(s) - 1])); \r\ndef count_Substring_With_Equal_Ends(s): \r\n    result = 0; \r\n    n = len(s); \r\n    for i in range(n):\r\n        for j in range(1,n-i+1): \r\n            if (check_Equality(s[i:i+j])): \r\n                result+=1; \r\n    return result;", "ctxs": [{"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.7631488"}, {"id": "41718", "text": "Function: numpy.reference.generated.numpy.char.count\nSnippet: numpy.char.count char.count(a, sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. Calls str.count element-wise. Parameters aarray_like of str or unicode substr or unicode The substring to search for. start, endint, optional Optional arguments start and end are interpreted as slice notation to specify the range in which to count. Returns outndarray Output array of ints. See also str.count Examples >>> c = np.array(['aAaAaA', ' aA ', 'abBABba']) >>> c array(['aAaAaA', ' aA ', 'abBABba'], dtype='<U7') >>> np.char.count(c, 'A') array([3, 1, 1]) >>> np.char.count(c, 'aA') array([3, 1, 0]) >>> np.char.count(c, 'A', start=1, end=4) array([2, 1, 1]) >>> np.char.count(c, 'A', start=1, end=3) array([1, 0, 0])", "score": "0.74186456"}, {"id": "41643", "text": "Function: numpy.reference.generated.numpy.char.chararray.count\nSnippet: numpy.char.chararray.count method char.chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.73721814"}, {"id": "41768", "text": "Function: numpy.reference.generated.numpy.chararray.count\nSnippet: numpy.chararray.count method chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.7336177"}, {"id": "41747", "text": "Function: numpy.reference.generated.numpy.char.replace\nSnippet: numpy.char.replace char.replace(a, old, new, count=None)[source] For each element in a, return a copy of the string with all occurrences of substring old replaced by new. Calls str.replace element-wise. Parameters aarray-like of str or unicode old, newstr or unicode countint, optional If the optional argument count is given, only the first count occurrences are replaced. Returns outndarray Output array of str or unicode, depending on input type See also str.replace", "score": "0.72286165"}]}
{"task_id": "mbpp_339", "code": "def find_Divisor(x,y):  \r\n    if (x==y): \r\n        return y \r\n    return 2", "test_list": ["assert find_Divisor(2,2) == 2", "assert find_Divisor(2,5) == 2", "assert find_Divisor(5,10) == 2"], "context": "Write a python function to find the maximum occuring divisor in an interval.", "function_name": "def find_Divisor(x,y):", "gold_generation": "if (x==y): \r\n        return y \r\n    return 2", "ctxs": [{"id": "19587", "text": "Function: python.library.decimal#decimal.MAX_PREC\nSnippet: decimal.MAX_PREC", "score": "0.6946667"}, {"id": "19586", "text": "Function: python.library.decimal#decimal.MAX_EMAX\nSnippet: decimal.MAX_EMAX", "score": "0.6778772"}, {"id": "18120", "text": "Function: python.library.audioop#audioop.findmax\nSnippet: audioop.findmax(fragment, length) Search fragment for a slice of length length samples (not bytes!) with maximum energy, i.e., return i for which rms(fragment[i*2:(i+length)*2]) is maximal. The fragments should both contain 2-byte samples. The routine takes time proportional to len(fragment).", "score": "0.66852164"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.659561"}, {"id": "19490", "text": "Function: python.library.decimal#decimal.Context.max\nSnippet: max(x, y) Compares two values numerically and returns the maximum.", "score": "0.6586467"}]}
{"task_id": "mbpp_340", "code": "def sum_three_smallest_nums(lst):\r\n\treturn sum(sorted([x for x in lst if x > 0])[:3])", "test_list": ["assert sum_three_smallest_nums([10,20,30,40,50,60,7]) == 37", "assert sum_three_smallest_nums([1,2,3,4,5]) == 6", "assert sum_three_smallest_nums([0,1,2,3,4,5]) == 6"], "context": "Write a python function to find the sum of the three lowest positive numbers from a given list of numbers.", "function_name": "def sum_three_smallest_nums(lst):", "gold_generation": "return sum(sorted([x for x in lst if x > 0])[:3])", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.7185606"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.6841565"}, {"id": "21813", "text": "Function: python.library.math#math.lcm\nSnippet: math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9.", "score": "0.67255116"}, {"id": "21776", "text": "Function: python.library.math\nSnippet: (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9. Note that frexp() and modf() have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 2**52 necessarily has no fractional bits. Power and logarithmic functions math.exp(x) Return e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). math.expm1(x) Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision: >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.0000050000069649e-05 >>> expm1(1e-5) # result accurate to full precision 1.0000050000166668e-05 New in version 3.2. math.log(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). math.log1p(x) Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. math.log2(x) Return the base-2 logarithm of x. This is usually more accurate than log(x, 2). New in version 3.3. See also int.bit_length() returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. math.log10(x) Return the base-10 logarithm of x. This is usually more accurate than log(x, 10). math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", "score": "0.6680673"}, {"id": "21836", "text": "Function: python.library.math#math.ulp\nSnippet: math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9.", "score": "0.6659324"}]}
{"task_id": "mbpp_341", "code": "def set_to_tuple(s):\r\n  t = tuple(sorted(s))\r\n  return (t)", "test_list": ["assert set_to_tuple({1, 2, 3, 4, 5}) == (1, 2, 3, 4, 5)", "assert set_to_tuple({6, 7, 8, 9, 10, 11}) == (6, 7, 8, 9, 10, 11)", "assert set_to_tuple({12, 13, 14, 15, 16}) == (12, 13, 14, 15, 16)"], "context": "Write a function to convert the given set into ordered tuples.", "function_name": "def set_to_tuple(s):", "gold_generation": "t = tuple(sorted(s))\r\n  return (t)", "ctxs": [{"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.7124991"}, {"id": "23564", "text": "Function: python.library.stdtypes#set\nSnippet: and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem.", "score": "0.7049531"}, {"id": "20215", "text": "Function: python.library.stdtypes#frozenset\nSnippet: and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem.", "score": "0.7001697"}, {"id": "23563", "text": "Function: python.library.stdtypes#set\nSnippet: class set([iterable]) class frozenset([iterable]) Return a new set or frozenset object whose elements are taken from iterable. The elements of a set must be hashable. To represent sets of sets, the inner sets must be frozenset objects. If iterable is not specified, a new empty set is returned. Sets can be created by several means: Use a comma-separated list of elements within braces: {'jack', 'sjoerd'} Use a set comprehension: {c for c in 'abracadabra' if c not in 'abc'} Use the type constructor: set(), set('foobar'), set(['a', 'b', 'foo']) Instances of set and frozenset provide the following operations: len(s) Return the number of elements in set s (cardinality of s). x in s Test x for membership in s. x not in s Test x for non-membership in s. isdisjoint(other) Return True if the set has no elements in common with other. Sets are disjoint if and only if their intersection is the empty set. issubset(other) set <= other Test whether every element in the set is in other. set < other Test whether the set is a proper subset of other, that is, set <= other and set != other. issuperset(other) set >= other Test whether every element in other is in the set. set > other Test whether the set is a proper superset of other, that is, set >= other and set != other. union(*others) set | other | ... Return a new set with elements from the set and all others. intersection(*others) set & other & ... Return a new set with elements common to the set and all others. difference(*others) set - other - ... Return a new set with elements in the set that are not in the others. symmetric_difference(other) set ^ other Return a new set with elements in either the set or other but not both. copy() Return a shallow copy of the set. Note, the non-operator versions of union(), intersection(), difference(), and symmetric_difference(), issubset(), and issuperset() methods will accept any iterable as an argument. In contrast, their operator based counterparts require their arguments to be sets. This precludes error-prone constructions like set('abc') & 'cbs' in favor of the more readable set('abc').intersection('cbs'). Both set and frozenset support set to set comparisons. Two sets are equal if and only if every element of each set is contained in the other (each is a subset of the other). A set is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal", "score": "0.67740774"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6734969"}]}
{"task_id": "mbpp_342", "code": "from heapq import heappop, heappush\r\nclass Node:\r\n    def __init__(self, value, list_num, index):\r\n        self.value = value\r\n        self.list_num = list_num\r\n        self.index = index\r\n    def __lt__(self, other):\r\n        return self.value < other.value\r\ndef find_minimum_range(list):\r\n    high = float('-inf')\r\n    p = (0, float('inf'))\r\n    pq = []\r\n    for i in range(len(list)):\r\n        heappush(pq, Node(list[i][0], i, 0))\r\n        high = max(high, list[i][0])\r\n    while True:\r\n        top = heappop(pq)\r\n        low = top.value\r\n        i = top.list_num\r\n        j = top.index\r\n        if high - low < p[1] - p[0]:\r\n            p = (low, high)\r\n        if j == len(list[i]) - 1:\r\n            return p\r\n        heappush(pq, Node(list[i][j + 1], i, j + 1))\r\n        high = max(high, list[i][j + 1])", "test_list": ["assert find_minimum_range([[3, 6, 8, 10, 15], [1, 5, 12], [4, 8, 15, 16], [2, 6]]) == (4, 6)", "assert find_minimum_range([[ 2, 3, 4, 8, 10, 15 ], [1, 5, 12], [7, 8, 15, 16], [3, 6]]) == (4, 7)", "assert find_minimum_range([[4, 7, 9, 11, 16], [2, 6, 13], [5, 9, 16, 17], [3, 7]]) == (5, 7)"], "context": "Write a function to find the smallest range that includes at-least one element from each of the given arrays.", "function_name": "from heapq import heappop, heappush\r\nclass Node:", "gold_generation": "def __init__(self, value, list_num, index):\r\n        self.value = value\r\n        self.list_num = list_num\r\n        self.index = index\r\n    def __lt__(self, other):\r\n        return self.value < other.value\r\ndef find_minimum_range(list):\r\n    high = float('-inf')\r\n    p = (0, float('inf'))\r\n    pq = []\r\n    for i in range(len(list)):\r\n        heappush(pq, Node(list[i][0], i, 0))\r\n        high = max(high, list[i][0])\r\n    while True:\r\n        top = heappop(pq)\r\n        low = top.value\r\n        i = top.list_num\r\n        j = top.index\r\n        if high - low < p[1] - p[0]:\r\n            p = (low, high)\r\n        if j == len(list[i]) - 1:\r\n            return p\r\n        heappush(pq, Node(list[i][j + 1], i, j + 1))\r\n        high = max(high, list[i][j + 1])", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.6992661"}, {"id": "43859", "text": "Function: numpy.reference.generated.numpy.recarray.min\nSnippet: numpy.recarray.min method recarray.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the minimum along a given axis. Refer to numpy.amin for full documentation. See also numpy.amin equivalent function", "score": "0.6951002"}, {"id": "41778", "text": "Function: numpy.reference.generated.numpy.chararray.find\nSnippet: numpy.chararray.find method chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.6880418"}, {"id": "41654", "text": "Function: numpy.reference.generated.numpy.char.chararray.find\nSnippet: numpy.char.chararray.find method char.chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.6847924"}, {"id": "43023", "text": "Function: numpy.reference.generated.numpy.minimum\nSnippet: numpy.minimum numpy.minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'minimum'> Element-wise minimum of array elements. Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The minimum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also maximum Element-wise maximum of two arrays, propagates NaNs. fmin Element-wise minimum of two arrays, ignores NaNs. amin The minimum value of an array along a given axis, propagates NaNs. nanmin The minimum value of an array along a given axis, ignores NaNs. fmax, amax, nanmax Notes The minimum is equivalent to np.where(x1 <= x2, x1, x2) when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting. Examples >>> np.minimum([2, 3, 4], [1, 5, 2]) array([1, 3, 2]) >>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting array([[ 0.5, 0. ], [ 0. , 1. ]]) >>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.minimum(-np.Inf, 1) -inf", "score": "0.67757916"}]}
{"task_id": "mbpp_343", "code": "def dig_let(s):\r\n d=l=0\r\n for c in s:\r\n    if c.isdigit():\r\n        d=d+1\r\n    elif c.isalpha():\r\n        l=l+1\r\n    else:\r\n        pass\r\n return (l,d)", "test_list": ["assert dig_let(\"python\")==(6,0)", "assert dig_let(\"program\")==(7,0)", "assert dig_let(\"python3.0\")==(6,2)"], "context": "Write a function to calculate the number of digits and letters in a string.", "function_name": "def dig_let(s):", "gold_generation": "d=l=0\r\n for c in s:\r\n    if c.isdigit():\r\n        d=d+1\r\n    elif c.isalpha():\r\n        l=l+1\r\n    else:\r\n        pass\r\n return (l,d)", "ctxs": [{"id": "24403", "text": "Function: python.library.string#string.digits\nSnippet: string.digits The string '0123456789'.", "score": "0.7591062"}, {"id": "24415", "text": "Function: python.library.string#string.octdigits\nSnippet: string.octdigits The string '01234567'.", "score": "0.7265962"}, {"id": "24414", "text": "Function: python.library.string#string.hexdigits\nSnippet: string.hexdigits The string '0123456789abcdefABCDEF'.", "score": "0.71917206"}, {"id": "21151", "text": "Function: python.library.io#io.TextIOBase.write\nSnippet: write(s) Write the string s to the stream and return the number of characters written.", "score": "0.69963926"}, {"id": "41664", "text": "Function: numpy.reference.generated.numpy.char.chararray.isdigit\nSnippet: numpy.char.chararray.isdigit method char.chararray.isdigit()[source] Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. See also char.isdigit", "score": "0.68714845"}]}
{"task_id": "mbpp_344", "code": "def count_Odd_Squares(n,m): \r\n    return int(m**0.5) - int((n-1)**0.5) ", "test_list": ["assert count_Odd_Squares(5,100) == 8", "assert count_Odd_Squares(8,65) == 6", "assert count_Odd_Squares(2,5) == 1"], "context": "Write a python function to find number of elements with odd factors in a given range.", "function_name": "def count_Odd_Squares(n,m):", "gold_generation": "return int(m**0.5) - int((n-1)**0.5)", "ctxs": [{"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.67209744"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.67062867"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6683515"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.66498667"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6633883"}]}
{"task_id": "mbpp_345", "code": "def diff_consecutivenums(nums):\r\n    result = [b-a for a, b in zip(nums[:-1], nums[1:])]\r\n    return result", "test_list": ["assert diff_consecutivenums([1, 1, 3, 4, 4, 5, 6, 7])==[0, 2, 1, 0, 1, 1, 1]", "assert diff_consecutivenums([4, 5, 8, 9, 6, 10])==[1, 3, 1, -3, 4]", "assert diff_consecutivenums([0, 1, 2, 3, 4, 4, 4, 4, 5, 7])==[1, 1, 1, 1, 0, 0, 0, 1, 2]"], "context": "Write a function to find the difference between two consecutive numbers in a given list.", "function_name": "def diff_consecutivenums(nums):", "gold_generation": "result = [b-a for a, b in zip(nums[:-1], nums[1:])]\r\n    return result", "ctxs": [{"id": "42129", "text": "Function: numpy.reference.generated.numpy.ma.ediff1d\nSnippet: numpy.ma.ediff1d ma.ediff1d(arr, to_end=None, to_begin=None)[source] Compute the differences between consecutive elements of an array. This function is the equivalent of numpy.ediff1d that takes masked values into account, see numpy.ediff1d for details. See also numpy.ediff1d Equivalent function for ndarrays.", "score": "0.69380176"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6934337"}, {"id": "19512", "text": "Function: python.library.decimal#decimal.Context.subtract\nSnippet: subtract(x, y) Return the difference between x and y.", "score": "0.6929472"}, {"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.6818893"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.6786581"}]}
{"task_id": "mbpp_346", "code": "def zigzag(n, k): \r\n\tif (n == 0 and k == 0): \r\n\t\treturn 1\r\n\tif (k == 0): \r\n\t\treturn 0\r\n\treturn zigzag(n, k - 1) + zigzag(n - 1, n - k)", "test_list": ["assert zigzag(4, 3) == 5", "assert zigzag(4, 2) == 4", "assert zigzag(3, 1) == 1"], "context": "Write a function to find entringer number e(n, k).", "function_name": "def zigzag(n, k):", "gold_generation": "if (n == 0 and k == 0): \r\n\t\treturn 1\r\n\tif (k == 0): \r\n\t\treturn 0\r\n\treturn zigzag(n, k - 1) + zigzag(n - 1, n - k)", "ctxs": [{"id": "42802", "text": "Function: numpy.reference.constants#numpy.e\nSnippet: numpy.e Euler’s constant, base of natural logarithms, Napier’s constant. e = 2.71828182845904523536028747135266249775724709369995... See Also exp : Exponential function log : Natural logarithm References https://en.wikipedia.org/wiki/E_%28mathematical_constant%29", "score": "0.71559834"}, {"id": "18467", "text": "Function: python.library.cmath#cmath.exp\nSnippet: cmath.exp(x) Return e raised to the power x, where e is the base of natural logarithms.", "score": "0.6735378"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.66993797"}, {"id": "19483", "text": "Function: python.library.decimal#decimal.Context.ln\nSnippet: ln(x) Returns the natural (base e) logarithm of x.", "score": "0.66512144"}, {"id": "42894", "text": "Function: numpy.reference.constants\nSnippet: array([False]) numpy.e Euler’s constant, base of natural logarithms, Napier’s constant. e = 2.71828182845904523536028747135266249775724709369995... See Also exp : Exponential function log : Natural logarithm References https://en.wikipedia.org/wiki/E_%28mathematical_constant%29 numpy.euler_gamma γ = 0.5772156649015328606065120900824024310421... References https://en.wikipedia.org/wiki/Euler-Mascheroni_constant numpy.inf IEEE 754 floating point representation of (positive) infinity. Returns yfloat A floating point representation of positive infinity. See Also isinf : Shows which elements are positive or negative infinity isposinf : Shows which elements are positive infinity isneginf : Shows which elements are negative infinity isnan : Shows which elements are Not a Number isfinite : Shows which elements are finite (not one of Not a Number, positive infinity and negative infinity) Notes NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Also that positive infinity is not equivalent to negative infinity. But infinity is equivalent to positive infinity. Inf, Infinity, PINF and infty are aliases for inf. Examples >>> np.inf inf >>> np.array([1]) / 0. array([ Inf]) numpy.infty IEEE 754 floating point representation of (positive) infinity. Use inf because Inf, Infinity, PINF and infty are aliases for inf. For more details, see inf. See Also inf numpy.nan IEEE 754 floating point representation of Not a Number (NaN). Returns y : A floating point representation of Not a Number. See Also isnan : Shows which elements are Not a Number. isfinite : Shows which elements are finite (not one of Not a Number, positive infinity and negative infinity) Notes NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. NaN and NAN are aliases of nan. Examples >>> np.nan nan >>> np.log(-1) nan >>> np.log([-1, 1, 2]) array([ NaN, 0. , 0.69314718]) numpy.newaxis A convenient alias for None, useful for indexing arrays. Examples >>> newaxis is None True >>> x = np.arange(3) >>> x array([0, 1, 2]) >>> x[:, newaxis] array([[0], [1], [2]]) >>> x[:, newaxis, newaxis] array([[[0]], [[1]], [[2]]]) >>> x[:, newaxis] * x array([[0, 0, 0], [0, 1, 2], [0, 2, 4]]) Outer product, same as outer(x, y): >>> y = np.arange(3, 6) >>> x[:, newaxis] * y array([[ 0, 0, 0], [ 3, 4, 5], [ 6, 8, 10]]) x[newaxis, :] is equivalent to x[newaxis] and x[None]: >>> x[newaxis, :].shape (1, 3) >>> x[newaxis].shape (1, 3) >>> x[None].shape (1, 3) >>> x[:, newaxis].shape (3, 1) numpy.pi pi = 3.1415926535897932384626433... References https://en.wikipedia.org/wiki/Pi", "score": "0.65969926"}]}
{"task_id": "mbpp_347", "code": "def count_Squares(m,n): \r\n    if (n < m): \r\n        temp = m \r\n        m = n \r\n        n = temp \r\n    return n * (n + 1) * (3 * m - n + 1) // 6", "test_list": ["assert count_Squares(4,3) == 20", "assert count_Squares(1,2) == 2", "assert count_Squares(2,2) == 5"], "context": "Write a python function to count the number of squares in a rectangle.", "function_name": "def count_Squares(m,n):", "gold_generation": "if (n < m): \r\n        temp = m \r\n        m = n \r\n        n = temp \r\n    return n * (n + 1) * (3 * m - n + 1) // 6", "ctxs": [{"id": "14324", "text": "Function: pandas.reference.api.pandas.dataframe.div\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6810493"}, {"id": "43202", "text": "Function: numpy.reference.generated.numpy.square\nSnippet: numpy.square numpy.square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'square'> Return the element-wise square of the input. Parameters xarray_like Input data. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Element-wise x*x, of the same shape and dtype as x. This is a scalar if x is a scalar. See also numpy.linalg.matrix_power sqrt power Examples >>> np.square([-1j, 1]) array([-1.-0.j, 1.+0.j])", "score": "0.6762521"}, {"id": "14476", "text": "Function: pandas.reference.api.pandas.dataframe.rpow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6743764"}, {"id": "14507", "text": "Function: pandas.reference.api.pandas.dataframe.sub\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6743541"}, {"id": "14478", "text": "Function: pandas.reference.api.pandas.dataframe.rsub\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6736448"}]}
{"task_id": "mbpp_348", "code": "def bin_coff(n, r): \r\n\tval = 1\r\n\tif (r > (n - r)): \r\n\t\tr = (n - r) \r\n\tfor i in range(0, r): \r\n\t\tval *= (n - i) \r\n\t\tval //= (i + 1) \r\n\treturn val \r\ndef find_ways(M): \r\n\tn = M // 2\r\n\ta = bin_coff(2 * n, n) \r\n\tb = a // (n + 1) \r\n\treturn (b) ", "test_list": ["assert find_ways(4) == 2", "assert find_ways(6) == 5", "assert find_ways(8) == 14"], "context": "Write a function to count sequences of given length having non-negative prefix sums that can be generated by given values.", "function_name": "def bin_coff(n, r):", "gold_generation": "val = 1\r\n\tif (r > (n - r)): \r\n\t\tr = (n - r) \r\n\tfor i in range(0, r): \r\n\t\tval *= (n - i) \r\n\t\tval //= (i + 1) \r\n\treturn val \r\ndef find_ways(M): \r\n\tn = M // 2\r\n\ta = bin_coff(2 * n, n) \r\n\tb = a // (n + 1) \r\n\treturn (b)", "ctxs": [{"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6840157"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.67783856"}, {"id": "21304", "text": "Function: python.library.itertools#itertools.count\nSnippet: itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments.", "score": "0.6756878"}, {"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.67167354"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.66812015"}]}
{"task_id": "mbpp_349", "code": "def check(string) :\r\n    p = set(string) \r\n    s = {'0', '1'} \r\n    if s == p or p == {'0'} or p == {'1'}: \r\n        return (\"Yes\") \r\n    else : \r\n        return (\"No\") ", "test_list": ["assert check(\"01010101010\") == \"Yes\"", "assert check(\"name0\") == \"No\"", "assert check(\"101\") == \"Yes\""], "context": "Write a python function to check whether the given string is a binary string or not.", "function_name": "def check(string) :", "gold_generation": "p = set(string) \r\n    s = {'0', '1'} \r\n    if s == p or p == {'0'} or p == {'1'}: \r\n        return (\"Yes\") \r\n    else : \r\n        return (\"No\")", "ctxs": [{"id": "42786", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.is_string\nSnippet: numpy.distutils.misc_util.is_string(s)[source]", "score": "0.7277483"}, {"id": "24361", "text": "Function: python.library.stdtypes#str.isupper\nSnippet: str.isupper() Return True if all cased characters 4 in the string are uppercase and there is at least one cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False", "score": "0.7220722"}, {"id": "18216", "text": "Function: python.library.binascii\nSnippet: binascii — Convert between binary and ASCII The binascii module contains a number of methods to convert between binary and various ASCII-encoded binary representations. Normally, you will not use these functions directly but use wrapper modules like uu, base64, or binhex instead. The binascii module contains low-level functions written in C for greater speed that are used by the higher-level modules. Note a2b_* functions accept Unicode strings containing only ASCII characters. Other functions only accept bytes-like objects (such as bytes, bytearray and other objects that support the buffer protocol). Changed in version 3.3: ASCII-only unicode strings are now accepted by the a2b_* functions. The binascii module defines the following functions: binascii.a2b_uu(string) Convert a single line of uuencoded data back to binary and return the binary data. Lines normally contain 45 (binary) bytes, except for the last line. Line data may be followed by whitespace. binascii.b2a_uu(data, *, backtick=False) Convert binary data to a line of ASCII characters, the return value is the converted line, including a newline char. The length of data should be at most 45. If backtick is true, zeros are represented by '`' instead of spaces. Changed in version 3.7: Added the backtick parameter. binascii.a2b_base64(string) Convert a block of base64 data back to binary and return the binary data. More than one line may be passed at a time. binascii.b2a_base64(data, *, newline=True) Convert binary data to a line of ASCII characters in base64 coding. The return value is the converted line, including a newline char if newline is true. The output of this function conforms to RFC 3548. Changed in version 3.6: Added the newline parameter. binascii.a2b_qp(data, header=False) Convert a block of quoted-printable data back to binary and return the binary data. More than one line may be passed at a time. If the optional argument header is present and true, underscores will be decoded as spaces. binascii.b2a_qp(data, quotetabs=False, istext=True, header=False) Convert binary data to a line(s) of ASCII characters in quoted-printable encoding. The return value is the converted line(s). If the optional argument quotetabs is present and true, all tabs and spaces will be encoded. If the optional argument istext is present and true, newlines are not encoded but trailing whitespace will be encoded. If the optional argument header is present and true, spaces will be encoded as underscores per RFC 1522. If the optional argument header is present and false, newline characters will be encoded as well; otherwise linefeed conversion might corrupt the binary data stream. binascii.a2b_hqx(string) Convert binhex4 formatted ASCII data to binary, without doing RLE-decompression. The string should contain a complete number of binary bytes, or (in case of the last portion of the binhex4 data) have the remaining bits zero. Deprecated since version 3.9. binascii.rledecode_hqx(data) Perform RLE-decompression on the data, as per the binhex4 standard. The algorithm uses 0x90 after a byte as a repeat indicator, followed by a count. A count of 0 specifies a byte value of 0x90. The routine returns the decompressed data, unless data input data ends in an", "score": "0.7092726"}, {"id": "15338", "text": "Function: pandas.reference.api.pandas.series.str.isdigit\nSnippet: pandas.Series.str.isdigit Series.str.isdigit()[source] Check whether all characters in each string are digits. This is equivalent to running the Python string method str.isdigit() for each element of the Series/Index. If a string has zero characters, False is returned for that check. Returns Series or Index of bool Series or Index of boolean values with the same length as the original Series/Index. See also Series.str.isalpha Check whether all characters are alphabetic. Series.str.isnumeric Check whether all characters are numeric. Series.str.isalnum Check whether all characters are alphanumeric. Series.str.isdigit Check whether all characters are digits. Series.str.isdecimal Check whether all characters are decimal. Series.str.isspace Check whether all characters are whitespace. Series.str.islower Check whether all characters are lowercase. Series.str.isupper Check whether all characters are uppercase. Series.str.istitle Check whether all characters are titlecase. Examples Checks for Alphabetic and Numeric Characters >>> s1 = pd.Series(['one', 'one1', '1', '']) >>> s1.str.isalpha() 0 True 1 False 2 False 3 False dtype: bool >>> s1.str.isnumeric() 0 False 1 False 2 True 3 False dtype: bool >>> s1.str.isalnum() 0 True 1 True 2 True 3 False dtype: bool Note that checks against characters mixed with any additional punctuation or whitespace will evaluate to false for an alphanumeric check. >>> s2 = pd.Series(['A B', '1.5', '3,000']) >>> s2.str.isalnum() 0 False 1 False 2 False dtype: bool More Detailed Checks for Numeric Characters There are several different but overlapping sets of numeric characters that can be checked for. >>> s3 = pd.Series(['23', '³', '⅕', '']) The s3.str.isdecimal method checks for characters used to form numbers in base 10. >>> s3.str.isdecimal() 0 True 1 False 2 False 3 False dtype: bool The s.str.isdigit method is the same as s3.str.isdecimal but also includes special digits, like superscripted and subscripted digits in unicode. >>> s3.str.isdigit() 0 True 1 True 2 False 3 False dtype: bool The s.str.isnumeric method is the same as s3.str.isdigit but also includes other characters that can represent quantities such as unicode fractions. >>> s3.str.isnumeric() 0 True 1 True 2 True 3 False dtype: bool Checks for Whitespace >>> s4 = pd.Series([' ', '\\t\\r\\n ', '']) >>> s4.str.isspace() 0 True 1 True 2 False dtype: bool Checks for Character Case >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) >>> s5.str.islower() 0 True 1 False 2 False 3 False dtype: bool >>> s5.str.isupper() 0 False 1 False 2 True 3 False dtype: bool The s5.str.istitle method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters. >>> s5.str.istitle() 0 False 1 True 2 False 3 False dtype: bool", "score": "0.7005091"}, {"id": "26530", "text": "Function: python.library.winreg#winreg.REG_BINARY\nSnippet: winreg.REG_BINARY Binary data in any form.", "score": "0.70047206"}]}
{"task_id": "mbpp_350", "code": "def minimum_Length(s) : \r\n    maxOcc = 0\r\n    n = len(s) \r\n    arr = [0]*26\r\n    for i in range(n) : \r\n        arr[ord(s[i]) -ord('a')] += 1\r\n    for i in range(26) : \r\n        if arr[i] > maxOcc : \r\n            maxOcc = arr[i] \r\n    return n - maxOcc ", "test_list": ["assert minimum_Length(\"mnm\") == 1", "assert minimum_Length(\"abcda\") == 3", "assert minimum_Length(\"abcb\") == 2"], "context": "Write a python function to minimize the length of the string by removing occurrence of only one character.", "function_name": "def minimum_Length(s) :", "gold_generation": "maxOcc = 0\r\n    n = len(s) \r\n    arr = [0]*26\r\n    for i in range(n) : \r\n        arr[ord(s[i]) -ord('a')] += 1\r\n    for i in range(26) : \r\n        if arr[i] > maxOcc : \r\n            maxOcc = arr[i] \r\n    return n - maxOcc", "ctxs": [{"id": "24376", "text": "Function: python.library.stdtypes#str.rstrip\nSnippet: str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty'", "score": "0.70338005"}, {"id": "24398", "text": "Function: python.library.string\nSnippet: characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", "score": "0.7019706"}, {"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.69688904"}, {"id": "41690", "text": "Function: numpy.reference.generated.numpy.char.chararray.rstrip\nSnippet: numpy.char.chararray.rstrip method char.chararray.rstrip(chars=None)[source] For each element in self, return a copy with the trailing characters removed. See also char.rstrip", "score": "0.6945481"}, {"id": "25756", "text": "Function: python.library.stdtypes\nSnippet: binary sequence of byte values to remove may be any bytes-like object. See removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> b'Monty Python'.rstrip(b' Python') b'M' >>> b'Monty Python'.removesuffix(b' Python') b'Monty' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3'] bytes.strip([chars]) bytearray.strip([chars]) Return a copy of the sequence with specified leading and trailing bytes removed. The chars argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters. If omitted or None, the chars argument defaults to removing ASCII whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> b' spacious '.strip() b'spacious' >>> b'www.example.com'.strip(b'cmowz.') b'example' The binary sequence of byte values to remove may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.capitalize() bytearray.capitalize() Return a copy of the sequence with each byte interpreted as an ASCII character, and the first byte capitalized and the rest", "score": "0.6940788"}]}
{"task_id": "mbpp_351", "code": "def first_Element(arr,n,k): \r\n    count_map = {}; \r\n    for i in range(0, n): \r\n        if(arr[i] in count_map.keys()): \r\n            count_map[arr[i]] += 1\r\n        else: \r\n            count_map[arr[i]] = 1\r\n        i += 1\r\n    for i in range(0, n):  \r\n        if (count_map[arr[i]] == k): \r\n            return arr[i] \r\n        i += 1 \r\n    return -1", "test_list": ["assert first_Element([0,1,2,3,4,5],6,1) == 0", "assert first_Element([1,2,1,3,4],5,2) == 1", "assert first_Element([2,3,4,3,5,7,1,2,3,5],10,2) == 2"], "context": "Write a python function to find the first element occurring k times in a given array.", "function_name": "def first_Element(arr,n,k):", "gold_generation": "count_map = {}; \r\n    for i in range(0, n): \r\n        if(arr[i] in count_map.keys()): \r\n            count_map[arr[i]] += 1\r\n        else: \r\n            count_map[arr[i]] = 1\r\n        i += 1\r\n    for i in range(0, n):  \r\n        if (count_map[arr[i]] == k): \r\n            return arr[i] \r\n        i += 1 \r\n    return -1", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.74008787"}, {"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.73976153"}, {"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.7065358"}, {"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.6914758"}, {"id": "22322", "text": "Function: python.library.operator#operator.indexOf\nSnippet: operator.indexOf(a, b) Return the index of the first of occurrence of b in a.", "score": "0.6750556"}]}
{"task_id": "mbpp_352", "code": "def unique_Characters(str):\r\n    for i in range(len(str)):\r\n        for j in range(i + 1,len(str)): \r\n            if (str[i] == str[j]):\r\n                return False;\r\n    return True;", "test_list": ["assert unique_Characters('aba') == False", "assert unique_Characters('abc') == True", "assert unique_Characters('abab') == False"], "context": "Write a python function to check whether all the characters in a given string are unique.", "function_name": "def unique_Characters(str):", "gold_generation": "for i in range(len(str)):\r\n        for j in range(i + 1,len(str)): \r\n            if (str[i] == str[j]):\r\n                return False;\r\n    return True;", "ctxs": [{"id": "41664", "text": "Function: numpy.reference.generated.numpy.char.chararray.isdigit\nSnippet: numpy.char.chararray.isdigit method char.chararray.isdigit()[source] Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. See also char.isdigit", "score": "0.71323836"}, {"id": "41736", "text": "Function: numpy.reference.generated.numpy.char.isupper\nSnippet: numpy.char.isupper char.isupper(a)[source] Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. Call str.isupper element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like of str or unicode Returns outndarray Output array of bools See also str.isupper", "score": "0.7126411"}, {"id": "41787", "text": "Function: numpy.reference.generated.numpy.chararray.isdigit\nSnippet: numpy.chararray.isdigit method chararray.isdigit()[source] Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. See also char.isdigit", "score": "0.70956427"}, {"id": "15343", "text": "Function: pandas.reference.api.pandas.series.str.isupper\nSnippet: pandas.Series.str.isupper Series.str.isupper()[source] Check whether all characters in each string are uppercase. This is equivalent to running the Python string method str.isupper() for each element of the Series/Index. If a string has zero characters, False is returned for that check. Returns Series or Index of bool Series or Index of boolean values with the same length as the original Series/Index. See also Series.str.isalpha Check whether all characters are alphabetic. Series.str.isnumeric Check whether all characters are numeric. Series.str.isalnum Check whether all characters are alphanumeric. Series.str.isdigit Check whether all characters are digits. Series.str.isdecimal Check whether all characters are decimal. Series.str.isspace Check whether all characters are whitespace. Series.str.islower Check whether all characters are lowercase. Series.str.isupper Check whether all characters are uppercase. Series.str.istitle Check whether all characters are titlecase. Examples Checks for Alphabetic and Numeric Characters >>> s1 = pd.Series(['one', 'one1', '1', '']) >>> s1.str.isalpha() 0 True 1 False 2 False 3 False dtype: bool >>> s1.str.isnumeric() 0 False 1 False 2 True 3 False dtype: bool >>> s1.str.isalnum() 0 True 1 True 2 True 3 False dtype: bool Note that checks against characters mixed with any additional punctuation or whitespace will evaluate to false for an alphanumeric check. >>> s2 = pd.Series(['A B', '1.5', '3,000']) >>> s2.str.isalnum() 0 False 1 False 2 False dtype: bool More Detailed Checks for Numeric Characters There are several different but overlapping sets of numeric characters that can be checked for. >>> s3 = pd.Series(['23', '³', '⅕', '']) The s3.str.isdecimal method checks for characters used to form numbers in base 10. >>> s3.str.isdecimal() 0 True 1 False 2 False 3 False dtype: bool The s.str.isdigit method is the same as s3.str.isdecimal but also includes special digits, like superscripted and subscripted digits in unicode. >>> s3.str.isdigit() 0 True 1 True 2 False 3 False dtype: bool The s.str.isnumeric method is the same as s3.str.isdigit but also includes other characters that can represent quantities such as unicode fractions. >>> s3.str.isnumeric() 0 True 1 True 2 True 3 False dtype: bool Checks for Whitespace >>> s4 = pd.Series([' ', '\\t\\r\\n ', '']) >>> s4.str.isspace() 0 True 1 True 2 False dtype: bool Checks for Character Case >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) >>> s5.str.islower() 0 True 1 False 2 False 3 False dtype: bool >>> s5.str.isupper() 0 False 1 False 2 True 3 False dtype: bool The s5.str.istitle method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters. >>> s5.str.istitle() 0 False 1 True 2 False 3 False dtype: bool", "score": "0.7072457"}, {"id": "41661", "text": "Function: numpy.reference.generated.numpy.char.chararray.isalnum\nSnippet: numpy.char.chararray.isalnum method char.chararray.isalnum()[source] Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. See also char.isalnum", "score": "0.7070792"}]}
{"task_id": "mbpp_353", "code": "def remove_column(list1, n):\r\n   for i in list1: \r\n    del i[n] \r\n   return list1", "test_list": ["assert remove_column([[1, 2, 3], [2, 4, 5], [1, 1, 1]],0)==[[2, 3], [4, 5], [1, 1]]", "assert remove_column([[1, 2, 3], [-2, 4, -5], [1, -1, 1]],2)==[[1, 2], [-2, 4], [1, -1]]", "assert remove_column([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]],0)==[[3], [7], [3], [15, 17], [7], [11]]"], "context": "Write a function to remove a specified column from a given nested list.", "function_name": "def remove_column(list1, n):", "gold_generation": "for i in list1: \r\n    del i[n] \r\n   return list1", "ctxs": [{"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.6723448"}, {"id": "14331", "text": "Function: pandas.reference.api.pandas.dataframe.droplevel\nSnippet: pandas.DataFrame.droplevel DataFrame.droplevel(level, axis=0)[source] Return Series/DataFrame with requested index / column level(s) removed. Parameters level:int, str, or list-like If a string is given, must be the name of a level If list-like, elements must be names or positional indexes of levels. axis:{0 or ‘index’, 1 or ‘columns’}, default 0 Axis along which the level(s) is removed: 0 or ‘index’: remove level(s) in column. 1 or ‘columns’: remove level(s) in row. Returns Series/DataFrame Series/DataFrame with requested index / column level(s) removed. Examples >>> df = pd.DataFrame([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]).set_index([0, 1]).rename_axis(['a', 'b']) >>> df.columns = pd.MultiIndex.from_tuples([ ... ('c', 'e'), ('d', 'f') ... ], names=['level_1', 'level_2']) >>> df level_1 c d level_2 e f a b 1 2 3 4 5 6 7 8 9 10 11 12 >>> df.droplevel('a') level_1 c d level_2 e f b 2 3 4 6 7 8 10 11 12 >>> df.droplevel('level_2', axis=1) level_1 c d a b 1 2 3 4 5 6 7 8 9 10 11 12", "score": "0.67219466"}, {"id": "15114", "text": "Function: pandas.reference.api.pandas.series.droplevel\nSnippet: pandas.Series.droplevel Series.droplevel(level, axis=0)[source] Return Series/DataFrame with requested index / column level(s) removed. Parameters level:int, str, or list-like If a string is given, must be the name of a level If list-like, elements must be names or positional indexes of levels. axis:{0 or ‘index’, 1 or ‘columns’}, default 0 Axis along which the level(s) is removed: 0 or ‘index’: remove level(s) in column. 1 or ‘columns’: remove level(s) in row. Returns Series/DataFrame Series/DataFrame with requested index / column level(s) removed. Examples >>> df = pd.DataFrame([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]).set_index([0, 1]).rename_axis(['a', 'b']) >>> df.columns = pd.MultiIndex.from_tuples([ ... ('c', 'e'), ('d', 'f') ... ], names=['level_1', 'level_2']) >>> df level_1 c d level_2 e f a b 1 2 3 4 5 6 7 8 9 10 11 12 >>> df.droplevel('a') level_1 c d level_2 e f b 2 3 4 6 7 8 10 11 12 >>> df.droplevel('level_2', axis=1) level_1 c d a b 1 2 3 4 5 6 7 8 9 10 11 12", "score": "0.6674882"}, {"id": "20228", "text": "Function: python.library.stdtypes#frozenset.remove\nSnippet: remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set.", "score": "0.66684675"}, {"id": "18674", "text": "Function: python.library.collections#collections.deque.remove\nSnippet: remove(value) Remove the first occurrence of value. If not found, raises a ValueError.", "score": "0.66209114"}]}
{"task_id": "mbpp_354", "code": "def tn_ap(a,n,d):\r\n  tn = a + (n - 1) * d\r\n  return tn", "test_list": ["assert tn_ap(1,5,2)==9", "assert tn_ap(2,6,4)==22", "assert tn_ap(1,4,5)==16"], "context": "Write a function to find t-nth term of arithemetic progression.", "function_name": "def tn_ap(a,n,d):", "gold_generation": "tn = a + (n - 1) * d\r\n  return tn", "ctxs": [{"id": "16375", "text": "Function: pandas.reference.api.pandas.tseries.offsets.semimonthend.n\nSnippet: pandas.tseries.offsets.SemiMonthEnd.n SemiMonthEnd.n", "score": "0.6498952"}, {"id": "35797", "text": "Function: django.ref.models.database-functions#django.db.models.functions.NthValue\nSnippet: class NthValue(expression, nth=1, **extra)", "score": "0.64922637"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.64804006"}, {"id": "21785", "text": "Function: python.library.math#math.atanh\nSnippet: math.atanh(x) Return the inverse hyperbolic tangent of x.", "score": "0.64549255"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.64275694"}]}
{"task_id": "mbpp_355", "code": "def count_Rectangles(radius):  \r\n    rectangles = 0 \r\n    diameter = 2 * radius \r\n    diameterSquare = diameter * diameter \r\n    for a in range(1, 2 * radius):  \r\n        for b in range(1, 2 * radius): \r\n            diagnalLengthSquare = (a * a +  b * b)  \r\n            if (diagnalLengthSquare <= diameterSquare) : \r\n                rectangles += 1\r\n    return rectangles ", "test_list": ["assert count_Rectangles(2) == 8", "assert count_Rectangles(1) == 1", "assert count_Rectangles(0) == 0"], "context": "Write a python function to count the number of rectangles in a circle of radius r.", "function_name": "def count_Rectangles(radius):", "gold_generation": "rectangles = 0 \r\n    diameter = 2 * radius \r\n    diameterSquare = diameter * diameter \r\n    for a in range(1, 2 * radius):  \r\n        for b in range(1, 2 * radius): \r\n            diagnalLengthSquare = (a * a +  b * b)  \r\n            if (diagnalLengthSquare <= diameterSquare) : \r\n                rectangles += 1\r\n    return rectangles", "ctxs": [{"id": "14478", "text": "Function: pandas.reference.api.pandas.dataframe.rsub\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6981925"}, {"id": "14471", "text": "Function: pandas.reference.api.pandas.dataframe.rmul\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.69683605"}, {"id": "14476", "text": "Function: pandas.reference.api.pandas.dataframe.rpow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6924654"}, {"id": "14467", "text": "Function: pandas.reference.api.pandas.dataframe.rfloordiv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.68607795"}, {"id": "14450", "text": "Function: pandas.reference.api.pandas.dataframe.rdiv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6783012"}]}
{"task_id": "mbpp_356", "code": "def find_angle(a,b):\r\n c = 180 - (a + b)\r\n return c\r\n", "test_list": ["assert find_angle(47,89)==44", "assert find_angle(45,95)==40", "assert find_angle(50,40)==90"], "context": "Write a function to find the third angle of a triangle using two angles.", "function_name": "def find_angle(a,b):", "gold_generation": "c = 180 - (a + b)\r\n return c", "ctxs": [{"id": "21784", "text": "Function: python.library.math#math.atan2\nSnippet: math.atan2(y, x) Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4.", "score": "0.64632875"}, {"id": "34305", "text": "Function: matplotlib.tri_api\nSnippet: matplotlib.tri Unstructured triangular grid functions. classmatplotlib.tri.Triangulation(x, y, triangles=None, mask=None)[source] An unstructured triangular grid consisting of npoints points and ntri triangles. The triangles can either be specified by the user or automatically generated using a Delaunay triangulation. Parameters x, y(npoints,) array-like Coordinates of grid points. triangles(ntri, 3) array-like of int, optional For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If not specified, the Delaunay triangulation is calculated. mask(ntri,) array-like of bool, optional Which triangles are masked out. Notes For a Triangulation to be valid it must not have duplicate points, triangles formed from colinear points, or overlapping triangles. Attributes triangles(ntri, 3) array of int For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If you want to take the mask into account, use get_masked_triangles instead. mask(ntri, 3) array of bool Masked out triangles. is_delaunaybool Whether the Triangulation is a calculated Delaunay triangulation (where triangles was not specified) or not. calculate_plane_coefficients(z)[source] Calculate plane equation coefficients for all unmasked triangles from the point (x, y) coordinates and specified z-array of shape (npoints). The returned array has shape (npoints, 3) and allows z-value at (x, y) position in triangle tri to be calculated using z = array[tri, 0] * x + array[tri, 1] * y + array[tri, 2]. propertyedges Return integer array of shape (nedges, 2) containing all edges of non-masked triangles. Each row defines an edge by it's start point index and end point index. Each edge appears only once, i.e. for an edge between points i and j, there will only be either (i, j) or (j, i). get_cpp_triangulation()[source] Return the underlying C++ Triangulation object, creating it if necessary. staticget_from_args_and_kwargs(*args, **kwargs)[source] Return a Triangulation object from the args and kwargs, and the remaining args and kwargs with the consumed values removed. There are two alternatives: either the first argument is a Triangulation object, in which case it is returned, or the args and kwargs are sufficient to create a new Triangulation to return. In the latter case, see Triangulation.__init__ for the possible args and kwargs. get_masked_triangles()[source] Return an array of triangles that are not masked. get_trifinder()[source] Return the default matplotlib.tri.TriFinder of this triangulation, creating it if necessary. This allows the same TriFinder object to be easily shared. propertyneighbors Return integer array of shape (ntri, 3) containing neighbor triangles. For each triangle, the indices of the three triangles that share the same edges, or -1 if there is no such neighboring triangle. neighbors[i, j] is the triangle that is the neighbor to the edge from point index triangles[i, j] to point index triangles[i, (j+1)%3]. set_mask(mask)[source] Set or clear the mask array. Parameters maskNone or bool array of length ntri classmatplotlib.tri.TriContourSet(ax, *args, **kwargs)[source] Bases: matplotlib.contour.ContourSet Create and store a set of contour lines or filled regions for a triangular grid. This class is typically not instantiated directly by the user but by tricontour and tricontourf. Attributes axAxes The Axes object in which the", "score": "0.64099133"}, {"id": "21777", "text": "Function: python.library.math\nSnippet: Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers. math.sqrt(x) Return the square root of x. Trigonometric functions math.acos(x) Return the arc cosine of x, in radians. The result is between 0 and pi. math.asin(x) Return the arc sine of x, in radians. The result is between -pi/2 and pi/2. math.atan(x) Return the arc tangent of x, in radians. The result is between -pi/2 and pi/2. math.atan2(y, x) Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4. math.cos(x) Return the cosine of x radians. math.dist(p, q) Return the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Roughly equivalent to: sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q))) New in version 3.8. math.hypot(*coordinates) Return the Euclidean norm, sqrt(sum(x**2 for x in coordinates)). This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point (x, y), this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, sqrt(x*x + y*y). Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. math.sin(x) Return the sine of x radians. math.tan(x) Return the tangent of x radians. Angular conversion math.degrees(x) Convert angle x from radians to degrees. math.radians(x) Convert angle x from degrees to radians. Hyperbolic functions Hyperbolic functions are analogs of trigonometric functions that are based on hyperbolas instead of circles. math.acosh(x) Return the inverse hyperbolic cosine of x. math.asinh(x) Return the inverse hyperbolic sine of x. math.atanh(x) Return the inverse hyperbolic tangent of x. math.cosh(x) Return the hyperbolic cosine of x. math.sinh(x) Return the hyperbolic sine of x. math.tanh(x) Return the hyperbolic tangent of x. Special functions math.erf(x) Return the error function at x. The erf() function can be used to compute traditional statistical functions such as the cumulative standard normal distribution: def phi(x): 'Cumulative distribution function for the standard normal distribution' return (1.0 + erf(x / sqrt(2.0))) / 2.0 New in version 3.2. math.erfc(x) Return the complementary error function at x. The complementary error function is defined as 1.0 - erf(x). It is used for large values of x where a subtraction from one would cause a loss of significance. New in version 3.2. math.gamma(x) Return the Gamma function at x. New in version 3.2. math.lgamma(x) Return the natural logarithm of the absolute value of the Gamma function at x. New in version 3.2. Constants math.pi The mathematical constant π =", "score": "0.634149"}, {"id": "13520", "text": "Function: pygame.ref.math#pygame.math.Vector3.angle_to\nSnippet: angle_to() calculates the angle to a given vector in degrees. angle_to(Vector3) -> float Returns the angle between self and the given vector.", "score": "0.6310695"}, {"id": "34319", "text": "Function: matplotlib.tri_api#matplotlib.tri.Triangulation\nSnippet: classmatplotlib.tri.Triangulation(x, y, triangles=None, mask=None)[source] An unstructured triangular grid consisting of npoints points and ntri triangles. The triangles can either be specified by the user or automatically generated using a Delaunay triangulation. Parameters x, y(npoints,) array-like Coordinates of grid points. triangles(ntri, 3) array-like of int, optional For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If not specified, the Delaunay triangulation is calculated. mask(ntri,) array-like of bool, optional Which triangles are masked out. Notes For a Triangulation to be valid it must not have duplicate points, triangles formed from colinear points, or overlapping triangles. Attributes triangles(ntri, 3) array of int For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If you want to take the mask into account, use get_masked_triangles instead. mask(ntri, 3) array of bool Masked out triangles. is_delaunaybool Whether the Triangulation is a calculated Delaunay triangulation (where triangles was not specified) or not. calculate_plane_coefficients(z)[source] Calculate plane equation coefficients for all unmasked triangles from the point (x, y) coordinates and specified z-array of shape (npoints). The returned array has shape (npoints, 3) and allows z-value at (x, y) position in triangle tri to be calculated using z = array[tri, 0] * x + array[tri, 1] * y + array[tri, 2]. propertyedges Return integer array of shape (nedges, 2) containing all edges of non-masked triangles. Each row defines an edge by it's start point index and end point index. Each edge appears only once, i.e. for an edge between points i and j, there will only be either (i, j) or (j, i). get_cpp_triangulation()[source] Return the underlying C++ Triangulation object, creating it if necessary. staticget_from_args_and_kwargs(*args, **kwargs)[source] Return a Triangulation object from the args and kwargs, and the remaining args and kwargs with the consumed values removed. There are two alternatives: either the first argument is a Triangulation object, in which case it is returned, or the args and kwargs are sufficient to create a new Triangulation to return. In the latter case, see Triangulation.__init__ for the possible args and kwargs. get_masked_triangles()[source] Return an array of triangles that are not masked. get_trifinder()[source] Return the default matplotlib.tri.TriFinder of this triangulation, creating it if necessary. This allows the same TriFinder object to be easily shared. propertyneighbors Return integer array of shape (ntri, 3) containing neighbor triangles. For each triangle, the indices of the three triangles that share the same edges, or -1 if there is no such neighboring triangle. neighbors[i, j] is the triangle that is the neighbor to the edge from point index triangles[i, j] to point index triangles[i, (j+1)%3]. set_mask(mask)[source] Set or clear the mask array. Parameters maskNone or bool array of length ntri", "score": "0.6289799"}]}
{"task_id": "mbpp_357", "code": "def find_max(test_list):\r\n  res = max(int(j) for i in test_list for j in i)\r\n  return (res) ", "test_list": ["assert find_max([(2, 4), (6, 7), (5, 1), (6, 10), (8, 7)]) == 10", "assert find_max([(3, 5), (7, 8), (6, 2), (7, 11), (9, 8)]) == 11", "assert find_max([(4, 6), (8, 9), (7, 3), (8, 12), (10, 9)]) == 12"], "context": "Write a function to find the maximum element of all the given tuple records.", "function_name": "def find_max(test_list):", "gold_generation": "res = max(int(j) for i in test_list for j in i)\r\n  return (res)", "ctxs": [{"id": "43920", "text": "Function: numpy.reference.generated.numpy.record.max\nSnippet: numpy.record.max method record.max() Scalar method identical to the corresponding array attribute. Please see ndarray.max.", "score": "0.74101007"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.6901589"}, {"id": "18120", "text": "Function: python.library.audioop#audioop.findmax\nSnippet: audioop.findmax(fragment, length) Search fragment for a slice of length length samples (not bytes!) with maximum energy, i.e., return i for which rms(fragment[i*2:(i+length)*2]) is maximal. The fragments should both contain 2-byte samples. The routine takes time proportional to len(fragment).", "score": "0.688414"}, {"id": "18126", "text": "Function: python.library.audioop#audioop.max\nSnippet: audioop.max(fragment, width) Return the maximum of the absolute value of all samples in a fragment.", "score": "0.6824168"}, {"id": "43857", "text": "Function: numpy.reference.generated.numpy.recarray.max\nSnippet: numpy.recarray.max method recarray.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the maximum along a given axis. Refer to numpy.amax for full documentation. See also numpy.amax equivalent function", "score": "0.66985065"}]}
{"task_id": "mbpp_358", "code": "def moddiv_list(nums1,nums2):\r\n  result = map(lambda x, y: x % y, nums1, nums2)\r\n  return list(result)", "test_list": ["assert moddiv_list([4,5,6],[1, 2, 3])==[0, 1, 0]", "assert moddiv_list([3,2],[1,4])==[0, 2]", "assert moddiv_list([90,120],[50,70])==[40, 50]"], "context": "Write a function to find modulo division of two lists using map and lambda function.", "function_name": "def moddiv_list(nums1,nums2):", "gold_generation": "result = map(lambda x, y: x % y, nums1, nums2)\r\n  return list(result)", "ctxs": [{"id": "43025", "text": "Function: numpy.reference.generated.numpy.mod\nSnippet: numpy.mod numpy.mod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'remainder'> Returns the element-wise remainder of division. Computes the remainder complementary to the floor_divide function. It is equivalent to the Python modulus operator``x1 % x2`` and has the same sign as the divisor x2. The MATLAB function equivalent to np.remainder is mod. Warning This should not be confused with: Python 3.7’s math.remainder and C’s remainder, which computes the IEEE remainder, which are the complement to round(x1 / x2). The MATLAB rem function and or the C % operator which is the complement to int(x1 / x2). Parameters x1array_like Dividend array. x2array_like Divisor array. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray The element-wise remainder of the quotient floor_divide(x1, x2). This is a scalar if both x1 and x2 are scalars. See also floor_divide Equivalent of Python // operator. divmod Simultaneous floor division and remainder. fmod Equivalent of the MATLAB rem function. divide, floor Notes Returns 0 when x2 is 0 and both x1 and x2 are (arrays of) integers. mod is an alias of remainder. Examples >>> np.remainder([4, 7], [2, 3]) array([0, 1]) >>> np.remainder(np.arange(7), 5) array([0, 1, 2, 3, 4, 0, 1]) The % operator can be used as a shorthand for np.remainder on ndarrays. >>> x1 = np.arange(7) >>> x1 % 5 array([0, 1, 2, 3, 4, 0, 1])", "score": "0.6726302"}, {"id": "22386", "text": "Function: python.library.operator#operator.__mod__\nSnippet: operator.mod(a, b) operator.__mod__(a, b) Return a % b.", "score": "0.6628106"}, {"id": "18611", "text": "Function: python.library.collections\nSnippet: Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6}) New in version 3.2. The usual dictionary methods are available for Counter objects except for two which work differently for counters. fromkeys(iterable) This class method is not implemented for Counter objects. update([iterable-or-mapping]) Elements are counted from an iterable or added-in from another mapping (or counter). Like dict.update() but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of (key, value) pairs. Common patterns for working with Counter objects: sum(c.values()) # total of all counts c.clear() # reset all counts list(c) # list unique elements set(c) # convert to a set dict(c) # convert to a regular dictionary c.items() # convert to a list of (elem, cnt) pairs Counter(dict(list_of_pairs)) # convert from a list of (elem, cnt) pairs c.most_common()[:-n-1:-1] # n least common elements +c # remove zero and negative counts Several mathematical operations are provided for combining Counter objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. Intersection and union return the minimum and maximum of corresponding counts. Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less. >>> c = Counter(a=3, b=1) >>> d = Counter(a=1, b=2) >>> c + d # add two counters together: c[x] + d[x] Counter({'a': 4, 'b': 3}) >>> c - d # subtract (keeping only positive counts) Counter({'a': 2}) >>> c & d # intersection: min(c[x], d[x]) Counter({'a': 1, 'b': 1}) >>> c | d # union: max(c[x], d[x]) Counter({'a': 3, 'b': 2}) Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter. >>> c = Counter(a=2, b=-4) >>> +c Counter({'a': 2}) >>> -c Counter({'b': 4}) New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations. Note Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values. To help with those use cases, this section documents the minimum range and type restrictions. The Counter class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you could store anything in the value field. The most_common() method requires only that the values be orderable. For in-place operations such as c[key] += 1, the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for update() and subtract() which allow negative and zero", "score": "0.6624038"}, {"id": "13937", "text": "Function: pandas.reference.frame\nSnippet: DataFrame.mod(other[, axis, level, fill_value]) Get Modulo of dataframe and other, element-wise (binary operator mod). DataFrame.pow(other[, axis, level, fill_value]) Get Exponential power of dataframe and other, element-wise (binary operator pow). DataFrame.dot(other) Compute the matrix multiplication between the DataFrame and other. DataFrame.radd(other[, axis, level, fill_value]) Get Addition of dataframe and other, element-wise (binary operator radd). DataFrame.rsub(other[, axis, level, fill_value]) Get Subtraction of dataframe and other, element-wise (binary operator rsub). DataFrame.rmul(other[, axis, level, fill_value]) Get Multiplication of dataframe and other, element-wise (binary operator rmul). DataFrame.rdiv(other[, axis, level, fill_value]) Get Floating division of dataframe and other, element-wise (binary operator rtruediv). DataFrame.rtruediv(other[, axis, level, ...]) Get Floating division of dataframe and other, element-wise (binary operator rtruediv). DataFrame.rfloordiv(other[, axis, level, ...]) Get Integer division of dataframe and other, element-wise (binary operator rfloordiv). DataFrame.rmod(other[, axis, level, fill_value]) Get Modulo of dataframe and other, element-wise (binary operator rmod). DataFrame.rpow(other[, axis, level, fill_value]) Get Exponential power of dataframe and other, element-wise (binary operator rpow). DataFrame.lt(other[, axis, level]) Get Less than of dataframe and other, element-wise (binary operator lt). DataFrame.gt(other[, axis, level]) Get Greater than of dataframe and other, element-wise (binary operator gt). DataFrame.le(other[, axis, level]) Get Less than or equal to of dataframe and other, element-wise (binary operator le). DataFrame.ge(other[, axis, level]) Get Greater than or equal to of dataframe and other, element-wise (binary operator ge). DataFrame.ne(other[, axis, level]) Get Not equal to of dataframe and other, element-wise (binary operator ne). DataFrame.eq(other[, axis, level]) Get Equal to of dataframe and other, element-wise (binary operator eq). DataFrame.combine(other, func[, fill_value, ...]) Perform column-wise combine with another DataFrame. DataFrame.combine_first(other) Update null elements with value in the same location in other. Function application, GroupBy & window DataFrame.apply(func[, axis, raw, ...]) Apply a function along an axis of the DataFrame. DataFrame.applymap(func[, na_action]) Apply a function to a Dataframe elementwise. DataFrame.pipe(func, *args, **kwargs) Apply chainable functions that expect Series or DataFrames. DataFrame.agg([func, axis]) Aggregate using one or more operations over the specified axis. DataFrame.aggregate([func, axis]) Aggregate using one or more operations over the specified axis. DataFrame.transform(func[, axis]) Call func on self producing a DataFrame with the same axis shape as self. DataFrame.groupby([by, axis, level, ...]) Group DataFrame using a mapper or by a Series of columns. DataFrame.rolling(window[, min_periods, ...]) Provide rolling window calculations. DataFrame.expanding([min_periods, center, ...]) Provide expanding window calculations. DataFrame.ewm([com, span, halflife, alpha, ...]) Provide exponentially weighted (EW) calculations. Computations / descriptive stats DataFrame.abs() Return a Series/DataFrame with absolute numeric value of each element. DataFrame.all([axis, bool_only, skipna, level]) Return whether all elements are True, potentially over an axis. DataFrame.any([axis, bool_only, skipna, level]) Return whether any element is True, potentially over an axis. DataFrame.clip([lower, upper, axis, inplace]) Trim values at input threshold(s). DataFrame.corr([method, min_periods]) Compute pairwise correlation of columns, excluding NA/null values. DataFrame.corrwith(other[, axis, drop, method]) Compute pairwise correlation. DataFrame.count([axis, level, numeric_only]) Count non-NA cells for each column or row. DataFrame.cov([min_periods, ddof]) Compute pairwise covariance of columns, excluding NA/null values. DataFrame.cummax([axis, skipna]) Return cumulative maximum over a DataFrame or Series axis. DataFrame.cummin([axis, skipna]) Return cumulative minimum over a DataFrame or Series axis. DataFrame.cumprod([axis, skipna]) Return", "score": "0.66096574"}, {"id": "14466", "text": "Function: pandas.reference.api.pandas.dataframe.rfloordiv\nSnippet: pandas.DataFrame.rfloordiv DataFrame.rfloordiv(other, axis='columns', level=None, fill_value=None)[source] Get Integer division of dataframe and other, element-wise (binary operator rfloordiv). Equivalent to other // dataframe, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, floordiv. Among flexible wrappers (add, sub, mul, div, mod, pow) to arithmetic operators: +, -, *, /, //, %, **. Parameters other:scalar, sequence, Series, or DataFrame Any single or multiple element data structure, or list-like object. axis:{0 or ‘index’, 1 or ‘columns’} Whether to compare by the index (0 or ‘index’) or columns (1 or ‘columns’). For Series input, axis to match Series index on. level:int or label Broadcast across a level, matching Index values on the passed MultiIndex level. fill_value:float or None, default None Fill existing missing (NaN) values, and any new element needed for successful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. Returns DataFrame Result of the arithmetic operation. See also DataFrame.add Add DataFrames. DataFrame.sub Subtract DataFrames. DataFrame.mul Multiply DataFrames. DataFrame.div Divide DataFrames (float division). DataFrame.truediv Divide DataFrames (float division). DataFrame.floordiv Divide DataFrames (integer division). DataFrame.mod Calculate modulo (remainder after division). DataFrame.pow Calculate exponential power. Notes Mismatched indices will be unioned together. Examples >>> df = pd.DataFrame({'angles': [0, 3, 4], ... 'degrees': [360, 180, 360]}, ... index=['circle', 'triangle', 'rectangle']) >>> df angles degrees circle 0 360 triangle 3 180 rectangle 4 360 Add a scalar with operator version which return the same results. >>> df + 1 angles degrees circle 1 361 triangle 4 181 rectangle 5 361 >>> df.add(1) angles degrees circle 1 361 triangle 4 181 rectangle 5 361 Divide by constant with reverse version. >>> df.div(10) angles degrees circle 0.0 36.0 triangle 0.3 18.0 rectangle 0.4 36.0 >>> df.rdiv(10) angles degrees circle inf 0.027778 triangle 3.333333 0.055556 rectangle 2.500000 0.027778 Subtract a list and Series by axis with operator version. >>> df - [1, 2] angles degrees circle -1 358 triangle 2 178 rectangle 3 358 >>> df.sub([1, 2], axis='columns') angles degrees circle -1 358 triangle 2 178 rectangle 3 358 >>> df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']), ... axis='index') angles degrees circle -1 359 triangle 2 179 rectangle 3 359 Multiply a DataFrame of different shape with operator version. >>> other = pd.DataFrame({'angles': [0, 3, 4]}, ... index=['circle', 'triangle', 'rectangle']) >>> other angles circle 0 triangle 3 rectangle 4 >>> df * other angles degrees circle 0 NaN triangle 9 NaN rectangle 16 NaN >>> df.mul(other, fill_value=0) angles degrees circle 0 0.0 triangle 9 0.0 rectangle 16 0.0 Divide by a MultiIndex by level. >>> df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6], ... 'degrees': [360, 180, 360, 360, 540, 720]}, ... index=[['A', 'A', 'A', 'B', 'B', 'B'], ... ['circle', 'triangle', 'rectangle', ... 'square', 'pentagon', 'hexagon']]) >>> df_multindex angles degrees A circle 0 360 triangle 3 180 rectangle 4 360 B square 4 360 pentagon 5 540 hexagon 6 720 >>> df.div(df_multindex, level=1, fill_value=0) angles degrees A circle NaN 1.0", "score": "0.6595689"}]}
{"task_id": "mbpp_359", "code": "def Check_Solution(a,b,c): \r\n    if (2*b*b == 9*a*c): \r\n        return (\"Yes\"); \r\n    else: \r\n        return (\"No\"); ", "test_list": ["assert Check_Solution(1,3,2) == \"Yes\"", "assert Check_Solution(1,2,3) == \"No\"", "assert Check_Solution(1,-5,6) == \"No\""], "context": "Write a python function to check whether one root of the quadratic equation is twice of the other or not.", "function_name": "def Check_Solution(a,b,c):", "gold_generation": "if (2*b*b == 9*a*c): \r\n        return (\"Yes\"); \r\n    else: \r\n        return (\"No\");", "ctxs": [{"id": "19508", "text": "Function: python.library.decimal#decimal.Context.same_quantum\nSnippet: same_quantum(x, y) Returns True if the two operands have the same exponent.", "score": "0.67792785"}, {"id": "19567", "text": "Function: python.library.decimal#decimal.Decimal.same_quantum\nSnippet: same_quantum(other, context=None) Test whether self and other have the same exponent or whether both are NaN. This operation is unaffected by context and is quiet: no flags are changed and no rounding is performed. As an exception, the C version may raise InvalidOperation if the second operand cannot be converted exactly.", "score": "0.6439432"}, {"id": "43377", "text": "Function: numpy.reference.generated.numpy.polynomial.hermite.hermite.has_samecoef\nSnippet: numpy.polynomial.hermite.Hermite.has_samecoef method polynomial.hermite.Hermite.has_samecoef(other)[source] Check if coefficients match. New in version 1.6.0. Parameters otherclass instance The other class must have the coef attribute. Returns boolboolean True if the coefficients are the same, False otherwise.", "score": "0.64218783"}, {"id": "21810", "text": "Function: python.library.math#math.isinf\nSnippet: math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise.", "score": "0.6421363"}, {"id": "21777", "text": "Function: python.library.math\nSnippet: Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers. math.sqrt(x) Return the square root of x. Trigonometric functions math.acos(x) Return the arc cosine of x, in radians. The result is between 0 and pi. math.asin(x) Return the arc sine of x, in radians. The result is between -pi/2 and pi/2. math.atan(x) Return the arc tangent of x, in radians. The result is between -pi/2 and pi/2. math.atan2(y, x) Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4. math.cos(x) Return the cosine of x radians. math.dist(p, q) Return the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Roughly equivalent to: sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q))) New in version 3.8. math.hypot(*coordinates) Return the Euclidean norm, sqrt(sum(x**2 for x in coordinates)). This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point (x, y), this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, sqrt(x*x + y*y). Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. math.sin(x) Return the sine of x radians. math.tan(x) Return the tangent of x radians. Angular conversion math.degrees(x) Convert angle x from radians to degrees. math.radians(x) Convert angle x from degrees to radians. Hyperbolic functions Hyperbolic functions are analogs of trigonometric functions that are based on hyperbolas instead of circles. math.acosh(x) Return the inverse hyperbolic cosine of x. math.asinh(x) Return the inverse hyperbolic sine of x. math.atanh(x) Return the inverse hyperbolic tangent of x. math.cosh(x) Return the hyperbolic cosine of x. math.sinh(x) Return the hyperbolic sine of x. math.tanh(x) Return the hyperbolic tangent of x. Special functions math.erf(x) Return the error function at x. The erf() function can be used to compute traditional statistical functions such as the cumulative standard normal distribution: def phi(x): 'Cumulative distribution function for the standard normal distribution' return (1.0 + erf(x / sqrt(2.0))) / 2.0 New in version 3.2. math.erfc(x) Return the complementary error function at x. The complementary error function is defined as 1.0 - erf(x). It is used for large values of x where a subtraction from one would cause a loss of significance. New in version 3.2. math.gamma(x) Return the Gamma function at x. New in version 3.2. math.lgamma(x) Return the natural logarithm of the absolute value of the Gamma function at x. New in version 3.2. Constants math.pi The mathematical constant π =", "score": "0.6397367"}]}
{"task_id": "mbpp_360", "code": "def get_carol(n): \r\n\tresult = (2**n) - 1\r\n\treturn result * result - 2", "test_list": ["assert get_carol(2) == 7", "assert get_carol(4) == 223", "assert get_carol(5) == 959"], "context": "Write a function to find the n’th carol number.", "function_name": "def get_carol(n):", "gold_generation": "result = (2**n) - 1\r\n\treturn result * result - 2", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.71861327"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6622513"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6463345"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6403856"}, {"id": "15976", "text": "Function: pandas.reference.api.pandas.tseries.offsets.easter.n\nSnippet: pandas.tseries.offsets.Easter.n Easter.n", "score": "0.6322485"}]}
{"task_id": "mbpp_361", "code": "def remove_empty(list1):\r\n  remove_empty = [x for x in list1 if x]\r\n  return remove_empty", "test_list": ["assert remove_empty([[], [], [], 'Red', 'Green', [1,2], 'Blue', [], []])==['Red', 'Green', [1, 2], 'Blue']", "assert remove_empty([[], [], [],[],[], 'Green', [1,2], 'Blue', [], []])==[ 'Green', [1, 2], 'Blue']", "assert remove_empty([[], [], [], 'Python',[],[], 'programming', 'language',[],[],[], [], []])==['Python', 'programming', 'language']"], "context": "Write a function to remove empty lists from a given list of lists.", "function_name": "def remove_empty(list1):", "gold_generation": "remove_empty = [x for x in list1 if x]\r\n  return remove_empty", "ctxs": [{"id": "18664", "text": "Function: python.library.collections#collections.deque.clear\nSnippet: clear() Remove all elements from the deque leaving it with length 0.", "score": "0.6731833"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.672157"}, {"id": "13772", "text": "Function: pygame.ref.sprite#pygame.sprite.Group.empty\nSnippet: empty() remove all Sprites empty() -> None Removes all Sprites from this Group.", "score": "0.65378934"}, {"id": "20217", "text": "Function: python.library.stdtypes#frozenset.clear\nSnippet: clear() Remove all elements from the set.", "score": "0.6532395"}, {"id": "14689", "text": "Function: pandas.reference.api.pandas.index.empty\nSnippet: pandas.Index.empty propertyIndex.empty", "score": "0.65300006"}]}
{"task_id": "mbpp_362", "code": "def max_occurrences(nums):\r\n    max_val = 0\r\n    result = nums[0] \r\n    for i in nums:\r\n        occu = nums.count(i)\r\n        if occu > max_val:\r\n            max_val = occu\r\n            result = i \r\n    return result", "test_list": ["assert max_occurrences([1,2,3,1,2,3,12,4,2]) ==  2", "assert max_occurrences([1,2,6,7,0,1,0,1,0]) == 1,0", "assert max_occurrences([1,2,3,1,2,4,1]) == 1"], "context": "Write a python function to find the item with maximum occurrences in a given list.", "function_name": "def max_occurrences(nums):", "gold_generation": "max_val = 0\r\n    result = nums[0] \r\n    for i in nums:\r\n        occu = nums.count(i)\r\n        if occu > max_val:\r\n            max_val = occu\r\n            result = i \r\n    return result", "ctxs": [{"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.73265296"}, {"id": "18120", "text": "Function: python.library.audioop#audioop.findmax\nSnippet: audioop.findmax(fragment, length) Search fragment for a slice of length length samples (not bytes!) with maximum energy, i.e., return i for which rms(fragment[i*2:(i+length)*2]) is maximal. The fragments should both contain 2-byte samples. The routine takes time proportional to len(fragment).", "score": "0.68697023"}, {"id": "20286", "text": "Function: python.library.functions\nSnippet: values of local and free variables used by the interpreter. map(function, iterable, ...) Return an iterator that applies function to every item of iterable, yielding the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterator stops when the shortest iterable is exhausted. For cases where the function inputs are already arranged into argument tuples, see itertools.starmap(). max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None. class memoryview(obj) Return a “memory view” object created from the given argument. See Memory Views for more information. min(iterable, *[, key, default]) min(arg1, arg2, *args[, key]) Return the smallest item in an iterable or the smallest of two or more arguments. If one positional argument is provided, it should be an iterable. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None. next(iterator[, default]) Retrieve the next item from the iterator by calling its __next__() method. If default is given, it is returned if the iterator is exhausted, otherwise StopIteration is raised. class object Return a new featureless object. object is a base for all classes. It has the methods that are common to all instances of Python classes. This function does not accept any arguments. Note object does not have a __dict__, so you can’t assign arbitrary attributes to an instance of the object class. oct(x) Convert an integer number to an octal string prefixed with “0o”. The result is a valid Python expression. If x", "score": "0.6825904"}, {"id": "18655", "text": "Function: python.library.collections#collections.Counter.most_common\nSnippet: most_common([n]) Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered in the order first encountered: >>> Counter('abracadabra').most_common(3) [('a', 5), ('b', 2), ('r', 2)]", "score": "0.67670333"}, {"id": "20488", "text": "Function: python.library.heapq#heapq.nlargest\nSnippet: heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n].", "score": "0.67663294"}]}
{"task_id": "mbpp_363", "code": "def add_K_element(test_list, K):\r\n  res = [tuple(j + K for j in sub ) for sub in test_list]\r\n  return (res) ", "test_list": ["assert add_K_element([(1, 3, 4), (2, 4, 6), (3, 8, 1)], 4) == [(5, 7, 8), (6, 8, 10), (7, 12, 5)]", "assert add_K_element([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 8) == [(9, 10, 11), (12, 13, 14), (15, 16, 17)]", "assert add_K_element([(11, 12, 13), (14, 15, 16), (17, 18, 19)], 9) == [(20, 21, 22), (23, 24, 25), (26, 27, 28)]"], "context": "Write a function to add the k elements to each element in the tuple.", "function_name": "def add_K_element(test_list, K):", "gold_generation": "res = [tuple(j + K for j in sub ) for sub in test_list]\r\n  return (res)", "ctxs": [{"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.6947592"}, {"id": "42611", "text": "Function: numpy.reference.generated.numpy.add\nSnippet: numpy.add numpy.add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'add'> Add arguments element-wise. Parameters x1, x2array_like The arrays to be added. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns addndarray or scalar The sum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. Notes Equivalent to x1 + x2 in terms of array broadcasting. Examples >>> np.add(1.0, 4.0) 5.0 >>> x1 = np.arange(9.0).reshape((3, 3)) >>> x2 = np.arange(3.0) >>> np.add(x1, x2) array([[ 0., 2., 4.], [ 3., 5., 7.], [ 6., 8., 10.]]) The + operator can be used as a shorthand for np.add on ndarrays. >>> x1 = np.arange(9.0).reshape((3, 3)) >>> x2 = np.arange(3.0) >>> x1 + x2 array([[ 0., 2., 4.], [ 3., 5., 7.], [ 6., 8., 10.]])", "score": "0.68794984"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.67871606"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.67456937"}, {"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.67410195"}]}
{"task_id": "mbpp_364", "code": "def make_flip(ch): \r\n\treturn '1' if (ch == '0') else '0'\r\ndef get_flip_with_starting_charcter(str, expected): \r\n\tflip_count = 0\r\n\tfor i in range(len( str)): \r\n\t\tif (str[i] != expected): \r\n\t\t\tflip_count += 1\r\n\t\texpected = make_flip(expected) \r\n\treturn flip_count \r\ndef min_flip_to_make_string_alternate(str): \r\n\treturn min(get_flip_with_starting_charcter(str, '0'),get_flip_with_starting_charcter(str, '1')) ", "test_list": ["assert min_flip_to_make_string_alternate(\"0001010111\") == 2", "assert min_flip_to_make_string_alternate(\"001\") == 1", "assert min_flip_to_make_string_alternate(\"010111011\") == 2 "], "context": "Write a function to find the number of flips required to make the given binary string a sequence of alternate characters.", "function_name": "def make_flip(ch):", "gold_generation": "return '1' if (ch == '0') else '0'\r\ndef get_flip_with_starting_charcter(str, expected): \r\n\tflip_count = 0\r\n\tfor i in range(len( str)): \r\n\t\tif (str[i] != expected): \r\n\t\t\tflip_count += 1\r\n\t\texpected = make_flip(expected) \r\n\treturn flip_count \r\ndef min_flip_to_make_string_alternate(str): \r\n\treturn min(get_flip_with_starting_charcter(str, '0'),get_flip_with_starting_charcter(str, '1'))", "ctxs": [{"id": "18295", "text": "Function: python.library.stdtypes#bytearray.swapcase\nSnippet: bytes.swapcase() bytearray.swapcase() Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart and vice-versa. For example: >>> b'Hello World'.swapcase() b'hELLO wORLD' Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. Unlike str.swapcase(), it is always the case that bin.swapcase().swapcase() == bin for the binary versions. Case conversions are symmetrical in ASCII, even though that is not generally true for arbitrary Unicode code points. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made.", "score": "0.70858663"}, {"id": "18339", "text": "Function: python.library.stdtypes#bytes.swapcase\nSnippet: bytes.swapcase() bytearray.swapcase() Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart and vice-versa. For example: >>> b'Hello World'.swapcase() b'hELLO wORLD' Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. Unlike str.swapcase(), it is always the case that bin.swapcase().swapcase() == bin for the binary versions. Case conversions are symmetrical in ASCII, even though that is not generally true for arbitrary Unicode code points. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made.", "score": "0.7071259"}, {"id": "18236", "text": "Function: python.library.binascii#binascii.unhexlify\nSnippet: binascii.a2b_hex(hexstr) binascii.unhexlify(hexstr) Return the binary data represented by the hexadecimal string hexstr. This function is the inverse of b2a_hex(). hexstr must contain an even number of hexadecimal digits (which can be upper or lower case), otherwise an Error exception is raised. Similar functionality (accepting only text string arguments, but more liberal towards whitespace) is also accessible using the bytes.fromhex() class method.", "score": "0.70443815"}, {"id": "18220", "text": "Function: python.library.binascii#binascii.a2b_hex\nSnippet: binascii.a2b_hex(hexstr) binascii.unhexlify(hexstr) Return the binary data represented by the hexadecimal string hexstr. This function is the inverse of b2a_hex(). hexstr must contain an even number of hexadecimal digits (which can be upper or lower case), otherwise an Error exception is raised. Similar functionality (accepting only text string arguments, but more liberal towards whitespace) is also accessible using the bytes.fromhex() class method.", "score": "0.6964055"}, {"id": "41704", "text": "Function: numpy.reference.generated.numpy.char.chararray.swapcase\nSnippet: numpy.char.chararray.swapcase method char.chararray.swapcase()[source] For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. See also char.swapcase", "score": "0.6821506"}]}
{"task_id": "mbpp_365", "code": "def count_Digit(n):\r\n    count = 0\r\n    while n != 0:\r\n        n //= 10\r\n        count += 1\r\n    return count", "test_list": ["assert count_Digit(12345) == 5", "assert count_Digit(11223305) == 8", "assert count_Digit(4123459) == 7"], "context": "Write a python function to count the number of digits of a given number.", "function_name": "def count_Digit(n):", "gold_generation": "count = 0\r\n    while n != 0:\r\n        n //= 10\r\n        count += 1\r\n    return count", "ctxs": [{"id": "24403", "text": "Function: python.library.string#string.digits\nSnippet: string.digits The string '0123456789'.", "score": "0.7563851"}, {"id": "24415", "text": "Function: python.library.string#string.octdigits\nSnippet: string.octdigits The string '01234567'.", "score": "0.7008283"}, {"id": "21304", "text": "Function: python.library.itertools#itertools.count\nSnippet: itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments.", "score": "0.69039756"}, {"id": "22306", "text": "Function: python.library.operator#operator.countOf\nSnippet: operator.countOf(a, b) Return the number of occurrences of b in a.", "score": "0.6811917"}, {"id": "25447", "text": "Function: python.library.token#token.NUMBER\nSnippet: token.NUMBER", "score": "0.67780954"}]}
{"task_id": "mbpp_366", "code": "def adjacent_num_product(list_nums):\r\n    return max(a*b for a, b in zip(list_nums, list_nums[1:]))", "test_list": ["assert adjacent_num_product([1,2,3,4,5,6]) == 30", "assert adjacent_num_product([1,2,3,4,5]) == 20", "assert adjacent_num_product([2,3]) == 6"], "context": "Write a python function to find the largest product of the pair of adjacent elements from a given list of integers.", "function_name": "def adjacent_num_product(list_nums):", "gold_generation": "return max(a*b for a, b in zip(list_nums, list_nums[1:]))", "ctxs": [{"id": "21311", "text": "Function: python.library.itertools#itertools.product\nSnippet: itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs.", "score": "0.6683865"}, {"id": "21316", "text": "Function: python.library.itertools#itertools.zip_longest\nSnippet: itertools.zip_longest(*iterables, fillvalue=None) Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. Roughly equivalent to: def zip_longest(*args, fillvalue=None): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- iterators = [iter(it) for it in args] num_active = len(iterators) if not num_active: return while True: values = [] for i, it in enumerate(iterators): try: value = next(it) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values.append(value) yield tuple(values) If one of the iterables is potentially infinite, then the zip_longest() function should be wrapped with something that limits the number of calls (for example islice() or takewhile()). If not specified, fillvalue defaults to None.", "score": "0.66276455"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6622236"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6612361"}, {"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.6610916"}]}
{"task_id": "mbpp_367", "code": "class Node: \r\n\tdef __init__(self, data): \r\n\t\tself.data = data \r\n\t\tself.left = None\r\n\t\tself.right = None\r\ndef get_height(root): \r\n\tif root is None: \r\n\t\treturn 0\r\n\treturn max(get_height(root.left), get_height(root.right)) + 1\r\ndef is_tree_balanced(root): \r\n\tif root is None: \r\n\t\treturn True\r\n\tlh = get_height(root.left) \r\n\trh = get_height(root.right) \r\n\tif (abs(lh - rh) <= 1) and is_tree_balanced( \r\n\troot.left) is True and is_tree_balanced( root.right) is True: \r\n\t\treturn True\r\n\treturn False", "test_list": ["assert is_tree_balanced(root) == False", "assert is_tree_balanced(root1) == True", "assert is_tree_balanced(root2) == False "], "context": "Write a function to check if a binary tree is balanced or not.", "function_name": "class Node:", "gold_generation": "def __init__(self, data): \r\n\t\tself.data = data \r\n\t\tself.left = None\r\n\t\tself.right = None\r\ndef get_height(root): \r\n\tif root is None: \r\n\t\treturn 0\r\n\treturn max(get_height(root.left), get_height(root.right)) + 1\r\ndef is_tree_balanced(root): \r\n\tif root is None: \r\n\t\treturn True\r\n\tlh = get_height(root.left) \r\n\trh = get_height(root.right) \r\n\tif (abs(lh - rh) <= 1) and is_tree_balanced( \r\n\troot.left) is True and is_tree_balanced( root.right) is True: \r\n\t\treturn True\r\n\treturn False", "ctxs": [{"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.65418184"}, {"id": "20480", "text": "Function: python.library.heapq\nSnippet: winner is to move some loser (let’s say cell 30 in the diagram above) into the 0 position, and then percolate this new 0 down the tree, exchanging values, until the invariant is re-established. This is clearly logarithmic on the total number of items in the tree. By iterating over all items, you get an O(n log n) sort. A nice feature of this sort is that you can efficiently insert new items while the sort is going on, provided that the inserted items are not “better” than the last 0’th element you extracted. This is especially useful in simulation contexts, where the tree holds all incoming events, and the “win” condition means the smallest scheduled time. When an event schedules other events for execution, they are scheduled into the future, so they can easily go into the heap. So, a heap is a good structure for implementing schedulers (this is what I used for my MIDI sequencer :-). Various structures for implementing schedulers have been extensively studied, and heaps are good for this, as they are reasonably speedy, the speed is almost constant, and the worst case is not much different than the average case. However, there are other representations which are more efficient overall, yet the worst cases might be terrible. Heaps are also very useful in big disk sorts. You most probably all know that a big sort implies producing “runs” (which are pre-sorted sequences, whose size is usually related to the amount of CPU memory), followed by a merging passes for these runs, which merging is often very cleverly organised 1. It is very important that the initial sort produces the longest runs possible. Tournaments are a good way to achieve that. If, using all the memory available to hold a tournament, you replace and percolate items that happen to fit the current run, you’ll produce runs which are twice the size of the memory for random input, and much better for input fuzzily ordered. Moreover, if you output the 0’th item on disk and get an input which may not fit in the current tournament (because the value “wins” over the last output value), it cannot fit in the heap, so the size of the heap decreases. The freed memory could be cleverly reused immediately for progressively building a second heap, which grows at exactly the same rate the first heap is melting. When the first heap completely vanishes, you switch heaps and start a new run. Clever and quite effective! In a word, heaps are useful memory structures to know. I use them in a few applications, and I think it is good to keep a ‘heap’ module around. :-) Footnotes 1 The disk balancing algorithms which are current, nowadays, are more annoying than clever, and this is a consequence of the seeking capabilities of the disks. On devices which cannot seek, like big tape drives, the story was quite different, and one had to be very clever to ensure (far in advance) that", "score": "0.64654416"}, {"id": "20477", "text": "Function: python.library.heapq\nSnippet: heapq — Heap queue algorithm Source code: Lib/heapq.py This module provides an implementation of the heap queue algorithm, also known as the priority queue algorithm. Heaps are binary trees for which every parent node has a value less than or equal to any of its children. This implementation uses arrays for which heap[k] <= heap[2*k+1] and heap[k] <= heap[2*k+2] for all k, counting elements from zero. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that its smallest element is always the root, heap[0]. The API below differs from textbook heap algorithms in two aspects: (a) We use zero-based indexing. This makes the relationship between the index for a node and the indexes for its children slightly less obvious, but is more suitable since Python uses zero-based indexing. (b) Our pop method returns the smallest item, not the largest (called a “min heap” in textbooks; a “max heap” is more common in texts because of its suitability for in-place sorting). These two make it possible to view the heap as a regular Python list without surprises: heap[0] is the smallest item, and heap.sort() maintains the heap invariant! To create a heap, use a list initialized to [], or you can transform a populated list into a heap via function heapify(). The following functions are provided: heapq.heappush(heap, item) Push the value item onto the heap, maintaining the heap invariant. heapq.heappop(heap) Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0]. heapq.heappushpop(heap, item) Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop(). heapq.heapify(x) Transform list x into a heap, in-place, in linear time. heapq.heapreplace(heap, item) Pop and return the smallest item from the heap, and also push the new item. The heap size doesn’t change. If the heap is empty, IndexError is raised. This one step operation is more efficient than a heappop() followed by heappush() and can be more appropriate when using a fixed-size heap. The pop/push combination always returns an element from the heap and replaces it with item. The value returned may be larger than the item added. If that isn’t desired, consider using heappushpop() instead. Its push/pop combination returns the smaller of the two values, leaving the larger value on the heap. The module also offers three general purpose functions based on heaps. heapq.merge(*iterables, key=None, reverse=False) Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an iterator over the sorted values. Similar to sorted(itertools.chain(*iterables)) but returns an iterable, does not pull the data into memory all at once, and assumes that each of the input streams is already sorted (smallest to largest). Has two optional arguments which must be specified as keyword arguments. key specifies a", "score": "0.6408571"}, {"id": "20426", "text": "Function: python.library.graphlib#graphlib.TopologicalSorter.is_active\nSnippet: is_active() Returns True if more progress can be made and False otherwise. Progress can be made if cycles do not block the resolution and either there are still nodes ready that haven’t yet been returned by TopologicalSorter.get_ready() or the number of nodes marked TopologicalSorter.done() is less than the number that have been returned by TopologicalSorter.get_ready(). The __bool__() method of this class defers to this function, so instead of: if ts.is_active(): ... it is possible to simply do: if ts: ... Raises ValueError if called without calling prepare() previously.", "score": "0.63952446"}, {"id": "20478", "text": "Function: python.library.heapq\nSnippet: key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters. heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n]. heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n]. The latter two functions perform best for smaller values of n. For larger values, it is more efficient to use the sorted() function. Also, when n==1, it is more efficient to use the built-in min() and max() functions. If repeated usage of these functions is required, consider turning the iterable into an actual heap. Basic Examples A heapsort can be implemented by pushing all values onto a heap and then popping off the smallest values one at a time: >>> def heapsort(iterable): ... h = [] ... for value in iterable: ... heappush(h, value) ... return [heappop(h) for i in range(len(h))] ... >>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] This is similar to sorted(iterable), but unlike sorted(), this implementation is not stable. Heap elements can be tuples. This is useful for assigning comparison values (such as task priorities) alongside the main record being tracked: >>> h = [] >>> heappush(h, (5, 'write code')) >>> heappush(h, (7, 'release product')) >>> heappush(h, (1, 'write spec')) >>> heappush(h, (3, 'create tests')) >>> heappop(h) (1, 'write spec') Priority Queue Implementation Notes A priority queue is common use for a heap, and it presents several implementation challenges: Sort stability: how do you get two tasks with equal priorities to be returned in the order they were originally added? Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order. If the priority of a task changes, how do you move it to a new position in the heap? Or if a pending task needs to be deleted, how do you find it and remove it from the queue? A solution to the first two challenges is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were", "score": "0.6372451"}]}
{"task_id": "mbpp_368", "code": "def repeat_tuples(test_tup, N):\r\n  res = ((test_tup, ) * N)\r\n  return (res) ", "test_list": ["assert repeat_tuples((1, 3), 4) == ((1, 3), (1, 3), (1, 3), (1, 3))", "assert repeat_tuples((1, 2), 3) == ((1, 2), (1, 2), (1, 2))", "assert repeat_tuples((3, 4), 5) == ((3, 4), (3, 4), (3, 4), (3, 4), (3, 4))"], "context": "Write a function to repeat the given tuple n times.", "function_name": "def repeat_tuples(test_tup, N):", "gold_generation": "res = ((test_tup, ) * N)\r\n  return (res)", "ctxs": [{"id": "21312", "text": "Function: python.library.itertools#itertools.repeat\nSnippet: itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for invariant parameters to the called function. Also used with zip() to create an invariant part of a tuple record. Roughly equivalent to: def repeat(object, times=None): # repeat(10, 3) --> 10 10 10 if times is None: while True: yield object else: for i in range(times): yield object A common use for repeat is to supply a stream of constant values to map or zip: >>> list(map(pow, range(10), repeat(2))) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]", "score": "0.74015415"}, {"id": "43869", "text": "Function: numpy.reference.generated.numpy.recarray.repeat\nSnippet: numpy.recarray.repeat method recarray.repeat(repeats, axis=None) Repeat elements of an array. Refer to numpy.repeat for full documentation. See also numpy.repeat equivalent function", "score": "0.72132576"}, {"id": "43932", "text": "Function: numpy.reference.generated.numpy.record.repeat\nSnippet: numpy.record.repeat method record.repeat() Scalar method identical to the corresponding array attribute. Please see ndarray.repeat.", "score": "0.7212128"}, {"id": "41682", "text": "Function: numpy.reference.generated.numpy.char.chararray.repeat\nSnippet: numpy.char.chararray.repeat method char.chararray.repeat(repeats, axis=None) Repeat elements of an array. Refer to numpy.repeat for full documentation. See also numpy.repeat equivalent function", "score": "0.7201243"}, {"id": "42556", "text": "Function: numpy.reference.generated.numpy.ndarray.repeat\nSnippet: numpy.ndarray.repeat method ndarray.repeat(repeats, axis=None) Repeat elements of an array. Refer to numpy.repeat for full documentation. See also numpy.repeat equivalent function", "score": "0.71740484"}]}
{"task_id": "mbpp_369", "code": "def lateralsurface_cuboid(l,w,h):\r\n  LSA = 2*h*(l+w)\r\n  return LSA", "test_list": ["assert lateralsurface_cuboid(8,5,6)==156", "assert lateralsurface_cuboid(7,9,10)==320", "assert lateralsurface_cuboid(10,20,30)==1800"], "context": "Write a function to find the lateral surface area of cuboid", "function_name": "def lateralsurface_cuboid(l,w,h):", "gold_generation": "LSA = 2*h*(l+w)\r\n  return LSA", "ctxs": [{"id": "16631", "text": "Function: skimage.api.skimage.draw\nSnippet: ellipsoid_stats skimage.draw.ellipsoid_stats(a, b, c) [source] Calculates analytical surface area and volume for ellipsoid with semimajor axes aligned with grid dimensions of specified spacing. Parameters afloat Length of semimajor axis aligned with x-axis. bfloat Length of semimajor axis aligned with y-axis. cfloat Length of semimajor axis aligned with z-axis. Returns volfloat Calculated volume of ellipsoid. surffloat Calculated surface area of ellipsoid. line skimage.draw.line(r0, c0, r1, c1) [source] Generate line pixel coordinates. Parameters r0, c0int Starting position (row, column). r1, c1int End position (row, column). Returns rr, cc(N,) ndarray of int Indices of pixels that belong to the line. May be used to directly index into an array, e.g. img[rr, cc] = 1. Notes Anti-aliased line generator is available with line_aa. Examples >>> from skimage.draw import line >>> img = np.zeros((10, 10), dtype=np.uint8) >>> rr, cc = line(1, 1, 8, 8) >>> img[rr, cc] = 1 >>> img array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8) line_aa skimage.draw.line_aa(r0, c0, r1, c1) [source] Generate anti-aliased line pixel coordinates. Parameters r0, c0int Starting position (row, column). r1, c1int End position (row, column). Returns rr, cc, val(N,) ndarray (int, int, float) Indices of pixels (rr, cc) and intensity values (val). img[rr, cc] = val. References 1 A Rasterizing Algorithm for Drawing Curves, A. Zingl, 2012 http://members.chello.at/easyfilter/Bresenham.pdf Examples >>> from skimage.draw import line_aa >>> img = np.zeros((10, 10), dtype=np.uint8) >>> rr, cc, val = line_aa(1, 1, 8, 8) >>> img[rr, cc] = val * 255 >>> img array([[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [ 0, 255, 74, 0, 0, 0, 0, 0, 0, 0], [ 0, 74, 255, 74, 0, 0, 0, 0, 0, 0], [ 0, 0, 74, 255, 74, 0, 0, 0, 0, 0], [ 0, 0, 0, 74, 255, 74, 0, 0, 0, 0], [ 0, 0, 0, 0, 74, 255, 74, 0, 0, 0], [ 0, 0, 0, 0, 0, 74, 255, 74, 0, 0], [ 0, 0, 0, 0, 0, 0, 74, 255, 74, 0], [ 0, 0, 0, 0, 0, 0, 0, 74, 255, 0], [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8) line_nd skimage.draw.line_nd(start, stop, *, endpoint=False, integer=True) [source] Draw a single-pixel thick line in n dimensions. The line produced will be ndim-connected. That is, two subsequent pixels in the line will be either direct or diagonal neighbours in n dimensions. Parameters startarray-like, shape (N,) The start coordinates of the line. stoparray-like, shape (N,) The end coordinates", "score": "0.6478584"}, {"id": "33487", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: barbs_doc='\\nPlot a 2D field of barbs.\\n\\nCall signature::\\n\\n barbs([X, Y], U, V, [C], **kw)\\n\\nWhere *X*, *Y* define the barb locations, *U*, *V* define the barb\\ndirections, and *C* optionally sets the color.\\n\\nAll arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked\\n*X*, *Y* are not supported at present.\\n\\nBarbs are traditionally used in meteorology as a way to plot the speed\\nand direction of wind observations, but can technically be used to\\nplot any two dimensional vector quantity. As opposed to arrows, which\\ngive vector magnitude by the length of the arrow, the barbs give more\\nquantitative information about the vector magnitude by putting slanted\\nlines or a triangle for various increments in magnitude, as show\\nschematically below::\\n\\n : /\\\\ \\\\\\n : / \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : ------------------------------\\n\\nThe largest increment is given by a triangle (or \"flag\"). After those\\ncome full lines (barbs). The smallest increment is a half line. There\\nis only, of course, ever at most 1 half line. If the magnitude is\\nsmall and only needs a single half-line and no full lines or\\ntriangles, the half-line is offset from the end of the barb so that it\\ncan be easily distinguished from barbs with a single full line. The\\nmagnitude for the barb shown above would nominally be 65, using the\\nstandard increments of 50, 10, and 5.\\n\\nSee also https://en.wikipedia.org/wiki/Wind_barb.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the barb locations. See *pivot* for how the\\n barbs are drawn to the x, y positions.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y components of the barb shaft.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If", "score": "0.6431392"}, {"id": "16645", "text": "Function: skimage.api.skimage.draw#skimage.draw.ellipsoid_stats\nSnippet: skimage.draw.ellipsoid_stats(a, b, c) [source] Calculates analytical surface area and volume for ellipsoid with semimajor axes aligned with grid dimensions of specified spacing. Parameters afloat Length of semimajor axis aligned with x-axis. bfloat Length of semimajor axis aligned with y-axis. cfloat Length of semimajor axis aligned with z-axis. Returns volfloat Calculated volume of ellipsoid. surffloat Calculated surface area of ellipsoid.", "score": "0.6386008"}, {"id": "17024", "text": "Function: skimage.api.skimage.measure#skimage.measure.mesh_surface_area\nSnippet: skimage.measure.mesh_surface_area(verts, faces) [source] Compute surface area, given vertices & triangular faces Parameters verts(V, 3) array of floats Array containing (x, y, z) coordinates for V unique mesh vertices. faces(F, 3) array of ints List of length-3 lists of integers, referencing vertex coordinates as provided in verts Returns areafloat Surface area of mesh. Units now [coordinate units] ** 2. See also skimage.measure.marching_cubes skimage.measure.marching_cubes_classic Notes The arguments expected by this function are the first two outputs from skimage.measure.marching_cubes. For unit correct output, ensure correct spacing was passed to skimage.measure.marching_cubes. This algorithm works properly only if the faces provided are all triangles.", "score": "0.63517797"}, {"id": "6713", "text": "Function: torch.linalg\nSnippet: The resulting tensor x has the same shape as input[other.ndim:]. Supports real-valued and complex-valued inputs. Note If input does not satisfy the requirement prod(input.shape[other.ndim:]) == prod(input.shape[:other.ndim]) after (optionally) moving the dimensions using dims, then a RuntimeError will be thrown. Parameters input (Tensor) – “left-hand-side” tensor, it must satisfy the requirement prod(input.shape[other.ndim:]) == prod(input.shape[:other.ndim]). other (Tensor) – “right-hand-side” tensor of shape input.shape[other.ndim]. dims (Tuple[int]) – dimensions of input to be moved before the computation. Equivalent to calling input = movedim(input, dims, range(len(dims) - input.ndim, 0)). If None (default), no dimensions are moved. Keyword Arguments out (Tensor, optional) – The output tensor. Ignored if None. Default: None Examples: >>> a = torch.eye(2 * 3 * 4).reshape((2 * 3, 4, 2, 3, 4)) >>> b = torch.randn(2 * 3, 4) >>> x = torch.linalg.tensorsolve(a, b) >>> x.shape torch.Size([2, 3, 4]) >>> torch.allclose(torch.tensordot(a, x, dims=x.ndim), b) True >>> a = torch.randn(6, 4, 4, 3, 2) >>> b = torch.randn(4, 3, 2) >>> x = torch.linalg.tensorsolve(a, b, dims=(0, 2)) >>> x.shape torch.Size([6, 4]) >>> a = a.permute(1, 3, 4, 0, 2) >>> a.shape[b.ndim:] torch.Size([6, 4]) >>> torch.allclose(torch.tensordot(a, x, dims=x.ndim), b, atol=1e-6) True torch.linalg.inv(input, *, out=None) → Tensor Computes the multiplicative inverse matrix of a square matrix input, or of each square matrix in a batched input. The result satisfies the relation: matmul(inv(input),input) = matmul(input,inv(input)) = eye(input.shape[0]).expand_as(input). Supports input of float, double, cfloat and cdouble data types. Note When given inputs on a CUDA device, this function synchronizes that device with the CPU. Note The inverse matrix is computed using LAPACK’s getrf and getri routines for CPU inputs. For CUDA inputs, cuSOLVER’s getrf and getrs routines as well as cuBLAS’ getrf and getri routines are used if CUDA version >= 10.1.243, otherwise MAGMA’s getrf and getri routines are used instead. Note If input is a non-invertible matrix or non-square matrix, or batch with at least one such matrix, then a RuntimeError will be thrown. Parameters input (Tensor) – the square (n, n) matrix or the batch of such matrices of size (*, n, n) where * is one or more batch dimensions. Keyword Arguments out (Tensor, optional) – The output tensor. Ignored if None. Default is None. Examples: >>> x = torch.rand(4, 4) >>> y = torch.linalg.inv(x) >>> z = torch.mm(x, y) >>> z tensor([[ 1.0000, -0.0000, -0.0000, 0.0000], [ 0.0000, 1.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 1.0000, 0.0000], [ 0.0000, -0.0000, -0.0000, 1.0000]]) >>> torch.max(torch.abs(z - torch.eye(4))) # Max non-zero tensor(1.1921e-07) >>> # Batched inverse example >>> x = torch.randn(2, 3, 4, 4) >>> y = torch.linalg.inv(x) >>> z = torch.matmul(x, y) >>> torch.max(torch.abs(z - torch.eye(4).expand_as(x))) # Max non-zero tensor(1.9073e-06) >>> x = torch.rand(4, 4, dtype=torch.cdouble) >>> y = torch.linalg.inv(x) >>> z = torch.mm(x, y) >>> z tensor([[ 1.0000e+00+0.0000e+00j, -1.3878e-16+3.4694e-16j, 5.5511e-17-1.1102e-16j, 0.0000e+00-1.6653e-16j], [ 5.5511e-16-1.6653e-16j, 1.0000e+00+6.9389e-17j, 2.2204e-16-1.1102e-16j, -2.2204e-16+1.1102e-16j], [ 3.8858e-16-1.2490e-16j, 2.7756e-17+3.4694e-17j, 1.0000e+00+0.0000e+00j, -4.4409e-16+5.5511e-17j], [ 4.4409e-16+5.5511e-16j, -3.8858e-16+1.8041e-16j, 2.2204e-16+0.0000e+00j, 1.0000e+00-3.4694e-16j]], dtype=torch.complex128) >>> torch.max(torch.abs(z - torch.eye(4, dtype=torch.cdouble))) # Max non-zero tensor(7.5107e-16, dtype=torch.float64) torch.linalg.qr(input, mode='reduced', *, out=None) -> (Tensor, Tensor) Computes the QR decomposition of a matrix or a batch", "score": "0.6334596"}]}
{"task_id": "mbpp_370", "code": "def float_sort(price):\r\n  float_sort=sorted(price, key=lambda x: float(x[1]), reverse=True)\r\n  return float_sort", "test_list": ["assert float_sort([('item1', '12.20'), ('item2', '15.10'), ('item3', '24.5')])==[('item3', '24.5'), ('item2', '15.10'), ('item1', '12.20')] ", "assert float_sort([('item1', '15'), ('item2', '10'), ('item3', '20')])==[('item3', '20'), ('item1', '15'), ('item2', '10')] ", "assert float_sort([('item1', '5'), ('item2', '10'), ('item3', '14')])==[('item3', '14'), ('item2', '10'), ('item1', '5')] "], "context": "Write a function to sort a tuple by its float element.", "function_name": "def float_sort(price):", "gold_generation": "float_sort=sorted(price, key=lambda x: float(x[1]), reverse=True)\r\n  return float_sort", "ctxs": [{"id": "25739", "text": "Function: python.library.stdtypes\nSnippet: a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort. Tuples Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a set or dict instance). class tuple([iterable]) Tuples may be constructed in a number of ways: Using a pair of parentheses to denote the empty tuple: () Using a trailing comma for a singleton tuple: a, or (a,) Separating items with commas: a, b, c or (a, b, c) Using the tuple() built-in: tuple() or tuple(iterable) The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, tuple('abc') returns ('a', 'b', 'c') and tuple( [1, 2, 3] ) returns (1, 2, 3). If no argument is given, the constructor creates a new empty tuple, (). Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, f(a, b, c) is a function call with three arguments, while f((a, b, c)) is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, collections.namedtuple() may be a more appropriate choice than a simple tuple object. Ranges The range type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops. class range(stop) class range(start, stop[, step]) The arguments to the range constructor must be integers (either built-in int or any object that implements the __index__ special method). If the step argument is omitted, it defaults to 1. If the start argument is", "score": "0.7402725"}, {"id": "14495", "text": "Function: pandas.reference.api.pandas.dataframe.sort_values\nSnippet: B 9 9 c 0 A 2 0 a 1 A 1 1 B Sorting with a key function >>> df.sort_values(by='col4', key=lambda col: col.str.lower()) col1 col2 col3 col4 0 A 2 0 a 1 A 1 1 B 2 B 9 9 c 3 NaN 8 4 D 4 D 7 2 e 5 C 4 3 F Natural sort with the key argument, using the natsort <https://github.com/SethMMorton/natsort> package. >>> df = pd.DataFrame({ ... \"time\": ['0hr', '128hr', '72hr', '48hr', '96hr'], ... \"value\": [10, 20, 30, 40, 50] ... }) >>> df time value 0 0hr 10 1 128hr 20 2 72hr 30 3 48hr 40 4 96hr 50 >>> from natsort import index_natsorted >>> df.sort_values( ... by=\"time\", ... key=lambda x: np.argsort(index_natsorted(df[\"time\"])) ... ) time value 0 0hr 10 3 48hr 40 2 72hr 30 4 96hr 50 1 128hr 20", "score": "0.7057406"}, {"id": "43940", "text": "Function: numpy.reference.generated.numpy.record.sort\nSnippet: numpy.record.sort method record.sort() Scalar method identical to the corresponding array attribute. Please see ndarray.sort.", "score": "0.7050724"}, {"id": "41639", "text": "Function: numpy.reference.generated.numpy.char.chararray.argsort\nSnippet: numpy.char.chararray.argsort method char.chararray.argsort(axis=- 1, kind=None, order=None)[source] Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.70445"}, {"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.70248824"}]}
{"task_id": "mbpp_371", "code": "def smallest_missing(A, left_element, right_element):\r\n    if left_element > right_element:\r\n        return left_element\r\n    mid = left_element + (right_element - left_element) // 2\r\n    if A[mid] == mid:\r\n        return smallest_missing(A, mid + 1, right_element)\r\n    else:\r\n        return smallest_missing(A, left_element, mid - 1)", "test_list": ["assert smallest_missing([0, 1, 2, 3, 4, 5, 6], 0, 6) == 7", "assert smallest_missing([0, 1, 2, 6, 9, 11, 15], 0, 6) == 3", "assert smallest_missing([1, 2, 3, 4, 6, 9, 11, 15], 0, 7) == 0"], "context": "Write a function to find the smallest missing element in a sorted array.", "function_name": "def smallest_missing(A, left_element, right_element):", "gold_generation": "if left_element > right_element:\r\n        return left_element\r\n    mid = left_element + (right_element - left_element) // 2\r\n    if A[mid] == mid:\r\n        return smallest_missing(A, mid + 1, right_element)\r\n    else:\r\n        return smallest_missing(A, left_element, mid - 1)", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.7329016"}, {"id": "21889", "text": "Function: python.library.functions#min\nSnippet: min(iterable, *[, key, default]) min(arg1, arg2, *args[, key]) Return the smallest item in an iterable or the smallest of two or more arguments. If one positional argument is provided, it should be an iterable. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.71928513"}, {"id": "20489", "text": "Function: python.library.heapq#heapq.nsmallest\nSnippet: heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n].", "score": "0.71072793"}, {"id": "41778", "text": "Function: numpy.reference.generated.numpy.chararray.find\nSnippet: numpy.chararray.find method chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.7045162"}, {"id": "41654", "text": "Function: numpy.reference.generated.numpy.char.chararray.find\nSnippet: numpy.char.chararray.find method char.chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.70173097"}]}
{"task_id": "mbpp_372", "code": "import heapq as hq\r\ndef heap_assending(nums):\r\n  hq.heapify(nums)\r\n  s_result = [hq.heappop(nums) for i in range(len(nums))]\r\n  return s_result", "test_list": ["assert heap_assending([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1])==[1, 2, 3, 4, 7, 8, 9, 9, 10, 14, 18]", "assert heap_assending([25, 35, 22, 85, 14, 65, 75, 25, 58])==[14, 22, 25, 25, 35, 58, 65, 75, 85]", "assert heap_assending([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"], "context": "Write a function to sort a given list of elements in ascending order using heap queue algorithm.", "function_name": "import heapq as hq\r\ndef heap_assending(nums):", "gold_generation": "hq.heapify(nums)\r\n  s_result = [hq.heappop(nums) for i in range(len(nums))]\r\n  return s_result", "ctxs": [{"id": "20477", "text": "Function: python.library.heapq\nSnippet: heapq — Heap queue algorithm Source code: Lib/heapq.py This module provides an implementation of the heap queue algorithm, also known as the priority queue algorithm. Heaps are binary trees for which every parent node has a value less than or equal to any of its children. This implementation uses arrays for which heap[k] <= heap[2*k+1] and heap[k] <= heap[2*k+2] for all k, counting elements from zero. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that its smallest element is always the root, heap[0]. The API below differs from textbook heap algorithms in two aspects: (a) We use zero-based indexing. This makes the relationship between the index for a node and the indexes for its children slightly less obvious, but is more suitable since Python uses zero-based indexing. (b) Our pop method returns the smallest item, not the largest (called a “min heap” in textbooks; a “max heap” is more common in texts because of its suitability for in-place sorting). These two make it possible to view the heap as a regular Python list without surprises: heap[0] is the smallest item, and heap.sort() maintains the heap invariant! To create a heap, use a list initialized to [], or you can transform a populated list into a heap via function heapify(). The following functions are provided: heapq.heappush(heap, item) Push the value item onto the heap, maintaining the heap invariant. heapq.heappop(heap) Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0]. heapq.heappushpop(heap, item) Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop(). heapq.heapify(x) Transform list x into a heap, in-place, in linear time. heapq.heapreplace(heap, item) Pop and return the smallest item from the heap, and also push the new item. The heap size doesn’t change. If the heap is empty, IndexError is raised. This one step operation is more efficient than a heappop() followed by heappush() and can be more appropriate when using a fixed-size heap. The pop/push combination always returns an element from the heap and replaces it with item. The value returned may be larger than the item added. If that isn’t desired, consider using heappushpop() instead. Its push/pop combination returns the smaller of the two values, leaving the larger value on the heap. The module also offers three general purpose functions based on heaps. heapq.merge(*iterables, key=None, reverse=False) Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an iterator over the sorted values. Similar to sorted(itertools.chain(*iterables)) but returns an iterable, does not pull the data into memory all at once, and assumes that each of the input streams is already sorted (smallest to largest). Has two optional arguments which must be specified as keyword arguments. key specifies a", "score": "0.7820475"}, {"id": "20478", "text": "Function: python.library.heapq\nSnippet: key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters. heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n]. heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n]. The latter two functions perform best for smaller values of n. For larger values, it is more efficient to use the sorted() function. Also, when n==1, it is more efficient to use the built-in min() and max() functions. If repeated usage of these functions is required, consider turning the iterable into an actual heap. Basic Examples A heapsort can be implemented by pushing all values onto a heap and then popping off the smallest values one at a time: >>> def heapsort(iterable): ... h = [] ... for value in iterable: ... heappush(h, value) ... return [heappop(h) for i in range(len(h))] ... >>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] This is similar to sorted(iterable), but unlike sorted(), this implementation is not stable. Heap elements can be tuples. This is useful for assigning comparison values (such as task priorities) alongside the main record being tracked: >>> h = [] >>> heappush(h, (5, 'write code')) >>> heappush(h, (7, 'release product')) >>> heappush(h, (1, 'write spec')) >>> heappush(h, (3, 'create tests')) >>> heappop(h) (1, 'write spec') Priority Queue Implementation Notes A priority queue is common use for a heap, and it presents several implementation challenges: Sort stability: how do you get two tasks with equal priorities to be returned in the order they were originally added? Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order. If the priority of a task changes, how do you move it to a new position in the heap? Or if a pending task needs to be deleted, how do you find it and remove it from the queue? A solution to the first two challenges is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were", "score": "0.74062407"}, {"id": "20482", "text": "Function: python.library.heapq#heapq.heapify\nSnippet: heapq.heapify(x) Transform list x into a heap, in-place, in linear time.", "score": "0.72416747"}, {"id": "20479", "text": "Function: python.library.heapq\nSnippet: added. And since no two entry counts are the same, the tuple comparison will never attempt to directly compare two tasks. Another solution to the problem of non-comparable tasks is to create a wrapper class that ignores the task item and only compares the priority field: from dataclasses import dataclass, field from typing import Any @dataclass(order=True) class PrioritizedItem: priority: int item: Any=field(compare=False) The remaining challenges revolve around finding a pending task and making changes to its priority or removing it entirely. Finding a task can be done with a dictionary pointing to an entry in the queue. Removing the entry or changing its priority is more difficult because it would break the heap structure invariants. So, a possible solution is to mark the entry as removed and add a new entry with the revised priority: pq = [] # list of entries arranged in a heap entry_finder = {} # mapping of tasks to entries REMOVED = '<removed-task>' # placeholder for a removed task counter = itertools.count() # unique sequence count def add_task(task, priority=0): 'Add a new task or update the priority of an existing task' if task in entry_finder: remove_task(task) count = next(counter) entry = [priority, count, task] entry_finder[task] = entry heappush(pq, entry) def remove_task(task): 'Mark an existing task as REMOVED. Raise KeyError if not found.' entry = entry_finder.pop(task) entry[-1] = REMOVED def pop_task(): 'Remove and return the lowest priority task. Raise KeyError if empty.' while pq: priority, count, task = heappop(pq) if task is not REMOVED: del entry_finder[task] return task raise KeyError('pop from an empty priority queue') Theory Heaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for all k, counting elements from 0. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that a[0] is always its smallest element. The strange invariant above is meant to be an efficient memory representation for a tournament. The numbers below are k, not a[k]: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 In the tree above, each cell k is topping 2*k+1 and 2*k+2. In a usual binary tournament we see in sports, each cell is the winner over the two cells it tops, and we can trace the winner down the tree to see all opponents s/he had. However, in many computer applications of such tournaments, we do not need to trace the history of a winner. To be more memory efficient, when a winner is promoted, we try to replace it by something else at a lower level, and the rule becomes that a cell and the two cells it tops contain three different items, but the top cell “wins” over the two topped cells. If this heap invariant is protected at all time, index 0 is clearly the overall winner. The simplest algorithmic way to remove it and find the “next”", "score": "0.7228198"}, {"id": "20488", "text": "Function: python.library.heapq#heapq.nlargest\nSnippet: heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n].", "score": "0.7146008"}]}
{"task_id": "mbpp_373", "code": "def volume_cuboid(l,w,h):\r\n  volume=l*w*h\r\n  return volume", "test_list": ["assert volume_cuboid(1,2,3)==6", "assert volume_cuboid(5,7,9)==315", "assert volume_cuboid(10,15,21)==3150"], "context": "Write a function to find the volume of a cuboid.", "function_name": "def volume_cuboid(l,w,h):", "gold_generation": "volume=l*w*h\r\n  return volume", "ctxs": [{"id": "33487", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: barbs_doc='\\nPlot a 2D field of barbs.\\n\\nCall signature::\\n\\n barbs([X, Y], U, V, [C], **kw)\\n\\nWhere *X*, *Y* define the barb locations, *U*, *V* define the barb\\ndirections, and *C* optionally sets the color.\\n\\nAll arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked\\n*X*, *Y* are not supported at present.\\n\\nBarbs are traditionally used in meteorology as a way to plot the speed\\nand direction of wind observations, but can technically be used to\\nplot any two dimensional vector quantity. As opposed to arrows, which\\ngive vector magnitude by the length of the arrow, the barbs give more\\nquantitative information about the vector magnitude by putting slanted\\nlines or a triangle for various increments in magnitude, as show\\nschematically below::\\n\\n : /\\\\ \\\\\\n : / \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : ------------------------------\\n\\nThe largest increment is given by a triangle (or \"flag\"). After those\\ncome full lines (barbs). The smallest increment is a half line. There\\nis only, of course, ever at most 1 half line. If the magnitude is\\nsmall and only needs a single half-line and no full lines or\\ntriangles, the half-line is offset from the end of the barb so that it\\ncan be easily distinguished from barbs with a single full line. The\\nmagnitude for the barb shown above would nominally be 65, using the\\nstandard increments of 50, 10, and 5.\\n\\nSee also https://en.wikipedia.org/wiki/Wind_barb.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the barb locations. See *pivot* for how the\\n barbs are drawn to the x, y positions.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y components of the barb shaft.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If", "score": "0.634711"}, {"id": "36351", "text": "Function: django.ref.contrib.gis.functions#django.contrib.gis.db.models.functions.Length\nSnippet: class Length(expression, spheroid=True, **extra)", "score": "0.6301309"}, {"id": "5647", "text": "Function: torch.generated.torch.bucketize#torch.bucketize\nSnippet: torch.bucketize(input, boundaries, *, out_int32=False, right=False, out=None) → Tensor Returns the indices of the buckets to which each value in the input belongs, where the boundaries of the buckets are set by boundaries. Return a new tensor with the same size as input. If right is False (default), then the left boundary is closed. More formally, the returned index satisfies the following rules: right returned index satisfies False boundaries[i-1] < input[m][n]...[l][x] <= boundaries[i] True boundaries[i-1] <= input[m][n]...[l][x] < boundaries[i] Parameters input (Tensor or Scalar) – N-D tensor or a Scalar containing the search value(s). boundaries (Tensor) – 1-D tensor, must contain a monotonically increasing sequence. Keyword Arguments out_int32 (bool, optional) – indicate the output data type. torch.int32 if True, torch.int64 otherwise. Default value is False, i.e. default output data type is torch.int64. right (bool, optional) – if False, return the first suitable location that is found. If True, return the last such index. If no suitable index found, return 0 for non-numerical value (eg. nan, inf) or the size of boundaries (one pass the last index). In other words, if False, gets the lower bound index for each value in input from boundaries. If True, gets the upper bound index instead. Default value is False. out (Tensor, optional) – the output tensor, must be the same size as input if provided. Example: >>> boundaries = torch.tensor([1, 3, 5, 7, 9]) >>> boundaries tensor([1, 3, 5, 7, 9]) >>> v = torch.tensor([[3, 6, 9], [3, 6, 9]]) >>> v tensor([[3, 6, 9], [3, 6, 9]]) >>> torch.bucketize(v, boundaries) tensor([[1, 3, 4], [1, 3, 4]]) >>> torch.bucketize(v, boundaries, right=True) tensor([[2, 3, 5], [2, 3, 5]])", "score": "0.6280959"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6219613"}, {"id": "7848", "text": "Function: torch.tensors#torch.Tensor.float_power\nSnippet: float_power(exponent) → Tensor See torch.float_power()", "score": "0.6215281"}]}
{"task_id": "mbpp_374", "code": "def permute_string(str):\r\n    if len(str) == 0:\r\n        return ['']\r\n    prev_list = permute_string(str[1:len(str)])\r\n    next_list = []\r\n    for i in range(0,len(prev_list)):\r\n        for j in range(0,len(str)):\r\n            new_str = prev_list[i][0:j]+str[0]+prev_list[i][j:len(str)-1]\r\n            if new_str not in next_list:\r\n                next_list.append(new_str)\r\n    return next_list", "test_list": ["assert permute_string('ab')==['ab', 'ba']", "assert permute_string('abc')==['abc', 'bac', 'bca', 'acb', 'cab', 'cba']", "assert permute_string('abcd')==['abcd', 'bacd', 'bcad', 'bcda', 'acbd', 'cabd', 'cbad', 'cbda', 'acdb', 'cadb', 'cdab', 'cdba', 'abdc', 'badc', 'bdac', 'bdca', 'adbc', 'dabc', 'dbac', 'dbca', 'adcb', 'dacb', 'dcab', 'dcba']"], "context": "Write a function to print all permutations of a given string including duplicates.", "function_name": "def permute_string(str):", "gold_generation": "if len(str) == 0:\r\n        return ['']\r\n    prev_list = permute_string(str[1:len(str)])\r\n    next_list = []\r\n    for i in range(0,len(prev_list)):\r\n        for j in range(0,len(str)):\r\n            new_str = prev_list[i][0:j]+str[0]+prev_list[i][j:len(str)-1]\r\n            if new_str not in next_list:\r\n                next_list.append(new_str)\r\n    return next_list", "ctxs": [{"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.7544139"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.75279903"}, {"id": "21302", "text": "Function: python.library.itertools#itertools.combinations_with_replacement\nSnippet: itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1.", "score": "0.69921637"}, {"id": "21301", "text": "Function: python.library.itertools#itertools.combinations\nSnippet: itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6923539"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.689949"}]}
{"task_id": "mbpp_375", "code": "def round_num(n,m):\r\n    a = (n //m) * m\r\n    b = a + m\r\n    return (b if n - a > b - n else a)", "test_list": ["assert round_num(4722,10)==4720", "assert round_num(1111,5)==1110", "assert round_num(219,2)==218"], "context": "Write a function to round the given number to the nearest multiple of a specific number.", "function_name": "def round_num(n,m):", "gold_generation": "a = (n //m) * m\r\n    b = a + m\r\n    return (b if n - a > b - n else a)", "ctxs": [{"id": "19597", "text": "Function: python.library.decimal#decimal.ROUND_HALF_EVEN\nSnippet: decimal.ROUND_HALF_EVEN Round to nearest with ties going to nearest even integer.", "score": "0.7456065"}, {"id": "20212", "text": "Function: python.library.fractions#fractions.Fraction.__round__\nSnippet: __round__() __round__(ndigits) The first version returns the nearest int to self, rounding half to even. The second version rounds self to the nearest multiple of Fraction(1, 10**ndigits) (logically, if ndigits is negative), again rounding half toward even. This method can also be accessed through the round() function.", "score": "0.744752"}, {"id": "19598", "text": "Function: python.library.decimal#decimal.ROUND_HALF_UP\nSnippet: decimal.ROUND_HALF_UP Round to nearest with ties going away from zero.", "score": "0.7326932"}, {"id": "19596", "text": "Function: python.library.decimal#decimal.ROUND_HALF_DOWN\nSnippet: decimal.ROUND_HALF_DOWN Round to nearest with ties going towards zero.", "score": "0.7274252"}, {"id": "23466", "text": "Function: python.library.functions#round\nSnippet: round(number[, ndigits]) Return number rounded to ndigits precision after the decimal point. If ndigits is omitted or is None, it returns the nearest integer to its input. For the built-in types supporting round(), values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice (so, for example, both round(0.5) and round(-0.5) are 0, and round(1.5) is 2). Any integer value is valid for ndigits (positive, zero, or negative). The return value is an integer if ndigits is omitted or None. Otherwise the return value has the same type as number. For a general Python object number, round delegates to number.__round__. Note The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a bug: it’s a result of the fact that most decimal fractions can’t be represented exactly as a float. See Floating Point Arithmetic: Issues and Limitations for more information.", "score": "0.7167197"}]}
{"task_id": "mbpp_376", "code": "def remove_replica(test_tup):\r\n  temp = set()\r\n  res = tuple(ele if ele not in temp and not temp.add(ele) \r\n\t\t\t\telse 'MSP' for ele in test_tup)\r\n  return (res)", "test_list": ["assert remove_replica((1, 1, 4, 4, 4, 5, 5, 6, 7, 7)) == (1, 'MSP', 4, 'MSP', 'MSP', 5, 'MSP', 6, 7, 'MSP')", "assert remove_replica((2, 3, 4, 4, 5, 6, 6, 7, 8, 9, 9)) == (2, 3, 4, 'MSP', 5, 6, 'MSP', 7, 8, 9, 'MSP')", "assert remove_replica((2, 2, 5, 4, 5, 7, 5, 6, 7, 7)) == (2, 'MSP', 5, 4, 'MSP', 7, 'MSP', 6, 'MSP', 'MSP')"], "context": "Write a function to remove tuple elements that occur more than once and replace the duplicates with some custom value.", "function_name": "def remove_replica(test_tup):", "gold_generation": "temp = set()\r\n  res = tuple(ele if ele not in temp and not temp.add(ele) \r\n\t\t\t\telse 'MSP' for ele in test_tup)\r\n  return (res)", "ctxs": [{"id": "18685", "text": "Function: python.library.collections#collections.somenamedtuple._replace\nSnippet: somenamedtuple._replace(**kwargs) Return a new instance of the named tuple replacing specified fields with new values: >>> p = Point(x=11, y=22) >>> p._replace(x=33) Point(x=33, y=22) >>> for partnum, record in inventory.items(): ... inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now())", "score": "0.71598285"}, {"id": "18674", "text": "Function: python.library.collections#collections.deque.remove\nSnippet: remove(value) Remove the first occurrence of value. If not found, raises a ValueError.", "score": "0.7108729"}, {"id": "21302", "text": "Function: python.library.itertools#itertools.combinations_with_replacement\nSnippet: itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1.", "score": "0.70687693"}, {"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.69813573"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6891179"}]}
{"task_id": "mbpp_377", "code": "def remove_Char(s,c) :  \r\n    counts = s.count(c) \r\n    s = list(s) \r\n    while counts :  \r\n        s.remove(c) \r\n        counts -= 1 \r\n    s = '' . join(s)   \r\n    return (s) ", "test_list": ["assert remove_Char(\"aba\",'a') == \"b\"", "assert remove_Char(\"toggle\",'g') == \"tole\"", "assert remove_Char(\"aabbc\",'b') == \"aac\""], "context": "Write a python function to remove all occurrences of a character in a given string.", "function_name": "def remove_Char(s,c) :", "gold_generation": "counts = s.count(c) \r\n    s = list(s) \r\n    while counts :  \r\n        s.remove(c) \r\n        counts -= 1 \r\n    s = '' . join(s)   \r\n    return (s)", "ctxs": [{"id": "41683", "text": "Function: numpy.reference.generated.numpy.char.chararray.replace\nSnippet: numpy.char.chararray.replace method char.chararray.replace(old, new, count=None)[source] For each element in self, return a copy of the string with all occurrences of substring old replaced by new. See also char.replace", "score": "0.7048081"}, {"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.70272136"}, {"id": "41747", "text": "Function: numpy.reference.generated.numpy.char.replace\nSnippet: numpy.char.replace char.replace(a, old, new, count=None)[source] For each element in a, return a copy of the string with all occurrences of substring old replaced by new. Calls str.replace element-wise. Parameters aarray-like of str or unicode old, newstr or unicode countint, optional If the optional argument count is given, only the first count occurrences are replaced. Returns outndarray Output array of str or unicode, depending on input type See also str.replace", "score": "0.7025661"}, {"id": "41805", "text": "Function: numpy.reference.generated.numpy.chararray.replace\nSnippet: numpy.chararray.replace method chararray.replace(old, new, count=None)[source] For each element in self, return a copy of the string with all occurrences of substring old replaced by new. See also char.replace", "score": "0.7021338"}, {"id": "24376", "text": "Function: python.library.stdtypes#str.rstrip\nSnippet: str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty'", "score": "0.69709337"}]}
{"task_id": "mbpp_378", "code": "def move_first(test_list):\r\n  test_list = test_list[-1:] + test_list[:-1]  \r\n  return test_list", "test_list": ["assert move_first([1,2,3,4]) == [4,1,2,3]", "assert move_first([0,1,2,3]) == [3,0,1,2]", "assert move_first([9,8,7,1]) == [1,9,8,7]"], "context": "Write a python function to shift last element to first position in the given list.", "function_name": "def move_first(test_list):", "gold_generation": "test_list = test_list[-1:] + test_list[:-1]  \r\n  return test_list", "ctxs": [{"id": "22336", "text": "Function: python.library.operator#operator.lshift\nSnippet: operator.lshift(a, b) operator.__lshift__(a, b) Return a shifted left by b.", "score": "0.71899295"}, {"id": "18679", "text": "Function: python.library.collections#collections.OrderedDict.move_to_end\nSnippet: move_to_end(key, last=True) Move an existing key to either end of an ordered dictionary. The item is moved to the right end if last is true (the default) or to the beginning if last is false. Raises KeyError if the key does not exist: >>> d = OrderedDict.fromkeys('abcde') >>> d.move_to_end('b') >>> ''.join(d.keys()) 'acdeb' >>> d.move_to_end('b', last=False) >>> ''.join(d.keys()) 'bacde' New in version 3.2.", "score": "0.716073"}, {"id": "22383", "text": "Function: python.library.operator#operator.__lshift__\nSnippet: operator.lshift(a, b) operator.__lshift__(a, b) Return a shifted left by b.", "score": "0.7118825"}, {"id": "43158", "text": "Function: numpy.reference.generated.numpy.right_shift\nSnippet: numpy.right_shift numpy.right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'right_shift'> Shift the bits of an integer to the right. Bits are shifted to the right x2. Because the internal representation of numbers is in binary format, this operation is equivalent to dividing x1 by 2**x2. Parameters x1array_like, int Input values. x2array_like, int Number of bits to remove at the right of x1. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray, int Return x1 with bits shifted x2 times to the right. This is a scalar if both x1 and x2 are scalars. See also left_shift Shift the bits of an integer to the left. binary_repr Return the binary representation of the input number as a string. Examples >>> np.binary_repr(10) '1010' >>> np.right_shift(10, 1) 5 >>> np.binary_repr(5) '101' >>> np.right_shift(10, [1,2,3]) array([5, 2, 1]) The >> operator can be used as a shorthand for np.right_shift on ndarrays. >>> x1 = 10 >>> x2 = np.array([1,2,3]) >>> x1 >> x2 array([5, 2, 1])", "score": "0.70272595"}, {"id": "42935", "text": "Function: numpy.reference.generated.numpy.left_shift\nSnippet: numpy.left_shift numpy.left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'left_shift'> Shift the bits of an integer to the left. Bits are shifted to the left by appending x2 0s at the right of x1. Since the internal representation of numbers is in binary format, this operation is equivalent to multiplying x1 by 2**x2. Parameters x1array_like of integer type Input values. x2array_like of integer type Number of zeros to append to x1. Has to be non-negative. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outarray of integer type Return x1 with bits shifted x2 times to the left. This is a scalar if both x1 and x2 are scalars. See also right_shift Shift the bits of an integer to the right. binary_repr Return the binary representation of the input number as a string. Examples >>> np.binary_repr(5) '101' >>> np.left_shift(5, 2) 20 >>> np.binary_repr(20) '10100' >>> np.left_shift(5, [1,2,3]) array([10, 20, 40]) Note that the dtype of the second argument may change the dtype of the result and can lead to unexpected results in some cases (see Casting Rules): >>> a = np.left_shift(np.uint8(255), 1) # Expect 254 >>> print(a, type(a)) # Unexpected result due to upcasting 510 <class 'numpy.int64'> >>> b = np.left_shift(np.uint8(255), np.uint8(1)) >>> print(b, type(b)) 254 <class 'numpy.uint8'> The << operator can be used as a shorthand for np.left_shift on ndarrays. >>> x1 = 5 >>> x2 = np.array([1, 2, 3]) >>> x1 << x2 array([10, 20, 40])", "score": "0.69130826"}]}
{"task_id": "mbpp_379", "code": "def surfacearea_cuboid(l,w,h):\r\n  SA = 2*(l*w + l * h + w * h)\r\n  return SA", "test_list": ["assert surfacearea_cuboid(1,2,3)==22", "assert surfacearea_cuboid(5,7,9)==286", "assert surfacearea_cuboid(10,15,21)==1350"], "context": "Write a function to find the surface area of a cuboid.", "function_name": "def surfacearea_cuboid(l,w,h):", "gold_generation": "SA = 2*(l*w + l * h + w * h)\r\n  return SA", "ctxs": [{"id": "17024", "text": "Function: skimage.api.skimage.measure#skimage.measure.mesh_surface_area\nSnippet: skimage.measure.mesh_surface_area(verts, faces) [source] Compute surface area, given vertices & triangular faces Parameters verts(V, 3) array of floats Array containing (x, y, z) coordinates for V unique mesh vertices. faces(F, 3) array of ints List of length-3 lists of integers, referencing vertex coordinates as provided in verts Returns areafloat Surface area of mesh. Units now [coordinate units] ** 2. See also skimage.measure.marching_cubes skimage.measure.marching_cubes_classic Notes The arguments expected by this function are the first two outputs from skimage.measure.marching_cubes. For unit correct output, ensure correct spacing was passed to skimage.measure.marching_cubes. This algorithm works properly only if the faces provided are all triangles.", "score": "0.65702164"}, {"id": "33487", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: barbs_doc='\\nPlot a 2D field of barbs.\\n\\nCall signature::\\n\\n barbs([X, Y], U, V, [C], **kw)\\n\\nWhere *X*, *Y* define the barb locations, *U*, *V* define the barb\\ndirections, and *C* optionally sets the color.\\n\\nAll arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked\\n*X*, *Y* are not supported at present.\\n\\nBarbs are traditionally used in meteorology as a way to plot the speed\\nand direction of wind observations, but can technically be used to\\nplot any two dimensional vector quantity. As opposed to arrows, which\\ngive vector magnitude by the length of the arrow, the barbs give more\\nquantitative information about the vector magnitude by putting slanted\\nlines or a triangle for various increments in magnitude, as show\\nschematically below::\\n\\n : /\\\\ \\\\\\n : / \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : ------------------------------\\n\\nThe largest increment is given by a triangle (or \"flag\"). After those\\ncome full lines (barbs). The smallest increment is a half line. There\\nis only, of course, ever at most 1 half line. If the magnitude is\\nsmall and only needs a single half-line and no full lines or\\ntriangles, the half-line is offset from the end of the barb so that it\\ncan be easily distinguished from barbs with a single full line. The\\nmagnitude for the barb shown above would nominally be 65, using the\\nstandard increments of 50, 10, and 5.\\n\\nSee also https://en.wikipedia.org/wiki/Wind_barb.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the barb locations. See *pivot* for how the\\n barbs are drawn to the x, y positions.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y components of the barb shaft.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If", "score": "0.64546585"}, {"id": "13179", "text": "Function: pygame.ref.draw\nSnippet: the given surface. The line has a thickness of one pixel and the endpoints have a height and width of one pixel each. The way a line and it's endpoints are drawn: If both endpoints are equal, only a single pixel is drawn (after rounding floats to nearest integer). Otherwise if the line is not steep (i.e. if the length along the x-axis is greater than the height along the y-axis): For each endpoint: If x, the endpoint's x-coordinate, is a whole number find which pixels would be covered by it and draw them. Otherwise: Calculate the position of the nearest point with a whole number for it's x-coordinate, when extending the line past the endpoint. Find which pixels would be covered and how much by that point. If the endpoint is the left one, multiply the coverage by (1 - the decimal part of x). Otherwise multiply the coverage by the decimal part of x. Then draw those pixels. e.g.: The left endpoint of the line ((1, 1.3), (5, 3)) would cover 70% of the pixel (1, 1) and 30% of the pixel (1, 2) while the right one would cover 100% of the pixel (5, 3). The left endpoint of the line ((1.2, 1.4), (4.6, 3.1)) would cover 56% (i.e. 0.8 * 70%) of the pixel (1, 1) and 24% (i.e. 0.8 * 30%) of the pixel (1, 2) while the right one would cover 42% (i.e. 0.6 * 70%) of the pixel (5, 3) and 18% (i.e. 0.6 * 30%) of the pixel (5, 4) while the right Then for each point between the endpoints, along the line, whose x-coordinate is a whole number: Find which pixels would be covered and how much by that point and draw them. e.g.: The points along the line ((1, 1), (4, 2.5)) would be (2, 1.5) and (3, 2) and would cover 50% of the pixel (2, 1), 50% of the pixel (2, 2) and 100% of the pixel (3, 2). The points along the line ((1.2, 1.4), (4.6, 3.1)) would be (2, 1.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)), (3, 2.3) (covering 70% of the pixel (3, 2) and 30% of the pixel (3, 3)) and (4, 2.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)) Otherwise do the same for steep lines as for non-steep lines except along the y-axis instead of the x-axis (using y instead of x, top instead of left and bottom instead of right). Note Regarding float values for coordinates, a point with coordinate consisting of two whole numbers is considered being right in the center of said pixel (and having a height and width of 1 pixel would therefore completely cover it), while a point with coordinate where one (or both) of the numbers have non-zero decimal parts would be partially covering two (or four if both numbers have decimal parts) adjacent pixels, e.g. the point (1.4, 2) covers", "score": "0.63724357"}, {"id": "16631", "text": "Function: skimage.api.skimage.draw\nSnippet: ellipsoid_stats skimage.draw.ellipsoid_stats(a, b, c) [source] Calculates analytical surface area and volume for ellipsoid with semimajor axes aligned with grid dimensions of specified spacing. Parameters afloat Length of semimajor axis aligned with x-axis. bfloat Length of semimajor axis aligned with y-axis. cfloat Length of semimajor axis aligned with z-axis. Returns volfloat Calculated volume of ellipsoid. surffloat Calculated surface area of ellipsoid. line skimage.draw.line(r0, c0, r1, c1) [source] Generate line pixel coordinates. Parameters r0, c0int Starting position (row, column). r1, c1int End position (row, column). Returns rr, cc(N,) ndarray of int Indices of pixels that belong to the line. May be used to directly index into an array, e.g. img[rr, cc] = 1. Notes Anti-aliased line generator is available with line_aa. Examples >>> from skimage.draw import line >>> img = np.zeros((10, 10), dtype=np.uint8) >>> rr, cc = line(1, 1, 8, 8) >>> img[rr, cc] = 1 >>> img array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8) line_aa skimage.draw.line_aa(r0, c0, r1, c1) [source] Generate anti-aliased line pixel coordinates. Parameters r0, c0int Starting position (row, column). r1, c1int End position (row, column). Returns rr, cc, val(N,) ndarray (int, int, float) Indices of pixels (rr, cc) and intensity values (val). img[rr, cc] = val. References 1 A Rasterizing Algorithm for Drawing Curves, A. Zingl, 2012 http://members.chello.at/easyfilter/Bresenham.pdf Examples >>> from skimage.draw import line_aa >>> img = np.zeros((10, 10), dtype=np.uint8) >>> rr, cc, val = line_aa(1, 1, 8, 8) >>> img[rr, cc] = val * 255 >>> img array([[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [ 0, 255, 74, 0, 0, 0, 0, 0, 0, 0], [ 0, 74, 255, 74, 0, 0, 0, 0, 0, 0], [ 0, 0, 74, 255, 74, 0, 0, 0, 0, 0], [ 0, 0, 0, 74, 255, 74, 0, 0, 0, 0], [ 0, 0, 0, 0, 74, 255, 74, 0, 0, 0], [ 0, 0, 0, 0, 0, 74, 255, 74, 0, 0], [ 0, 0, 0, 0, 0, 0, 74, 255, 74, 0], [ 0, 0, 0, 0, 0, 0, 0, 74, 255, 0], [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8) line_nd skimage.draw.line_nd(start, stop, *, endpoint=False, integer=True) [source] Draw a single-pixel thick line in n dimensions. The line produced will be ndim-connected. That is, two subsequent pixels in the line will be either direct or diagonal neighbours in n dimensions. Parameters startarray-like, shape (N,) The start coordinates of the line. stoparray-like, shape (N,) The end coordinates", "score": "0.62878066"}, {"id": "42657", "text": "Function: numpy.reference.generated.numpy.average\nSnippet: >>> avg = np.average(a, weights=w) >>> print(avg.dtype) complex256", "score": "0.62583965"}]}
{"task_id": "mbpp_380", "code": "def multi_list(rownum,colnum):\r\n  multi_list = [[0 for col in range(colnum)] for row in range(rownum)]\r\n  for row in range(rownum):\r\n    for col in range(colnum):\r\n        multi_list[row][col]= row*col\r\n  return multi_list\r\n", "test_list": ["assert multi_list(3,4)==[[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]] ", "assert multi_list(5,7)==[[0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6], [0, 2, 4, 6, 8, 10, 12], [0, 3, 6, 9, 12, 15, 18], [0, 4, 8, 12, 16, 20, 24]]", "assert multi_list(10,15)==[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28], [0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42], [0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56], [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70], [0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84], [0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98], [0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112], [0, 9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99, 108, 117, 126]]"], "context": "Write a function to generate a two-dimensional array.", "function_name": "def multi_list(rownum,colnum):", "gold_generation": "multi_list = [[0 for col in range(colnum)] for row in range(rownum)]\r\n  for row in range(rownum):\r\n    for col in range(colnum):\r\n        multi_list[row][col]= row*col\r\n  return multi_list", "ctxs": [{"id": "43079", "text": "Function: numpy.reference.generated.numpy.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.72654414"}, {"id": "42637", "text": "Function: numpy.reference.generated.numpy.array\nSnippet: than one dimension: >>> np.array([[1, 2], [3, 4]]) array([[1, 2], [3, 4]]) Minimum dimensions 2: >>> np.array([1, 2, 3], ndmin=2) array([[1, 2, 3]]) Type provided: >>> np.array([1, 2, 3], dtype=complex) array([ 1.+0.j, 2.+0.j, 3.+0.j]) Data-type consisting of more than one element: >>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')]) >>> x['a'] array([1, 3]) Creating an array from sub-classes: >>> np.array(np.mat('1 2; 3 4')) array([[1, 2], [3, 4]]) >>> np.array(np.mat('1 2; 3 4'), subok=True) matrix([[1, 2], [3, 4]])", "score": "0.69903445"}, {"id": "42742", "text": "Function: numpy.reference.generated.numpy.diagflat\nSnippet: numpy.diagflat numpy.diagflat(v, k=0)[source] Create a two-dimensional array with the flattened input as a diagonal. Parameters varray_like Input data, which is flattened and set as the k-th diagonal of the output. kint, optional Diagonal to set; 0, the default, corresponds to the “main” diagonal, a positive (negative) k giving the number of the diagonal above (below) the main. Returns outndarray The 2-D output array. See also diag MATLAB work-alike for 1-D and 2-D arrays. diagonal Return specified diagonals. trace Sum along diagonals. Examples >>> np.diagflat([[1,2], [3,4]]) array([[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]) >>> np.diagflat([1,2], 1) array([[0, 1, 0], [0, 0, 2], [0, 0, 0]])", "score": "0.6972207"}, {"id": "43150", "text": "Function: numpy.reference.generated.numpy.record\nSnippet: identical to the corresponding array attribute. tofile Scalar method identical to the corresponding array attribute. tolist Scalar method identical to the corresponding array attribute. tostring Scalar method identical to the corresponding array attribute. trace Scalar method identical to the corresponding array attribute. transpose Scalar method identical to the corresponding array attribute. var Scalar method identical to the corresponding array attribute. view Scalar method identical to the corresponding array attribute. conj tobytes", "score": "0.69529307"}, {"id": "41966", "text": "Function: numpy.reference.generated.numpy.fft.fft2\nSnippet: +0.j ]])", "score": "0.6924355"}]}
{"task_id": "mbpp_381", "code": "from operator import itemgetter\r\ndef index_on_inner_list(list_data, index_no):\r\n    result = sorted(list_data, key=itemgetter(index_no))\r\n    return result", "test_list": ["assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==[('Beau Turnbull', 94, 98), ('Brady Kent', 97, 96), ('Greyson Fulton', 98, 99), ('Wyatt Knott', 91, 94)]", "assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,1)==[('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98), ('Brady Kent', 97, 96), ('Greyson Fulton', 98, 99)]", "assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,2)==[('Wyatt Knott', 91, 94), ('Brady Kent', 97, 96), ('Beau Turnbull', 94, 98), ('Greyson Fulton', 98, 99)]"], "context": "Write a function to sort a list of lists by a given index of the inner list.", "function_name": "from operator import itemgetter\r\ndef index_on_inner_list(list_data, index_no):", "gold_generation": "result = sorted(list_data, key=itemgetter(index_no))\r\n    return result", "ctxs": [{"id": "15305", "text": "Function: pandas.reference.api.pandas.series.sort_index\nSnippet: s = pd.Series([1, 2, 3, 4], index=['A', 'b', 'C', 'd']) >>> s.sort_index(key=lambda x : x.str.lower()) A 1 b 2 C 3 d 4 dtype: int64", "score": "0.71782845"}, {"id": "42504", "text": "Function: numpy.reference.generated.numpy.ndarray.argsort\nSnippet: numpy.ndarray.argsort method ndarray.argsort(axis=- 1, kind=None, order=None) Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.69916683"}, {"id": "14754", "text": "Function: pandas.reference.api.pandas.index.sort\nSnippet: pandas.Index.sort finalIndex.sort(*args, **kwargs)[source] Use sort_values instead.", "score": "0.6975366"}, {"id": "43832", "text": "Function: numpy.reference.generated.numpy.recarray.argsort\nSnippet: numpy.recarray.argsort method recarray.argsort(axis=- 1, kind=None, order=None) Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.6960553"}, {"id": "42377", "text": "Function: numpy.reference.generated.numpy.matrix.argsort\nSnippet: numpy.matrix.argsort method matrix.argsort(axis=- 1, kind=None, order=None) Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.69580483"}]}
{"task_id": "mbpp_382", "code": "def find_rotation_count(A):\r\n    (left, right) = (0, len(A) - 1)\r\n    while left <= right:\r\n        if A[left] <= A[right]:\r\n            return left\r\n        mid = (left + right) // 2\r\n        next = (mid + 1) % len(A)\r\n        prev = (mid - 1 + len(A)) % len(A)\r\n        if A[mid] <= A[next] and A[mid] <= A[prev]:\r\n            return mid\r\n        elif A[mid] <= A[right]:\r\n            right = mid - 1\r\n        elif A[mid] >= A[left]:\r\n            left = mid + 1\r\n    return -1", "test_list": ["assert find_rotation_count([8, 9, 10, 1, 2, 3, 4, 5, 6, 7]) == 3", "assert find_rotation_count([8, 9, 10,2, 5, 6]) == 3", "assert find_rotation_count([2, 5, 6, 8, 9, 10]) == 0"], "context": "Write a function to find the number of rotations in a circularly sorted array.", "function_name": "def find_rotation_count(A):", "gold_generation": "(left, right) = (0, len(A) - 1)\r\n    while left <= right:\r\n        if A[left] <= A[right]:\r\n            return left\r\n        mid = (left + right) // 2\r\n        next = (mid + 1) % len(A)\r\n        prev = (mid - 1 + len(A)) % len(A)\r\n        if A[mid] <= A[next] and A[mid] <= A[prev]:\r\n            return mid\r\n        elif A[mid] <= A[right]:\r\n            right = mid - 1\r\n        elif A[mid] >= A[left]:\r\n            left = mid + 1\r\n    return -1", "ctxs": [{"id": "42831", "text": "Function: numpy.reference.generated.numpy.fliplr\nSnippet: numpy.fliplr numpy.fliplr(m)[source] Reverse the order of elements along axis 1 (left/right). For a 2-D array, this flips the entries in each row in the left/right direction. Columns are preserved, but appear in a different order than before. Parameters marray_like Input array, must be at least 2-D. Returns fndarray A view of m with the columns reversed. Since a view is returned, this operation is \\(\\mathcal O(1)\\). See also flipud Flip array in the up/down direction. flip Flip array in one or more dimensions. rot90 Rotate array counterclockwise. Notes Equivalent to m[:,::-1] or np.flip(m, axis=1). Requires the array to be at least 2-D. Examples >>> A = np.diag([1.,2.,3.]) >>> A array([[1., 0., 0.], [0., 2., 0.], [0., 0., 3.]]) >>> np.fliplr(A) array([[0., 0., 1.], [0., 2., 0.], [3., 0., 0.]]) >>> A = np.random.randn(2,3,5) >>> np.all(np.fliplr(A) == A[:,::-1,...]) True", "score": "0.69966334"}, {"id": "30892", "text": "Function: matplotlib.collections_api#matplotlib.collections.RegularPolyCollection.get_rotation\nSnippet: get_rotation()[source]", "score": "0.69668746"}, {"id": "18676", "text": "Function: python.library.collections#collections.deque.rotate\nSnippet: rotate(n=1) Rotate the deque n steps to the right. If n is negative, rotate to the left. When the deque is not empty, rotating one step to the right is equivalent to d.appendleft(d.pop()), and rotating one step to the left is equivalent to d.append(d.popleft()).", "score": "0.69602716"}, {"id": "29392", "text": "Function: matplotlib.collections_api#matplotlib.collections.AsteriskPolygonCollection.get_rotation\nSnippet: get_rotation()[source]", "score": "0.6913017"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.69034785"}]}
{"task_id": "mbpp_383", "code": "def even_bit_toggle_number(n) : \r\n    res = 0; count = 0; temp = n    \r\n    while(temp > 0 ) : \r\n        if (count % 2 == 0) : \r\n            res = res | (1 << count)      \r\n        count = count + 1\r\n        temp >>= 1 \r\n    return n ^ res ", "test_list": ["assert even_bit_toggle_number(10) == 15", "assert even_bit_toggle_number(20) == 1", "assert even_bit_toggle_number(30) == 11"], "context": "Write a python function to toggle all odd bits of a given number.", "function_name": "def even_bit_toggle_number(n) :", "gold_generation": "res = 0; count = 0; temp = n    \r\n    while(temp > 0 ) : \r\n        if (count % 2 == 0) : \r\n            res = res | (1 << count)      \r\n        count = count + 1\r\n        temp >>= 1 \r\n    return n ^ res", "ctxs": [{"id": "7760", "text": "Function: torch.tensors#torch.Tensor.bitwise_xor_\nSnippet: bitwise_xor_() → Tensor In-place version of bitwise_xor()", "score": "0.6998855"}, {"id": "19487", "text": "Function: python.library.decimal#decimal.Context.logical_invert\nSnippet: logical_invert(x) Invert all the digits in x.", "score": "0.69797605"}, {"id": "7758", "text": "Function: torch.tensors#torch.Tensor.bitwise_or_\nSnippet: bitwise_or_() → Tensor In-place version of bitwise_or()", "score": "0.69472754"}, {"id": "7759", "text": "Function: torch.tensors#torch.Tensor.bitwise_xor\nSnippet: bitwise_xor() → Tensor See torch.bitwise_xor()", "score": "0.6876509"}, {"id": "7757", "text": "Function: torch.tensors#torch.Tensor.bitwise_or\nSnippet: bitwise_or() → Tensor See torch.bitwise_or()", "score": "0.6875683"}]}
{"task_id": "mbpp_384", "code": "def frequency_Of_Smallest(n,arr): \r\n    mn = arr[0] \r\n    freq = 1\r\n    for i in range(1,n): \r\n        if (arr[i] < mn): \r\n            mn = arr[i] \r\n            freq = 1\r\n        elif (arr[i] == mn): \r\n            freq += 1\r\n    return freq ", "test_list": ["assert frequency_Of_Smallest(5,[1,2,3,4,3]) == 1", "assert frequency_Of_Smallest(7,[3,1,2,5,6,2,3]) == 1", "assert frequency_Of_Smallest(7,[3,3,6,3,7,4,9]) == 3"], "context": "Write a python function to find the frequency of the smallest value in a given array.", "function_name": "def frequency_Of_Smallest(n,arr):", "gold_generation": "mn = arr[0] \r\n    freq = 1\r\n    for i in range(1,n): \r\n        if (arr[i] < mn): \r\n            mn = arr[i] \r\n            freq = 1\r\n        elif (arr[i] == mn): \r\n            freq += 1\r\n    return freq", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.74114513"}, {"id": "13013", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos#sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.7094341"}, {"id": "12778", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.7022551"}, {"id": "43859", "text": "Function: numpy.reference.generated.numpy.recarray.min\nSnippet: numpy.recarray.min method recarray.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the minimum along a given axis. Refer to numpy.amin for full documentation. See also numpy.amin equivalent function", "score": "0.69298685"}, {"id": "14927", "text": "Function: pandas.reference.api.pandas.period.freq\nSnippet: pandas.Period.freq Period.freq", "score": "0.6923239"}]}
{"task_id": "mbpp_385", "code": "def get_perrin(n):\r\n  if (n == 0):\r\n    return 3\r\n  if (n == 1):\r\n    return 0\r\n  if (n == 2):\r\n    return 2 \r\n  return get_perrin(n - 2) + get_perrin(n - 3)", "test_list": ["assert get_perrin(9) == 12", "assert get_perrin(4) == 2", "assert get_perrin(6) == 5"], "context": "Write a function to find the n'th perrin number using recursion.", "function_name": "def get_perrin(n):", "gold_generation": "if (n == 0):\r\n    return 3\r\n  if (n == 1):\r\n    return 0\r\n  if (n == 2):\r\n    return 2 \r\n  return get_perrin(n - 2) + get_perrin(n - 3)", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6569663"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6384162"}, {"id": "21296", "text": "Function: python.library.itertools\nSnippet: D E B F C\" # Recipe credited to George Sakkis num_active = len(iterables) nexts = cycle(iter(it).__next__ for it in iterables) while num_active: try: for next in nexts: yield next() except StopIteration: # Remove the iterator we just exhausted from the cycle. num_active -= 1 nexts = cycle(islice(nexts, num_active)) def partition(pred, iterable): \"Use a predicate to partition entries into false entries and true entries\" # partition(is_odd, range(10)) --> 0 2 4 6 8 and 1 3 5 7 9 t1, t2 = tee(iterable) return filterfalse(pred, t1), filter(pred, t2) def powerset(iterable): \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\" s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s)+1)) def unique_everseen(iterable, key=None): \"List unique elements, preserving order. Remember all elements ever seen.\" # unique_everseen('AAAABBBCCDAABBB') --> A B C D # unique_everseen('ABBCcAD', str.lower) --> A B C D seen = set() seen_add = seen.add if key is None: for element in filterfalse(seen.__contains__, iterable): seen_add(element) yield element else: for element in iterable: k = key(element) if k not in seen: seen_add(k) yield element def unique_justseen(iterable, key=None): \"List unique elements, preserving order. Remember only the element just seen.\" # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B # unique_justseen('ABBCcAD', str.lower) --> A B C A D return map(next, map(operator.itemgetter(1), groupby(iterable, key))) def iter_except(func, exception, first=None): \"\"\" Call a function repeatedly until an exception is raised. Converts a call-until-exception interface to an iterator interface. Like builtins.iter(func, sentinel) but uses an exception instead of a sentinel to end the loop. Examples: iter_except(functools.partial(heappop, h), IndexError) # priority queue iterator iter_except(d.popitem, KeyError) # non-blocking dict iterator iter_except(d.popleft, IndexError) # non-blocking deque iterator iter_except(q.get_nowait, Queue.Empty) # loop over a producer Queue iter_except(s.pop, KeyError) # non-blocking set iterator \"\"\" try: if first is not None: yield first() # For database APIs needing an initial cast to db.first() while True: yield func() except exception: pass def first_true(iterable, default=False, pred=None): \"\"\"Returns the first true value in the iterable. If no true value is found, returns *default* If *pred* is not None, returns the first item for which pred(item) is true. \"\"\" # first_true([a,b,c], x) --> a or b or c or x # first_true([a,b], x, f) --> a if f(a) else b if f(b) else x return next(filter(pred, iterable), default) def random_product(*args, repeat=1): \"Random selection from itertools.product(*args, **kwds)\" pools = [tuple(pool) for pool in args] * repeat return tuple(map(random.choice, pools)) def random_permutation(iterable, r=None): \"Random selection from itertools.permutations(iterable, r)\" pool = tuple(iterable) r = len(pool) if r is None else r return tuple(random.sample(pool, r)) def random_combination(iterable, r): \"Random selection from itertools.combinations(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.sample(range(n), r)) return tuple(pool[i] for i in indices) def random_combination_with_replacement(iterable, r): \"Random selection from itertools.combinations_with_replacement(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.choices(range(n), k=r)) return tuple(pool[i] for i in indices) def nth_combination(iterable, r, index): \"Equivalent to list(combinations(iterable, r))[index]\" pool = tuple(iterable) n = len(pool) if r < 0 or r > n: raise ValueError c = 1 k = min(r, n-r) for i in range(1, k+1): c = c", "score": "0.6341976"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.63380945"}, {"id": "22281", "text": "Function: python.library.numbers#numbers.Rational.numerator\nSnippet: numerator Abstract.", "score": "0.6330965"}]}
{"task_id": "mbpp_386", "code": "def swap_count(s):\r\n\tchars = s\r\n\tcount_left = 0\r\n\tcount_right = 0\r\n\tswap = 0\r\n\timbalance = 0; \r\n\tfor i in range(len(chars)):\r\n\t\tif chars[i] == '[':\r\n\t\t\tcount_left += 1\r\n\t\t\tif imbalance > 0:\r\n\t\t\t\tswap += imbalance\r\n\t\t\t\timbalance -= 1\r\n\t\telif chars[i] == ']':\r\n\t\t\tcount_right += 1\r\n\t\t\timbalance = (count_right - count_left) \r\n\treturn swap", "test_list": ["assert swap_count(\"[]][][\") == 2", "assert swap_count(\"[[][]]\") == 0", "assert swap_count(\"[[][]]][\") == 1"], "context": "Write a function to find out the minimum no of swaps required for bracket balancing in the given string.", "function_name": "def swap_count(s):", "gold_generation": "chars = s\r\n\tcount_left = 0\r\n\tcount_right = 0\r\n\tswap = 0\r\n\timbalance = 0; \r\n\tfor i in range(len(chars)):\r\n\t\tif chars[i] == '[':\r\n\t\t\tcount_left += 1\r\n\t\t\tif imbalance > 0:\r\n\t\t\t\tswap += imbalance\r\n\t\t\t\timbalance -= 1\r\n\t\telif chars[i] == ']':\r\n\t\t\tcount_right += 1\r\n\t\t\timbalance = (count_right - count_left) \r\n\treturn swap", "ctxs": [{"id": "41704", "text": "Function: numpy.reference.generated.numpy.char.chararray.swapcase\nSnippet: numpy.char.chararray.swapcase method char.chararray.swapcase()[source] For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. See also char.swapcase", "score": "0.68379325"}, {"id": "20478", "text": "Function: python.library.heapq\nSnippet: key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters. heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n]. heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n]. The latter two functions perform best for smaller values of n. For larger values, it is more efficient to use the sorted() function. Also, when n==1, it is more efficient to use the built-in min() and max() functions. If repeated usage of these functions is required, consider turning the iterable into an actual heap. Basic Examples A heapsort can be implemented by pushing all values onto a heap and then popping off the smallest values one at a time: >>> def heapsort(iterable): ... h = [] ... for value in iterable: ... heappush(h, value) ... return [heappop(h) for i in range(len(h))] ... >>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] This is similar to sorted(iterable), but unlike sorted(), this implementation is not stable. Heap elements can be tuples. This is useful for assigning comparison values (such as task priorities) alongside the main record being tracked: >>> h = [] >>> heappush(h, (5, 'write code')) >>> heappush(h, (7, 'release product')) >>> heappush(h, (1, 'write spec')) >>> heappush(h, (3, 'create tests')) >>> heappop(h) (1, 'write spec') Priority Queue Implementation Notes A priority queue is common use for a heap, and it presents several implementation challenges: Sort stability: how do you get two tasks with equal priorities to be returned in the order they were originally added? Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order. If the priority of a task changes, how do you move it to a new position in the heap? Or if a pending task needs to be deleted, how do you find it and remove it from the queue? A solution to the first two challenges is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were", "score": "0.68085825"}, {"id": "41825", "text": "Function: numpy.reference.generated.numpy.chararray.swapcase\nSnippet: numpy.chararray.swapcase method chararray.swapcase()[source] For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. See also char.swapcase", "score": "0.6795415"}, {"id": "41691", "text": "Function: numpy.reference.generated.numpy.char.chararray.searchsorted\nSnippet: numpy.char.chararray.searchsorted method char.chararray.searchsorted(v, side='left', sorter=None) Find indices where elements of v should be inserted in a to maintain order. For full documentation, see numpy.searchsorted See also numpy.searchsorted equivalent function", "score": "0.6770939"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.67551374"}]}
{"task_id": "mbpp_387", "code": "def even_or_odd(N): \r\n    l = len(N) \r\n    if (N[l-1] =='0'or N[l-1] =='2'or \r\n        N[l-1] =='4'or N[l-1] =='6'or \r\n        N[l-1] =='8'or N[l-1] =='A'or \r\n        N[l-1] =='C'or N[l-1] =='E'): \r\n        return (\"Even\") \r\n    else: \r\n        return (\"Odd\") ", "test_list": ["assert even_or_odd(\"AB3454D\") ==\"Odd\"", "assert even_or_odd(\"ABC\") == \"Even\"", "assert even_or_odd(\"AAD\") == \"Odd\""], "context": "Write a python function to check whether the hexadecimal number is even or odd.", "function_name": "def even_or_odd(N):", "gold_generation": "l = len(N) \r\n    if (N[l-1] =='0'or N[l-1] =='2'or \r\n        N[l-1] =='4'or N[l-1] =='6'or \r\n        N[l-1] =='8'or N[l-1] =='A'or \r\n        N[l-1] =='C'or N[l-1] =='E'): \r\n        return (\"Even\") \r\n    else: \r\n        return (\"Odd\")", "ctxs": [{"id": "25733", "text": "Function: python.library.stdtypes\nSnippet: ratio is exactly equal to the original float and with a positive denominator. Raises OverflowError on infinities and a ValueError on NaNs. float.is_integer() Return True if the float instance is finite with integral value, and False otherwise: >>> (-2.0).is_integer() True >>> (3.2).is_integer() False Two methods support conversion to and from hexadecimal strings. Since Python’s floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. float.hex() Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading 0x and a trailing p and exponent. classmethod float.fromhex(s) Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that float.hex() is an instance method, while float.fromhex() is a class method. A hexadecimal string takes the form: [sign] ['0x'] integer ['.' fraction] ['p' exponent] where the optional sign may by either + or -, integer and fraction are strings of hexadecimal digits, and exponent is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of float.hex() is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C’s %a format character or Java’s Double.toHexString are accepted by float.fromhex(). Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string 0x3.a7p10 represents the floating-point number (3 + 10./16 + 7./16**2) * 2.0**10, or 3740.0: >>> float.fromhex('0x3.a7p10') 3740.0 Applying the reverse conversion to 3740.0 gives a different hexadecimal string representing the same number: >>> float.hex(3740.0) '0x1.d380000000000p+11' Hashing of numeric types For numbers x and y, possibly of different types, it’s a requirement that hash(x) == hash(y) whenever x == y (see the __hash__() method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including int, float, decimal.Decimal and fractions.Fraction) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of int and fractions.Fraction, and all finite instances of float and decimal.Decimal. Essentially, this function is given by reduction modulo P for a fixed prime P. The value of P is made available to Python as the modulus attribute of sys.hash_info. CPython implementation detail: Currently, the prime used is P = 2**31 - 1 on machines with 32-bit C longs and P = 2**61 - 1 on machines with 64-bit C longs. Here are the rules", "score": "0.7194054"}, {"id": "19073", "text": "Function: python.library.curses.ascii#curses.ascii.isxdigit\nSnippet: curses.ascii.isxdigit(c) Checks for an ASCII hexadecimal digit. This is equivalent to c in string.hexdigits.", "score": "0.7110737"}, {"id": "20284", "text": "Function: python.library.functions\nSnippet: hexadecimal string prefixed with “0x”. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> hex(255) '0xff' >>> hex(-42) '-0x2a' If you want to convert an integer number to an uppercase or lower hexadecimal string with prefix or not, you can use either of the following ways: >>> '%#x' % 255, '%x' % 255, '%X' % 255 ('0xff', 'ff', 'FF') >>> format(255, '#x'), format(255, 'x'), format(255, 'X') ('0xff', 'ff', 'FF') >>> f'{255:#x}', f'{255:x}', f'{255:X}' ('0xff', 'ff', 'FF') See also format() for more information. See also int() for converting a hexadecimal string to an integer using a base of 16. Note To obtain a hexadecimal string representation for a float, use the float.hex() method. id(object) Return the “identity” of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value. CPython implementation detail: This is the address of the object in memory. Raises an auditing event builtins.id with argument id. input([prompt]) If the prompt argument is present, it is written to standard output without a trailing newline. The function then reads a line from input, converts it to a string (stripping a trailing newline), and returns that. When EOF is read, EOFError is raised. Example: >>> s = input('--> ') --> Monty Python's Flying Circus >>> s \"Monty Python's Flying Circus\" If the readline module was loaded, then input() will use it to provide elaborate line editing and history features. Raises an auditing event builtins.input with argument prompt before reading input Raises an auditing event builtins.input/result with the result after successfully reading input. class int([x]) class int(x, base=10) Return an integer object constructed from a number or string x, or return 0 if no arguments are given. If x defines __int__(), int(x) returns x.__int__(). If x defines __index__(), it returns x.__index__(). If x defines __trunc__(), it returns x.__trunc__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in radix base. Optionally, the literal can be preceded by + or - (with no space in between) and surrounded by whitespace. A base-n literal consists of the digits 0 to n-1, with a to z (or A to Z) having values 10 to 35. The default base is 10. The allowed values are 0 and 2–36. Base-2, -8, and -16 literals can be optionally prefixed with 0b/0B, 0o/0O, or 0x/0X, as with integer literals in code. Base 0 means to interpret exactly as a code literal, so that the actual base is 2, 8, 10, or 16, and so that int('010', 0) is not legal, while int('010') is, as well as int('010', 8). The integer type is described in Numeric Types — int, float, complex. Changed in version 3.4: If base is not an instance of int", "score": "0.7076664"}, {"id": "24414", "text": "Function: python.library.string#string.hexdigits\nSnippet: string.hexdigits The string '0123456789abcdefABCDEF'.", "score": "0.70406866"}, {"id": "20491", "text": "Function: python.library.functions#hex\nSnippet: hex(x) Convert an integer number to a lowercase hexadecimal string prefixed with “0x”. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> hex(255) '0xff' >>> hex(-42) '-0x2a' If you want to convert an integer number to an uppercase or lower hexadecimal string with prefix or not, you can use either of the following ways: >>> '%#x' % 255, '%x' % 255, '%X' % 255 ('0xff', 'ff', 'FF') >>> format(255, '#x'), format(255, 'x'), format(255, 'X') ('0xff', 'ff', 'FF') >>> f'{255:#x}', f'{255:x}', f'{255:X}' ('0xff', 'ff', 'FF') See also format() for more information. See also int() for converting a hexadecimal string to an integer using a base of 16. Note To obtain a hexadecimal string representation for a float, use the float.hex() method.", "score": "0.6998176"}]}
{"task_id": "mbpp_388", "code": "def highest_Power_of_2(n): \r\n    res = 0; \r\n    for i in range(n, 0, -1): \r\n        if ((i & (i - 1)) == 0): \r\n            res = i; \r\n            break; \r\n    return res; ", "test_list": ["assert highest_Power_of_2(10) == 8", "assert highest_Power_of_2(19) == 16", "assert highest_Power_of_2(32) == 32"], "context": "Write a python function to find the highest power of 2 that is less than or equal to n.", "function_name": "def highest_Power_of_2(n):", "gold_generation": "res = 0; \r\n    for i in range(n, 0, -1): \r\n        if ((i & (i - 1)) == 0): \r\n            res = i; \r\n            break; \r\n    return res;", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.7059676"}, {"id": "21825", "text": "Function: python.library.math#math.pow\nSnippet: math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError. Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers.", "score": "0.6769663"}, {"id": "21812", "text": "Function: python.library.math#math.isqrt\nSnippet: math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8.", "score": "0.66929656"}, {"id": "20290", "text": "Function: python.library.functions\nSnippet: integer representing the Unicode code point of that character. For example, ord('a') returns the integer 97 and ord('€') (Euro sign) returns 8364. This is the inverse of chr(). pow(base, exp[, mod]) Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp. The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10**2 returns 100, but 10**-2 returns 0.01. For int operands base and exp, if mod is present, mod must also be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod. In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod. Here’s an example of computing an inverse for 38 modulo 97: >>> pow(38, -1, mod=97) 23 >>> 23 * 38 % 97 == 1 True Changed in version 3.8: For int operands, the three-argument form of pow now allows the second argument to be negative, permitting computation of modular inverses. Changed in version 3.8: Allow keyword arguments. Formerly, only positional arguments were supported. print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False) Print objects to the text stream file, separated by sep and followed by end. sep, end, file and flush, if present, must be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end. The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Since printed arguments are converted to text strings, print() cannot be used with binary mode file objects. For these, use file.write(...) instead. Whether output is buffered is usually determined by file, but if the flush keyword argument is true, the stream is forcibly flushed. Changed in version 3.3: Added the flush keyword argument. class property(fget=None, fset=None, fdel=None, doc=None) Return a property attribute. fget is a function for getting an attribute value. fset is a function for setting an attribute value. fdel is a function for deleting an attribute value. And doc creates a docstring for the attribute. A typical use is to define a managed attribute x: class C: def __init__(self): self._x = None def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") If c is an instance of C, c.x", "score": "0.6668179"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6667751"}]}
{"task_id": "mbpp_389", "code": "def find_lucas(n): \r\n\tif (n == 0): \r\n\t\treturn 2\r\n\tif (n == 1): \r\n\t\treturn 1\r\n\treturn find_lucas(n - 1) + find_lucas(n - 2) ", "test_list": ["assert find_lucas(9) == 76", "assert find_lucas(4) == 7", "assert find_lucas(3) == 4"], "context": "Write a function to find the n'th lucas number.", "function_name": "def find_lucas(n):", "gold_generation": "if (n == 0): \r\n\t\treturn 2\r\n\tif (n == 1): \r\n\t\treturn 1\r\n\treturn find_lucas(n - 1) + find_lucas(n - 2)", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6484351"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6389631"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.63303596"}, {"id": "43079", "text": "Function: numpy.reference.generated.numpy.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.63189805"}, {"id": "22281", "text": "Function: python.library.numbers#numbers.Rational.numerator\nSnippet: numerator Abstract.", "score": "0.6277135"}]}
{"task_id": "mbpp_390", "code": "def add_string(list,string):\r\n add_string=[string.format(i) for i in  list]\r\n return add_string", "test_list": ["assert add_string([1,2,3,4],'temp{0}')==['temp1', 'temp2', 'temp3', 'temp4']", "assert add_string(['a','b','c','d'], 'python{0}')==[ 'pythona', 'pythonb', 'pythonc', 'pythond']", "assert add_string([5,6,7,8],'string{0}')==['string5', 'string6', 'string7', 'string8']"], "context": "Write a function to insert a given string at the beginning of all items in a list.", "function_name": "def add_string(list,string):", "gold_generation": "add_string=[string.format(i) for i in  list]\r\n return add_string", "ctxs": [{"id": "17639", "text": "Function: python.library.array#array.array.insert\nSnippet: array.insert(i, x) Insert a new item with value x in the array before position i. Negative values are treated as being relative to the end of the array.", "score": "0.6992387"}, {"id": "25033", "text": "Function: python.library.textwrap#textwrap.TextWrapper.initial_indent\nSnippet: initial_indent (default: '') String that will be prepended to the first line of wrapped output. Counts towards the length of the first line. The empty string is not indented.", "score": "0.68090737"}, {"id": "25743", "text": "Function: python.library.stdtypes\nSnippet: on). To expand the string, the current column is set to zero and the string is examined character by character. If the character is a tab (\\t), one or more space characters are inserted in the result until the current column is equal to the next tab position. (The tab character itself is not copied.) If the character is a newline (\\n) or return (\\r), it is copied and the current column is reset to zero. Any other character is copied unchanged and the current column is incremented by one regardless of how the character is represented when printed. >>> '01\\t012\\t0123\\t01234'.expandtabs() '01 012 0123 01234' >>> '01\\t012\\t0123\\t01234'.expandtabs(4) '01 012 0123 01234' str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True str.format(*args, **kwargs) Perform a string formatting operation. The string on which this method is called can contain literal text or replacement fields delimited by braces {}. Each replacement field contains either the numeric index of a positional argument, or the name of a keyword argument. Returns a copy of the string where each replacement field is replaced with the string value of the corresponding argument. >>> \"The sum of 1 + 2 is {0}\".format(1+2) 'The sum of 1 + 2 is 3' See Format String Syntax for a description of the various formatting options that can be specified in format strings. Note When formatting a number (int, float, complex, decimal.Decimal and subclasses) with the n type (ex: '{:n}'.format(1234)), the function temporarily sets the LC_CTYPE locale to the LC_NUMERIC locale to decode decimal_point and thousands_sep fields of localeconv() if they are non-ASCII or longer than 1 byte, and the LC_NUMERIC locale is different than the LC_CTYPE locale. This temporary change affects other threads. Changed in version 3.7: When formatting a number with the n type, the function sets temporarily the LC_CTYPE locale to the LC_NUMERIC locale in some cases. str.format_map(mapping) Similar to str.format(**mapping), except that mapping is used directly and not copied to a dict. This is useful if for example mapping is a dict subclass: >>> class Default(dict): ... def __missing__(self, key): ... return key ... >>> '{name} was born in {country}'.format_map(Default(name='Guido')) 'Guido was born in country' New in version 3.2. str.index(sub[, start[, end]]) Like find(), but raise ValueError when the substring is not found. str.isalnum() Return True if all characters in the string are alphanumeric and there is at least one character, False otherwise. A character c is alphanumeric if one of the following returns True: c.isalpha(), c.isdecimal(), c.isdigit(), or c.isnumeric(). str.isalpha() Return True if all characters in the string are alphabetic and there is at least one character, False otherwise. Alphabetic characters are those characters", "score": "0.6651385"}, {"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.6633952"}, {"id": "24397", "text": "Function: python.library.string\nSnippet: example of how to use a Template: >>> from string import Template >>> s = Template('$who likes $what') >>> s.substitute(who='tim', what='kung pao') 'tim likes kung pao' >>> d = dict(who='tim') >>> Template('Give $who $100').substitute(d) Traceback (most recent call last): ... ValueError: Invalid placeholder in string: line 1, col 11 >>> Template('$who likes $what').substitute(d) Traceback (most recent call last): ... KeyError: 'what' >>> Template('$who likes $what').safe_substitute(d) 'tim likes $what' Advanced usage: you can derive subclasses of Template to customize the placeholder syntax, delimiter character, or the entire regular expression used to parse template strings. To do this, you can override these class attributes: delimiter – This is the literal string describing a placeholder introducing delimiter. The default value is $. Note that this should not be a regular expression, as the implementation will call re.escape() on this string as needed. Note further that you cannot change the delimiter after class creation (i.e. a different delimiter must be set in the subclass’s class namespace). idpattern – This is the regular expression describing the pattern for non-braced placeholders. The default value is the regular expression (?a:[_a-z][_a-z0-9]*). If this is given and braceidpattern is None this pattern will also apply to braced placeholders. Note Since default flags is re.IGNORECASE, pattern [a-z] can match with some non-ASCII characters. That’s why we use the local a flag here. Changed in version 3.7: braceidpattern can be used to define separate patterns used inside and outside the braces. braceidpattern – This is like idpattern but describes the pattern for braced placeholders. Defaults to None which means to fall back to idpattern (i.e. the same pattern is used both inside and outside braces). If given, this allows you to define different patterns for braced and unbraced placeholders. New in version 3.7. flags – The regular expression flags that will be applied when compiling the regular expression used for recognizing substitutions. The default value is re.IGNORECASE. Note that re.VERBOSE will always be added to the flags, so custom idpatterns must follow conventions for verbose regular expressions. New in version 3.2. Alternatively, you can provide the entire regular expression pattern by overriding the class attribute pattern. If you do this, the value must be a regular expression object with four named capturing groups. The capturing groups correspond to the rules given above, along with the invalid placeholder rule: escaped – This group matches the escape sequence, e.g. $$, in the default pattern. named – This group matches the unbraced placeholder name; it should not include the delimiter in capturing group. braced – This group matches the brace enclosed placeholder name; it should not include either the delimiter or braces in the capturing group. invalid – This group matches any other delimiter pattern (usually a single delimiter), and it should appear last in the regular expression. Helper functions string.capwords(s, sep=None) Split the argument into words using str.split(), capitalize each word using str.capitalize(), and join the capitalized words using str.join(). If the optional second argument sep is absent or None, runs of whitespace", "score": "0.6581345"}]}
{"task_id": "mbpp_391", "code": "def convert_list_dictionary(l1, l2, l3):\r\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\r\n     return result", "test_list": ["assert convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"],[\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"] ,[85, 98, 89, 92])==[{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]", "assert convert_list_dictionary([\"abc\",\"def\",\"ghi\",\"jkl\"],[\"python\",\"program\",\"language\",\"programs\"],[100,200,300,400])==[{'abc':{'python':100}},{'def':{'program':200}},{'ghi':{'language':300}},{'jkl':{'programs':400}}]", "assert convert_list_dictionary([\"A1\",\"A2\",\"A3\",\"A4\"],[\"java\",\"C\",\"C++\",\"DBMS\"],[10,20,30,40])==[{'A1':{'java':10}},{'A2':{'C':20}},{'A3':{'C++':30}},{'A4':{'DBMS':40}}]"], "context": "Write a function to convert more than one list to nested dictionary.", "function_name": "def convert_list_dictionary(l1, l2, l3):", "gold_generation": "result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\r\n     return result", "ctxs": [{"id": "8558", "text": "Function: werkzeug.datastructures.index#werkzeug.datastructures.MultiDict.to_dict\nSnippet: to_dict(flat=True) Return the contents as regular dict. If flat is True the returned dict will only have the first item present, if flat is False all values will be returned as lists. Parameters flat – If set to False the dict returned will have lists with all the values in it. Otherwise it will only contain the first value for each key. Returns a dict", "score": "0.70126015"}, {"id": "8561", "text": "Function: werkzeug.datastructures.index#werkzeug.datastructures.OrderedMultiDict\nSnippet: class werkzeug.datastructures.OrderedMultiDict(mapping=None) Works like a regular MultiDict but preserves the order of the fields. To convert the ordered multi dict into a list you can use the items() method and pass it multi=True. In general an OrderedMultiDict is an order of magnitude slower than a MultiDict. note Due to a limitation in Python you cannot convert an ordered multi dict into a regular dict by using dict(multidict). Instead you have to use the to_dict() method, otherwise the internal bucket objects are exposed.", "score": "0.6964306"}, {"id": "8549", "text": "Function: werkzeug.datastructures.index#werkzeug.datastructures.MultiDict.lists\nSnippet: lists() Return a iterator of (key, values) pairs, where values is the list of all values associated with the key.", "score": "0.68708825"}, {"id": "8550", "text": "Function: werkzeug.datastructures.index#werkzeug.datastructures.MultiDict.listvalues\nSnippet: listvalues() Return an iterator of all values associated with a key. Zipping keys() and this is the same as calling lists(): >>> d = MultiDict({\"foo\": [1, 2, 3]}) >>> zip(d.keys(), d.listvalues()) == d.lists() True", "score": "0.6776439"}, {"id": "17646", "text": "Function: python.library.array#array.array.tolist\nSnippet: array.tolist() Convert the array to an ordinary list with the same items.", "score": "0.6751496"}]}
{"task_id": "mbpp_392", "code": "def get_max_sum (n):\r\n\tres = list()\r\n\tres.append(0)\r\n\tres.append(1)\r\n\ti = 2\r\n\twhile i<n + 1:\r\n\t\tres.append(max(i, (res[int(i / 2)] \r\n\t\t\t\t\t\t+ res[int(i / 3)] +\r\n\t\t\t\t\t\t\tres[int(i / 4)]\r\n\t\t\t\t\t\t+ res[int(i / 5)])))\r\n\t\ti = i + 1\r\n\treturn res[n]", "test_list": ["assert get_max_sum(60) == 106", "assert get_max_sum(10) == 12", "assert get_max_sum(2) == 2"], "context": "Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).", "function_name": "def get_max_sum (n):", "gold_generation": "res = list()\r\n\tres.append(0)\r\n\tres.append(1)\r\n\ti = 2\r\n\twhile i<n + 1:\r\n\t\tres.append(max(i, (res[int(i / 2)] \r\n\t\t\t\t\t\t+ res[int(i / 3)] +\r\n\t\t\t\t\t\t\tres[int(i / 4)]\r\n\t\t\t\t\t\t+ res[int(i / 5)])))\r\n\t\ti = i + 1\r\n\treturn res[n]", "ctxs": [{"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.64223737"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.63279504"}, {"id": "15379", "text": "Function: pandas.reference.api.pandas.series.sum\nSnippet: pandas.Series.sum Series.sum(axis=None, skipna=True, level=None, numeric_only=None, min_count=0, **kwargs)[source] Return the sum of the values over the requested axis. This is equivalent to the method numpy.sum. Parameters axis:{index (0)} Axis for the function to be applied on. skipna:bool, default True Exclude NA/null values when computing the result. level:int or level name, default None If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar. numeric_only:bool, default None Include only float, int, boolean columns. If None, will attempt to use everything, then use only numeric data. Not implemented for Series. min_count:int, default 0 The required number of valid values to perform the operation. If fewer than min_count non-NA values are present the result will be NA. **kwargs Additional keyword arguments to be passed to the function. Returns scalar or Series (if level specified) See also Series.sum Return the sum. Series.min Return the minimum. Series.max Return the maximum. Series.idxmin Return the index of the minimum. Series.idxmax Return the index of the maximum. DataFrame.sum Return the sum over the requested axis. DataFrame.min Return the minimum over the requested axis. DataFrame.max Return the maximum over the requested axis. DataFrame.idxmin Return the index of the minimum over the requested axis. DataFrame.idxmax Return the index of the maximum over the requested axis. Examples >>> idx = pd.MultiIndex.from_arrays([ ... ['warm', 'warm', 'cold', 'cold'], ... ['dog', 'falcon', 'fish', 'spider']], ... names=['blooded', 'animal']) >>> s = pd.Series([4, 2, 0, 8], name='legs', index=idx) >>> s blooded animal warm dog 4 falcon 2 cold fish 0 spider 8 Name: legs, dtype: int64 >>> s.sum() 14 By default, the sum of an empty or all-NA Series is 0. >>> pd.Series([], dtype=\"float64\").sum() # min_count=0 is the default 0.0 This can be controlled with the min_count parameter. For example, if you’d like the sum of an empty series to be NaN, pass min_count=1. >>> pd.Series([], dtype=\"float64\").sum(min_count=1) nan Thanks to the skipna parameter, min_count handles all-NA and empty series identically. >>> pd.Series([np.nan]).sum() 0.0 >>> pd.Series([np.nan]).sum(min_count=1) nan", "score": "0.6322211"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.6281971"}, {"id": "42615", "text": "Function: numpy.reference.generated.numpy.amax\nSnippet: >>> np.amax([5], initial=6) 6 >>> max([5], default=6) 5", "score": "0.6281848"}]}
{"task_id": "mbpp_393", "code": "def max_length_list(input_list):\r\n    max_length = max(len(x) for x in input_list )   \r\n    max_list = max(input_list, key = lambda i: len(i))    \r\n    return(max_length, max_list)", "test_list": ["assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])", "assert max_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(5,[1,2,3,4,5])", "assert max_length_list([[3,4,5],[6,7,8,9],[10,11,12]])==(4,[6,7,8,9])"], "context": "Write a function to find the list with maximum length using lambda function.", "function_name": "def max_length_list(input_list):", "gold_generation": "max_length = max(len(x) for x in input_list )   \r\n    max_list = max(input_list, key = lambda i: len(i))    \r\n    return(max_length, max_list)", "ctxs": [{"id": "18671", "text": "Function: python.library.collections#collections.deque.maxlen\nSnippet: maxlen Maximum size of a deque or None if unbounded. New in version 3.1.", "score": "0.7141265"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.68971634"}, {"id": "21316", "text": "Function: python.library.itertools#itertools.zip_longest\nSnippet: itertools.zip_longest(*iterables, fillvalue=None) Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. Roughly equivalent to: def zip_longest(*args, fillvalue=None): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- iterators = [iter(it) for it in args] num_active = len(iterators) if not num_active: return while True: values = [] for i, it in enumerate(iterators): try: value = next(it) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values.append(value) yield tuple(values) If one of the iterables is potentially infinite, then the zip_longest() function should be wrapped with something that limits the number of calls (for example islice() or takewhile()). If not specified, fillvalue defaults to None.", "score": "0.6856007"}, {"id": "20457", "text": "Function: python.library.hashlib#hashlib.blake2b.MAX_KEY_SIZE\nSnippet: blake2b.MAX_KEY_SIZE", "score": "0.67472714"}, {"id": "20462", "text": "Function: python.library.hashlib#hashlib.blake2s.MAX_KEY_SIZE\nSnippet: blake2s.MAX_KEY_SIZE", "score": "0.6729377"}]}
{"task_id": "mbpp_394", "code": "def check_distinct(test_tup):\r\n  res = True\r\n  temp = set()\r\n  for ele in test_tup:\r\n    if ele in temp:\r\n      res = False\r\n      break\r\n    temp.add(ele)\r\n  return (res) ", "test_list": ["assert check_distinct((1, 4, 5, 6, 1, 4)) == False", "assert check_distinct((1, 4, 5, 6)) == True", "assert check_distinct((2, 3, 4, 5, 6)) == True"], "context": "Write a function to check if given tuple is distinct or not.", "function_name": "def check_distinct(test_tup):", "gold_generation": "res = True\r\n  temp = set()\r\n  for ele in test_tup:\r\n    if ele in temp:\r\n      res = False\r\n      break\r\n    temp.add(ele)\r\n  return (res)", "ctxs": [{"id": "36917", "text": "Function: django.ref.contrib.postgres.aggregates#django.contrib.postgres.aggregates.StringAgg.distinct\nSnippet: distinct An optional boolean argument that determines if concatenated values will be distinct. Defaults to False.", "score": "0.7323459"}, {"id": "36894", "text": "Function: django.ref.contrib.postgres.aggregates#django.contrib.postgres.aggregates.ArrayAgg.distinct\nSnippet: distinct An optional boolean argument that determines if array values will be distinct. Defaults to False.", "score": "0.7265621"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6959359"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.692868"}, {"id": "42785", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.is_sequence\nSnippet: numpy.distutils.misc_util.is_sequence(seq)[source]", "score": "0.6893131"}]}
{"task_id": "mbpp_395", "code": "def first_non_repeating_character(str1):\r\n  char_order = []\r\n  ctr = {}\r\n  for c in str1:\r\n    if c in ctr:\r\n      ctr[c] += 1\r\n    else:\r\n      ctr[c] = 1 \r\n      char_order.append(c)\r\n  for c in char_order:\r\n    if ctr[c] == 1:\r\n      return c\r\n  return None", "test_list": ["assert first_non_repeating_character(\"abcabc\") == None", "assert first_non_repeating_character(\"abc\") == \"a\"", "assert first_non_repeating_character(\"ababc\") == \"c\""], "context": "Write a python function to find the first non-repeated character in a given string.", "function_name": "def first_non_repeating_character(str1):", "gold_generation": "char_order = []\r\n  ctr = {}\r\n  for c in str1:\r\n    if c in ctr:\r\n      ctr[c] += 1\r\n    else:\r\n      ctr[c] = 1 \r\n      char_order.append(c)\r\n  for c in char_order:\r\n    if ctr[c] == 1:\r\n      return c\r\n  return None", "ctxs": [{"id": "41724", "text": "Function: numpy.reference.generated.numpy.char.find\nSnippet: numpy.char.find char.find(a, sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. Calls str.find element-wise. For each element, return the lowest index in the string where substring sub is found, such that sub is contained in the range [start, end]. Parameters aarray_like of str or unicode substr or unicode start, endint, optional Optional arguments start and end are interpreted as in slice notation. Returns outndarray or int Output array of ints. Returns -1 if sub is not found. See also str.find", "score": "0.7011119"}, {"id": "23301", "text": "Function: python.library.re\nSnippet: repetitions as possible. For example, a{3,5} will match from 3 to 5 'a' characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, a{4,}b will match 'aaaab' or a thousand 'a' characters followed by a 'b', but not 'aaab'. The comma may not be omitted or the modifier would be confused with the previously described form. {m,n}? Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous qualifier. For example, on the 6-character string 'aaaaaa', a{3,5} will match 5 'a' characters, while a{3,5}? will only match 3 characters. \\ Either escapes special characters (permitting you to match characters like '*', '?', and so forth), or signals a special sequence; special sequences are discussed below. If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions. [] Used to indicate a set of characters. In a set: Characters can be listed individually, e.g. [amk] will match 'a', 'm', or 'k'. Ranges of characters can be indicated by giving two characters and separating them by a '-', for example [a-z] will match any lowercase ASCII letter, [0-5][0-9] will match all the two-digits numbers from 00 to 59, and [0-9A-Fa-f] will match any hexadecimal digit. If - is escaped (e.g. [a\\-z]) or if it’s placed as the first or last character (e.g. [-a] or [a-]), it will match a literal '-'. Special characters lose their special meaning inside sets. For example, [(+*)] will match any of the literal characters '(', '+', '*', or ')'. Character classes such as \\w or \\S (defined below) are also accepted inside a set, although the characters they match depends on whether ASCII or LOCALE mode is in force. Characters that are not within a range can be matched by complementing the set. If the first character of the set is '^', all the characters that are not in the set will be matched. For example, [^5] will match any character except '5', and [^^] will match any character except '^'. ^ has no special meaning if it’s not the first character in the set. To match a literal ']' inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both [()[\\]{}] and []()[{}] will both match a parenthesis. Support of nested sets and set operations as in Unicode Technical Standard #18 might be added in the future. This would change the syntax, so to facilitate this change", "score": "0.68927884"}, {"id": "23310", "text": "Function: python.library.re\nSnippet: for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\" Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). Pattern.fullmatch(string[, pos[, endpos]]) If the whole string matches this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o[gh]\") >>> pattern.fullmatch(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.fullmatch(\"ogre\") # No match as not the full string matches. >>> pattern.fullmatch(\"doggie\", 1, 3) # Matches within given limits. <re.Match object; span=(1, 3), match='og'> New in version 3.4. Pattern.split(string, maxsplit=0) Identical to the split() function, using the compiled pattern. Pattern.findall(string[, pos[, endpos]]) Similar to the findall() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.finditer(string[, pos[, endpos]]) Similar to the finditer() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.sub(repl, string, count=0) Identical to the sub() function, using the compiled pattern. Pattern.subn(repl, string, count=0) Identical to the subn() function, using the compiled pattern. Pattern.flags The regex", "score": "0.6873105"}, {"id": "41654", "text": "Function: numpy.reference.generated.numpy.char.chararray.find\nSnippet: numpy.char.chararray.find method char.chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.68647575"}, {"id": "41778", "text": "Function: numpy.reference.generated.numpy.chararray.find\nSnippet: numpy.chararray.find method chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.68304765"}]}
{"task_id": "mbpp_396", "code": "import re  \r\nregex = r'^[a-z]$|^([a-z]).*\\1$'\r\ndef check_char(string): \r\n\tif(re.search(regex, string)): \r\n\t\treturn \"Valid\" \r\n\telse: \r\n\t\treturn \"Invalid\" ", "test_list": ["assert check_char(\"abba\") == \"Valid\"", "assert check_char(\"a\") == \"Valid\"", "assert check_char(\"abcd\") == \"Invalid\""], "context": "Write a function to check whether the given string starts and ends with the same character or not using regex.", "function_name": "import re  \r\nregex = r'^[a-z]$|^([a-z]).*\\1$'\r\ndef check_char(string):", "gold_generation": "if(re.search(regex, string)): \r\n\t\treturn \"Valid\" \r\n\telse: \r\n\t\treturn \"Invalid\"", "ctxs": [{"id": "23304", "text": "Function: python.library.re\nSnippet: Similar to positive lookbehind assertions, the contained pattern must only match strings of some fixed length. Patterns which start with negative lookbehind assertions may match at the beginning of the string being searched. (?(id/name)yes-pattern|no-pattern) Will try to match with yes-pattern if the group with given id or name exists, and with no-pattern if it doesn’t. no-pattern is optional and can be omitted. For example, (<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$) is a poor email matching pattern, which will match with '<user@host.com>' as well as 'user@host.com', but not with '<user@host.com' nor 'user@host.com>'. The special sequences consist of '\\' and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, \\$ matches the character '$'. \\number Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, (.+) \\1 matches 'the the' or '55 55', but not 'thethe' (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the '[' and ']' of a character class, all numeric escapes are treated as characters. \\A Matches only at the start of the string. \\b Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of word characters. Note that formally, \\b is defined as the boundary between a \\w and a \\W character (or vice versa), or between \\w and the beginning/end of the string. This means that r'\\bfoo\\b' matches 'foo', 'foo.', '(foo)', 'bar foo baz' but not 'foobar' or 'foo3'. By default Unicode alphanumerics are the ones used in Unicode patterns, but this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. Inside a character range, \\b represents the backspace character, for compatibility with Python’s string literals. \\B Matches the empty string, but only when it is not at the beginning or end of a word. This means that r'py\\B' matches 'python', 'py3', 'py2', but not 'py', 'py.', or 'py!'. \\B is just the opposite of \\b, so word characters in Unicode patterns are Unicode alphanumerics or the underscore, although this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. \\d For Unicode (str) patterns: Matches any Unicode decimal digit (that is, any character in Unicode character category [Nd]). This includes [0-9], and also many other digit characters. If the ASCII flag is used only [0-9] is matched. For 8-bit (bytes) patterns: Matches any decimal digit; this is equivalent to [0-9]. \\D Matches any character which is not a decimal digit. This is the opposite of \\d. If the", "score": "0.7259864"}, {"id": "24379", "text": "Function: python.library.stdtypes#str.startswith\nSnippet: str.startswith(prefix[, start[, end]]) Return True if string starts with the prefix, otherwise return False. prefix can also be a tuple of prefixes to look for. With optional start, test string beginning at that position. With optional end, stop comparing string at that position.", "score": "0.72265595"}, {"id": "23310", "text": "Function: python.library.re\nSnippet: for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\" Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). Pattern.fullmatch(string[, pos[, endpos]]) If the whole string matches this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o[gh]\") >>> pattern.fullmatch(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.fullmatch(\"ogre\") # No match as not the full string matches. >>> pattern.fullmatch(\"doggie\", 1, 3) # Matches within given limits. <re.Match object; span=(1, 3), match='og'> New in version 3.4. Pattern.split(string, maxsplit=0) Identical to the split() function, using the compiled pattern. Pattern.findall(string[, pos[, endpos]]) Similar to the findall() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.finditer(string[, pos[, endpos]]) Similar to the finditer() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.sub(repl, string, count=0) Identical to the sub() function, using the compiled pattern. Pattern.subn(repl, string, count=0) Identical to the subn() function, using the compiled pattern. Pattern.flags The regex", "score": "0.7225609"}, {"id": "23307", "text": "Function: python.library.re\nSnippet: '^' matches only at the beginning of the string, and '$' only at the end of the string and immediately before the newline (if any) at the end of the string. Corresponds to the inline flag (?m). re.S re.DOTALL Make the '.' special character match any character at all, including a newline; without this flag, '.' will match anything except a newline. Corresponds to the inline flag (?s). re.X re.VERBOSE This flag allows you to write regular expressions that look nicer and are more readable by allowing you to visually separate logical sections of the pattern and add comments. Whitespace within the pattern is ignored, except when in a character class, or when preceded by an unescaped backslash, or within tokens like *?, (?: or (?P<...>. When a line contains a # that is not in a character class and is not preceded by an unescaped backslash, all characters from the leftmost such # through the end of the line are ignored. This means that the two following regular expression objects that match a decimal number are functionally equal: a = re.compile(r\"\"\"\\d + # the integral part \\. # the decimal point \\d * # some fractional digits\"\"\", re.X) b = re.compile(r\"\\d+\\.\\d*\") Corresponds to the inline flag (?x). re.search(pattern, string, flags=0) Scan through string looking for the first location where the regular expression pattern produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. re.match(pattern, string, flags=0) If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. Note that even in MULTILINE mode, re.match() will only match at the beginning of the string and not at the beginning of each line. If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). re.fullmatch(pattern, string, flags=0) If the whole string matches the regular expression pattern, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. New in version 3.4. re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string,", "score": "0.7214079"}, {"id": "23359", "text": "Function: python.library.re#re.Pattern.match\nSnippet: Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()).", "score": "0.71816325"}]}
{"task_id": "mbpp_397", "code": "def median_numbers(a,b,c):\r\n if a > b:\r\n    if a < c:\r\n        median = a\r\n    elif b > c:\r\n        median = b\r\n    else:\r\n        median = c\r\n else:\r\n    if a > c:\r\n        median = a\r\n    elif b < c:\r\n        median = b\r\n    else:\r\n        median = c\r\n return median", "test_list": ["assert median_numbers(25,55,65)==55.0", "assert median_numbers(20,10,30)==20.0", "assert median_numbers(15,45,75)==45.0"], "context": "Write a function to find the median of three specific numbers.", "function_name": "def median_numbers(a,b,c):", "gold_generation": "if a > b:\r\n    if a < c:\r\n        median = a\r\n    elif b > c:\r\n        median = b\r\n    else:\r\n        median = c\r\n else:\r\n    if a > c:\r\n        median = a\r\n    elif b < c:\r\n        median = b\r\n    else:\r\n        median = c\r\n return median", "ctxs": [{"id": "24308", "text": "Function: python.library.statistics#statistics.median\nSnippet: statistics.median(data) Return the median (middle value) of numeric data, using the common “mean of middle two” method. If data is empty, StatisticsError is raised. data can be a sequence or iterable. The median is a robust measure of central location and is less affected by the presence of outliers. When the number of data points is odd, the middle data point is returned: >>> median([1, 3, 5]) 3 When the number of data points is even, the median is interpolated by taking the average of the two middle values: >>> median([1, 3, 5, 7]) 4.0 This is suited for when your data is discrete, and you don’t mind that the median may not be an actual data point. If the data is ordinal (supports order operations) but not numeric (doesn’t support addition), consider using median_low() or median_high() instead.", "score": "0.7151096"}, {"id": "24298", "text": "Function: python.library.statistics\nSnippet: statistics.median_low(data) Return the low median of numeric data. If data is empty, StatisticsError is raised. data can be a sequence or iterable. The low median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the smaller of the two middle values is returned. >>> median_low([1, 3, 5]) 3 >>> median_low([1, 3, 5, 7]) 3 Use the low median when your data are discrete and you prefer the median to be an actual data point rather than interpolated. statistics.median_high(data) Return the high median of data. If data is empty, StatisticsError is raised. data can be a sequence or iterable. The high median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the larger of the two middle values is returned. >>> median_high([1, 3, 5]) 3 >>> median_high([1, 3, 5, 7]) 5 Use the high median when your data are discrete and you prefer the median to be an actual data point rather than interpolated. statistics.median_grouped(data, interval=1) Return the median of grouped continuous data, calculated as the 50th percentile, using interpolation. If data is empty, StatisticsError is raised. data can be a sequence or iterable. >>> median_grouped([52, 52, 53, 54]) 52.5 In the following example, the data are rounded, so that each value represents the midpoint of data classes, e.g. 1 is the midpoint of the class 0.5–1.5, 2 is the midpoint of 1.5–2.5, 3 is the midpoint of 2.5–3.5, etc. With the data given, the middle value falls somewhere in the class 3.5–4.5, and interpolation is used to estimate it: >>> median_grouped([1, 2, 2, 3, 4, 4, 4, 4, 4, 5]) 3.7 Optional argument interval represents the class interval, and defaults to 1. Changing the class interval naturally will change the interpolation: >>> median_grouped([1, 3, 3, 5, 7], interval=1) 3.25 >>> median_grouped([1, 3, 3, 5, 7], interval=2) 3.5 This function does not check whether the data points are at least interval apart. CPython implementation detail: Under some circumstances, median_grouped() may coerce data points to floats. This behaviour is likely to change in the future. See also “Statistics for the Behavioral Sciences”, Frederick J Gravetter and Larry B Wallnau (8th Edition). The SSMEDIAN function in the Gnome Gnumeric spreadsheet, including this discussion. statistics.mode(data) Return the single most common data point from discrete or nominal data. The mode (when it exists) is the most typical value and serves as a measure of central location. If there are multiple modes with the same frequency, returns the first one encountered in the data. If the smallest or largest of those is desired instead, use min(multimode(data)) or max(multimode(data)). If the input data is empty, StatisticsError is raised. mode assumes discrete data and returns a single value. This is the standard treatment of the mode as commonly taught in schools: >>> mode([1, 1, 2, 3, 3, 3, 3, 4]) 3 The mode is unique in", "score": "0.70195216"}, {"id": "14160", "text": "Function: pandas.reference.api.pandas.core.groupby.groupby.median\nSnippet: pandas.core.groupby.GroupBy.median finalGroupBy.median(numeric_only=NoDefault.no_default)[source] Compute median of groups, excluding missing values. For multiple groupings, the result index will be a MultiIndex Parameters numeric_only:bool, default True Include only float, int, boolean columns. If None, will attempt to use everything, then use only numeric data. Returns Series or DataFrame Median of values within each group. See also Series.groupby Apply a function groupby to a Series. DataFrame.groupby Apply a function groupby to each row or column of a DataFrame.", "score": "0.68796706"}, {"id": "14206", "text": "Function: pandas.reference.api.pandas.core.resample.resampler.median\nSnippet: pandas.core.resample.Resampler.median Resampler.median(_method='median', *args, **kwargs)[source] Compute median of groups, excluding missing values. For multiple groupings, the result index will be a MultiIndex Parameters numeric_only:bool, default True Include only float, int, boolean columns. If None, will attempt to use everything, then use only numeric data. Returns Series or DataFrame Median of values within each group. See also Series.groupby Apply a function groupby to a Series. DataFrame.groupby Apply a function groupby to each row or column of a DataFrame.", "score": "0.685641"}, {"id": "24296", "text": "Function: python.library.statistics\nSnippet: statistics — Mathematical statistics functions New in version 3.4. Source code: Lib/statistics.py This module provides functions for calculating mathematical statistics of numeric (Real-valued) data. The module is not intended to be a competitor to third-party libraries such as NumPy, SciPy, or proprietary full-featured statistics packages aimed at professional statisticians such as Minitab, SAS and Matlab. It is aimed at the level of graphing and scientific calculators. Unless explicitly noted, these functions support int, float, Decimal and Fraction. Behaviour with other types (whether in the numeric tower or not) is currently unsupported. Collections with a mix of types are also undefined and implementation-dependent. If your input data consists of mixed types, you may be able to use map() to ensure a consistent result, for example: map(float, input_data). Averages and measures of central location These functions calculate an average or typical value from a population or sample. mean() Arithmetic mean (“average”) of data. fmean() Fast, floating point arithmetic mean. geometric_mean() Geometric mean of data. harmonic_mean() Harmonic mean of data. median() Median (middle value) of data. median_low() Low median of data. median_high() High median of data. median_grouped() Median, or 50th percentile, of grouped data. mode() Single mode (most common value) of discrete or nominal data. multimode() List of modes (most common values) of discrete or nomimal data. quantiles() Divide data into intervals with equal probability. Measures of spread These functions calculate a measure of how much the population or sample tends to deviate from the typical or average values. pstdev() Population standard deviation of data. pvariance() Population variance of data. stdev() Sample standard deviation of data. variance() Sample variance of data. Function details Note: The functions do not require the data given to them to be sorted. However, for reading convenience, most of the examples show sorted sequences. statistics.mean(data) Return the sample arithmetic mean of data which can be a sequence or iterable. The arithmetic mean is the sum of the data divided by the number of data points. It is commonly called “the average”, although it is only one of many different mathematical averages. It is a measure of the central location of the data. If data is empty, StatisticsError will be raised. Some examples of use: >>> mean([1, 2, 3, 4, 4]) 2.8 >>> mean([-1.0, 2.5, 3.25, 5.75]) 2.625 >>> from fractions import Fraction as F >>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)]) Fraction(13, 21) >>> from decimal import Decimal as D >>> mean([D(\"0.5\"), D(\"0.75\"), D(\"0.625\"), D(\"0.375\")]) Decimal('0.5625') Note The mean is strongly affected by outliers and is not a robust estimator for central location: the mean is not necessarily a typical example of the data points. For more robust measures of central location, see median() and mode(). The sample mean gives an unbiased estimate of the true population mean, so that when taken on average over all the possible samples, mean(sample) converges on the true mean of the entire population. If data represents the entire population rather than a sample, then mean(data) is equivalent to calculating the true", "score": "0.6782912"}]}
{"task_id": "mbpp_398", "code": "def sum_of_digits(nums):\r\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())", "test_list": ["assert sum_of_digits([10,2,56])==14", "assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19", "assert sum_of_digits([10,20,-4,5,-70])==19"], "context": "Write a function to compute the sum of digits of each number of a given list.", "function_name": "def sum_of_digits(nums):", "gold_generation": "return sum(int(el) for n in nums for el in str(n) if el.isdigit())", "ctxs": [{"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.6939863"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.68902194"}, {"id": "24403", "text": "Function: python.library.string#string.digits\nSnippet: string.digits The string '0123456789'.", "score": "0.68462235"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.68438935"}, {"id": "19451", "text": "Function: python.library.decimal#decimal.Context.add\nSnippet: add(x, y) Return the sum of x and y.", "score": "0.68085164"}]}
{"task_id": "mbpp_399", "code": "def bitwise_xor(test_tup1, test_tup2):\r\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "test_list": ["assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)", "assert bitwise_xor((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)", "assert bitwise_xor((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)"], "context": "Write a function to perform the mathematical bitwise xor operation across the given tuples.", "function_name": "def bitwise_xor(test_tup1, test_tup2):", "gold_generation": "res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res)", "ctxs": [{"id": "22353", "text": "Function: python.library.operator#operator.xor\nSnippet: operator.xor(a, b) operator.__xor__(a, b) Return the bitwise exclusive or of a and b.", "score": "0.75447285"}, {"id": "42665", "text": "Function: numpy.reference.generated.numpy.bitwise_xor\nSnippet: numpy.bitwise_xor numpy.bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'bitwise_xor'> Compute the bit-wise XOR of two arrays element-wise. Computes the bit-wise XOR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator ^. Parameters x1, x2array_like Only integer and boolean types are handled. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Result. This is a scalar if both x1 and x2 are scalars. See also logical_xor bitwise_and bitwise_or binary_repr Return the binary representation of the input number as a string. Examples The number 13 is represented by 00001101. Likewise, 17 is represented by 00010001. The bit-wise XOR of 13 and 17 is therefore 00011100, or 28: >>> np.bitwise_xor(13, 17) 28 >>> np.binary_repr(28) '11100' >>> np.bitwise_xor(31, 5) 26 >>> np.bitwise_xor([31,3], 5) array([26, 6]) >>> np.bitwise_xor([31,3], [5,6]) array([26, 5]) >>> np.bitwise_xor([True, True], [False, True]) array([ True, False]) The ^ operator can be used as a shorthand for np.bitwise_xor on ndarrays. >>> x1 = np.array([True, True]) >>> x2 = np.array([False, True]) >>> x1 ^ x2 array([ True, False])", "score": "0.75175095"}, {"id": "22398", "text": "Function: python.library.operator#operator.__xor__\nSnippet: operator.xor(a, b) operator.__xor__(a, b) Return the bitwise exclusive or of a and b.", "score": "0.7448858"}, {"id": "7760", "text": "Function: torch.tensors#torch.Tensor.bitwise_xor_\nSnippet: bitwise_xor_() → Tensor In-place version of bitwise_xor()", "score": "0.7372203"}, {"id": "7759", "text": "Function: torch.tensors#torch.Tensor.bitwise_xor\nSnippet: bitwise_xor() → Tensor See torch.bitwise_xor()", "score": "0.7335456"}]}
{"task_id": "mbpp_400", "code": "def extract_freq(test_list):\r\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\r\n  return (res)", "test_list": ["assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3", "assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4", "assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4"], "context": "Write a function to extract the frequency of unique tuples in the given list order irrespective.", "function_name": "def extract_freq(test_list):", "gold_generation": "res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\r\n  return (res)", "ctxs": [{"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.7087778"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.7073136"}, {"id": "21301", "text": "Function: python.library.itertools#itertools.combinations\nSnippet: itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6989112"}, {"id": "21302", "text": "Function: python.library.itertools#itertools.combinations_with_replacement\nSnippet: itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1.", "score": "0.6978982"}, {"id": "43260", "text": "Function: numpy.reference.generated.numpy.unique\nSnippet: the unique values: >>> a = np.array(['a', 'b', 'b', 'c', 'a']) >>> u, indices = np.unique(a, return_index=True) >>> u array(['a', 'b', 'c'], dtype='<U1') >>> indices array([0, 1, 3]) >>> a[indices] array(['a', 'b', 'c'], dtype='<U1') Reconstruct the input array from the unique values and inverse: >>> a = np.array([1, 2, 6, 4, 2, 3, 2]) >>> u, indices = np.unique(a, return_inverse=True) >>> u array([1, 2, 3, 4, 6]) >>> indices array([0, 1, 4, 3, 1, 2, 1]) >>> u[indices] array([1, 2, 6, 4, 2, 3, 2]) Reconstruct the input values from the unique values and counts: >>> a = np.array([1, 2, 6, 4, 2, 3, 2]) >>> values, counts = np.unique(a, return_counts=True) >>> values array([1, 2, 3, 4, 6]) >>> counts array([1, 3, 1, 1, 1]) >>> np.repeat(values, counts) array([1, 2, 2, 2, 3, 4, 6]) # original order not preserved", "score": "0.66689825"}]}
{"task_id": "mbpp_401", "code": "def add_nested_tuples(test_tup1, test_tup2):\r\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "test_list": ["assert add_nested_tuples(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((7, 10), (7, 14), (3, 10), (8, 13))", "assert add_nested_tuples(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((9, 12), (9, 16), (5, 12), (10, 15))", "assert add_nested_tuples(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((11, 14), (11, 18), (7, 14), (12, 17))"], "context": "Write a function to perform index wise addition of tuple elements in the given two nested tuples.", "function_name": "def add_nested_tuples(test_tup1, test_tup2):", "gold_generation": "res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res)", "ctxs": [{"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.7019341"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.68383753"}, {"id": "43987", "text": "Function: numpy.reference.generated.numpy.ufunc.at\nSnippet: numpy.ufunc.at method ufunc.at(a, indices, b=None, /) Performs unbuffered in place operation on operand ‘a’ for elements specified by ‘indices’. For addition ufunc, this method is equivalent to a[indices] += b, except that results are accumulated for elements that are indexed more than once. For example, a[[0,0]] += 1 will only increment the first element once because of buffering, whereas add.at(a, [0,0], 1) will increment the first element twice. New in version 1.8.0. Parameters aarray_like The array to perform in place operation on. indicesarray_like or tuple Array like index object or slice object for indexing into first operand. If first operand has multiple dimensions, indices can be a tuple of array like index objects or slice objects. barray_like Second operand for ufuncs requiring two operands. Operand must be broadcastable over first operand after indexing or slicing. Examples Set items 0 and 1 to their negative values: >>> a = np.array([1, 2, 3, 4]) >>> np.negative.at(a, [0, 1]) >>> a array([-1, -2, 3, 4]) Increment items 0 and 1, and increment item 2 twice: >>> a = np.array([1, 2, 3, 4]) >>> np.add.at(a, [0, 1, 2, 2], 1) >>> a array([2, 3, 5, 4]) Add items 0 and 1 in first array to second array, and store results in first array: >>> a = np.array([1, 2, 3, 4]) >>> b = np.array([1, 2]) >>> np.add.at(a, [0, 1], b) >>> a array([2, 4, 3, 4])", "score": "0.67836004"}, {"id": "18611", "text": "Function: python.library.collections\nSnippet: Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6}) New in version 3.2. The usual dictionary methods are available for Counter objects except for two which work differently for counters. fromkeys(iterable) This class method is not implemented for Counter objects. update([iterable-or-mapping]) Elements are counted from an iterable or added-in from another mapping (or counter). Like dict.update() but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of (key, value) pairs. Common patterns for working with Counter objects: sum(c.values()) # total of all counts c.clear() # reset all counts list(c) # list unique elements set(c) # convert to a set dict(c) # convert to a regular dictionary c.items() # convert to a list of (elem, cnt) pairs Counter(dict(list_of_pairs)) # convert from a list of (elem, cnt) pairs c.most_common()[:-n-1:-1] # n least common elements +c # remove zero and negative counts Several mathematical operations are provided for combining Counter objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. Intersection and union return the minimum and maximum of corresponding counts. Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less. >>> c = Counter(a=3, b=1) >>> d = Counter(a=1, b=2) >>> c + d # add two counters together: c[x] + d[x] Counter({'a': 4, 'b': 3}) >>> c - d # subtract (keeping only positive counts) Counter({'a': 2}) >>> c & d # intersection: min(c[x], d[x]) Counter({'a': 1, 'b': 1}) >>> c | d # union: max(c[x], d[x]) Counter({'a': 3, 'b': 2}) Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter. >>> c = Counter(a=2, b=-4) >>> +c Counter({'a': 2}) >>> -c Counter({'b': 4}) New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations. Note Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values. To help with those use cases, this section documents the minimum range and type restrictions. The Counter class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you could store anything in the value field. The most_common() method requires only that the values be orderable. For in-place operations such as c[key] += 1, the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for update() and subtract() which allow negative and zero", "score": "0.6742524"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.67275906"}]}
{"task_id": "mbpp_402", "code": "def ncr_modp(n, r, p): \r\n    C = [0 for i in range(r+1)]   \r\n    C[0] = 1\r\n    for i in range(1, n+1): \r\n        for j in range(min(i, r), 0, -1): \r\n            C[j] = (C[j] + C[j-1]) % p   \r\n    return C[r] ", "test_list": ["assert ncr_modp(10,2,13)==6", "assert ncr_modp(15,12,43)==25", "assert ncr_modp(17,9,18)==10"], "context": "Write a function to compute the value of ncr%p.", "function_name": "def ncr_modp(n, r, p):", "gold_generation": "C = [0 for i in range(r+1)]   \r\n    C[0] = 1\r\n    for i in range(1, n+1): \r\n        for j in range(min(i, r), 0, -1): \r\n            C[j] = (C[j] + C[j-1]) % p   \r\n    return C[r]", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.67246854"}, {"id": "42048", "text": "Function: numpy.reference.generated.numpy.lib.scimath.log\nSnippet: numpy.lib.scimath.log lib.scimath.log(x)[source] Compute the natural logarithm of x. Return the “principal value” (for a description of this, see numpy.log) of \\(log_e(x)\\). For real x > 0, this is a real number (log(0) returns -inf and log(np.inf) returns inf). Otherwise, the complex principle value is returned. Parameters xarray_like The value(s) whose log is (are) required. Returns outndarray or scalar The log of the x value(s). If x was a scalar, so is out, otherwise an array is returned. See also numpy.log Notes For a log() that returns NAN when real x < 0, use numpy.log (note, however, that otherwise numpy.log and this log are identical, i.e., both return -inf for x = 0, inf for x = inf, and, notably, the complex principle value if x.imag != 0). Examples >>> np.emath.log(np.exp(1)) 1.0 Negative arguments are handled “correctly” (recall that exp(log(x)) == x does not hold for real x < 0): >>> np.emath.log(-np.exp(1)) == (1 + np.pi * 1j) True", "score": "0.66378427"}, {"id": "43960", "text": "Function: numpy.reference.routines.statistics\nSnippet: Statistics Order statistics ptp(a[, axis, out, keepdims]) Range of values (maximum - minimum) along an axis. percentile(a, q[, axis, out, ...]) Compute the q-th percentile of the data along the specified axis. nanpercentile(a, q[, axis, out, ...]) Compute the qth percentile of the data along the specified axis, while ignoring nan values. quantile(a, q[, axis, out, overwrite_input, ...]) Compute the q-th quantile of the data along the specified axis. nanquantile(a, q[, axis, out, ...]) Compute the qth quantile of the data along the specified axis, while ignoring nan values. Averages and variances median(a[, axis, out, overwrite_input, keepdims]) Compute the median along the specified axis. average(a[, axis, weights, returned]) Compute the weighted average along the specified axis. mean(a[, axis, dtype, out, keepdims, where]) Compute the arithmetic mean along the specified axis. std(a[, axis, dtype, out, ddof, keepdims, where]) Compute the standard deviation along the specified axis. var(a[, axis, dtype, out, ddof, keepdims, where]) Compute the variance along the specified axis. nanmedian(a[, axis, out, overwrite_input, ...]) Compute the median along the specified axis, while ignoring NaNs. nanmean(a[, axis, dtype, out, keepdims, where]) Compute the arithmetic mean along the specified axis, ignoring NaNs. nanstd(a[, axis, dtype, out, ddof, ...]) Compute the standard deviation along the specified axis, while ignoring NaNs. nanvar(a[, axis, dtype, out, ddof, ...]) Compute the variance along the specified axis, while ignoring NaNs. Correlating corrcoef(x[, y, rowvar, bias, ddof, dtype]) Return Pearson product-moment correlation coefficients. correlate(a, v[, mode]) Cross-correlation of two 1-dimensional sequences. cov(m[, y, rowvar, bias, ddof, fweights, ...]) Estimate a covariance matrix, given data and weights. Histograms histogram(a[, bins, range, normed, weights, ...]) Compute the histogram of a dataset. histogram2d(x, y[, bins, range, normed, ...]) Compute the bi-dimensional histogram of two data samples. histogramdd(sample[, bins, range, normed, ...]) Compute the multidimensional histogram of some data. bincount(x, /[, weights, minlength]) Count number of occurrences of each value in array of non-negative ints. histogram_bin_edges(a[, bins, range, weights]) Function to calculate only the edges of the bins used by the histogram function. digitize(x, bins[, right]) Return the indices of the bins to which each value in input array belongs.", "score": "0.6591288"}, {"id": "41966", "text": "Function: numpy.reference.generated.numpy.fft.fft2\nSnippet: +0.j ]])", "score": "0.6580079"}, {"id": "19441", "text": "Function: python.library.decimal\nSnippet: >>> print(exp(Decimal(2))) 7.389056098930650227230427461 >>> print(exp(2.0)) 7.38905609893 >>> print(exp(2+0j)) (7.38905609893+0j) \"\"\" getcontext().prec += 2 i, lasts, s, fact, num = 0, 0, 1, 1, 1 while s != lasts: lasts = s i += 1 fact *= i num *= x s += num / fact getcontext().prec -= 2 return +s def cos(x): \"\"\"Return the cosine of x as measured in radians. The Taylor series approximation works best for a small value of x. For larger values, first compute x = x % (2 * pi). >>> print(cos(Decimal('0.5'))) 0.8775825618903727161162815826 >>> print(cos(0.5)) 0.87758256189 >>> print(cos(0.5+0j)) (0.87758256189+0j) \"\"\" getcontext().prec += 2 i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1 while s != lasts: lasts = s i += 2 fact *= i * (i-1) num *= x * x sign *= -1 s += num / fact * sign getcontext().prec -= 2 return +s def sin(x): \"\"\"Return the sine of x as measured in radians. The Taylor series approximation works best for a small value of x. For larger values, first compute x = x % (2 * pi). >>> print(sin(Decimal('0.5'))) 0.4794255386042030002732879352 >>> print(sin(0.5)) 0.479425538604 >>> print(sin(0.5+0j)) (0.479425538604+0j) \"\"\" getcontext().prec += 2 i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1 while s != lasts: lasts = s i += 2 fact *= i * (i-1) num *= x * x sign *= -1 s += num / fact * sign getcontext().prec -= 2 return +s Decimal FAQ Q. It is cumbersome to type decimal.Decimal('1234.5'). Is there a way to minimize typing when using the interactive interpreter? A. Some users abbreviate the constructor to just a single letter: >>> D = decimal.Decimal >>> D('1.23') + D('3.45') Decimal('4.68') Q. In a fixed-point application with two decimal places, some inputs have many places and need to be rounded. Others are not supposed to have excess digits and need to be validated. What methods should be used? A. The quantize() method rounds to a fixed number of decimal places. If the Inexact trap is set, it is also useful for validation: >>> TWOPLACES = Decimal(10) ** -2 # same as Decimal('0.01') >>> # Round to two places >>> Decimal('3.214').quantize(TWOPLACES) Decimal('3.21') >>> # Validate that a number does not exceed two places >>> Decimal('3.21').quantize(TWOPLACES, context=Context(traps=[Inexact])) Decimal('3.21') >>> Decimal('3.214').quantize(TWOPLACES, context=Context(traps=[Inexact])) Traceback (most recent call last): ... Inexact: None Q. Once I have valid two place inputs, how do I maintain that invariant throughout an application? A. Some operations like addition, subtraction, and multiplication by an integer will automatically preserve fixed point. Others operations, like division and non-integer multiplication, will change the number of decimal places and need to be followed-up with a quantize() step: >>> a = Decimal('102.72') # Initial fixed-point values >>> b = Decimal('3.17') >>> a + b # Addition preserves fixed-point Decimal('105.89') >>> a - b Decimal('99.55') >>> a * 42 # So does integer multiplication Decimal('4314.24') >>> (a * b).quantize(TWOPLACES) # Must quantize non-integer multiplication Decimal('325.62') >>> (b / a).quantize(TWOPLACES) # And quantize division Decimal('0.03')", "score": "0.65557384"}]}
{"task_id": "mbpp_403", "code": "import re\r\ndef is_valid_URL(str):\r\n\tregex = (\"((http|https)://)(www.)?\" +\r\n\t\t\t\"[a-zA-Z0-9@:%._\\\\+~#?&//=]\" +\r\n\t\t\t\"{2,256}\\\\.[a-z]\" +\r\n\t\t\t\"{2,6}\\\\b([-a-zA-Z0-9@:%\" +\r\n\t\t\t\"._\\\\+~#?&//=]*)\")\r\n\tp = re.compile(regex)\r\n\tif (str == None):\r\n\t\treturn False\r\n\tif(re.search(p, str)):\r\n\t\treturn True\r\n\telse:\r\n\t\treturn False", "test_list": ["assert is_valid_URL(\"https://www.google.com\") == True", "assert is_valid_URL(\"https:/www.gmail.com\") == False", "assert is_valid_URL(\"https:// www.redit.com\") == False"], "context": "Write a function to check if a url is valid or not using regex.", "function_name": "import re\r\ndef is_valid_URL(str):", "gold_generation": "regex = (\"((http|https)://)(www.)?\" +\r\n\t\t\t\"[a-zA-Z0-9@:%._\\\\+~#?&//=]\" +\r\n\t\t\t\"{2,256}\\\\.[a-z]\" +\r\n\t\t\t\"{2,6}\\\\b([-a-zA-Z0-9@:%\" +\r\n\t\t\t\"._\\\\+~#?&//=]*)\")\r\n\tp = re.compile(regex)\r\n\tif (str == None):\r\n\t\treturn False\r\n\tif(re.search(p, str)):\r\n\t\treturn True\r\n\telse:\r\n\t\treturn False", "ctxs": [{"id": "23326", "text": "Function: python.library.re#re.error.pattern\nSnippet: pattern The regular expression pattern.", "score": "0.69963676"}, {"id": "23304", "text": "Function: python.library.re\nSnippet: Similar to positive lookbehind assertions, the contained pattern must only match strings of some fixed length. Patterns which start with negative lookbehind assertions may match at the beginning of the string being searched. (?(id/name)yes-pattern|no-pattern) Will try to match with yes-pattern if the group with given id or name exists, and with no-pattern if it doesn’t. no-pattern is optional and can be omitted. For example, (<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$) is a poor email matching pattern, which will match with '<user@host.com>' as well as 'user@host.com', but not with '<user@host.com' nor 'user@host.com>'. The special sequences consist of '\\' and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, \\$ matches the character '$'. \\number Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, (.+) \\1 matches 'the the' or '55 55', but not 'thethe' (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the '[' and ']' of a character class, all numeric escapes are treated as characters. \\A Matches only at the start of the string. \\b Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of word characters. Note that formally, \\b is defined as the boundary between a \\w and a \\W character (or vice versa), or between \\w and the beginning/end of the string. This means that r'\\bfoo\\b' matches 'foo', 'foo.', '(foo)', 'bar foo baz' but not 'foobar' or 'foo3'. By default Unicode alphanumerics are the ones used in Unicode patterns, but this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. Inside a character range, \\b represents the backspace character, for compatibility with Python’s string literals. \\B Matches the empty string, but only when it is not at the beginning or end of a word. This means that r'py\\B' matches 'python', 'py3', 'py2', but not 'py', 'py.', or 'py!'. \\B is just the opposite of \\b, so word characters in Unicode patterns are Unicode alphanumerics or the underscore, although this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. \\d For Unicode (str) patterns: Matches any Unicode decimal digit (that is, any character in Unicode character category [Nd]). This includes [0-9], and also many other digit characters. If the ASCII flag is used only [0-9] is matched. For 8-bit (bytes) patterns: Matches any decimal digit; this is equivalent to [0-9]. \\D Matches any character which is not a decimal digit. This is the opposite of \\d. If the", "score": "0.68349177"}, {"id": "35536", "text": "Function: django.ref.validators#django.core.validators.URLValidator\nSnippet: class URLValidator(schemes=None, regex=None, message=None, code=None) A RegexValidator subclass that ensures a value looks like a URL, and raises an error code of 'invalid' if it doesn’t. Loopback addresses and reserved IP spaces are considered valid. Literal IPv6 addresses (RFC 3986#section-3.2.2) and Unicode domains are both supported. In addition to the optional arguments of its parent RegexValidator class, URLValidator accepts an extra optional attribute: schemes URL/URI scheme list to validate against. If not provided, the default list is ['http', 'https', 'ftp', 'ftps']. As a reference, the IANA website provides a full list of valid URI schemes.", "score": "0.67603815"}, {"id": "26105", "text": "Function: python.library.unittest#unittest.TestCase.assertWarnsRegex\nSnippet: assertWarnsRegex(warning, regex, callable, *args, **kwds) assertWarnsRegex(warning, regex, *, msg=None) Like assertWarns() but also tests that regex matches on the message of the triggered warning. regex may be a regular expression object or a string containing a regular expression suitable for use by re.search(). Example: self.assertWarnsRegex(DeprecationWarning, r'legacy_function\\(\\) is deprecated', legacy_function, 'XYZ') or: with self.assertWarnsRegex(RuntimeWarning, 'unsafe frobnicating'): frobnicate('/etc/passwd') New in version 3.2. Changed in version 3.3: Added the msg keyword argument when used as a context manager.", "score": "0.6732927"}, {"id": "25948", "text": "Function: python.library.unittest\nSnippet: <= than second depending on the method name. If not, the test will fail: >>> self.assertGreaterEqual(3, 4) AssertionError: \"3\" unexpectedly not greater than or equal to \"4\" New in version 3.1. assertRegex(text, regex, msg=None) assertNotRegex(text, regex, msg=None) Test that a regex search matches (or does not match) text. In case of failure, the error message will include the pattern and the text (or the pattern and the part of text that unexpectedly matched). regex may be a regular expression object or a string containing a regular expression suitable for use by re.search(). New in version 3.1: Added under the name assertRegexpMatches. Changed in version 3.2: The method assertRegexpMatches() has been renamed to assertRegex(). New in version 3.2: assertNotRegex(). New in version 3.5: The name assertNotRegexpMatches is a deprecated alias for assertNotRegex(). assertCountEqual(first, second, msg=None) Test that sequence first contains the same elements as second, regardless of their order. When they don’t, an error message listing the differences between the sequences will be generated. Duplicate elements are not ignored when comparing first and second. It verifies whether each element has the same count in both sequences. Equivalent to: assertEqual(Counter(list(first)), Counter(list(second))) but works with sequences of unhashable objects as well. New in version 3.2. The assertEqual() method dispatches the equality check for objects of the same type to different type-specific methods. These methods are already implemented for most of the built-in types, but it’s also possible to register new methods using addTypeEqualityFunc(): addTypeEqualityFunc(typeobj, function) Registers a type-specific method called by assertEqual() to check if two objects of exactly the same typeobj (not subclasses) compare equal. function must take two positional arguments and a third msg=None keyword argument just as assertEqual() does. It must raise self.failureException(msg) when inequality between the first two parameters is detected – possibly providing useful information and explaining the inequalities in details in the error message. New in version 3.1. The list of type-specific methods automatically used by assertEqual() are summarized in the following table. Note that it’s usually not necessary to invoke these methods directly. Method Used to compare New in assertMultiLineEqual(a, b) strings 3.1 assertSequenceEqual(a, b) sequences 3.1 assertListEqual(a, b) lists 3.1 assertTupleEqual(a, b) tuples 3.1 assertSetEqual(a, b) sets or frozensets 3.1 assertDictEqual(a, b) dicts 3.1 assertMultiLineEqual(first, second, msg=None) Test that the multiline string first is equal to the string second. When not equal a diff of the two strings highlighting the differences will be included in the error message. This method is used by default when comparing strings with assertEqual(). New in version 3.1. assertSequenceEqual(first, second, msg=None, seq_type=None) Tests that two sequences are equal. If a seq_type is supplied, both first and second must be instances of seq_type or a failure will be raised. If the sequences are different an error message is constructed that shows the difference between the two. This method is not called directly by assertEqual(), but it’s used to implement assertListEqual() and assertTupleEqual(). New in version 3.1. assertListEqual(first, second, msg=None) assertTupleEqual(first, second, msg=None) Tests that two lists or tuples are equal. If", "score": "0.66736805"}]}
{"task_id": "mbpp_404", "code": "def minimum(a,b):   \r\n    if a <= b: \r\n        return a \r\n    else: \r\n        return b ", "test_list": ["assert minimum(1,2) == 1", "assert minimum(-5,-4) == -5", "assert minimum(0,0) == 0"], "context": "Write a python function to find the minimum of two numbers.", "function_name": "def minimum(a,b):", "gold_generation": "if a <= b: \r\n        return a \r\n    else: \r\n        return b", "ctxs": [{"id": "19492", "text": "Function: python.library.decimal#decimal.Context.min\nSnippet: min(x, y) Compares two values numerically and returns the minimum.", "score": "0.77103794"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6961668"}, {"id": "21889", "text": "Function: python.library.functions#min\nSnippet: min(iterable, *[, key, default]) min(arg1, arg2, *args[, key]) Return the smallest item in an iterable or the smallest of two or more arguments. If one positional argument is provided, it should be an iterable. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.68366194"}, {"id": "13013", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos#sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.6816376"}, {"id": "19589", "text": "Function: python.library.decimal#decimal.MIN_ETINY\nSnippet: decimal.MIN_ETINY", "score": "0.6800051"}]}
{"task_id": "mbpp_405", "code": "def check_tuplex(tuplex,tuple1): \r\n  if tuple1 in tuplex:\r\n    return True\r\n  else:\r\n     return False", "test_list": ["assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'r')==True", "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'5')==False", "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\",\"e\"),3)==True"], "context": "Write a function to check whether an element exists within a tuple.", "function_name": "def check_tuplex(tuplex,tuple1):", "gold_generation": "if tuple1 in tuplex:\r\n    return True\r\n  else:\r\n     return False", "ctxs": [{"id": "25364", "text": "Function: python.library.tkinter.ttk#tkinter.ttk.Treeview.exists\nSnippet: exists(item) Returns True if the specified item is present in the tree.", "score": "0.7037699"}, {"id": "17578", "text": "Function: python.library.functions#any\nSnippet: any(iterable) Return True if any element of the iterable is true. If the iterable is empty, return False. Equivalent to: def any(iterable): for element in iterable: if element: return True return False", "score": "0.6947669"}, {"id": "17577", "text": "Function: python.library.functions#all\nSnippet: all(iterable) Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to: def all(iterable): for element in iterable: if not element: return False return True", "score": "0.69006336"}, {"id": "35962", "text": "Function: django.ref.models.querysets#django.db.models.query.QuerySet.exists\nSnippet: exists()", "score": "0.68993324"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.6864087"}]}
{"task_id": "mbpp_406", "code": "def find_Parity(x): \r\n    y = x ^ (x >> 1); \r\n    y = y ^ (y >> 2); \r\n    y = y ^ (y >> 4); \r\n    y = y ^ (y >> 8); \r\n    y = y ^ (y >> 16); \r\n    if (y & 1): \r\n        return (\"Odd Parity\"); \r\n    return (\"Even Parity\"); ", "test_list": ["assert find_Parity(12) == \"Even Parity\"", "assert find_Parity(7) == \"Odd Parity\"", "assert find_Parity(10) == \"Even Parity\""], "context": "Write a python function to find the parity of a given number.", "function_name": "def find_Parity(x):", "gold_generation": "y = x ^ (x >> 1); \r\n    y = y ^ (y >> 2); \r\n    y = y ^ (y >> 4); \r\n    y = y ^ (y >> 8); \r\n    y = y ^ (y >> 16); \r\n    if (y & 1): \r\n        return (\"Odd Parity\"); \r\n    return (\"Even Parity\");", "ctxs": [{"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.6802718"}, {"id": "21776", "text": "Function: python.library.math\nSnippet: (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9. Note that frexp() and modf() have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 2**52 necessarily has no fractional bits. Power and logarithmic functions math.exp(x) Return e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). math.expm1(x) Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision: >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.0000050000069649e-05 >>> expm1(1e-5) # result accurate to full precision 1.0000050000166668e-05 New in version 3.2. math.log(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). math.log1p(x) Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. math.log2(x) Return the base-2 logarithm of x. This is usually more accurate than log(x, 2). New in version 3.3. See also int.bit_length() returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. math.log10(x) Return the base-10 logarithm of x. This is usually more accurate than log(x, 10). math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", "score": "0.67662764"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.67328644"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.6726512"}, {"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.6725126"}]}
{"task_id": "mbpp_407", "code": "def rearrange_bigger(n):\r\n    nums = list(str(n))\r\n    for i in range(len(nums)-2,-1,-1):\r\n        if nums[i] < nums[i+1]:\r\n            z = nums[i:]\r\n            y = min(filter(lambda x: x > z[0], z))\r\n            z.remove(y)\r\n            z.sort()\r\n            nums[i:] = [y] + z\r\n            return int(\"\".join(nums))\r\n    return False", "test_list": ["assert rearrange_bigger(12)==21", "assert rearrange_bigger(10)==False", "assert rearrange_bigger(102)==120"], "context": "Write a function to create the next bigger number by rearranging the digits of a given number.", "function_name": "def rearrange_bigger(n):", "gold_generation": "nums = list(str(n))\r\n    for i in range(len(nums)-2,-1,-1):\r\n        if nums[i] < nums[i+1]:\r\n            z = nums[i:]\r\n            y = min(filter(lambda x: x > z[0], z))\r\n            z.remove(y)\r\n            z.sort()\r\n            nums[i:] = [y] + z\r\n            return int(\"\".join(nums))\r\n    return False", "ctxs": [{"id": "19497", "text": "Function: python.library.decimal#decimal.Context.next_plus\nSnippet: next_plus(x) Returns the smallest representable number larger than x.", "score": "0.6822657"}, {"id": "19496", "text": "Function: python.library.decimal#decimal.Context.next_minus\nSnippet: next_minus(x) Returns the largest representable number smaller than x.", "score": "0.67282164"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6592972"}, {"id": "19559", "text": "Function: python.library.decimal#decimal.Decimal.next_plus\nSnippet: next_plus(context=None) Return the smallest number representable in the given context (or in the current thread’s context if no context is given) that is larger than the given operand.", "score": "0.6532297"}, {"id": "19558", "text": "Function: python.library.decimal#decimal.Decimal.next_minus\nSnippet: next_minus(context=None) Return the largest number representable in the given context (or in the current thread’s context if no context is given) that is smaller than the given operand.", "score": "0.65230453"}]}
{"task_id": "mbpp_408", "code": "import heapq\r\ndef k_smallest_pairs(nums1, nums2, k):\r\n   queue = []\r\n   def push(i, j):\r\n       if i < len(nums1) and j < len(nums2):\r\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\r\n   push(0, 0)\r\n   pairs = []\r\n   while queue and len(pairs) < k:\r\n       _, i, j = heapq.heappop(queue)\r\n       pairs.append([nums1[i], nums2[j]])\r\n       push(i, j + 1)\r\n       if j == 0:\r\n           push(i + 1, 0)\r\n   return pairs", "test_list": ["assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]", "assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]", "assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]"], "context": "Write a function to find k number of pairs which consist of one element from the first array and one element from the second array.", "function_name": "import heapq\r\ndef k_smallest_pairs(nums1, nums2, k):", "gold_generation": "queue = []\r\n   def push(i, j):\r\n       if i < len(nums1) and j < len(nums2):\r\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\r\n   push(0, 0)\r\n   pairs = []\r\n   while queue and len(pairs) < k:\r\n       _, i, j = heapq.heappop(queue)\r\n       pairs.append([nums1[i], nums2[j]])\r\n       push(i, j + 1)\r\n       if j == 0:\r\n           push(i + 1, 0)\r\n   return pairs", "ctxs": [{"id": "11665", "text": "Function: sklearn.modules.generated.sklearn.metrics.pairwise_distances#sklearn.metrics.pairwise_distances\nSnippet: passed directly to the distance function. If using a scipy.spatial.distance metric, the parameters are still metric dependent. See the scipy docs for usage examples. Returns Dndarray of shape (n_samples_X, n_samples_X) or (n_samples_X, n_samples_Y) A distance matrix D such that D_{i, j} is the distance between the ith and jth vectors of the given matrix X, if Y is None. If Y is not None, then D_{i, j} is the distance between the ith array from X and the jth array from Y. See also pairwise_distances_chunked Performs the same calculation as this function, but returns a generator of chunks of the distance matrix, in order to limit memory usage. paired_distances Computes the distances between corresponding elements of two arrays.", "score": "0.6684133"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.6633737"}, {"id": "43258", "text": "Function: numpy.reference.generated.numpy.union1d\nSnippet: numpy.union1d numpy.union1d(ar1, ar2)[source] Find the union of two arrays. Return the unique, sorted array of values that are in either of the two input arrays. Parameters ar1, ar2array_like Input arrays. They are flattened if they are not already 1D. Returns union1dndarray Unique, sorted union of the input arrays. See also numpy.lib.arraysetops Module with a number of other functions for performing set operations on arrays. Examples >>> np.union1d([-1, 0, 1], [-2, 0, 2]) array([-2, -1, 0, 1, 2]) To find the union of more than two arrays, use functools.reduce: >>> from functools import reduce >>> reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2])) array([1, 2, 3, 4, 6])", "score": "0.65943605"}, {"id": "12715", "text": "Function: sklearn.modules.generated.sklearn.metrics.pairwise_distances\nSnippet: are passed directly to the distance function. If using a scipy.spatial.distance metric, the parameters are still metric dependent. See the scipy docs for usage examples. Returns Dndarray of shape (n_samples_X, n_samples_X) or (n_samples_X, n_samples_Y) A distance matrix D such that D_{i, j} is the distance between the ith and jth vectors of the given matrix X, if Y is None. If Y is not None, then D_{i, j} is the distance between the ith array from X and the jth array from Y. See also pairwise_distances_chunked Performs the same calculation as this function, but returns a generator of chunks of the distance matrix, in order to limit memory usage. paired_distances Computes the distances between corresponding elements of two arrays. Examples using sklearn.metrics.pairwise_distances Agglomerative clustering with different metrics", "score": "0.65744054"}, {"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.65590936"}]}
{"task_id": "mbpp_409", "code": "def min_product_tuple(list1):\r\n    result_min = min([abs(x * y) for x, y in list1] )\r\n    return result_min", "test_list": ["assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8", "assert min_product_tuple([(10,20), (15,2), (5,10)] )==30", "assert min_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==100"], "context": "Write a function to find the minimum product from the pairs of tuples within a given list.", "function_name": "def min_product_tuple(list1):", "gold_generation": "result_min = min([abs(x * y) for x, y in list1] )\r\n    return result_min", "ctxs": [{"id": "21311", "text": "Function: python.library.itertools#itertools.product\nSnippet: itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs.", "score": "0.68736875"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6680571"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.65947396"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.65833664"}, {"id": "21889", "text": "Function: python.library.functions#min\nSnippet: min(iterable, *[, key, default]) min(arg1, arg2, *args[, key]) Return the smallest item in an iterable or the smallest of two or more arguments. If one positional argument is provided, it should be an iterable. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.6555661"}]}
{"task_id": "mbpp_410", "code": "def min_val(listval):\r\n     min_val = min(i for i in listval if isinstance(i, int))\r\n     return min_val", "test_list": ["assert min_val(['Python', 3, 2, 4, 5, 'version'])==2", "assert min_val(['Python', 15, 20, 25])==15", "assert min_val(['Python', 30, 20, 40, 50, 'version'])==20"], "context": "Write a function to find the minimum value in a given heterogeneous list.", "function_name": "def min_val(listval):", "gold_generation": "min_val = min(i for i in listval if isinstance(i, int))\r\n     return min_val", "ctxs": [{"id": "19492", "text": "Function: python.library.decimal#decimal.Context.min\nSnippet: min(x, y) Compares two values numerically and returns the minimum.", "score": "0.7036465"}, {"id": "43859", "text": "Function: numpy.reference.generated.numpy.recarray.min\nSnippet: numpy.recarray.min method recarray.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the minimum along a given axis. Refer to numpy.amin for full documentation. See also numpy.amin equivalent function", "score": "0.686577"}, {"id": "13013", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos#sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.6831002"}, {"id": "20489", "text": "Function: python.library.heapq#heapq.nsmallest\nSnippet: heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n].", "score": "0.6828362"}, {"id": "43023", "text": "Function: numpy.reference.generated.numpy.minimum\nSnippet: numpy.minimum numpy.minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'minimum'> Element-wise minimum of array elements. Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The minimum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also maximum Element-wise maximum of two arrays, propagates NaNs. fmin Element-wise minimum of two arrays, ignores NaNs. amin The minimum value of an array along a given axis, propagates NaNs. nanmin The minimum value of an array along a given axis, ignores NaNs. fmax, amax, nanmax Notes The minimum is equivalent to np.where(x1 <= x2, x1, x2) when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting. Examples >>> np.minimum([2, 3, 4], [1, 5, 2]) array([1, 3, 2]) >>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting array([[ 0.5, 0. ], [ 0. , 1. ]]) >>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.minimum(-np.Inf, 1) -inf", "score": "0.68067765"}]}
{"task_id": "mbpp_411", "code": "import re\r\ndef snake_to_camel(word):\r\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))", "test_list": ["assert snake_to_camel('android_tv') == 'AndroidTv'", "assert snake_to_camel('google_pixel') == 'GooglePixel'", "assert snake_to_camel('apple_watch') == 'AppleWatch'"], "context": "Write a function to convert the given snake case string to camel case string by using regex.", "function_name": "import re\r\ndef snake_to_camel(word):", "gold_generation": "return ''.join(x.capitalize() or '_' for x in word.split('_'))", "ctxs": [{"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.69818944"}, {"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.68191963"}, {"id": "23369", "text": "Function: python.library.re#re.sub\nSnippet: re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern are replaced only when not adjacent to a previous empty match, so sub('x*', '-', 'abxd') returns '-a-b--d-'. In string-type repl arguments, in addition to the character escapes and backreferences described above, \\g<name> will use the substring matched by the group named name, as defined by the (?P<name>...) syntax. \\g<number> uses the corresponding group number; \\g<2> is therefore equivalent to \\2, but isn’t ambiguous in a replacement such as \\g<2>0. \\20 would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character '0'. The backreference \\g<0> substitutes in the entire substring matched by the RE. Changed in version 3.1: Added the optional flags argument. Changed in version 3.5: Unmatched groups are replaced with an empty string. Changed in version 3.6: Unknown escapes in pattern consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Unknown escapes in repl consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Empty matches for the pattern are replaced when adjacent to a previous non-empty match.", "score": "0.6815836"}, {"id": "23341", "text": "Function: python.library.re#re.Match.group\nSnippet: Match.group([group1, ...]) Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an IndexError exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is None. If a group is contained in a part of the pattern that matched multiple times, the last match is returned. >>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\") >>> m.group(0) # The entire match 'Isaac Newton' >>> m.group(1) # The first parenthesized subgroup. 'Isaac' >>> m.group(2) # The second parenthesized subgroup. 'Newton' >>> m.group(1, 2) # Multiple arguments give us a tuple. ('Isaac', 'Newton') If the regular expression uses the (?P<name>...) syntax, the groupN arguments may also be strings identifying groups by their group name. If a string argument is not used as a group name in the pattern, an IndexError exception is raised. A moderately complicated example: >>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm Reynolds\") >>> m.group('first_name') 'Malcolm' >>> m.group('last_name') 'Reynolds' Named groups can also be referred to by their index: >>> m.group(1) 'Malcolm' >>> m.group(2) 'Reynolds' If a group matches multiple times, only the last match is accessible: >>> m = re.match(r\"(..)+\", \"a1b2c3\") # Matches 3 times. >>> m.group(1) # Returns only the last match. 'c3'", "score": "0.6745503"}, {"id": "23326", "text": "Function: python.library.re#re.error.pattern\nSnippet: pattern The regular expression pattern.", "score": "0.6729321"}]}
{"task_id": "mbpp_412", "code": "def remove_odd(l):\r\n    for i in l:\r\n        if i % 2 != 0:\r\n            l.remove(i)\r\n    return l", "test_list": ["assert remove_odd([1,2,3]) == [2]", "assert remove_odd([2,4,6]) == [2,4,6]", "assert remove_odd([10,20,3]) == [10,20]"], "context": "Write a python function to remove odd numbers from a given list.", "function_name": "def remove_odd(l):", "gold_generation": "for i in l:\r\n        if i % 2 != 0:\r\n            l.remove(i)\r\n    return l", "ctxs": [{"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.68516666"}, {"id": "25738", "text": "Function: python.library.stdtypes\nSnippet: from s (2) s.remove(x) remove the first item from s where s[i] is equal to x (3) s.reverse() reverses the items of s in place (4) Notes: t must have the same length as the slice it is replacing. The optional argument i defaults to -1, so that by default the last item is removed and returned. remove() raises ValueError when x is not found in s. The reverse() method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence. clear() and copy() are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as dict and set). copy() is not part of the collections.abc.MutableSequence ABC, but most concrete mutable sequence classes provide it. New in version 3.3: clear() and copy() methods. The value n is an integer, or an object implementing __index__(). Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for s * n under Common Sequence Operations. Lists Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). class list([iterable]) Lists may be constructed in several ways: Using a pair of square brackets to denote the empty list: [] Using square brackets, separating items with commas: [a], [a, b, c] Using a list comprehension: [x for x in iterable] Using the type constructor: list() or list(iterable) The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to iterable[:]. For example, list('abc') returns ['a', 'b', 'c'] and list( (1, 2, 3) ) returns [1, 2, 3]. If no argument is given, the constructor creates a new empty list, []. Many other operations also produce lists, including the sorted() built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is", "score": "0.6766088"}, {"id": "25756", "text": "Function: python.library.stdtypes\nSnippet: binary sequence of byte values to remove may be any bytes-like object. See removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> b'Monty Python'.rstrip(b' Python') b'M' >>> b'Monty Python'.removesuffix(b' Python') b'Monty' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3'] bytes.strip([chars]) bytearray.strip([chars]) Return a copy of the sequence with specified leading and trailing bytes removed. The chars argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters. If omitted or None, the chars argument defaults to removing ASCII whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> b' spacious '.strip() b'spacious' >>> b'www.example.com'.strip(b'cmowz.') b'example' The binary sequence of byte values to remove may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.capitalize() bytearray.capitalize() Return a copy of the sequence with each byte interpreted as an ASCII character, and the first byte capitalized and the rest", "score": "0.6699402"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.64892495"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.64573014"}]}
{"task_id": "mbpp_413", "code": "def extract_nth_element(list1, n):\r\n    result = [x[n] for x in list1]\r\n    return result", "test_list": ["assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']", "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,2)==[99, 96, 94, 98]", "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)],1)==[98, 97, 91, 94]"], "context": "Write a function to extract the nth element from a given list of tuples.", "function_name": "def extract_nth_element(list1, n):", "gold_generation": "result = [x[n] for x in list1]\r\n    return result", "ctxs": [{"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.70108956"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6964918"}, {"id": "20295", "text": "Function: python.library.functions\nSnippet: aggregates elements from each of the iterables. Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator. Equivalent to: def zip(*iterables): # zip('ABCD', 'xy') --> Ax By sentinel = object() iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using zip(*[iter(s)]*n). This repeats the same iterator n times so that each output tuple has the result of n calls to the iterator. This has the effect of dividing the input into n-length chunks. zip() should only be used with unequal length inputs when you don’t care about trailing, unmatched values from the longer iterables. If those values are important, use itertools.zip_longest() instead. zip() in conjunction with the * operator can be used to unzip a list: >>> x = [1, 2, 3] >>> y = [4, 5, 6] >>> zipped = zip(x, y) >>> list(zipped) [(1, 4), (2, 5), (3, 6)] >>> x2, y2 = zip(*zip(x, y)) >>> x == list(x2) and y == list(y2) True __import__(name, globals=None, locals=None, fromlist=(), level=0) Note This is an advanced function that is not needed in everyday Python programming, unlike importlib.import_module(). This function is invoked by the import statement. It can be replaced (by importing the builtins module and assigning to builtins.__import__) in order to change semantics of the import statement, but doing so is strongly discouraged as it is usually simpler to use import hooks (see PEP 302) to attain the same goals and does not cause issues with code which assumes the default import implementation is in use. Direct use of __import__() is also discouraged in favor of importlib.import_module(). The function imports the module name, potentially using the given globals and locals to determine how to interpret the name in a package context. The fromlist gives the names of objects or submodules that should be imported from the module given by name. The standard implementation does not use its locals argument at all, and uses its globals only to determine the package context of the import statement. level specifies whether to use absolute or relative imports. 0 (the default) means only perform absolute imports. Positive values for level indicate the number of parent directories to search relative to the directory of the module calling __import__() (see PEP 328 for the details). When the name variable is of the form package.module, normally, the top-level package (the name up till the first dot) is returned, not the module named by name. However, when a non-empty fromlist argument is given, the module named by name is returned. For example, the statement import spam results", "score": "0.6964281"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.69357973"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.68913877"}]}
{"task_id": "mbpp_414", "code": "def overlapping(list1,list2):  \r\n    c=0\r\n    d=0\r\n    for i in list1: \r\n        c+=1\r\n    for i in list2: \r\n        d+=1\r\n    for i in range(0,c): \r\n        for j in range(0,d): \r\n            if(list1[i]==list2[j]): \r\n                return 1\r\n    return 0", "test_list": ["assert overlapping([1,2,3,4,5],[6,7,8,9]) == False", "assert overlapping([1,2,3],[4,5,6]) == False", "assert overlapping([1,4,5],[1,4,5]) == True"], "context": "Write a python function to check whether the value exists in a sequence or not.", "function_name": "def overlapping(list1,list2):", "gold_generation": "c=0\r\n    d=0\r\n    for i in list1: \r\n        c+=1\r\n    for i in list2: \r\n        d+=1\r\n    for i in range(0,c): \r\n        for j in range(0,d): \r\n            if(list1[i]==list2[j]): \r\n                return 1\r\n    return 0", "ctxs": [{"id": "42785", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.is_sequence\nSnippet: numpy.distutils.misc_util.is_sequence(seq)[source]", "score": "0.7610506"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.71262866"}, {"id": "15209", "text": "Function: pandas.reference.api.pandas.series.isin\nSnippet: pandas.Series.isin Series.isin(values)[source] Whether elements in Series are contained in values. Return a boolean Series showing whether each element in the Series matches an element in the passed sequence of values exactly. Parameters values:set or list-like The sequence of values to test. Passing in a single string will raise a TypeError. Instead, turn a single string into a list of one element. Returns Series Series of booleans indicating if each element is in values. Raises TypeError If values is a string See also DataFrame.isin Equivalent method on DataFrame. Examples >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama', ... 'hippo'], name='animal') >>> s.isin(['cow', 'lama']) 0 True 1 True 2 True 3 False 4 True 5 False Name: animal, dtype: bool To invert the boolean values, use the ~ operator: >>> ~s.isin(['cow', 'lama']) 0 False 1 False 2 False 3 True 4 False 5 True Name: animal, dtype: bool Passing a single string as s.isin('lama') will raise an error. Use a list of one element instead: >>> s.isin(['lama']) 0 True 1 False 2 True 3 False 4 True 5 False Name: animal, dtype: bool Strings and integers are distinct and are therefore not comparable: >>> pd.Series([1]).isin(['1']) 0 False dtype: bool >>> pd.Series([1.1]).isin(['1.1']) 0 False dtype: bool", "score": "0.7027247"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.70050216"}, {"id": "19643", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: class difflib.SequenceMatcher(isjunk=None, a='', b='', autojunk=True) Optional argument isjunk must be None (the default) or a one-argument function that takes a sequence element and returns true if and only if the element is “junk” and should be ignored. Passing None for isjunk is equivalent to passing lambda x: False; in other words, no elements are ignored. For example, pass: lambda x: x in \" \\t\" if you’re comparing lines as sequences of characters, and don’t want to synch up on blanks or hard tabs. The optional arguments a and b are sequences to be compared; both default to empty strings. The elements of both sequences must be hashable. The optional argument autojunk can be used to disable the automatic junk heuristic. New in version 3.2: The autojunk parameter. SequenceMatcher objects get three data attributes: bjunk is the set of elements of b for which isjunk is True; bpopular is the set of non-junk elements considered popular by the heuristic (if it is not disabled); b2j is a dict mapping the remaining elements of b to a list of positions where they occur. All three are reset whenever b is reset with set_seqs() or set_seq2(). New in version 3.2: The bjunk and bpopular attributes. SequenceMatcher objects have the following methods: set_seqs(a, b) Set the two sequences to be compared. SequenceMatcher computes and caches detailed information about the second sequence, so if you want to compare one sequence against many sequences, use set_seq2() to set the commonly used sequence once and call set_seq1() repeatedly, once for each of the other sequences. set_seq1(a) Set the first sequence to be compared. The second sequence to be compared is not changed. set_seq2(b) Set the second sequence to be compared. The first sequence to be compared is not changed. find_longest_match(alo=0, ahi=None, blo=0, bhi=None) Find longest matching block in a[alo:ahi] and b[blo:bhi]. If isjunk was omitted or None, find_longest_match() returns (i, j, k) such that a[i:i+k] is equal to b[j:j+k], where alo <= i <= i+k <= ahi and blo <= j <= j+k <= bhi. For all (i', j', k') meeting those conditions, the additional conditions k >= k', i <= i', and if i == i', j <= j' are also met. In other words, of all maximal matching blocks, return one that starts earliest in a, and of all those maximal matching blocks that start earliest in a, return the one that starts earliest in b. >>> s = SequenceMatcher(None, \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=0, b=4, size=5) If isjunk was provided, first the longest matching block is determined as above, but with the additional restriction that no junk element appears in the block. Then that block is extended as far as possible by matching (only) junk elements on both sides. So the resulting block never matches on junk except as identical junk happens to be adjacent to an interesting match. Here’s the same example as before, but considering blanks to be junk. That prevents ' abcd' from matching the '", "score": "0.70033133"}]}
{"task_id": "mbpp_415", "code": "def max_Product(arr): \r\n    arr_len = len(arr) \r\n    if (arr_len < 2): \r\n        return (\"No pairs exists\")           \r\n    x = arr[0]; y = arr[1]      \r\n    for i in range(0,arr_len): \r\n        for j in range(i + 1,arr_len): \r\n            if (arr[i] * arr[j] > x * y): \r\n                x = arr[i]; y = arr[j] \r\n    return x,y    ", "test_list": ["assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)", "assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)", "assert max_Product([1,2,3]) == (2,3)"], "context": "Write a python function to find a pair with highest product from a given array of integers.", "function_name": "def max_Product(arr):", "gold_generation": "arr_len = len(arr) \r\n    if (arr_len < 2): \r\n        return (\"No pairs exists\")           \r\n    x = arr[0]; y = arr[1]      \r\n    for i in range(0,arr_len): \r\n        for j in range(i + 1,arr_len): \r\n            if (arr[i] * arr[j] > x * y): \r\n                x = arr[i]; y = arr[j] \r\n    return x,y", "ctxs": [{"id": "43865", "text": "Function: numpy.reference.generated.numpy.recarray.prod\nSnippet: numpy.recarray.prod method recarray.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True) Return the product of the array elements over the given axis Refer to numpy.prod for full documentation. See also numpy.prod equivalent function", "score": "0.6663518"}, {"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.65837353"}, {"id": "11665", "text": "Function: sklearn.modules.generated.sklearn.metrics.pairwise_distances#sklearn.metrics.pairwise_distances\nSnippet: passed directly to the distance function. If using a scipy.spatial.distance metric, the parameters are still metric dependent. See the scipy docs for usage examples. Returns Dndarray of shape (n_samples_X, n_samples_X) or (n_samples_X, n_samples_Y) A distance matrix D such that D_{i, j} is the distance between the ith and jth vectors of the given matrix X, if Y is None. If Y is not None, then D_{i, j} is the distance between the ith array from X and the jth array from Y. See also pairwise_distances_chunked Performs the same calculation as this function, but returns a generator of chunks of the distance matrix, in order to limit memory usage. paired_distances Computes the distances between corresponding elements of two arrays.", "score": "0.65443426"}, {"id": "20488", "text": "Function: python.library.heapq#heapq.nlargest\nSnippet: heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n].", "score": "0.6535687"}, {"id": "43185", "text": "Function: numpy.reference.generated.numpy.shares_memory\nSnippet: numpy.shares_memory numpy.shares_memory(a, b, /, max_work=None) Determine if two arrays share memory. Warning This function can be exponentially slow for some inputs, unless max_work is set to a finite number or MAY_SHARE_BOUNDS. If in doubt, use numpy.may_share_memory instead. Parameters a, bndarray Input arrays max_workint, optional Effort to spend on solving the overlap problem (maximum number of candidate solutions to consider). The following special values are recognized: max_work=MAY_SHARE_EXACT (default) The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays. Finding the exact solution may take extremely long in some cases. max_work=MAY_SHARE_BOUNDS Only the memory bounds of a and b are checked. Returns outbool Raises numpy.TooHardError Exceeded max_work. See also may_share_memory Examples >>> x = np.array([1, 2, 3, 4]) >>> np.shares_memory(x, np.array([5, 6, 7])) False >>> np.shares_memory(x[::2], x) True >>> np.shares_memory(x[::2], x[1::2]) False Checking whether two arrays share memory is NP-complete, and runtime may increase exponentially in the number of dimensions. Hence, max_work should generally be set to a finite number, as it is possible to construct examples that take extremely long to run: >>> from numpy.lib.stride_tricks import as_strided >>> x = np.zeros([192163377], dtype=np.int8) >>> x1 = as_strided(x, strides=(36674, 61119, 85569), shape=(1049, 1049, 1049)) >>> x2 = as_strided(x[64023025:], strides=(12223, 12224, 1), shape=(1049, 1049, 1)) >>> np.shares_memory(x1, x2, max_work=1000) Traceback (most recent call last): ... numpy.TooHardError: Exceeded max_work Running np.shares_memory(x1, x2) without max_work set takes around 1 minute for this case. It is possible to find problems that take still significantly longer.", "score": "0.6535004"}]}
{"task_id": "mbpp_416", "code": "MAX = 1000000\r\ndef breakSum(n): \r\n\tdp = [0]*(n+1) \r\n\tdp[0] = 0\r\n\tdp[1] = 1\r\n\tfor i in range(2, n+1): \r\n\t\tdp[i] = max(dp[int(i/2)] + dp[int(i/3)] + dp[int(i/4)], i); \r\n\treturn dp[n]", "test_list": ["assert breakSum(12) == 13", "assert breakSum(24) == 27", "assert breakSum(23) == 23"], "context": "Write a function to find the maximum sum we can make by dividing number in three parts recursively and summing them up together for the given number.", "function_name": "MAX = 1000000\r\ndef breakSum(n):", "gold_generation": "dp = [0]*(n+1) \r\n\tdp[0] = 0\r\n\tdp[1] = 1\r\n\tfor i in range(2, n+1): \r\n\t\tdp[i] = max(dp[int(i/2)] + dp[int(i/3)] + dp[int(i/4)], i); \r\n\treturn dp[n]", "ctxs": [{"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.65158045"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.6515295"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.65090966"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6435493"}, {"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.6362101"}]}
{"task_id": "mbpp_417", "code": "def group_tuples(Input): \r\n\tout = {} \r\n\tfor elem in Input: \r\n\t\ttry: \r\n\t\t\tout[elem[0]].extend(elem[1:]) \r\n\t\texcept KeyError: \r\n\t\t\tout[elem[0]] = list(elem) \r\n\treturn [tuple(values) for values in out.values()] ", "test_list": ["assert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]", "assert group_tuples([('a', 'b'), ('a', 'c'), ('d', 'e')]) == [('a', 'b', 'c'), ('d', 'e')]", "assert group_tuples([('f', 'g'), ('f', 'g'), ('h', 'i')]) == [('f', 'g', 'g'), ('h', 'i')]"], "context": "Write a function to find common first element in given list of tuple.", "function_name": "def group_tuples(Input):", "gold_generation": "out = {} \r\n\tfor elem in Input: \r\n\t\ttry: \r\n\t\t\tout[elem[0]].extend(elem[1:]) \r\n\t\texcept KeyError: \r\n\t\t\tout[elem[0]] = list(elem) \r\n\treturn [tuple(values) for values in out.values()]", "ctxs": [{"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.67508733"}, {"id": "42824", "text": "Function: numpy.reference.generated.numpy.find_common_type\nSnippet: numpy.find_common_type numpy.find_common_type(array_types, scalar_types)[source] Determine common type following standard coercion rules. Parameters array_typessequence A list of dtypes or dtype convertible objects representing arrays. scalar_typessequence A list of dtypes or dtype convertible objects representing scalars. Returns datatypedtype The common data type, which is the maximum of array_types ignoring scalar_types, unless the maximum of scalar_types is of a different kind (dtype.kind). If the kind is not understood, then None is returned. See also dtype, common_type, can_cast, mintypecode Examples >>> np.find_common_type([], [np.int64, np.float32, complex]) dtype('complex128') >>> np.find_common_type([np.int64, np.float32], []) dtype('float64') The standard casting rules ensure that a scalar cannot up-cast an array unless the scalar is of a fundamentally different kind of data (i.e. under a different hierarchy in the data type hierarchy) then the array: >>> np.find_common_type([np.float32], [np.int64, np.float64]) dtype('float32') Complex is of a different type, so it up-casts the float in the array_types argument: >>> np.find_common_type([np.float32], [complex]) dtype('complex128') Type specifier strings are convertible to dtypes and can therefore be used instead of dtypes: >>> np.find_common_type(['f4', 'f4', 'i4'], ['c8']) dtype('complex128')", "score": "0.67148304"}, {"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.6641284"}, {"id": "18655", "text": "Function: python.library.collections#collections.Counter.most_common\nSnippet: most_common([n]) Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered in the order first encountered: >>> Counter('abracadabra').most_common(3) [('a', 5), ('b', 2), ('r', 2)]", "score": "0.66216415"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.6619772"}]}
{"task_id": "mbpp_418", "code": "def Find_Max(lst): \r\n    maxList = max((x) for x in lst) \r\n    return maxList", "test_list": ["assert Find_Max([['A'],['A','B'],['A','B','C']]) == ['A','B','C']", "assert Find_Max([[1],[1,2],[1,2,3]]) == [1,2,3]", "assert Find_Max([[1,1],[1,2,3],[1,5,6,1]]) == [1,5,6,1]"], "context": "Write a python function to find the sublist having maximum length.", "function_name": "def Find_Max(lst):", "gold_generation": "maxList = max((x) for x in lst) \r\n    return maxList", "ctxs": [{"id": "18944", "text": "Function: python.library.ctypes#ctypes.Array._length_\nSnippet: _length_ A positive integer specifying the number of elements in the array. Out-of-range subscripts result in an IndexError. Will be returned by len().", "score": "0.69615483"}, {"id": "21919", "text": "Function: python.library.mmap#mmap.mmap.find\nSnippet: find(sub[, start[, end]]) Returns the lowest index in the object where the subsequence sub is found, such that sub is contained in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. Returns -1 on failure. Changed in version 3.5: Writable bytes-like object is now accepted.", "score": "0.69569784"}, {"id": "19646", "text": "Function: python.library.difflib#difflib.SequenceMatcher.find_longest_match\nSnippet: find_longest_match(alo=0, ahi=None, blo=0, bhi=None) Find longest matching block in a[alo:ahi] and b[blo:bhi]. If isjunk was omitted or None, find_longest_match() returns (i, j, k) such that a[i:i+k] is equal to b[j:j+k], where alo <= i <= i+k <= ahi and blo <= j <= j+k <= bhi. For all (i', j', k') meeting those conditions, the additional conditions k >= k', i <= i', and if i == i', j <= j' are also met. In other words, of all maximal matching blocks, return one that starts earliest in a, and of all those maximal matching blocks that start earliest in a, return the one that starts earliest in b. >>> s = SequenceMatcher(None, \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=0, b=4, size=5) If isjunk was provided, first the longest matching block is determined as above, but with the additional restriction that no junk element appears in the block. Then that block is extended as far as possible by matching (only) junk elements on both sides. So the resulting block never matches on junk except as identical junk happens to be adjacent to an interesting match. Here’s the same example as before, but considering blanks to be junk. That prevents ' abcd' from matching the ' abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments.", "score": "0.6956725"}, {"id": "18671", "text": "Function: python.library.collections#collections.deque.maxlen\nSnippet: maxlen Maximum size of a deque or None if unbounded. New in version 3.1.", "score": "0.69364893"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.69171923"}]}
{"task_id": "mbpp_419", "code": "def round_and_sum(list1):\r\n  lenght=len(list1)\r\n  round_and_sum=sum(list(map(round,list1))* lenght)\r\n  return round_and_sum", "test_list": ["assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243", "assert round_and_sum([5,2,9,24.3,29])==345", "assert round_and_sum([25.0,56.7,89.2])==513"], "context": "Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.", "function_name": "def round_and_sum(list1):", "gold_generation": "lenght=len(list1)\r\n  round_and_sum=sum(list(map(round,list1))* lenght)\r\n  return round_and_sum", "ctxs": [{"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.68217885"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.67630947"}, {"id": "21803", "text": "Function: python.library.math#math.fsum\nSnippet: math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation.", "score": "0.6753783"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.6744188"}, {"id": "19451", "text": "Function: python.library.decimal#decimal.Context.add\nSnippet: add(x, y) Return the sum of x and y.", "score": "0.6697693"}]}
{"task_id": "mbpp_420", "code": "def cube_Sum(n): \r\n    sum = 0\r\n    for i in range(1,n + 1): \r\n        sum += (2*i)*(2*i)*(2*i) \r\n    return sum", "test_list": ["assert cube_Sum(2) == 72", "assert cube_Sum(3) == 288", "assert cube_Sum(4) == 800"], "context": "Write a python function to find the cube sum of first n even natural numbers.", "function_name": "def cube_Sum(n):", "gold_generation": "sum = 0\r\n    for i in range(1,n + 1): \r\n        sum += (2*i)*(2*i)*(2*i) \r\n    return sum", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6765402"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6696463"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.6530818"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.65165824"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.64990616"}]}
{"task_id": "mbpp_421", "code": "def concatenate_tuple(test_tup):\r\n    delim = \"-\"\r\n    res = ''.join([str(ele) + delim for ele in test_tup])\r\n    res = res[ : len(res) - len(delim)]\r\n    return (str(res)) ", "test_list": ["assert concatenate_tuple((\"ID\", \"is\", 4, \"UTS\") ) == 'ID-is-4-UTS'", "assert concatenate_tuple((\"QWE\", \"is\", 4, \"RTY\") ) == 'QWE-is-4-RTY'", "assert concatenate_tuple((\"ZEN\", \"is\", 4, \"OP\") ) == 'ZEN-is-4-OP'"], "context": "Write a function to concatenate each element of tuple by the delimiter.", "function_name": "def concatenate_tuple(test_tup):", "gold_generation": "delim = \"-\"\r\n    res = ''.join([str(ele) + delim for ele in test_tup])\r\n    res = res[ : len(res) - len(delim)]\r\n    return (str(res))", "ctxs": [{"id": "25737", "text": "Function: python.library.stdtypes\nSnippet: a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str objects, you can build a list and use str.join() at the end or else write to an io.StringIO instance and retrieve its value when complete if concatenating bytes objects, you can similarly use bytes.join() or io.BytesIO, or you can do in-place concatenation with a bytearray object. bytearray objects are mutable and have an efficient overallocation mechanism if concatenating tuple objects, extend a list instead for other types, investigate the relevant class documentation Some sequence types (such as range) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition. index raises ValueError when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using s[i:j].index(x), only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. Immutable Sequence Types The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the hash() built-in. This support allows immutable sequences, such as tuple instances, to be used as dict keys and stored in set and frozenset instances. Attempting to hash an immutable sequence that contains unhashable values will result in TypeError. Mutable Sequence Types The operations in the following table are defined on mutable sequence types. The collections.abc.MutableSequence ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, bytearray only accepts integers that meet the value restriction 0 <= x <= 255). Operation Result Notes s[i] = x item i of s is replaced by x s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t del s[i:j] same as s[i:j] = [] s[i:j:k] = t the elements of s[i:j:k] are replaced by those of t (1) del s[i:j:k] removes the elements of s[i:j:k] from the list s.append(x) appends x to the end of the sequence (same as s[len(s):len(s)] = [x]) s.clear() removes all items from s (same as del s[:]) (5) s.copy() creates a shallow copy of s (same as s[:]) (5) s.extend(t) or s += t extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t) s *= n updates s with its contents repeated n times (6) s.insert(i, x) inserts x into s at the index given by i (same as s[i:i] = [x]) s.pop([i]) retrieves the item at i and also removes it", "score": "0.6935806"}, {"id": "41737", "text": "Function: numpy.reference.generated.numpy.char.join\nSnippet: numpy.char.join char.join(sep, seq)[source] Return a string which is the concatenation of the strings in the sequence seq. Calls str.join element-wise. Parameters separray_like of str or unicode seqarray_like of str or unicode Returns outndarray Output array of str or unicode, depending on input types See also str.join", "score": "0.68592006"}, {"id": "5260", "text": "Function: tensorflow.sparse.concat\nSnippet: SparseTensor.", "score": "0.6847849"}, {"id": "43169", "text": "Function: numpy.reference.generated.numpy.savetxt\nSnippet: delimiter=',') # X is an array >>> np.savetxt('test.out', (x,y,z)) # x,y,z equal sized 1D arrays >>> np.savetxt('test.out', x, fmt='%1.4e') # use exponential notation", "score": "0.6832704"}, {"id": "24362", "text": "Function: python.library.stdtypes#str.join\nSnippet: str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method.", "score": "0.68214107"}]}
{"task_id": "mbpp_422", "code": "def find_Average_Of_Cube(n):  \r\n    sum = 0\r\n    for i in range(1, n + 1): \r\n        sum += i * i * i  \r\n    return round(sum / n, 6) ", "test_list": ["assert find_Average_Of_Cube(2) == 4.5", "assert find_Average_Of_Cube(3) == 12", "assert find_Average_Of_Cube(1) == 1"], "context": "Write a python function to find the average of cubes of first n natural numbers.", "function_name": "def find_Average_Of_Cube(n):", "gold_generation": "sum = 0\r\n    for i in range(1, n + 1): \r\n        sum += i * i * i  \r\n    return round(sum / n, 6)", "ctxs": [{"id": "42657", "text": "Function: numpy.reference.generated.numpy.average\nSnippet: >>> avg = np.average(a, weights=w) >>> print(avg.dtype) complex256", "score": "0.70041907"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.67402154"}, {"id": "42656", "text": "Function: numpy.reference.generated.numpy.average\nSnippet: numpy.average numpy.average(a, axis=None, weights=None, returned=False)[source] Compute the weighted average along the specified axis. Parameters aarray_like Array containing data to be averaged. If a is not an array, a conversion is attempted. axisNone or int or tuple of ints, optional Axis or axes along which to average a. The default, axis=None, will average over all of the elements of the input array. If axis is negative it counts from the last to the first axis. New in version 1.7.0. If axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before. weightsarray_like, optional An array of weights associated with the values in a. Each value in a contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of a along the given axis) or of the same shape as a. If weights=None, then all data in a are assumed to have a weight equal to one. The 1-D calculation is: avg = sum(a * weights) / sum(weights) The only constraint on weights is that sum(weights) must not be 0. returnedbool, optional Default is False. If True, the tuple (average, sum_of_weights) is returned, otherwise only the average is returned. If weights=None, sum_of_weights is equivalent to the number of elements over which the average is taken. Returns retval, [sum_of_weights]array_type or double Return the average along the specified axis. When returned is True, return a tuple with the average as the first element and the sum of the weights as the second element. sum_of_weights is of the same type as retval. The result dtype follows a genereal pattern. If weights is None, the result dtype will be that of a , or float64 if a is integral. Otherwise, if weights is not None and a is non- integral, the result type will be the type of lowest precision capable of representing values of both a and weights. If a happens to be integral, the previous rules still applies but the result dtype will at least be float64. Raises ZeroDivisionError When all weights along axis are zero. See numpy.ma.average for a version robust to this type of error. TypeError When the length of 1D weights is not the same as the shape of a along axis. See also mean ma.average average for masked arrays – useful if your data contains “missing” values numpy.result_type Returns the type that results from applying the numpy type promotion rules to the arguments. Examples >>> data = np.arange(1, 5) >>> data array([1, 2, 3, 4]) >>> np.average(data) 2.5 >>> np.average(np.arange(1, 11), weights=np.arange(10, 0, -1)) 4.0 >>> data = np.arange(6).reshape((3,2)) >>> data array([[0, 1], [2, 3], [4, 5]]) >>> np.average(data, axis=1, weights=[1./4, 3./4]) array([0.75, 2.75, 4.75]) >>> np.average(data, weights=[1./4, 3./4]) Traceback (most recent call last): ... TypeError: Axis must be specified when shapes of a and weights differ. >>> a = np.ones(5, dtype=np.float128) >>> w = np.ones(5, dtype=np.complex64)", "score": "0.6690879"}, {"id": "42315", "text": "Function: numpy.reference.generated.numpy.ma.mean\nSnippet: numpy.ma.mean ma.mean(self, axis=None, dtype=None, out=None, keepdims=<no value>) = <numpy.ma.core._frommethod object> Returns the average of the array elements along given axis. Masked entries are ignored, and result elements which are not finite will be masked. Refer to numpy.mean for full documentation. See also numpy.ndarray.mean corresponding function for ndarrays numpy.mean Equivalent function numpy.ma.average Weighted average. Examples >>> a = np.ma.array([1,2,3], mask=[False, False, True]) >>> a masked_array(data=[1, 2, --], mask=[False, False, True], fill_value=999999) >>> a.mean() 1.5", "score": "0.65576446"}, {"id": "23268", "text": "Function: python.library.random\nSnippet: for a multiserver queue: from heapq import heappush, heappop from random import expovariate, gauss from statistics import mean, median, stdev average_arrival_interval = 5.6 average_service_time = 15.0 stdev_service_time = 3.5 num_servers = 3 waits = [] arrival_time = 0.0 servers = [0.0] * num_servers # time when each server becomes available for i in range(100_000): arrival_time += expovariate(1.0 / average_arrival_interval) next_server_available = heappop(servers) wait = max(0.0, next_server_available - arrival_time) waits.append(wait) service_duration = gauss(average_service_time, stdev_service_time) service_completed = arrival_time + wait + service_duration heappush(servers, service_completed) print(f'Mean wait: {mean(waits):.1f}. Stdev wait: {stdev(waits):.1f}.') print(f'Median wait: {median(waits):.1f}. Max wait: {max(waits):.1f}.') See also Statistics for Hackers a video tutorial by Jake Vanderplas on statistical analysis using just a few fundamental concepts including simulation, sampling, shuffling, and cross-validation. Economics Simulation a simulation of a marketplace by Peter Norvig that shows effective use of many of the tools and distributions provided by this module (gauss, uniform, sample, betavariate, choice, triangular, and randrange). A Concrete Introduction to Probability (using Python) a tutorial by Peter Norvig covering the basics of probability theory, how to write simulations, and how to perform data analysis using Python. Recipes The default random() returns multiples of 2⁻⁵³ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, 0.05954861408025609 isn’t an integer multiple of 2⁻⁵³. The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2⁵² ≤ mantissa < 2⁵³. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. from random import Random from math import ldexp class FullRandom(Random): def random(self): mantissa = 0x10_0000_0000_0000 | self.getrandbits(52) exponent = -53 x = 0 while not x: x = self.getrandbits(32) exponent += x.bit_length() - 32 return ldexp(mantissa, exponent) All real valued distributions in the class will use the new method: >>> fr = FullRandom() >>> fr.random() 0.05954861408025609 >>> fr.expovariate(0.25) 8.87925541791544 The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻¹⁰⁷⁴ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float and is equal to math.ulp(0.0).) See also Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by random().", "score": "0.6551876"}]}
{"task_id": "mbpp_423", "code": "def get_maxgold(gold, m, n): \r\n    goldTable = [[0 for i in range(n)] \r\n                        for j in range(m)]   \r\n    for col in range(n-1, -1, -1): \r\n        for row in range(m):  \r\n            if (col == n-1): \r\n                right = 0\r\n            else: \r\n                right = goldTable[row][col+1] \r\n            if (row == 0 or col == n-1): \r\n                right_up = 0\r\n            else: \r\n                right_up = goldTable[row-1][col+1] \r\n            if (row == m-1 or col == n-1): \r\n                right_down = 0\r\n            else: \r\n                right_down = goldTable[row+1][col+1] \r\n            goldTable[row][col] = gold[row][col] + max(right, right_up, right_down) \r\n    res = goldTable[0][0] \r\n    for i in range(1, m): \r\n        res = max(res, goldTable[i][0])  \r\n    return res ", "test_list": ["assert get_maxgold([[1, 3, 1, 5],[2, 2, 4, 1],[5, 0, 2, 3],[0, 6, 1, 2]],4,4)==16", "assert get_maxgold([[10,20],[30,40]],2,2)==70", "assert get_maxgold([[4,9],[3,7]],2,2)==13"], "context": "Write a function to solve gold mine problem.", "function_name": "def get_maxgold(gold, m, n):", "gold_generation": "goldTable = [[0 for i in range(n)] \r\n                        for j in range(m)]   \r\n    for col in range(n-1, -1, -1): \r\n        for row in range(m):  \r\n            if (col == n-1): \r\n                right = 0\r\n            else: \r\n                right = goldTable[row][col+1] \r\n            if (row == 0 or col == n-1): \r\n                right_up = 0\r\n            else: \r\n                right_up = goldTable[row-1][col+1] \r\n            if (row == m-1 or col == n-1): \r\n                right_down = 0\r\n            else: \r\n                right_down = goldTable[row+1][col+1] \r\n            goldTable[row][col] = gold[row][col] + max(right, right_up, right_down) \r\n    res = goldTable[0][0] \r\n    for i in range(1, m): \r\n        res = max(res, goldTable[i][0])  \r\n    return res", "ctxs": [{"id": "25440", "text": "Function: python.library.token#token.MINEQUAL\nSnippet: token.MINEQUAL Token value for \"-=\".", "score": "0.6352183"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.63191056"}, {"id": "36347", "text": "Function: django.ref.contrib.gis.functions#django.contrib.gis.db.models.functions.GeoHash\nSnippet: class GeoHash(expression, precision=None, **extra)", "score": "0.6314326"}, {"id": "20290", "text": "Function: python.library.functions\nSnippet: integer representing the Unicode code point of that character. For example, ord('a') returns the integer 97 and ord('€') (Euro sign) returns 8364. This is the inverse of chr(). pow(base, exp[, mod]) Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp. The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10**2 returns 100, but 10**-2 returns 0.01. For int operands base and exp, if mod is present, mod must also be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod. In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod. Here’s an example of computing an inverse for 38 modulo 97: >>> pow(38, -1, mod=97) 23 >>> 23 * 38 % 97 == 1 True Changed in version 3.8: For int operands, the three-argument form of pow now allows the second argument to be negative, permitting computation of modular inverses. Changed in version 3.8: Allow keyword arguments. Formerly, only positional arguments were supported. print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False) Print objects to the text stream file, separated by sep and followed by end. sep, end, file and flush, if present, must be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end. The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Since printed arguments are converted to text strings, print() cannot be used with binary mode file objects. For these, use file.write(...) instead. Whether output is buffered is usually determined by file, but if the flush keyword argument is true, the stream is forcibly flushed. Changed in version 3.3: Added the flush keyword argument. class property(fget=None, fset=None, fdel=None, doc=None) Return a property attribute. fget is a function for getting an attribute value. fset is a function for setting an attribute value. fdel is a function for deleting an attribute value. And doc creates a docstring for the attribute. A typical use is to define a managed attribute x: class C: def __init__(self): self._x = None def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") If c is an instance of C, c.x", "score": "0.6308118"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.6267182"}]}
{"task_id": "mbpp_424", "code": "def extract_rear(test_tuple):\r\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\r\n  return (res) ", "test_list": ["assert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']", "assert extract_rear(('Avenge', 'for', 'People') ) == ['e', 'r', 'e']", "assert extract_rear(('Gotta', 'get', 'go') ) == ['a', 't', 'o']"], "context": "Write a function to extract only the rear index element of each string in the given tuple.", "function_name": "def extract_rear(test_tuple):", "gold_generation": "res = list(sub[len(sub) - 1] for sub in test_tuple)\r\n  return (res)", "ctxs": [{"id": "24349", "text": "Function: python.library.stdtypes#str.index\nSnippet: str.index(sub[, start[, end]]) Like find(), but raise ValueError when the substring is not found.", "score": "0.71865714"}, {"id": "24371", "text": "Function: python.library.stdtypes#str.rfind\nSnippet: str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.", "score": "0.71755385"}, {"id": "41748", "text": "Function: numpy.reference.generated.numpy.char.rfind\nSnippet: numpy.char.rfind char.rfind(a, sub, start=0, end=None)[source] For each element in a, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. Calls str.rfind element-wise. Parameters aarray-like of str or unicode substr or unicode start, endint, optional Optional arguments start and end are interpreted as in slice notation. Returns outndarray Output array of ints. Return -1 on failure. See also str.rfind", "score": "0.7160615"}, {"id": "41686", "text": "Function: numpy.reference.generated.numpy.char.chararray.rfind\nSnippet: numpy.char.chararray.rfind method char.chararray.rfind(sub, start=0, end=None)[source] For each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. See also char.rfind", "score": "0.7053809"}, {"id": "24346", "text": "Function: python.library.stdtypes#str.find\nSnippet: str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True", "score": "0.7037541"}]}
{"task_id": "mbpp_425", "code": "def count_element_in_list(list1, x): \r\n    ctr = 0\r\n    for i in range(len(list1)): \r\n        if x in list1[i]: \r\n            ctr+= 1          \r\n    return ctr", "test_list": ["assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]],1)==3", "assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'A')==3", "assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'E')==1"], "context": "Write a function to count the number of sublists containing a particular element.", "function_name": "def count_element_in_list(list1, x):", "gold_generation": "ctr = 0\r\n    for i in range(len(list1)): \r\n        if x in list1[i]: \r\n            ctr+= 1          \r\n    return ctr", "ctxs": [{"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.7028"}, {"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.70041573"}, {"id": "18260", "text": "Function: python.library.stdtypes#bytearray.count\nSnippet: bytes.count(sub[, start[, end]]) bytearray.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.7003783"}, {"id": "18304", "text": "Function: python.library.stdtypes#bytes.count\nSnippet: bytes.count(sub[, start[, end]]) bytearray.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.6974517"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.6960532"}]}
{"task_id": "mbpp_426", "code": "def filter_oddnumbers(nums):\r\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\r\n return odd_nums", "test_list": ["assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1,3,5,7,9]", "assert filter_oddnumbers([10,20,45,67,84,93])==[45,67,93]", "assert filter_oddnumbers([5,7,9,8,6,4,3])==[5,7,9,3]"], "context": "Write a function to filter odd numbers using lambda function.", "function_name": "def filter_oddnumbers(nums):", "gold_generation": "odd_nums = list(filter(lambda x: x%2 != 0, nums))\r\n return odd_nums", "ctxs": [{"id": "21307", "text": "Function: python.library.itertools#itertools.filterfalse\nSnippet: itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x", "score": "0.6694456"}, {"id": "20282", "text": "Function: python.library.functions\nSnippet: local dictionary, respectively, which may be useful to pass around for use as the second and third argument to exec(). Note The default locals act as described for function locals() below: modifications to the default locals dictionary should not be attempted. Pass an explicit locals dictionary if you need to see effects of the code on locals after function exec() returns. filter(function, iterable) Construct an iterator from those elements of iterable for which function returns true. iterable may be either a sequence, a container which supports iteration, or an iterator. If function is None, the identity function is assumed, that is, all elements of iterable that are false are removed. Note that filter(function, iterable) is equivalent to the generator expression (item for item in iterable if function(item)) if function is not None and (item for item in iterable if item) if function is None. See itertools.filterfalse() for the complementary function that returns elements of iterable for which function returns false. class float([x]) Return a floating point number constructed from a number or string x. If the argument is a string, it should contain a decimal number, optionally preceded by a sign, and optionally embedded in whitespace. The optional sign may be '+' or '-'; a '+' sign has no effect on the value produced. The argument may also be a string representing a NaN (not-a-number), or a positive or negative infinity. More precisely, the input must conform to the following grammar after leading and trailing whitespace characters are removed: sign ::= \"+\" | \"-\" infinity ::= \"Infinity\" | \"inf\" nan ::= \"nan\" numeric_value ::= floatnumber | infinity | nan numeric_string ::= [sign] numeric_value Here floatnumber is the form of a Python floating-point literal, described in Floating point literals. Case is not significant, so, for example, “inf”, “Inf”, “INFINITY” and “iNfINity” are all acceptable spellings for positive infinity. Otherwise, if the argument is an integer or a floating point number, a floating point number with the same value (within Python’s floating point precision) is returned. If the argument is outside the range of a Python float, an OverflowError will be raised. For a general Python object x, float(x) delegates to x.__float__(). If __float__() is not defined then it falls back to __index__(). If no argument is given, 0.0 is returned. Examples: >>> float('+1.23') 1.23 >>> float(' -12345\\n') -12345.0 >>> float('1e-003') 0.001 >>> float('+1E6') 1000000.0 >>> float('-Infinity') -inf The float type is described in Numeric Types — int, float, complex. Changed in version 3.6: Grouping digits with underscores as in code literals is allowed. Changed in version 3.7: x is now a positional-only parameter. Changed in version 3.8: Falls back to __index__() if __float__() is not defined. format(value[, format_spec]) Convert a value to a “formatted” representation, as controlled by format_spec. The interpretation of format_spec will depend on the type of the value argument, however there is a standard formatting syntax that is used by most built-in types: Format Specification Mini-Language. The default format_spec is an empty string which usually gives the same", "score": "0.6649099"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6583678"}, {"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.65789866"}, {"id": "23266", "text": "Function: python.library.random\nSnippet: distribution. Conditions on the parameters are alpha > 0 and beta > 0. Returned values range between 0 and 1. random.expovariate(lambd) Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called “lambda”, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. random.gammavariate(alpha, beta) Gamma distribution. (Not the gamma function!) Conditions on the parameters are alpha > 0 and beta > 0. The probability distribution function is: x ** (alpha - 1) * math.exp(-x / beta) pdf(x) = -------------------------------------- math.gamma(alpha) * beta ** alpha random.gauss(mu, sigma) Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the normalvariate() function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe normalvariate() function instead. random.lognormvariate(mu, sigma) Log normal distribution. If you take the natural logarithm of this distribution, you’ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. random.normalvariate(mu, sigma) Normal distribution. mu is the mean, and sigma is the standard deviation. random.vonmisesvariate(mu, kappa) mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. random.paretovariate(alpha) Pareto distribution. alpha is the shape parameter. random.weibullvariate(alpha, beta) Weibull distribution. alpha is the scale parameter and beta is the shape parameter. Alternative Generator class random.Random([seed]) Class that implements the default pseudo-random number generator used by the random module. Deprecated since version 3.9: In the future, the seed must be one of the following types: NoneType, int, float, str, bytes, or bytearray. class random.SystemRandom([seed]) Class that uses the os.urandom() function for generating random numbers from sources provided by the operating system. Not available on all systems. Does not rely on software state, and sequences are not reproducible. Accordingly, the seed() method has no effect and is ignored. The getstate() and setstate() methods raise NotImplementedError if called. Notes on Reproducibility Sometimes it is useful to be able to reproduce the sequences given by a pseudo-random number generator. By re-using a seed value, the same sequence should be reproducible from run to run as long as multiple threads are not running. Most of the random module’s algorithms and seeding functions are subject to change across Python versions, but two aspects are guaranteed not to change: If a new seeding method is added, then a backward compatible seeder will be offered. The generator’s random() method will continue to produce", "score": "0.65576506"}]}
{"task_id": "mbpp_427", "code": "import re\r\ndef change_date_format(dt):\r\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)", "test_list": ["assert change_date_format(\"2026-01-02\") == '02-01-2026'", "assert change_date_format(\"2020-11-13\") == '13-11-2020'", "assert change_date_format(\"2021-04-26\") == '26-04-2021'"], "context": "Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format by using regex.", "function_name": "import re\r\ndef change_date_format(dt):", "gold_generation": "return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)", "ctxs": [{"id": "19313", "text": "Function: python.library.datetime#datetime.date.replace\nSnippet: date.replace(year=self.year, month=self.month, day=self.day) Return a date with the same value, except for those parameters given new values by whichever keyword arguments are specified. Example: >>> from datetime import date >>> d = date(2002, 12, 31) >>> d.replace(day=26) datetime.date(2002, 12, 26)", "score": "0.690519"}, {"id": "19322", "text": "Function: python.library.datetime#datetime.date.__str__\nSnippet: date.__str__() For a date d, str(d) is equivalent to d.isoformat().", "score": "0.68038607"}, {"id": "19304", "text": "Function: python.library.datetime#datetime.date.fromisoformat\nSnippet: classmethod date.fromisoformat(date_string) Return a date corresponding to a date_string given in the format YYYY-MM-DD: >>> from datetime import date >>> date.fromisoformat('2019-12-04') datetime.date(2019, 12, 4) This is the inverse of date.isoformat(). It only supports the format YYYY-MM-DD. New in version 3.7.", "score": "0.6796935"}, {"id": "19327", "text": "Function: python.library.datetime#datetime.datetime.date\nSnippet: datetime.date() Return date object with same year, month and day.", "score": "0.674834"}, {"id": "19308", "text": "Function: python.library.datetime#datetime.date.isoformat\nSnippet: date.isoformat() Return a string representing the date in ISO 8601 format, YYYY-MM-DD: >>> from datetime import date >>> date(2002, 12, 4).isoformat() '2002-12-04' This is the inverse of date.fromisoformat().", "score": "0.67437595"}]}
{"task_id": "mbpp_428", "code": "def shell_sort(my_list):\r\n    gap = len(my_list) // 2\r\n    while gap > 0:\r\n        for i in range(gap, len(my_list)):\r\n            current_item = my_list[i]\r\n            j = i\r\n            while j >= gap and my_list[j - gap] > current_item:\r\n                my_list[j] = my_list[j - gap]\r\n                j -= gap\r\n            my_list[j] = current_item\r\n        gap //= 2\r\n\r\n    return my_list", "test_list": ["assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]", "assert shell_sort([24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87]", "assert shell_sort([32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96]"], "context": "Write a function to sort the given array by using shell sort.", "function_name": "def shell_sort(my_list):", "gold_generation": "gap = len(my_list) // 2\r\n    while gap > 0:\r\n        for i in range(gap, len(my_list)):\r\n            current_item = my_list[i]\r\n            j = i\r\n            while j >= gap and my_list[j - gap] > current_item:\r\n                my_list[j] = my_list[j - gap]\r\n                j -= gap\r\n            my_list[j] = current_item\r\n        gap //= 2\r\n\r\n    return my_list", "ctxs": [{"id": "43832", "text": "Function: numpy.reference.generated.numpy.recarray.argsort\nSnippet: numpy.recarray.argsort method recarray.argsort(axis=- 1, kind=None, order=None) Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.73225164"}, {"id": "41639", "text": "Function: numpy.reference.generated.numpy.char.chararray.argsort\nSnippet: numpy.char.chararray.argsort method char.chararray.argsort(axis=- 1, kind=None, order=None)[source] Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.72087896"}, {"id": "41764", "text": "Function: numpy.reference.generated.numpy.chararray.argsort\nSnippet: numpy.chararray.argsort method chararray.argsort(axis=- 1, kind=None, order=None)[source] Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.7171534"}, {"id": "42504", "text": "Function: numpy.reference.generated.numpy.ndarray.argsort\nSnippet: numpy.ndarray.argsort method ndarray.argsort(axis=- 1, kind=None, order=None) Returns the indices that would sort this array. Refer to numpy.argsort for full documentation. See also numpy.argsort equivalent function", "score": "0.714948"}, {"id": "42341", "text": "Function: numpy.reference.generated.numpy.ma.sort\nSnippet: numpy.ma.sort ma.sort(a, axis=- 1, kind=None, order=None, endwith=True, fill_value=None)[source] Return a sorted copy of the masked array. Equivalent to creating a copy of the array and applying the MaskedArray sort() method. Refer to MaskedArray.sort for the full documentation See also MaskedArray.sort equivalent method", "score": "0.7021358"}]}
{"task_id": "mbpp_429", "code": "def and_tuples(test_tup1, test_tup2):\r\n  res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "test_list": ["assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)", "assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)", "assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)"], "context": "Write a function to extract the elementwise and tuples from the given two tuples.", "function_name": "def and_tuples(test_tup1, test_tup2):", "gold_generation": "res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res)", "ctxs": [{"id": "20295", "text": "Function: python.library.functions\nSnippet: aggregates elements from each of the iterables. Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator. Equivalent to: def zip(*iterables): # zip('ABCD', 'xy') --> Ax By sentinel = object() iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using zip(*[iter(s)]*n). This repeats the same iterator n times so that each output tuple has the result of n calls to the iterator. This has the effect of dividing the input into n-length chunks. zip() should only be used with unequal length inputs when you don’t care about trailing, unmatched values from the longer iterables. If those values are important, use itertools.zip_longest() instead. zip() in conjunction with the * operator can be used to unzip a list: >>> x = [1, 2, 3] >>> y = [4, 5, 6] >>> zipped = zip(x, y) >>> list(zipped) [(1, 4), (2, 5), (3, 6)] >>> x2, y2 = zip(*zip(x, y)) >>> x == list(x2) and y == list(y2) True __import__(name, globals=None, locals=None, fromlist=(), level=0) Note This is an advanced function that is not needed in everyday Python programming, unlike importlib.import_module(). This function is invoked by the import statement. It can be replaced (by importing the builtins module and assigning to builtins.__import__) in order to change semantics of the import statement, but doing so is strongly discouraged as it is usually simpler to use import hooks (see PEP 302) to attain the same goals and does not cause issues with code which assumes the default import implementation is in use. Direct use of __import__() is also discouraged in favor of importlib.import_module(). The function imports the module name, potentially using the given globals and locals to determine how to interpret the name in a package context. The fromlist gives the names of objects or submodules that should be imported from the module given by name. The standard implementation does not use its locals argument at all, and uses its globals only to determine the package context of the import statement. level specifies whether to use absolute or relative imports. 0 (the default) means only perform absolute imports. Positive values for level indicate the number of parent directories to search relative to the directory of the module calling __import__() (see PEP 328 for the details). When the name variable is of the form package.module, normally, the top-level package (the name up till the first dot) is returned, not the module named by name. However, when a non-empty fromlist argument is given, the module named by name is returned. For example, the statement import spam results", "score": "0.6789261"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.6738652"}, {"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.6716113"}, {"id": "36544", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.OGRGeometry.tuple\nSnippet: tuple", "score": "0.6714575"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.66472715"}]}
{"task_id": "mbpp_430", "code": "def parabola_directrix(a, b, c): \r\n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\r\n  return directrix", "test_list": ["assert parabola_directrix(5,3,2)==-198", "assert parabola_directrix(9,8,4)==-2336", "assert parabola_directrix(2,4,6)==-130"], "context": "Write a function to find the directrix of a parabola.", "function_name": "def parabola_directrix(a, b, c):", "gold_generation": "directrix=((int)(c - ((b * b) + 1) * 4 * a ))\r\n  return directrix", "ctxs": [{"id": "41966", "text": "Function: numpy.reference.generated.numpy.fft.fft2\nSnippet: +0.j ]])", "score": "0.64876664"}, {"id": "43592", "text": "Function: numpy.reference.generated.numpy.polynomial.polynomial.polyline\nSnippet: numpy.polynomial.polynomial.polyline polynomial.polynomial.polyline(off, scl)[source] Returns an array representing a linear polynomial. Parameters off, sclscalars The “y-intercept” and “slope” of the line, respectively. Returns yndarray This module’s representation of the linear polynomial off + scl*x. See also numpy.polynomial.chebyshev.chebline numpy.polynomial.legendre.legline numpy.polynomial.laguerre.lagline numpy.polynomial.hermite.hermline numpy.polynomial.hermite_e.hermeline Examples >>> from numpy.polynomial import polynomial as P >>> P.polyline(1,-1) array([ 1, -1]) >>> P.polyval(1, P.polyline(1,-1)) # should be 0 0.0", "score": "0.64650965"}, {"id": "42994", "text": "Function: numpy.reference.arrays.scalars#numpy.longcomplex\nSnippet: numpy.longcomplex[source] alias of numpy.clongdouble", "score": "0.6381111"}, {"id": "43602", "text": "Function: numpy.reference.generated.numpy.polynomial.polynomial.polynomial.deriv\nSnippet: numpy.polynomial.polynomial.Polynomial.deriv method polynomial.polynomial.Polynomial.deriv(m=1)[source] Differentiate. Return a series instance of that is the derivative of the current series. Parameters mnon-negative int Find the derivative of order m. Returns new_seriesseries A new series representing the derivative. The domain is the same as the domain of the differentiated series.", "score": "0.63781565"}, {"id": "43303", "text": "Function: numpy.reference.generated.numpy.polynomial.chebyshev.chebgrid3d\nSnippet: numpy.polynomial.chebyshev.chebgrid3d polynomial.chebyshev.chebgrid3d(x, y, z, c)[source] Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z. This function returns the values: \\[p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * T_i(a) * T_j(b) * T_k(c)\\] where the points (a, b, c) consist of all triples formed by taking a from x, b from y, and c from z. The resulting points form a grid with x in the first dimension, y in the second, and z in the third. The parameters x, y, and z are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either x, y, and z or their elements must support multiplication and addition both with themselves and with the elements of c. If c has fewer than three dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape + y.shape + z.shape. Parameters x, y, zarray_like, compatible objects The three dimensional series is evaluated at the points in the Cartesian product of x, y, and z. If x,`y`, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. carray_like Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients. Returns valuesndarray, compatible object The values of the two dimensional polynomial at points in the Cartesian product of x and y. See also chebval, chebval2d, chebgrid2d, chebval3d Notes New in version 1.7.0.", "score": "0.63728416"}]}
{"task_id": "mbpp_431", "code": "def common_element(list1, list2):\r\n     result = False\r\n     for x in list1:\r\n         for y in list2:\r\n             if x == y:\r\n                 result = True\r\n                 return result", "test_list": ["assert common_element([1,2,3,4,5], [5,6,7,8,9])==True", "assert common_element([1,2,3,4,5], [6,7,8,9])==None", "assert common_element(['a','b','c'], ['d','b','e'])==True"], "context": "Write a function that takes two lists and returns true if they have at least one common element.", "function_name": "def common_element(list1, list2):", "gold_generation": "result = False\r\n     for x in list1:\r\n         for y in list2:\r\n             if x == y:\r\n                 result = True\r\n                 return result", "ctxs": [{"id": "20224", "text": "Function: python.library.stdtypes#frozenset.isdisjoint\nSnippet: isdisjoint(other) Return True if the set has no elements in common with other. Sets are disjoint if and only if their intersection is the empty set.", "score": "0.703677"}, {"id": "20225", "text": "Function: python.library.stdtypes#frozenset.issubset\nSnippet: issubset(other) set <= other Test whether every element in the set is in other.", "score": "0.683171"}, {"id": "29169", "text": "Function: matplotlib.cbook_api#matplotlib.cbook.Grouper.joined\nSnippet: joined(a, b)[source] Return whether a and b are members of the same set.", "score": "0.6759994"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.67479706"}, {"id": "20226", "text": "Function: python.library.stdtypes#frozenset.issuperset\nSnippet: issuperset(other) set >= other Test whether every element in other is in the set.", "score": "0.6743412"}]}
{"task_id": "mbpp_432", "code": "def median_trapezium(base1,base2,height):\r\n median = 0.5 * (base1+ base2)\r\n return median", "test_list": ["assert median_trapezium(15,25,35)==20", "assert median_trapezium(10,20,30)==15", "assert median_trapezium(6,9,4)==7.5"], "context": "Write a function to find the median of a trapezium.", "function_name": "def median_trapezium(base1,base2,height):", "gold_generation": "median = 0.5 * (base1+ base2)\r\n return median", "ctxs": [{"id": "7982", "text": "Function: torch.tensors#torch.Tensor.median\nSnippet: median(dim=None, keepdim=False) -> (Tensor, LongTensor) See torch.median()", "score": "0.66765654"}, {"id": "24320", "text": "Function: python.library.statistics#statistics.NormalDist.median\nSnippet: median A read-only property for the median of a normal distribution.", "score": "0.66697854"}, {"id": "24308", "text": "Function: python.library.statistics#statistics.median\nSnippet: statistics.median(data) Return the median (middle value) of numeric data, using the common “mean of middle two” method. If data is empty, StatisticsError is raised. data can be a sequence or iterable. The median is a robust measure of central location and is less affected by the presence of outliers. When the number of data points is odd, the middle data point is returned: >>> median([1, 3, 5]) 3 When the number of data points is even, the median is interpolated by taking the average of the two middle values: >>> median([1, 3, 5, 7]) 4.0 This is suited for when your data is discrete, and you don’t mind that the median may not be an actual data point. If the data is ordinal (supports order operations) but not numeric (doesn’t support addition), consider using median_low() or median_high() instead.", "score": "0.66290814"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.66262263"}, {"id": "24298", "text": "Function: python.library.statistics\nSnippet: statistics.median_low(data) Return the low median of numeric data. If data is empty, StatisticsError is raised. data can be a sequence or iterable. The low median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the smaller of the two middle values is returned. >>> median_low([1, 3, 5]) 3 >>> median_low([1, 3, 5, 7]) 3 Use the low median when your data are discrete and you prefer the median to be an actual data point rather than interpolated. statistics.median_high(data) Return the high median of data. If data is empty, StatisticsError is raised. data can be a sequence or iterable. The high median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the larger of the two middle values is returned. >>> median_high([1, 3, 5]) 3 >>> median_high([1, 3, 5, 7]) 5 Use the high median when your data are discrete and you prefer the median to be an actual data point rather than interpolated. statistics.median_grouped(data, interval=1) Return the median of grouped continuous data, calculated as the 50th percentile, using interpolation. If data is empty, StatisticsError is raised. data can be a sequence or iterable. >>> median_grouped([52, 52, 53, 54]) 52.5 In the following example, the data are rounded, so that each value represents the midpoint of data classes, e.g. 1 is the midpoint of the class 0.5–1.5, 2 is the midpoint of 1.5–2.5, 3 is the midpoint of 2.5–3.5, etc. With the data given, the middle value falls somewhere in the class 3.5–4.5, and interpolation is used to estimate it: >>> median_grouped([1, 2, 2, 3, 4, 4, 4, 4, 4, 5]) 3.7 Optional argument interval represents the class interval, and defaults to 1. Changing the class interval naturally will change the interpolation: >>> median_grouped([1, 3, 3, 5, 7], interval=1) 3.25 >>> median_grouped([1, 3, 3, 5, 7], interval=2) 3.5 This function does not check whether the data points are at least interval apart. CPython implementation detail: Under some circumstances, median_grouped() may coerce data points to floats. This behaviour is likely to change in the future. See also “Statistics for the Behavioral Sciences”, Frederick J Gravetter and Larry B Wallnau (8th Edition). The SSMEDIAN function in the Gnome Gnumeric spreadsheet, including this discussion. statistics.mode(data) Return the single most common data point from discrete or nominal data. The mode (when it exists) is the most typical value and serves as a measure of central location. If there are multiple modes with the same frequency, returns the first one encountered in the data. If the smallest or largest of those is desired instead, use min(multimode(data)) or max(multimode(data)). If the input data is empty, StatisticsError is raised. mode assumes discrete data and returns a single value. This is the standard treatment of the mode as commonly taught in schools: >>> mode([1, 1, 2, 3, 3, 3, 3, 4]) 3 The mode is unique in", "score": "0.659677"}]}
{"task_id": "mbpp_433", "code": "def check_greater(arr, number):\r\n  arr.sort()\r\n  if number > arr[-1]:\r\n    return ('Yes, the entered number is greater than those in the array')\r\n  else:\r\n    return ('No, entered number is less than those in the array')", "test_list": ["assert check_greater([1, 2, 3, 4, 5], 4) == 'No, entered number is less than those in the array'", "assert check_greater([2, 3, 4, 5, 6], 8) == 'Yes, the entered number is greater than those in the array'", "assert check_greater([9, 7, 4, 8, 6, 1], 11) == 'Yes, the entered number is greater than those in the array'"], "context": "Write a function to check whether the entered number is greater than the elements of the given array.", "function_name": "def check_greater(arr, number):", "gold_generation": "arr.sort()\r\n  if number > arr[-1]:\r\n    return ('Yes, the entered number is greater than those in the array')\r\n  else:\r\n    return ('No, entered number is less than those in the array')", "ctxs": [{"id": "42165", "text": "Function: numpy.reference.generated.numpy.ma.masked_greater_equal\nSnippet: numpy.ma.masked_greater_equal ma.masked_greater_equal(x, value, copy=True)[source] Mask an array where greater than or equal to a given value. This function is a shortcut to masked_where, with condition = (x >= value). See also masked_where Mask where a condition is met. Examples >>> import numpy.ma as ma >>> a = np.arange(4) >>> a array([0, 1, 2, 3]) >>> ma.masked_greater_equal(a, 2) masked_array(data=[0, 1, --, --], mask=[False, False, True, True], fill_value=999999)", "score": "0.68105125"}, {"id": "43965", "text": "Function: numpy.reference.generated.numpy.testing.assert_array_almost_equal_nulp\nSnippet: numpy.testing.assert_array_almost_equal_nulp testing.assert_array_almost_equal_nulp(x, y, nulp=1)[source] Compare two arrays relatively to their spacing. This is a relatively robust method to compare two arrays whose amplitude is variable. Parameters x, yarray_like Input arrays. nulpint, optional The maximum number of unit in the last place for tolerance (see Notes). Default is 1. Returns None Raises AssertionError If the spacing between x and y for one or more elements is larger than nulp. See also assert_array_max_ulp Check that all items of arrays differ in at most N Units in the Last Place. spacing Return the distance between x and the nearest adjacent number. Notes An assertion is raised if the following condition is not met: abs(x - y) <= nulps * spacing(maximum(abs(x), abs(y))) Examples >>> x = np.array([1., 1e-10, 1e-20]) >>> eps = np.finfo(x.dtype).eps >>> np.testing.assert_array_almost_equal_nulp(x, x*eps/2 + x) >>> np.testing.assert_array_almost_equal_nulp(x, x*eps + x) Traceback (most recent call last): ... AssertionError: X and Y are not equal to 1 ULP (max is 2)", "score": "0.6800333"}, {"id": "42871", "text": "Function: numpy.reference.generated.numpy.greater_equal\nSnippet: numpy.greater_equal numpy.greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'greater_equal'> Return the truth value of (x1 >= x2) element-wise. Parameters x1, x2array_like Input arrays. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outbool or ndarray of bool Output array, element-wise comparison of x1 and x2. Typically of type bool, unless dtype=object is passed. This is a scalar if both x1 and x2 are scalars. See also greater, less, less_equal, equal, not_equal Examples >>> np.greater_equal([4, 2, 1], [2, 2, 2]) array([ True, True, False]) The >= operator can be used as a shorthand for np.greater_equal on ndarrays. >>> a = np.array([4, 2, 1]) >>> b = np.array([2, 2, 2]) >>> a >= b array([ True, True, False])", "score": "0.67824227"}, {"id": "42870", "text": "Function: numpy.reference.generated.numpy.greater\nSnippet: numpy.greater numpy.greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'greater'> Return the truth value of (x1 > x2) element-wise. Parameters x1, x2array_like Input arrays. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Output array, element-wise comparison of x1 and x2. Typically of type bool, unless dtype=object is passed. This is a scalar if both x1 and x2 are scalars. See also greater_equal, less, less_equal, equal, not_equal Examples >>> np.greater([4,2],[2,2]) array([ True, False]) The > operator can be used as a shorthand for np.greater on ndarrays. >>> a = np.array([4, 2]) >>> b = np.array([2, 2]) >>> a > b array([ True, False])", "score": "0.6772009"}, {"id": "42164", "text": "Function: numpy.reference.generated.numpy.ma.masked_greater\nSnippet: numpy.ma.masked_greater ma.masked_greater(x, value, copy=True)[source] Mask an array where greater than a given value. This function is a shortcut to masked_where, with condition = (x > value). See also masked_where Mask where a condition is met. Examples >>> import numpy.ma as ma >>> a = np.arange(4) >>> a array([0, 1, 2, 3]) >>> ma.masked_greater(a, 2) masked_array(data=[0, 1, 2, --], mask=[False, False, False, True], fill_value=999999)", "score": "0.6764509"}]}
{"task_id": "mbpp_434", "code": "import re\r\ndef text_match_one(text):\r\n        patterns = 'ab+?'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')\r\n", "test_list": ["assert text_match_one(\"ac\")==('Not matched!')", "assert text_match_one(\"dc\")==('Not matched!')", "assert text_match_one(\"abba\")==('Found a match!')"], "context": "Write a function that matches a string that has an a followed by one or more b's.", "function_name": "import re\r\ndef text_match_one(text):", "gold_generation": "patterns = 'ab+?'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')", "ctxs": [{"id": "23300", "text": "Function: python.library.re\nSnippet: For further information and a gentler presentation, consult the Regular Expression HOWTO. Regular expressions can contain both special and ordinary characters. Most ordinary characters, like 'A', 'a', or '0', are the simplest regular expressions; they simply match themselves. You can concatenate ordinary characters, so last matches the string 'last'. (In the rest of this section, we’ll write RE’s in this special style, usually without quotes, and strings to be matched 'in single quotes'.) Some characters, like '|' or '(', are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. Repetition qualifiers (*, +, ?, {m,n}, etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix ?, and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression (?:a{6})* matches any multiple of six 'a' characters. The special characters are: . (Dot.) In the default mode, this matches any character except a newline. If the DOTALL flag has been specified, this matches any character including a newline. ^ (Caret.) Matches the start of the string, and in MULTILINE mode also matches immediately after each newline. $ Matches the end of the string or just before the newline at the end of the string, and in MULTILINE mode also matches before a newline. foo matches both ‘foo’ and ‘foobar’, while the regular expression foo$ matches only ‘foo’. More interestingly, searching for foo.$ in 'foo1\\nfoo2\\n' matches ‘foo2’ normally, but ‘foo1’ in MULTILINE mode; searching for a single $ in 'foo\\n' will find two (empty) matches: one just before the newline, and one at the end of the string. * Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. ab* will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s. + Causes the resulting RE to match 1 or more repetitions of the preceding RE. ab+ will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’. ? Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. ab? will match either ‘a’ or ‘ab’. *?, +?, ?? The '*', '+', and '?' qualifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE <.*> is matched against '<a> b <c>', it will match the entire string, and not just '<a>'. Adding ? after the qualifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using the RE <.*?> will match only '<a>'. {m} Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, a{6} will match exactly six 'a' characters, but not five. {m,n} Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many", "score": "0.6908912"}, {"id": "23304", "text": "Function: python.library.re\nSnippet: Similar to positive lookbehind assertions, the contained pattern must only match strings of some fixed length. Patterns which start with negative lookbehind assertions may match at the beginning of the string being searched. (?(id/name)yes-pattern|no-pattern) Will try to match with yes-pattern if the group with given id or name exists, and with no-pattern if it doesn’t. no-pattern is optional and can be omitted. For example, (<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$) is a poor email matching pattern, which will match with '<user@host.com>' as well as 'user@host.com', but not with '<user@host.com' nor 'user@host.com>'. The special sequences consist of '\\' and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, \\$ matches the character '$'. \\number Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, (.+) \\1 matches 'the the' or '55 55', but not 'thethe' (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the '[' and ']' of a character class, all numeric escapes are treated as characters. \\A Matches only at the start of the string. \\b Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of word characters. Note that formally, \\b is defined as the boundary between a \\w and a \\W character (or vice versa), or between \\w and the beginning/end of the string. This means that r'\\bfoo\\b' matches 'foo', 'foo.', '(foo)', 'bar foo baz' but not 'foobar' or 'foo3'. By default Unicode alphanumerics are the ones used in Unicode patterns, but this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. Inside a character range, \\b represents the backspace character, for compatibility with Python’s string literals. \\B Matches the empty string, but only when it is not at the beginning or end of a word. This means that r'py\\B' matches 'python', 'py3', 'py2', but not 'py', 'py.', or 'py!'. \\B is just the opposite of \\b, so word characters in Unicode patterns are Unicode alphanumerics or the underscore, although this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. \\d For Unicode (str) patterns: Matches any Unicode decimal digit (that is, any character in Unicode character category [Nd]). This includes [0-9], and also many other digit characters. If the ASCII flag is used only [0-9] is matched. For 8-bit (bytes) patterns: Matches any decimal digit; this is equivalent to [0-9]. \\D Matches any character which is not a decimal digit. This is the opposite of \\d. If the", "score": "0.69004536"}, {"id": "23301", "text": "Function: python.library.re\nSnippet: repetitions as possible. For example, a{3,5} will match from 3 to 5 'a' characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, a{4,}b will match 'aaaab' or a thousand 'a' characters followed by a 'b', but not 'aaab'. The comma may not be omitted or the modifier would be confused with the previously described form. {m,n}? Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous qualifier. For example, on the 6-character string 'aaaaaa', a{3,5} will match 5 'a' characters, while a{3,5}? will only match 3 characters. \\ Either escapes special characters (permitting you to match characters like '*', '?', and so forth), or signals a special sequence; special sequences are discussed below. If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions. [] Used to indicate a set of characters. In a set: Characters can be listed individually, e.g. [amk] will match 'a', 'm', or 'k'. Ranges of characters can be indicated by giving two characters and separating them by a '-', for example [a-z] will match any lowercase ASCII letter, [0-5][0-9] will match all the two-digits numbers from 00 to 59, and [0-9A-Fa-f] will match any hexadecimal digit. If - is escaped (e.g. [a\\-z]) or if it’s placed as the first or last character (e.g. [-a] or [a-]), it will match a literal '-'. Special characters lose their special meaning inside sets. For example, [(+*)] will match any of the literal characters '(', '+', '*', or ')'. Character classes such as \\w or \\S (defined below) are also accepted inside a set, although the characters they match depends on whether ASCII or LOCALE mode is in force. Characters that are not within a range can be matched by complementing the set. If the first character of the set is '^', all the characters that are not in the set will be matched. For example, [^5] will match any character except '5', and [^^] will match any character except '^'. ^ has no special meaning if it’s not the first character in the set. To match a literal ']' inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both [()[\\]{}] and []()[{}] will both match a parenthesis. Support of nested sets and set operations as in Unicode Technical Standard #18 might be added in the future. This would change the syntax, so to facilitate this change", "score": "0.6884216"}, {"id": "23341", "text": "Function: python.library.re#re.Match.group\nSnippet: Match.group([group1, ...]) Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an IndexError exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is None. If a group is contained in a part of the pattern that matched multiple times, the last match is returned. >>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\") >>> m.group(0) # The entire match 'Isaac Newton' >>> m.group(1) # The first parenthesized subgroup. 'Isaac' >>> m.group(2) # The second parenthesized subgroup. 'Newton' >>> m.group(1, 2) # Multiple arguments give us a tuple. ('Isaac', 'Newton') If the regular expression uses the (?P<name>...) syntax, the groupN arguments may also be strings identifying groups by their group name. If a string argument is not used as a group name in the pattern, an IndexError exception is raised. A moderately complicated example: >>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm Reynolds\") >>> m.group('first_name') 'Malcolm' >>> m.group('last_name') 'Reynolds' Named groups can also be referred to by their index: >>> m.group(1) 'Malcolm' >>> m.group(2) 'Reynolds' If a group matches multiple times, only the last match is accessible: >>> m = re.match(r\"(..)+\", \"a1b2c3\") # Matches 3 times. >>> m.group(1) # Returns only the last match. 'c3'", "score": "0.67617506"}, {"id": "23309", "text": "Function: python.library.re\nSnippet: are replaced only when not adjacent to a previous empty match, so sub('x*', '-', 'abxd') returns '-a-b--d-'. In string-type repl arguments, in addition to the character escapes and backreferences described above, \\g<name> will use the substring matched by the group named name, as defined by the (?P<name>...) syntax. \\g<number> uses the corresponding group number; \\g<2> is therefore equivalent to \\2, but isn’t ambiguous in a replacement such as \\g<2>0. \\20 would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character '0'. The backreference \\g<0> substitutes in the entire substring matched by the RE. Changed in version 3.1: Added the optional flags argument. Changed in version 3.5: Unmatched groups are replaced with an empty string. Changed in version 3.6: Unknown escapes in pattern consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Unknown escapes in repl consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Empty matches for the pattern are replaced when adjacent to a previous non-empty match. re.subn(pattern, repl, string, count=0, flags=0) Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Changed in version 3.1: Added the optional flags argument. Changed in version 3.5: Unmatched groups are replaced with an empty string. re.escape(pattern) Escape special characters in pattern. This is useful if you want to match an arbitrary literal string that may have regular expression metacharacters in it. For example: >>> print(re.escape('http://www.python.org')) http://www\\.python\\.org >>> legal_chars = string.ascii_lowercase + string.digits + \"!#$%&'*+-.^_`|~:\" >>> print('[%s]+' % re.escape(legal_chars)) [abcdefghijklmnopqrstuvwxyz0123456789!\\#\\$%\\&'\\*\\+\\-\\.\\^_`\\|\\~:]+ >>> operators = ['+', '-', '*', '/', '**'] >>> print('|'.join(map(re.escape, sorted(operators, reverse=True)))) /|\\-|\\+|\\*\\*|\\* This function must not be used for the replacement string in sub() and subn(), only backslashes should be escaped. For example: >>> digits_re = r'\\d+' >>> sample = '/usr/sbin/sendmail - 0 errors, 12 warnings' >>> print(re.sub(digits_re, digits_re.replace('\\\\', r'\\\\'), sample)) /usr/sbin/sendmail - \\d+ errors, \\d+ warnings Changed in version 3.3: The '_' character is no longer escaped. Changed in version 3.7: Only characters that can have special meaning in a regular expression are escaped. As a result, '!', '\"', '%', \"'\", ',', '/', ':', ';', '<', '=', '>', '@', and \"`\" are no longer escaped. re.purge() Clear the regular expression cache. exception re.error(msg, pattern=None, pos=None) Exception raised when a string passed to one of the functions here is not a valid regular expression (for example, it might contain unmatched parentheses) or when some other error occurs during compilation or matching. It is never an error if a string contains no match for a pattern. The error instance has the following additional attributes: msg The unformatted error message. pattern The regular expression pattern. pos The index in pattern where compilation failed (may be None). lineno The line corresponding to pos (may be None). colno The column corresponding to pos (may be None). Changed in version 3.5: Added additional attributes. Regular Expression Objects Compiled regular expression objects support the following methods and attributes: Pattern.search(string[, pos[, endpos]]) Scan through string looking", "score": "0.67567724"}]}
{"task_id": "mbpp_435", "code": "def last_Digit(n) :\r\n    return (n % 10) ", "test_list": ["assert last_Digit(123) == 3", "assert last_Digit(25) == 5", "assert last_Digit(30) == 0"], "context": "Write a python function to find the last digit of a given number.", "function_name": "def last_Digit(n) :", "gold_generation": "return (n % 10)", "ctxs": [{"id": "24403", "text": "Function: python.library.string#string.digits\nSnippet: string.digits The string '0123456789'.", "score": "0.70814395"}, {"id": "19592", "text": "Function: python.library.decimal#decimal.ROUND_05UP\nSnippet: decimal.ROUND_05UP Round away from zero if last digit after rounding towards zero would have been 0 or 5; otherwise round towards zero.", "score": "0.6936789"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6918745"}, {"id": "21836", "text": "Function: python.library.math#math.ulp\nSnippet: math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9.", "score": "0.68236625"}, {"id": "24415", "text": "Function: python.library.string#string.octdigits\nSnippet: string.octdigits The string '01234567'.", "score": "0.68161213"}]}
{"task_id": "mbpp_436", "code": "def neg_nos(list1):\r\n  for num in list1: \r\n    if num < 0: \r\n       return num ", "test_list": ["assert neg_nos([-1,4,5,-6]) == -1,-6", "assert neg_nos([-1,-2,3,4]) == -1,-2", "assert neg_nos([-7,-6,8,9]) == -7,-6"], "context": "Write a python function to print negative numbers in a list.", "function_name": "def neg_nos(list1):", "gold_generation": "for num in list1: \r\n    if num < 0: \r\n       return num", "ctxs": [{"id": "25740", "text": "Function: python.library.stdtypes\nSnippet: omitted, it defaults to 0. If step is zero, ValueError is raised. For a positive step, the contents of a range r are determined by the formula r[i] = start + step*i where i >= 0 and r[i] < stop. For a negative step, the contents of the range are still determined by the formula r[i] = start + step*i, but the constraints are i >= 0 and r[i] > stop. A range object will be empty if r[0] does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than sys.maxsize are permitted but some features (such as len()) may raise OverflowError. Range examples: >>> list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> list(range(0, 30, 5)) [0, 5, 10, 15, 20, 25] >>> list(range(0, 10, 3)) [0, 3, 6, 9] >>> list(range(0, -10, -1)) [0, -1, -2, -3, -4, -5, -6, -7, -8, -9] >>> list(range(0)) [] >>> list(range(1, 0)) [] Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). start The value of the start parameter (or 0 if the parameter was not supplied) stop The value of the stop parameter step The value of the step parameter (or 1 if the parameter was not supplied) The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and subranges as needed). Range objects implement the collections.abc.Sequence ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): >>> r = range(0, 20, 2) >>> r range(0, 20, 2) >>> 11 in r False >>> 10 in r True >>> r.index(10) 5 >>> r[5] 10 >>> r[:5] range(0, 10, 2) >>> r[-1] 18 Testing range objects for equality with == and != compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different start, stop and step attributes, for example range(0) == range(2, 1, 3) or range(0, 3, 2) == range(0, 4, 2).) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test int objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity). New in version 3.3: The", "score": "0.69040227"}, {"id": "17592", "text": "Function: python.library.argparse\nSnippet: negative numbers: >>> parser = argparse.ArgumentParser(prog='PROG') >>> parser.add_argument('-x') >>> parser.add_argument('foo', nargs='?') >>> # no negative number options, so -1 is a positional argument >>> parser.parse_args(['-x', '-1']) Namespace(foo=None, x='-1') >>> # no negative number options, so -1 and -5 are positional arguments >>> parser.parse_args(['-x', '-1', '-5']) Namespace(foo='-5', x='-1') >>> parser = argparse.ArgumentParser(prog='PROG') >>> parser.add_argument('-1', dest='one') >>> parser.add_argument('foo', nargs='?') >>> # negative number options present, so -1 is an option >>> parser.parse_args(['-1', 'X']) Namespace(foo=None, one='X') >>> # negative number options present, so -2 is an option >>> parser.parse_args(['-2']) usage: PROG [-h] [-1 ONE] [foo] PROG: error: no such option: -2 >>> # negative number options present, so both -1s are options >>> parser.parse_args(['-1', '-1']) usage: PROG [-h] [-1 ONE] [foo] PROG: error: argument -1: expected one argument If you have positional arguments that must begin with - and don’t look like negative numbers, you can insert the pseudo-argument '--' which tells parse_args() that everything after that is a positional argument: >>> parser.parse_args(['--', '-f']) Namespace(foo='-f', one=None) Argument abbreviations (prefix matching) The parse_args() method by default allows long options to be abbreviated to a prefix, if the abbreviation is unambiguous (the prefix matches a unique option): >>> parser = argparse.ArgumentParser(prog='PROG') >>> parser.add_argument('-bacon') >>> parser.add_argument('-badger') >>> parser.parse_args('-bac MMM'.split()) Namespace(bacon='MMM', badger=None) >>> parser.parse_args('-bad WOOD'.split()) Namespace(bacon=None, badger='WOOD') >>> parser.parse_args('-ba BA'.split()) usage: PROG [-h] [-bacon BACON] [-badger BADGER] PROG: error: ambiguous option: -ba could match -badger, -bacon An error is produced for arguments that could produce more than one options. This feature can be disabled by setting allow_abbrev to False. Beyond sys.argv Sometimes it may be useful to have an ArgumentParser parse arguments other than those of sys.argv. This can be accomplished by passing a list of strings to parse_args(). This is useful for testing at the interactive prompt: >>> parser = argparse.ArgumentParser() >>> parser.add_argument( ... 'integers', metavar='int', type=int, choices=range(10), ... nargs='+', help='an integer in the range 0..9') >>> parser.add_argument( ... '--sum', dest='accumulate', action='store_const', const=sum, ... default=max, help='sum the integers (default: find the max)') >>> parser.parse_args(['1', '2', '3', '4']) Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4]) >>> parser.parse_args(['1', '2', '3', '4', '--sum']) Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4]) The Namespace object class argparse.Namespace Simple class used by default by parse_args() to create an object holding attributes and return it. This class is deliberately simple, just an object subclass with a readable string representation. If you prefer to have dict-like view of the attributes, you can use the standard Python idiom, vars(): >>> parser = argparse.ArgumentParser() >>> parser.add_argument('--foo') >>> args = parser.parse_args(['--foo', 'BAR']) >>> vars(args) {'foo': 'BAR'} It may also be useful to have an ArgumentParser assign attributes to an already existing object, rather than a new Namespace object. This can be achieved by specifying the namespace= keyword argument: >>> class C: ... pass ... >>> c = C() >>> parser = argparse.ArgumentParser() >>> parser.add_argument('--foo') >>> parser.parse_args(args=['--foo', 'BAR'], namespace=c) >>> c.foo 'BAR' Other utilities Sub-commands ArgumentParser.add_subparsers([title][, description][, prog][, parser_class][, action][, option_string][, dest][, required][, help][, metavar]) Many programs split up their functionality into a number of sub-commands, for example,", "score": "0.6895205"}, {"id": "43061", "text": "Function: numpy.reference.generated.numpy.negative\nSnippet: numpy.negative numpy.negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'negative'> Numerical negative, element-wise. Parameters xarray_like or scalar Input array. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar Returned array or scalar: y = -x. This is a scalar if x is a scalar. Examples >>> np.negative([1.,-1.]) array([-1., 1.]) The unary - operator can be used as a shorthand for np.negative on ndarrays. >>> x1 = np.array(([1., -1.])) >>> -x1 array([-1., 1.])", "score": "0.68385756"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.67779905"}, {"id": "23294", "text": "Function: python.library.stdtypes#range\nSnippet: class range(stop) class range(start, stop[, step]) The arguments to the range constructor must be integers (either built-in int or any object that implements the __index__ special method). If the step argument is omitted, it defaults to 1. If the start argument is omitted, it defaults to 0. If step is zero, ValueError is raised. For a positive step, the contents of a range r are determined by the formula r[i] = start + step*i where i >= 0 and r[i] < stop. For a negative step, the contents of the range are still determined by the formula r[i] = start + step*i, but the constraints are i >= 0 and r[i] > stop. A range object will be empty if r[0] does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than sys.maxsize are permitted but some features (such as len()) may raise OverflowError. Range examples: >>> list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> list(range(0, 30, 5)) [0, 5, 10, 15, 20, 25] >>> list(range(0, 10, 3)) [0, 3, 6, 9] >>> list(range(0, -10, -1)) [0, -1, -2, -3, -4, -5, -6, -7, -8, -9] >>> list(range(0)) [] >>> list(range(1, 0)) [] Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). start The value of the start parameter (or 0 if the parameter was not supplied) stop The value of the stop parameter step The value of the step parameter (or 1 if the parameter was not supplied)", "score": "0.66559726"}]}
{"task_id": "mbpp_437", "code": "def remove_odd(str1):\r\n str2 = ''\r\n for i in range(1, len(str1) + 1):\r\n    if(i % 2 == 0):\r\n        str2 = str2 + str1[i - 1]\r\n return str2", "test_list": ["assert remove_odd(\"python\")==(\"yhn\")", "assert remove_odd(\"program\")==(\"rga\")", "assert remove_odd(\"language\")==(\"agae\")"], "context": "Write a function to remove odd characters in a string.", "function_name": "def remove_odd(str1):", "gold_generation": "str2 = ''\r\n for i in range(1, len(str1) + 1):\r\n    if(i % 2 == 0):\r\n        str2 = str2 + str1[i - 1]\r\n return str2", "ctxs": [{"id": "24398", "text": "Function: python.library.string\nSnippet: characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", "score": "0.69579774"}, {"id": "24376", "text": "Function: python.library.stdtypes#str.rstrip\nSnippet: str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty'", "score": "0.69569385"}, {"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.69263893"}, {"id": "25746", "text": "Function: python.library.stdtypes\nSnippet: Return -1 on failure. str.rindex(sub[, start[, end]]) Like rfind() but raises ValueError when the substring sub is not found. str.rjust(width[, fillchar]) Return the string right justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.rpartition(sep) Split the string at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself. str.rsplit(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any whitespace string is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below. str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty' str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3'] str.splitlines([keepends]) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. This", "score": "0.6910404"}, {"id": "25756", "text": "Function: python.library.stdtypes\nSnippet: binary sequence of byte values to remove may be any bytes-like object. See removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> b'Monty Python'.rstrip(b' Python') b'M' >>> b'Monty Python'.removesuffix(b' Python') b'Monty' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3'] bytes.strip([chars]) bytearray.strip([chars]) Return a copy of the sequence with specified leading and trailing bytes removed. The chars argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters. If omitted or None, the chars argument defaults to removing ASCII whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> b' spacious '.strip() b'spacious' >>> b'www.example.com'.strip(b'cmowz.') b'example' The binary sequence of byte values to remove may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.capitalize() bytearray.capitalize() Return a copy of the sequence with each byte interpreted as an ASCII character, and the first byte capitalized and the rest", "score": "0.68499684"}]}
{"task_id": "mbpp_438", "code": "def count_bidirectional(test_list):\r\n  res = 0\r\n  for idx in range(0, len(test_list)):\r\n    for iidx in range(idx + 1, len(test_list)):\r\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\r\n        res += 1\r\n  return (str(res)) ", "test_list": ["assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == '3'", "assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == '2'", "assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == '4'"], "context": "Write a function to count bidirectional tuple pairs.", "function_name": "def count_bidirectional(test_list):", "gold_generation": "res = 0\r\n  for idx in range(0, len(test_list)):\r\n    for iidx in range(idx + 1, len(test_list)):\r\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\r\n        res += 1\r\n  return (str(res))", "ctxs": [{"id": "22306", "text": "Function: python.library.operator#operator.countOf\nSnippet: operator.countOf(a, b) Return the number of occurrences of b in a.", "score": "0.6920458"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.68427753"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.6815697"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.67889374"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.67069924"}]}
{"task_id": "mbpp_439", "code": "def multiple_to_single(L):\r\n  x = int(\"\".join(map(str, L)))\r\n  return x", "test_list": ["assert multiple_to_single([11, 33, 50])==113350", "assert multiple_to_single([-1,2,3,4,5,6])==-123456", "assert multiple_to_single([10,15,20,25])==10152025"], "context": "Write a function to convert a list of multiple integers into a single integer.", "function_name": "def multiple_to_single(L):", "gold_generation": "x = int(\"\".join(map(str, L)))\r\n  return x", "ctxs": [{"id": "17646", "text": "Function: python.library.array#array.array.tolist\nSnippet: array.tolist() Convert the array to an ordinary list with the same items.", "score": "0.67408437"}, {"id": "25737", "text": "Function: python.library.stdtypes\nSnippet: a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str objects, you can build a list and use str.join() at the end or else write to an io.StringIO instance and retrieve its value when complete if concatenating bytes objects, you can similarly use bytes.join() or io.BytesIO, or you can do in-place concatenation with a bytearray object. bytearray objects are mutable and have an efficient overallocation mechanism if concatenating tuple objects, extend a list instead for other types, investigate the relevant class documentation Some sequence types (such as range) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition. index raises ValueError when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using s[i:j].index(x), only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. Immutable Sequence Types The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the hash() built-in. This support allows immutable sequences, such as tuple instances, to be used as dict keys and stored in set and frozenset instances. Attempting to hash an immutable sequence that contains unhashable values will result in TypeError. Mutable Sequence Types The operations in the following table are defined on mutable sequence types. The collections.abc.MutableSequence ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, bytearray only accepts integers that meet the value restriction 0 <= x <= 255). Operation Result Notes s[i] = x item i of s is replaced by x s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t del s[i:j] same as s[i:j] = [] s[i:j:k] = t the elements of s[i:j:k] are replaced by those of t (1) del s[i:j:k] removes the elements of s[i:j:k] from the list s.append(x) appends x to the end of the sequence (same as s[len(s):len(s)] = [x]) s.clear() removes all items from s (same as del s[:]) (5) s.copy() creates a shallow copy of s (same as s[:]) (5) s.extend(t) or s += t extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t) s *= n updates s with its contents repeated n times (6) s.insert(i, x) inserts x into s at the index given by i (same as s[i:i] = [x]) s.pop([i]) retrieves the item at i and also removes it", "score": "0.66879153"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6679631"}, {"id": "42835", "text": "Function: numpy.reference.arrays.scalars#numpy.float32\nSnippet: numpy.float32[source] alias of numpy.single", "score": "0.6652888"}, {"id": "19499", "text": "Function: python.library.decimal#decimal.Context.normalize\nSnippet: normalize(x) Reduces x to its simplest form.", "score": "0.6624083"}]}
{"task_id": "mbpp_440", "code": "import re\r\ndef find_adverb_position(text):\r\n for m in re.finditer(r\"\\w+ly\", text):\r\n    return (m.start(), m.end(), m.group(0))", "test_list": ["assert find_adverb_position(\"clearly!! we can see the sky\")==(0, 7, 'clearly')", "assert find_adverb_position(\"seriously!! there are many roses\")==(0, 9, 'seriously')", "assert find_adverb_position(\"unfortunately!! sita is going to home\")==(0, 13, 'unfortunately')"], "context": "Write a function to find all adverbs and their positions in a given sentence.", "function_name": "import re\r\ndef find_adverb_position(text):", "gold_generation": "for m in re.finditer(r\"\\w+ly\", text):\r\n    return (m.start(), m.end(), m.group(0))", "ctxs": [{"id": "23315", "text": "Function: python.library.re\nSnippet: ['carefully', 'quickly'] Finding all Adverbs and their Positions If one wants more information about all matches of a pattern than the matched text, finditer() is useful as it provides match objects instead of strings. Continuing with the previous example, if a writer wanted to find all of the adverbs and their positions in some text, they would use finditer() in the following manner: >>> text = \"He was carefully disguised but captured quickly by police.\" >>> for m in re.finditer(r\"\\w+ly\", text): ... print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0))) 07-16: carefully 40-47: quickly Raw String Notation Raw string notation (r\"text\") keeps regular expressions sane. Without it, every backslash ('\\') in a regular expression would have to be prefixed with another one to escape it. For example, the two following lines of code are functionally identical: >>> re.match(r\"\\W(.)\\1\\W\", \" ff \") <re.Match object; span=(0, 4), match=' ff '> >>> re.match(\"\\\\W(.)\\\\1\\\\W\", \" ff \") <re.Match object; span=(0, 4), match=' ff '> When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, this means r\"\\\\\". Without raw string notation, one must use \"\\\\\\\\\", making the following lines of code functionally identical: >>> re.match(r\"\\\\\", r\"\\\\\") <re.Match object; span=(0, 1), match='\\\\'> >>> re.match(\"\\\\\\\\\", r\"\\\\\") <re.Match object; span=(0, 1), match='\\\\'> Writing a Tokenizer A tokenizer or scanner analyzes a string to categorize groups of characters. This is a useful first step in writing a compiler or interpreter. The text categories are specified with regular expressions. The technique is to combine those into a single master regular expression and to loop over successive matches: from typing import NamedTuple import re class Token(NamedTuple): type: str value: str line: int column: int def tokenize(code): keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'} token_specification = [ ('NUMBER', r'\\d+(\\.\\d*)?'), # Integer or decimal number ('ASSIGN', r':='), # Assignment operator ('END', r';'), # Statement terminator ('ID', r'[A-Za-z]+'), # Identifiers ('OP', r'[+\\-*/]'), # Arithmetic operators ('NEWLINE', r'\\n'), # Line endings ('SKIP', r'[ \\t]+'), # Skip over spaces and tabs ('MISMATCH', r'.'), # Any other character ] tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specification) line_num = 1 line_start = 0 for mo in re.finditer(tok_regex, code): kind = mo.lastgroup value = mo.group() column = mo.start() - line_start if kind == 'NUMBER': value = float(value) if '.' in value else int(value) elif kind == 'ID' and value in keywords: kind = value elif kind == 'NEWLINE': line_start = mo.end() line_num += 1 continue elif kind == 'SKIP': continue elif kind == 'MISMATCH': raise RuntimeError(f'{value!r} unexpected on line {line_num}') yield Token(kind, value, line_num, column) statements = ''' IF quantity THEN total := total + price * quantity; tax := price * 0.05; ENDIF; ''' for token in tokenize(statements): print(token) The tokenizer produces the following output: Token(type='IF', value='IF', line=2, column=4) Token(type='ID', value='quantity', line=2, column=7) Token(type='THEN', value='THEN', line=2, column=16) Token(type='ID', value='total', line=3, column=8) Token(type='ASSIGN', value=':=', line=3, column=14) Token(type='ID', value='total', line=3, column=17) Token(type='OP', value='+', line=3, column=23) Token(type='ID', value='price', line=3, column=25) Token(type='OP', value='*', line=3, column=31) Token(type='ID', value='quantity', line=3, column=33)", "score": "0.7114342"}, {"id": "23310", "text": "Function: python.library.re\nSnippet: for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\" Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). Pattern.fullmatch(string[, pos[, endpos]]) If the whole string matches this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o[gh]\") >>> pattern.fullmatch(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.fullmatch(\"ogre\") # No match as not the full string matches. >>> pattern.fullmatch(\"doggie\", 1, 3) # Matches within given limits. <re.Match object; span=(1, 3), match='og'> New in version 3.4. Pattern.split(string, maxsplit=0) Identical to the split() function, using the compiled pattern. Pattern.findall(string[, pos[, endpos]]) Similar to the findall() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.finditer(string[, pos[, endpos]]) Similar to the finditer() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.sub(repl, string, count=0) Identical to the sub() function, using the compiled pattern. Pattern.subn(repl, string, count=0) Identical to the subn() function, using the compiled pattern. Pattern.flags The regex", "score": "0.6327039"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.6321443"}, {"id": "41813", "text": "Function: numpy.reference.generated.numpy.chararray.searchsorted\nSnippet: numpy.chararray.searchsorted method chararray.searchsorted(v, side='left', sorter=None) Find indices where elements of v should be inserted in a to maintain order. For full documentation, see numpy.searchsorted See also numpy.searchsorted equivalent function", "score": "0.6311576"}, {"id": "41691", "text": "Function: numpy.reference.generated.numpy.char.chararray.searchsorted\nSnippet: numpy.char.chararray.searchsorted method char.chararray.searchsorted(v, side='left', sorter=None) Find indices where elements of v should be inserted in a to maintain order. For full documentation, see numpy.searchsorted See also numpy.searchsorted equivalent function", "score": "0.6309494"}]}
{"task_id": "mbpp_441", "code": "def surfacearea_cube(l):\r\n  surfacearea= 6*l*l\r\n  return surfacearea", "test_list": ["assert surfacearea_cube(5)==150", "assert surfacearea_cube(3)==54", "assert surfacearea_cube(10)==600"], "context": "Write a function to find the surface area of a cube.", "function_name": "def surfacearea_cube(l):", "gold_generation": "surfacearea= 6*l*l\r\n  return surfacearea", "ctxs": [{"id": "17024", "text": "Function: skimage.api.skimage.measure#skimage.measure.mesh_surface_area\nSnippet: skimage.measure.mesh_surface_area(verts, faces) [source] Compute surface area, given vertices & triangular faces Parameters verts(V, 3) array of floats Array containing (x, y, z) coordinates for V unique mesh vertices. faces(F, 3) array of ints List of length-3 lists of integers, referencing vertex coordinates as provided in verts Returns areafloat Surface area of mesh. Units now [coordinate units] ** 2. See also skimage.measure.marching_cubes skimage.measure.marching_cubes_classic Notes The arguments expected by this function are the first two outputs from skimage.measure.marching_cubes. For unit correct output, ensure correct spacing was passed to skimage.measure.marching_cubes. This algorithm works properly only if the faces provided are all triangles.", "score": "0.6861626"}, {"id": "17021", "text": "Function: skimage.api.skimage.measure#skimage.measure.marching_cubes_classic\nSnippet: guarantees coherent orientation as of version 0.12. To quantify the area of an isosurface generated by this algorithm, pass outputs directly into skimage.measure.mesh_surface_area. References 1(1,2,3) Lorensen, William and Harvey E. Cline. Marching Cubes: A High Resolution 3D Surface Construction Algorithm. Computer Graphics (SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170). DOI:10.1145/37401.37422", "score": "0.6537728"}, {"id": "17020", "text": "Function: skimage.api.skimage.measure#skimage.measure.marching_cubes_classic\nSnippet: skimage.measure.marching_cubes_classic(volume, level=None, spacing=(1.0, 1.0, 1.0), gradient_direction='descent') [source] Classic marching cubes algorithm to find surfaces in 3d volumetric data. Note that the marching_cubes() algorithm is recommended over this algorithm, because it’s faster and produces better results. Parameters volume(M, N, P) array of doubles Input data volume to find isosurfaces. Will be cast to np.float64. levelfloat Contour value to search for isosurfaces in volume. If not given or None, the average of the min and max of vol is used. spacinglength-3 tuple of floats Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in volume. gradient_directionstring Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object Returns verts(V, 3) array Spatial coordinates for V unique mesh vertices. Coordinate order matches input volume (M, N, P). If allow_degenerate is set to True, then the presence of degenerate triangles in the mesh can make this array have duplicate vertices. faces(F, 3) array Define triangular faces via referencing vertex indices from verts. This algorithm specifically outputs triangles, so each face has exactly three indices. See also skimage.measure.marching_cubes skimage.measure.mesh_surface_area Notes The marching cubes algorithm is implemented as described in [1]. A simple explanation is available here: http://users.polytech.unice.fr/~lingrand/MarchingCubes/algo.html There are several known ambiguous cases in the marching cubes algorithm. Using point labeling as in [1], Figure 4, as shown: v8 ------ v7 / | / | y / | / | ^ z v4 ------ v3 | | / | v5 ----|- v6 |/ (note: NOT right handed!) | / | / ----> x | / | / v1 ------ v2 Most notably, if v4, v8, v2, and v6 are all >= level (or any generalization of this case) two parallel planes are generated by this algorithm, separating v4 and v8 from v2 and v6. An equally valid interpretation would be a single connected thin surface enclosing all four points. This is the best known ambiguity, though there are others. This algorithm does not attempt to resolve such ambiguities; it is a naive implementation of marching cubes as in [1], but may be a good beginning for work with more recent techniques (Dual Marching Cubes, Extended Marching Cubes, Cubic Marching Squares, etc.). Because of interactions between neighboring cubes, the isosurface(s) generated by this algorithm are NOT guaranteed to be closed, particularly for complicated contours. Furthermore, this algorithm does not guarantee a single contour will be returned. Indeed, ALL isosurfaces which cross level will be found, regardless of connectivity. The output is a triangular mesh consisting of a set of unique vertices and connecting triangles. The order of these vertices and triangles in the output list is determined by the position of the smallest x,y,z (in lexicographical order) coordinate in the contour. This is a side-effect of how the input array is traversed, but can be relied upon. The generated mesh", "score": "0.6285617"}, {"id": "33487", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: barbs_doc='\\nPlot a 2D field of barbs.\\n\\nCall signature::\\n\\n barbs([X, Y], U, V, [C], **kw)\\n\\nWhere *X*, *Y* define the barb locations, *U*, *V* define the barb\\ndirections, and *C* optionally sets the color.\\n\\nAll arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked\\n*X*, *Y* are not supported at present.\\n\\nBarbs are traditionally used in meteorology as a way to plot the speed\\nand direction of wind observations, but can technically be used to\\nplot any two dimensional vector quantity. As opposed to arrows, which\\ngive vector magnitude by the length of the arrow, the barbs give more\\nquantitative information about the vector magnitude by putting slanted\\nlines or a triangle for various increments in magnitude, as show\\nschematically below::\\n\\n : /\\\\ \\\\\\n : / \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : ------------------------------\\n\\nThe largest increment is given by a triangle (or \"flag\"). After those\\ncome full lines (barbs). The smallest increment is a half line. There\\nis only, of course, ever at most 1 half line. If the magnitude is\\nsmall and only needs a single half-line and no full lines or\\ntriangles, the half-line is offset from the end of the barb so that it\\ncan be easily distinguished from barbs with a single full line. The\\nmagnitude for the barb shown above would nominally be 65, using the\\nstandard increments of 50, 10, and 5.\\n\\nSee also https://en.wikipedia.org/wiki/Wind_barb.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the barb locations. See *pivot* for how the\\n barbs are drawn to the x, y positions.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y components of the barb shaft.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If", "score": "0.62574625"}, {"id": "16974", "text": "Function: skimage.api.skimage.measure\nSnippet: x = np.eye(3).astype(int) >>> print(x) [[1 0 0] [0 1 0] [0 0 1]] >>> print(label(x, connectivity=1)) [[1 0 0] [0 2 0] [0 0 3]] >>> print(label(x, connectivity=2)) [[1 0 0] [0 1 0] [0 0 1]] >>> print(label(x, background=-1)) [[1 2 2] [2 1 2] [2 2 1]] >>> x = np.array([[1, 0, 0], ... [1, 1, 5], ... [0, 0, 0]]) >>> print(label(x)) [[1 0 0] [1 1 2] [0 0 0]] Examples using skimage.measure.label Measure region properties Euler number Segment human cells (in mitosis) marching_cubes skimage.measure.marching_cubes(volume, level=None, *, spacing=(1.0, 1.0, 1.0), gradient_direction='descent', step_size=1, allow_degenerate=True, method='lewiner', mask=None) [source] Marching cubes algorithm to find surfaces in 3d volumetric data. In contrast with Lorensen et al. approach [2], Lewiner et al. algorithm is faster, resolves ambiguities, and guarantees topologically correct results. Therefore, this algorithm generally a better choice. Parameters volume(M, N, P) array Input data volume to find isosurfaces. Will internally be converted to float32 if necessary. levelfloat, optional Contour value to search for isosurfaces in volume. If not given or None, the average of the min and max of vol is used. spacinglength-3 tuple of floats, optional Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in volume. gradient_directionstring, optional Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite, considering the left-hand rule. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object step_sizeint, optional Step size in voxels. Default 1. Larger steps yield faster but coarser results. The result will always be topologically correct though. allow_degeneratebool, optional Whether to allow degenerate (i.e. zero-area) triangles in the end-result. Default True. If False, degenerate triangles are removed, at the cost of making the algorithm slower. method: str, optional One of ‘lewiner’, ‘lorensen’ or ‘_lorensen’. Specify witch of Lewiner et al. or Lorensen et al. method will be used. The ‘_lorensen’ flag correspond to an old implementation that will be deprecated in version 0.19. mask(M, N, P) array, optional Boolean array. The marching cube algorithm will be computed only on True elements. This will save computational time when interfaces are located within certain region of the volume M, N, P-e.g. the top half of the cube-and also allow to compute finite surfaces-i.e. open surfaces that do not end at the border of the cube. Returns verts(V, 3) array Spatial coordinates for V unique mesh vertices. Coordinate order matches input volume (M, N, P). If allow_degenerate is set to True, then the presence of degenerate triangles in the mesh can make this array have duplicate vertices. faces(F, 3) array Define triangular faces via referencing vertex indices from verts. This algorithm specifically outputs triangles, so each face has exactly three indices. normals(V, 3) array The normal direction at each vertex, as calculated from the data. values(V, ) array Gives a measure for the maximum value of the data in the local region near each", "score": "0.6252824"}]}
{"task_id": "mbpp_442", "code": "from array import array\r\ndef positive_count(nums):\r\n    n = len(nums)\r\n    n1 = 0\r\n    for x in nums:\r\n        if x > 0:\r\n            n1 += 1\r\n        else:\r\n          None\r\n    return round(n1/n,2)", "test_list": ["assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54", "assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69", "assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56"], "context": "Write a function to find the ration of positive numbers in an array of integers.", "function_name": "from array import array\r\ndef positive_count(nums):", "gold_generation": "n = len(nums)\r\n    n1 = 0\r\n    for x in nums:\r\n        if x > 0:\r\n            n1 += 1\r\n        else:\r\n          None\r\n    return round(n1/n,2)", "ctxs": [{"id": "20204", "text": "Function: python.library.fractions#fractions.Fraction.as_integer_ratio\nSnippet: as_integer_ratio() Return a tuple of two integers, whose ratio is equal to the Fraction and with a positive denominator. New in version 3.8.", "score": "0.70890707"}, {"id": "21070", "text": "Function: python.library.stdtypes#int.as_integer_ratio\nSnippet: int.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original integer and with a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. New in version 3.8.", "score": "0.69558436"}, {"id": "20189", "text": "Function: python.library.stdtypes#float.as_integer_ratio\nSnippet: float.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original float and with a positive denominator. Raises OverflowError on infinities and a ValueError on NaNs.", "score": "0.67957646"}, {"id": "13013", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos#sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.65933096"}, {"id": "12778", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.6551351"}]}
{"task_id": "mbpp_443", "code": "def largest_neg(list1): \r\n    max = list1[0] \r\n    for x in list1: \r\n        if x < max : \r\n             max = x  \r\n    return max", "test_list": ["assert largest_neg([1,2,3,-4,-6]) == -6", "assert largest_neg([1,2,3,-8,-9]) == -9", "assert largest_neg([1,2,3,4,-1]) == -1"], "context": "Write a python function to find the largest negative number from the given list.", "function_name": "def largest_neg(list1):", "gold_generation": "max = list1[0] \r\n    for x in list1: \r\n        if x < max : \r\n             max = x  \r\n    return max", "ctxs": [{"id": "19496", "text": "Function: python.library.decimal#decimal.Context.next_minus\nSnippet: next_minus(x) Returns the largest representable number smaller than x.", "score": "0.72113425"}, {"id": "19558", "text": "Function: python.library.decimal#decimal.Decimal.next_minus\nSnippet: next_minus(context=None) Return the largest number representable in the given context (or in the current thread’s context if no context is given) that is smaller than the given operand.", "score": "0.7015423"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.68088216"}, {"id": "43061", "text": "Function: numpy.reference.generated.numpy.negative\nSnippet: numpy.negative numpy.negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'negative'> Numerical negative, element-wise. Parameters xarray_like or scalar Input array. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar Returned array or scalar: y = -x. This is a scalar if x is a scalar. Examples >>> np.negative([1.,-1.]) array([-1., 1.]) The unary - operator can be used as a shorthand for np.negative on ndarrays. >>> x1 = np.array(([1., -1.])) >>> -x1 array([-1., 1.])", "score": "0.67038405"}, {"id": "21776", "text": "Function: python.library.math\nSnippet: (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9. Note that frexp() and modf() have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 2**52 necessarily has no fractional bits. Power and logarithmic functions math.exp(x) Return e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). math.expm1(x) Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision: >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.0000050000069649e-05 >>> expm1(1e-5) # result accurate to full precision 1.0000050000166668e-05 New in version 3.2. math.log(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). math.log1p(x) Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. math.log2(x) Return the base-2 logarithm of x. This is usually more accurate than log(x, 2). New in version 3.3. See also int.bit_length() returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. math.log10(x) Return the base-10 logarithm of x. This is usually more accurate than log(x, 10). math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", "score": "0.66834486"}]}
{"task_id": "mbpp_444", "code": "def trim_tuple(test_list, K):\r\n  res = []\r\n  for ele in test_list:\r\n    N = len(ele)\r\n    res.append(tuple(list(ele)[K: N - K]))\r\n  return (str(res)) ", "test_list": ["assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'", "assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'", "assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'"], "context": "Write a function to trim each tuple by k in the given tuple list.", "function_name": "def trim_tuple(test_list, K):", "gold_generation": "res = []\r\n  for ele in test_list:\r\n    N = len(ele)\r\n    res.append(tuple(list(ele)[K: N - K]))\r\n  return (str(res))", "ctxs": [{"id": "36704", "text": "Function: django.ref.contrib.gis.geos#django.contrib.gis.geos.WKTWriter.trim\nSnippet: trim", "score": "0.6763018"}, {"id": "18685", "text": "Function: python.library.collections#collections.somenamedtuple._replace\nSnippet: somenamedtuple._replace(**kwargs) Return a new instance of the named tuple replacing specified fields with new values: >>> p = Point(x=11, y=22) >>> p._replace(x=33) Point(x=33, y=22) >>> for partnum, record in inventory.items(): ... inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now())", "score": "0.65849006"}, {"id": "25756", "text": "Function: python.library.stdtypes\nSnippet: binary sequence of byte values to remove may be any bytes-like object. See removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> b'Monty Python'.rstrip(b' Python') b'M' >>> b'Monty Python'.removesuffix(b' Python') b'Monty' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3'] bytes.strip([chars]) bytearray.strip([chars]) Return a copy of the sequence with specified leading and trailing bytes removed. The chars argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters. If omitted or None, the chars argument defaults to removing ASCII whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> b' spacious '.strip() b'spacious' >>> b'www.example.com'.strip(b'cmowz.') b'example' The binary sequence of byte values to remove may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.capitalize() bytearray.capitalize() Return a copy of the sequence with each byte interpreted as an ASCII character, and the first byte capitalized and the rest", "score": "0.6573447"}, {"id": "18617", "text": "Function: python.library.collections\nSnippet: a new instance of the named tuple replacing specified fields with new values: >>> p = Point(x=11, y=22) >>> p._replace(x=33) Point(x=33, y=22) >>> for partnum, record in inventory.items(): ... inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now()) somenamedtuple._fields Tuple of strings listing the field names. Useful for introspection and for creating new named tuple types from existing named tuples. >>> p._fields # view the field names ('x', 'y') >>> Color = namedtuple('Color', 'red green blue') >>> Pixel = namedtuple('Pixel', Point._fields + Color._fields) >>> Pixel(11, 22, 128, 255, 0) Pixel(x=11, y=22, red=128, green=255, blue=0) somenamedtuple._field_defaults Dictionary mapping field names to default values. >>> Account = namedtuple('Account', ['type', 'balance'], defaults=[0]) >>> Account._field_defaults {'balance': 0} >>> Account('premium') Account(type='premium', balance=0) To retrieve a field whose name is stored in a string, use the getattr() function: >>> getattr(p, 'x') 11 To convert a dictionary to a named tuple, use the double-star-operator (as described in Unpacking Argument Lists): >>> d = {'x': 11, 'y': 22} >>> Point(**d) Point(x=11, y=22) Since a named tuple is a regular Python class, it is easy to add or change functionality with a subclass. Here is how to add a calculated field and a fixed-width print format: >>> class Point(namedtuple('Point', ['x', 'y'])): ... __slots__ = () ... @property ... def hypot(self): ... return (self.x ** 2 + self.y ** 2) ** 0.5 ... def __str__(self): ... return 'Point: x=%6.3f y=%6.3f hypot=%6.3f' % (self.x, self.y, self.hypot) >>> for p in Point(3, 4), Point(14, 5/7): ... print(p) Point: x= 3.000 y= 4.000 hypot= 5.000 Point: x=14.000 y= 0.714 hypot=14.018 The subclass shown above sets __slots__ to an empty tuple. This helps keep memory requirements low by preventing the creation of instance dictionaries. Subclassing is not useful for adding new, stored fields. Instead, simply create a new named tuple type from the _fields attribute: >>> Point3D = namedtuple('Point3D', Point._fields + ('z',)) Docstrings can be customized by making direct assignments to the __doc__ fields: >>> Book = namedtuple('Book', ['id', 'title', 'authors']) >>> Book.__doc__ += ': Hardcover book in active collection' >>> Book.id.__doc__ = '13-digit ISBN' >>> Book.title.__doc__ = 'Title of first printing' >>> Book.authors.__doc__ = 'List of authors sorted by last name' Changed in version 3.5: Property docstrings became writeable. See also See typing.NamedTuple for a way to add type hints for named tuples. It also provides an elegant notation using the class keyword: class Component(NamedTuple): part_number: int weight: float description: Optional[str] = None See types.SimpleNamespace() for a mutable namespace based on an underlying dictionary instead of a tuple. The dataclasses module provides a decorator and functions for automatically adding generated special methods to user-defined classes. OrderedDict objects Ordered dictionaries are just like regular dictionaries but have some extra capabilities relating to ordering operations. They have become less important now that the built-in dict class gained the ability to remember insertion order (this new behavior became guaranteed in Python 3.7). Some differences from dict still remain: The regular dict was designed to be very good at mapping operations. Tracking insertion order was secondary. The OrderedDict was designed to be", "score": "0.65469134"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.65177107"}]}
{"task_id": "mbpp_445", "code": "def index_multiplication(test_tup1, test_tup2):\r\n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res) ", "test_list": ["assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))", "assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))", "assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))"], "context": "Write a function to perform index wise multiplication of tuple elements in the given two tuples.", "function_name": "def index_multiplication(test_tup1, test_tup2):", "gold_generation": "res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res)", "ctxs": [{"id": "43166", "text": "Function: numpy.reference.generated.numpy.s_\nSnippet: numpy.s_ numpy.s_ = <numpy.lib.index_tricks.IndexExpression object> A nicer way to build up index tuples for arrays. Note Use one of the two predefined instances index_exp or s_ rather than directly using IndexExpression. For any index combination, including slicing and axis insertion, a[indices] is the same as a[np.index_exp[indices]] for any array a. However, np.index_exp[indices] can be used anywhere in Python code and returns a tuple of slice objects that can be used in the construction of complex index expressions. Parameters maketuplebool If True, always returns a tuple. See also index_exp Predefined instance that always returns a tuple: index_exp = IndexExpression(maketuple=True). s_ Predefined instance without tuple conversion: s_ = IndexExpression(maketuple=False). Notes You can do all this with slice() plus a few special objects, but there’s a lot to remember and this version is simpler because it uses the standard array indexing syntax. Examples >>> np.s_[2::2] slice(2, None, 2) >>> np.index_exp[2::2] (slice(2, None, 2),) >>> np.array([0, 1, 2, 3, 4])[np.s_[2::2]] array([2, 4])", "score": "0.6861201"}, {"id": "43029", "text": "Function: numpy.reference.generated.numpy.multiply\nSnippet: numpy.multiply numpy.multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'multiply'> Multiply arguments element-wise. Parameters x1, x2array_like Input arrays to be multiplied. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray The product of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. Notes Equivalent to x1 * x2 in terms of array broadcasting. Examples >>> np.multiply(2.0, 4.0) 8.0 >>> x1 = np.arange(9.0).reshape((3, 3)) >>> x2 = np.arange(3.0) >>> np.multiply(x1, x2) array([[ 0., 1., 4.], [ 0., 4., 10.], [ 0., 7., 16.]]) The * operator can be used as a shorthand for np.multiply on ndarrays. >>> x1 = np.arange(9.0).reshape((3, 3)) >>> x2 = np.arange(3.0) >>> x1 * x2 array([[ 0., 1., 4.], [ 0., 4., 10.], [ 0., 7., 16.]])", "score": "0.68280816"}, {"id": "43987", "text": "Function: numpy.reference.generated.numpy.ufunc.at\nSnippet: numpy.ufunc.at method ufunc.at(a, indices, b=None, /) Performs unbuffered in place operation on operand ‘a’ for elements specified by ‘indices’. For addition ufunc, this method is equivalent to a[indices] += b, except that results are accumulated for elements that are indexed more than once. For example, a[[0,0]] += 1 will only increment the first element once because of buffering, whereas add.at(a, [0,0], 1) will increment the first element twice. New in version 1.8.0. Parameters aarray_like The array to perform in place operation on. indicesarray_like or tuple Array like index object or slice object for indexing into first operand. If first operand has multiple dimensions, indices can be a tuple of array like index objects or slice objects. barray_like Second operand for ufuncs requiring two operands. Operand must be broadcastable over first operand after indexing or slicing. Examples Set items 0 and 1 to their negative values: >>> a = np.array([1, 2, 3, 4]) >>> np.negative.at(a, [0, 1]) >>> a array([-1, -2, 3, 4]) Increment items 0 and 1, and increment item 2 twice: >>> a = np.array([1, 2, 3, 4]) >>> np.add.at(a, [0, 1, 2, 2], 1) >>> a array([2, 3, 5, 4]) Add items 0 and 1 in first array to second array, and store results in first array: >>> a = np.array([1, 2, 3, 4]) >>> b = np.array([1, 2]) >>> np.add.at(a, [0, 1], b) >>> a array([2, 4, 3, 4])", "score": "0.67119926"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.66937834"}, {"id": "19495", "text": "Function: python.library.decimal#decimal.Context.multiply\nSnippet: multiply(x, y) Return the product of x and y.", "score": "0.6621473"}]}
{"task_id": "mbpp_446", "code": "from collections import Counter \r\ndef count_Occurrence(tup, lst): \r\n    count = 0\r\n    for item in tup: \r\n        if item in lst: \r\n            count+= 1 \r\n    return count  ", "test_list": ["assert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'] ) == 3", "assert count_Occurrence((1, 2, 3, 1, 4, 6, 7, 1, 4),[1, 4, 7]) == 6", "assert count_Occurrence((1,2,3,4,5,6),[1,2]) == 2"], "context": "Write a python function to count the occurence of all elements of list in a tuple.", "function_name": "from collections import Counter \r\ndef count_Occurrence(tup, lst):", "gold_generation": "count = 0\r\n    for item in tup: \r\n        if item in lst: \r\n            count+= 1 \r\n    return count", "ctxs": [{"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.7339716"}, {"id": "22190", "text": "Function: python.library.multiprocessing.shared_memory#multiprocessing.shared_memory.ShareableList.count\nSnippet: count(value) Returns the number of occurrences of value.", "score": "0.7260147"}, {"id": "22306", "text": "Function: python.library.operator#operator.countOf\nSnippet: operator.countOf(a, b) Return the number of occurrences of b in a.", "score": "0.7247173"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.70479804"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.69904447"}]}
{"task_id": "mbpp_447", "code": "def cube_nums(nums):\r\n cube_nums = list(map(lambda x: x ** 3, nums))\r\n return cube_nums", "test_list": ["assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]", "assert cube_nums([10,20,30])==([1000, 8000, 27000])", "assert cube_nums([12,15])==([1728, 3375])"], "context": "Write a function to find cubes of individual elements in a list using lambda function.", "function_name": "def cube_nums(nums):", "gold_generation": "cube_nums = list(map(lambda x: x ** 3, nums))\r\n return cube_nums", "ctxs": [{"id": "20295", "text": "Function: python.library.functions\nSnippet: aggregates elements from each of the iterables. Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator. Equivalent to: def zip(*iterables): # zip('ABCD', 'xy') --> Ax By sentinel = object() iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using zip(*[iter(s)]*n). This repeats the same iterator n times so that each output tuple has the result of n calls to the iterator. This has the effect of dividing the input into n-length chunks. zip() should only be used with unequal length inputs when you don’t care about trailing, unmatched values from the longer iterables. If those values are important, use itertools.zip_longest() instead. zip() in conjunction with the * operator can be used to unzip a list: >>> x = [1, 2, 3] >>> y = [4, 5, 6] >>> zipped = zip(x, y) >>> list(zipped) [(1, 4), (2, 5), (3, 6)] >>> x2, y2 = zip(*zip(x, y)) >>> x == list(x2) and y == list(y2) True __import__(name, globals=None, locals=None, fromlist=(), level=0) Note This is an advanced function that is not needed in everyday Python programming, unlike importlib.import_module(). This function is invoked by the import statement. It can be replaced (by importing the builtins module and assigning to builtins.__import__) in order to change semantics of the import statement, but doing so is strongly discouraged as it is usually simpler to use import hooks (see PEP 302) to attain the same goals and does not cause issues with code which assumes the default import implementation is in use. Direct use of __import__() is also discouraged in favor of importlib.import_module(). The function imports the module name, potentially using the given globals and locals to determine how to interpret the name in a package context. The fromlist gives the names of objects or submodules that should be imported from the module given by name. The standard implementation does not use its locals argument at all, and uses its globals only to determine the package context of the import statement. level specifies whether to use absolute or relative imports. 0 (the default) means only perform absolute imports. Positive values for level indicate the number of parent directories to search relative to the directory of the module calling __import__() (see PEP 328 for the details). When the name variable is of the form package.module, normally, the top-level package (the name up till the first dot) is returned, not the module named by name. However, when a non-empty fromlist argument is given, the module named by name is returned. For example, the statement import spam results", "score": "0.6682712"}, {"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.6656893"}, {"id": "21296", "text": "Function: python.library.itertools\nSnippet: D E B F C\" # Recipe credited to George Sakkis num_active = len(iterables) nexts = cycle(iter(it).__next__ for it in iterables) while num_active: try: for next in nexts: yield next() except StopIteration: # Remove the iterator we just exhausted from the cycle. num_active -= 1 nexts = cycle(islice(nexts, num_active)) def partition(pred, iterable): \"Use a predicate to partition entries into false entries and true entries\" # partition(is_odd, range(10)) --> 0 2 4 6 8 and 1 3 5 7 9 t1, t2 = tee(iterable) return filterfalse(pred, t1), filter(pred, t2) def powerset(iterable): \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\" s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s)+1)) def unique_everseen(iterable, key=None): \"List unique elements, preserving order. Remember all elements ever seen.\" # unique_everseen('AAAABBBCCDAABBB') --> A B C D # unique_everseen('ABBCcAD', str.lower) --> A B C D seen = set() seen_add = seen.add if key is None: for element in filterfalse(seen.__contains__, iterable): seen_add(element) yield element else: for element in iterable: k = key(element) if k not in seen: seen_add(k) yield element def unique_justseen(iterable, key=None): \"List unique elements, preserving order. Remember only the element just seen.\" # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B # unique_justseen('ABBCcAD', str.lower) --> A B C A D return map(next, map(operator.itemgetter(1), groupby(iterable, key))) def iter_except(func, exception, first=None): \"\"\" Call a function repeatedly until an exception is raised. Converts a call-until-exception interface to an iterator interface. Like builtins.iter(func, sentinel) but uses an exception instead of a sentinel to end the loop. Examples: iter_except(functools.partial(heappop, h), IndexError) # priority queue iterator iter_except(d.popitem, KeyError) # non-blocking dict iterator iter_except(d.popleft, IndexError) # non-blocking deque iterator iter_except(q.get_nowait, Queue.Empty) # loop over a producer Queue iter_except(s.pop, KeyError) # non-blocking set iterator \"\"\" try: if first is not None: yield first() # For database APIs needing an initial cast to db.first() while True: yield func() except exception: pass def first_true(iterable, default=False, pred=None): \"\"\"Returns the first true value in the iterable. If no true value is found, returns *default* If *pred* is not None, returns the first item for which pred(item) is true. \"\"\" # first_true([a,b,c], x) --> a or b or c or x # first_true([a,b], x, f) --> a if f(a) else b if f(b) else x return next(filter(pred, iterable), default) def random_product(*args, repeat=1): \"Random selection from itertools.product(*args, **kwds)\" pools = [tuple(pool) for pool in args] * repeat return tuple(map(random.choice, pools)) def random_permutation(iterable, r=None): \"Random selection from itertools.permutations(iterable, r)\" pool = tuple(iterable) r = len(pool) if r is None else r return tuple(random.sample(pool, r)) def random_combination(iterable, r): \"Random selection from itertools.combinations(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.sample(range(n), r)) return tuple(pool[i] for i in indices) def random_combination_with_replacement(iterable, r): \"Random selection from itertools.combinations_with_replacement(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.choices(range(n), k=r)) return tuple(pool[i] for i in indices) def nth_combination(iterable, r, index): \"Equivalent to list(combinations(iterable, r))[index]\" pool = tuple(iterable) n = len(pool) if r < 0 or r > n: raise ValueError c = 1 k = min(r, n-r) for i in range(1, k+1): c = c", "score": "0.6649699"}, {"id": "27121", "text": "Function: python.library.functions#zip\nSnippet: zip(*iterables) Make an iterator that aggregates elements from each of the iterables. Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator. Equivalent to: def zip(*iterables): # zip('ABCD', 'xy') --> Ax By sentinel = object() iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using zip(*[iter(s)]*n). This repeats the same iterator n times so that each output tuple has the result of n calls to the iterator. This has the effect of dividing the input into n-length chunks. zip() should only be used with unequal length inputs when you don’t care about trailing, unmatched values from the longer iterables. If those values are important, use itertools.zip_longest() instead. zip() in conjunction with the * operator can be used to unzip a list: >>> x = [1, 2, 3] >>> y = [4, 5, 6] >>> zipped = zip(x, y) >>> list(zipped) [(1, 4), (2, 5), (3, 6)] >>> x2, y2 = zip(*zip(x, y)) >>> x == list(x2) and y == list(y2) True", "score": "0.6514226"}, {"id": "20482", "text": "Function: python.library.heapq#heapq.heapify\nSnippet: heapq.heapify(x) Transform list x into a heap, in-place, in linear time.", "score": "0.6475819"}]}
{"task_id": "mbpp_448", "code": "def cal_sum(n): \r\n\ta = 3\r\n\tb = 0\r\n\tc = 2\r\n\tif (n == 0): \r\n\t\treturn 3\r\n\tif (n == 1): \r\n\t\treturn 3\r\n\tif (n == 2): \r\n\t\treturn 5\r\n\tsum = 5\r\n\twhile (n > 2): \r\n\t\td = a + b \r\n\t\tsum = sum + d \r\n\t\ta = b \r\n\t\tb = c \r\n\t\tc = d \r\n\t\tn = n-1\r\n\treturn sum", "test_list": ["assert cal_sum(9) == 49", "assert cal_sum(10) == 66", "assert cal_sum(11) == 88"], "context": "Write a function to calculate the sum of perrin numbers.", "function_name": "def cal_sum(n):", "gold_generation": "a = 3\r\n\tb = 0\r\n\tc = 2\r\n\tif (n == 0): \r\n\t\treturn 3\r\n\tif (n == 1): \r\n\t\treturn 3\r\n\tif (n == 2): \r\n\t\treturn 5\r\n\tsum = 5\r\n\twhile (n > 2): \r\n\t\td = a + b \r\n\t\tsum = sum + d \r\n\t\ta = b \r\n\t\tb = c \r\n\t\tc = d \r\n\t\tn = n-1\r\n\treturn sum", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.658745"}, {"id": "22280", "text": "Function: python.library.numbers#numbers.Rational.denominator\nSnippet: denominator Abstract.", "score": "0.65405226"}, {"id": "22281", "text": "Function: python.library.numbers#numbers.Rational.numerator\nSnippet: numerator Abstract.", "score": "0.64712816"}, {"id": "5279", "text": "Function: tensorflow.sparse.segment_sum\nSnippet: tf.sparse.segment_sum View source on GitHub Computes the sum along sparse segments of a tensor. tf.sparse.segment_sum( data, indices, segment_ids, num_segments=None, name=None ) Read the section on segmentation for an explanation of segments. Like tf.math.segment_sum, but segment_ids can have rank less than data's first dimension, selecting a subset of dimension 0, specified by indices. segment_ids is allowed to have missing ids, in which case the output will be zeros at those indices. In those cases num_segments is used to determine the size of the output. For example: c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]]) # Select two rows, one segment. tf.sparse.segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0])) # => [[0 0 0 0]] # Select two rows, two segment. tf.sparse.segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1])) # => [[ 1 2 3 4] # [-1 -2 -3 -4]] # With missing segment ids. tf.sparse.segment_sum(c, tf.constant([0, 1]), tf.constant([0, 2]), num_segments=4) # => [[ 1 2 3 4] # [ 0 0 0 0] # [-1 -2 -3 -4] # [ 0 0 0 0]] # Select all rows, two segments. tf.sparse.segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1])) # => [[0 0 0 0] # [5 6 7 8]] # Which is equivalent to: tf.math.segment_sum(c, tf.constant([0, 0, 1])) Args data A Tensor with data that will be assembled in the output. indices A 1-D Tensor with indices into data. Has same rank as segment_ids. segment_ids A 1-D Tensor with indices into the output Tensor. Values should be sorted and can be repeated. num_segments An optional int32 scalar. Indicates the size of the output Tensor. name A name for the operation (optional). Returns A tensor of the shape as data, except for dimension 0 which has size k, the number of segments specified via num_segments or inferred for the last element in segments_ids.", "score": "0.6409719"}, {"id": "1194", "text": "Function: tensorflow.compat.v1.scan\nSnippet: packs the results of applying fn to tensors unpacked from elems along the first dimension, and the previous accumulator value(s), from first to last (or last to first, if reverse=True). Raises TypeError if fn is not callable or the structure of the output of fn and initializer do not match. ValueError if the lengths of the output of fn and initializer do not match. Examples: elems = np.array([1, 2, 3, 4, 5, 6]) sum = scan(lambda a, x: a + x, elems) # sum == [1, 3, 6, 10, 15, 21] sum = scan(lambda a, x: a + x, elems, reverse=True) # sum == [21, 20, 18, 15, 11, 6] elems = np.array([1, 2, 3, 4, 5, 6]) initializer = np.array(0) sum_one = scan( lambda a, x: x[0] - x[1] + a, (elems + 1, elems), initializer) # sum_one == [1, 2, 3, 4, 5, 6] elems = np.array([1, 0, 0, 0, 0, 0]) initializer = (np.array(0), np.array(1)) fibonaccis = scan(lambda a, _: (a[1], a[0] + a[1]), elems, initializer) # fibonaccis == ([1, 1, 2, 3, 5, 8], [1, 2, 3, 5, 8, 13])", "score": "0.6332072"}]}
{"task_id": "mbpp_449", "code": "def check_Triangle(x1,y1,x2,y2,x3,y3): \r\n    a = (x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))   \r\n    if a == 0: \r\n        return ('No') \r\n    else: \r\n        return ('Yes') ", "test_list": ["assert check_Triangle(1,5,2,5,4,6) == 'Yes'", "assert check_Triangle(1,1,1,4,1,5) == 'No'", "assert check_Triangle(1,1,1,1,1,1) == 'No'"], "context": "Write a python function to check whether the triangle is valid or not if 3 points are given.", "function_name": "def check_Triangle(x1,y1,x2,y2,x3,y3):", "gold_generation": "a = (x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))   \r\n    if a == 0: \r\n        return ('No') \r\n    else: \r\n        return ('Yes')", "ctxs": [{"id": "13364", "text": "Function: pygame.ref.gfxdraw\nSnippet: ValueError -- if len(points) < 3 (must have at least 3 points) IndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)", "score": "0.70438755"}, {"id": "34305", "text": "Function: matplotlib.tri_api\nSnippet: matplotlib.tri Unstructured triangular grid functions. classmatplotlib.tri.Triangulation(x, y, triangles=None, mask=None)[source] An unstructured triangular grid consisting of npoints points and ntri triangles. The triangles can either be specified by the user or automatically generated using a Delaunay triangulation. Parameters x, y(npoints,) array-like Coordinates of grid points. triangles(ntri, 3) array-like of int, optional For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If not specified, the Delaunay triangulation is calculated. mask(ntri,) array-like of bool, optional Which triangles are masked out. Notes For a Triangulation to be valid it must not have duplicate points, triangles formed from colinear points, or overlapping triangles. Attributes triangles(ntri, 3) array of int For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If you want to take the mask into account, use get_masked_triangles instead. mask(ntri, 3) array of bool Masked out triangles. is_delaunaybool Whether the Triangulation is a calculated Delaunay triangulation (where triangles was not specified) or not. calculate_plane_coefficients(z)[source] Calculate plane equation coefficients for all unmasked triangles from the point (x, y) coordinates and specified z-array of shape (npoints). The returned array has shape (npoints, 3) and allows z-value at (x, y) position in triangle tri to be calculated using z = array[tri, 0] * x + array[tri, 1] * y + array[tri, 2]. propertyedges Return integer array of shape (nedges, 2) containing all edges of non-masked triangles. Each row defines an edge by it's start point index and end point index. Each edge appears only once, i.e. for an edge between points i and j, there will only be either (i, j) or (j, i). get_cpp_triangulation()[source] Return the underlying C++ Triangulation object, creating it if necessary. staticget_from_args_and_kwargs(*args, **kwargs)[source] Return a Triangulation object from the args and kwargs, and the remaining args and kwargs with the consumed values removed. There are two alternatives: either the first argument is a Triangulation object, in which case it is returned, or the args and kwargs are sufficient to create a new Triangulation to return. In the latter case, see Triangulation.__init__ for the possible args and kwargs. get_masked_triangles()[source] Return an array of triangles that are not masked. get_trifinder()[source] Return the default matplotlib.tri.TriFinder of this triangulation, creating it if necessary. This allows the same TriFinder object to be easily shared. propertyneighbors Return integer array of shape (ntri, 3) containing neighbor triangles. For each triangle, the indices of the three triangles that share the same edges, or -1 if there is no such neighboring triangle. neighbors[i, j] is the triangle that is the neighbor to the edge from point index triangles[i, j] to point index triangles[i, (j+1)%3]. set_mask(mask)[source] Set or clear the mask array. Parameters maskNone or bool array of length ntri classmatplotlib.tri.TriContourSet(ax, *args, **kwargs)[source] Bases: matplotlib.contour.ContourSet Create and store a set of contour lines or filled regions for a triangular grid. This class is typically not instantiated directly by the user but by tricontour and tricontourf. Attributes axAxes The Axes object in which the", "score": "0.70325184"}, {"id": "34319", "text": "Function: matplotlib.tri_api#matplotlib.tri.Triangulation\nSnippet: classmatplotlib.tri.Triangulation(x, y, triangles=None, mask=None)[source] An unstructured triangular grid consisting of npoints points and ntri triangles. The triangles can either be specified by the user or automatically generated using a Delaunay triangulation. Parameters x, y(npoints,) array-like Coordinates of grid points. triangles(ntri, 3) array-like of int, optional For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If not specified, the Delaunay triangulation is calculated. mask(ntri,) array-like of bool, optional Which triangles are masked out. Notes For a Triangulation to be valid it must not have duplicate points, triangles formed from colinear points, or overlapping triangles. Attributes triangles(ntri, 3) array of int For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If you want to take the mask into account, use get_masked_triangles instead. mask(ntri, 3) array of bool Masked out triangles. is_delaunaybool Whether the Triangulation is a calculated Delaunay triangulation (where triangles was not specified) or not. calculate_plane_coefficients(z)[source] Calculate plane equation coefficients for all unmasked triangles from the point (x, y) coordinates and specified z-array of shape (npoints). The returned array has shape (npoints, 3) and allows z-value at (x, y) position in triangle tri to be calculated using z = array[tri, 0] * x + array[tri, 1] * y + array[tri, 2]. propertyedges Return integer array of shape (nedges, 2) containing all edges of non-masked triangles. Each row defines an edge by it's start point index and end point index. Each edge appears only once, i.e. for an edge between points i and j, there will only be either (i, j) or (j, i). get_cpp_triangulation()[source] Return the underlying C++ Triangulation object, creating it if necessary. staticget_from_args_and_kwargs(*args, **kwargs)[source] Return a Triangulation object from the args and kwargs, and the remaining args and kwargs with the consumed values removed. There are two alternatives: either the first argument is a Triangulation object, in which case it is returned, or the args and kwargs are sufficient to create a new Triangulation to return. In the latter case, see Triangulation.__init__ for the possible args and kwargs. get_masked_triangles()[source] Return an array of triangles that are not masked. get_trifinder()[source] Return the default matplotlib.tri.TriFinder of this triangulation, creating it if necessary. This allows the same TriFinder object to be easily shared. propertyneighbors Return integer array of shape (ntri, 3) containing neighbor triangles. For each triangle, the indices of the three triangles that share the same edges, or -1 if there is no such neighboring triangle. neighbors[i, j] is the triangle that is the neighbor to the edge from point index triangles[i, j] to point index triangles[i, (j+1)%3]. set_mask(mask)[source] Set or clear the mask array. Parameters maskNone or bool array of length ntri", "score": "0.6948726"}, {"id": "14324", "text": "Function: pandas.reference.api.pandas.dataframe.div\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.683513"}, {"id": "14480", "text": "Function: pandas.reference.api.pandas.dataframe.rtruediv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6833113"}]}
{"task_id": "mbpp_450", "code": "def extract_string(str, l):\r\n    result = [e for e in str if len(e) == l] \r\n    return result", "test_list": ["assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,8)==['practice', 'solution']", "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,6)==['Python']", "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,9)==['exercises']"], "context": "Write a function to extract specified size of strings from a give list of string values.", "function_name": "def extract_string(str, l):", "gold_generation": "result = [e for e in str if len(e) == l] \r\n    return result", "ctxs": [{"id": "25746", "text": "Function: python.library.stdtypes\nSnippet: Return -1 on failure. str.rindex(sub[, start[, end]]) Like rfind() but raises ValueError when the substring sub is not found. str.rjust(width[, fillchar]) Return the string right justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.rpartition(sep) Split the string at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself. str.rsplit(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any whitespace string is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below. str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty' str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3'] str.splitlines([keepends]) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. This", "score": "0.6874922"}, {"id": "21147", "text": "Function: python.library.io#io.TextIOBase.read\nSnippet: read(size=-1) Read and return at most size characters from the stream as a single str. If size is negative or None, reads until EOF.", "score": "0.68067485"}, {"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.67658925"}, {"id": "42691", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: same data with a new shape. resize(new_shape[, refcheck]) Change shape and size of array in-place. rfind(sub[, start, end]) For each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. rindex(sub[, start, end]) Like rfind, but raises ValueError when the substring sub is not found. rjust(width[, fillchar]) Return an array with the elements of self right-justified in a string of length width. rsplit([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. rstrip([chars]) For each element in self, return a copy with the trailing characters removed. searchsorted(v[, side, sorter]) Find indices where elements of v should be inserted in a to maintain order. setfield(val, dtype[, offset]) Put a value into a specified place in a field defined by a data-type. setflags([write, align, uic]) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. sort([axis, kind, order]) Sort an array in-place. split([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. splitlines([keepends]) For each element in self, return a list of the lines in the element, breaking at line boundaries. squeeze([axis]) Remove axes of length one from a. startswith(prefix[, start, end]) Returns a boolean array which is True where the string element in self starts with prefix, otherwise False. strip([chars]) For each element in self, return a copy with the leading and trailing characters removed. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. swapcase() For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. title() For each element in self, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. translate(table[, deletechars]) For each element in self, return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table. transpose(*axes) Returns a view of the array with axes transposed. upper() Return an array with the elements of self converted to uppercase. view([dtype][, type]) New view of array with the same data. zfill(width) Return the numeric string left-filled with zeros in a string of length width.", "score": "0.6756964"}, {"id": "24377", "text": "Function: python.library.stdtypes#str.split\nSnippet: str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3']", "score": "0.6752851"}]}
{"task_id": "mbpp_451", "code": "import re\r\ndef remove_whitespaces(text1):\r\n  return (re.sub(r'\\s+', '',text1))", "test_list": ["assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'", "assert remove_whitespaces(' Google    Dart ') == 'GoogleDart'", "assert remove_whitespaces(' iOS    Swift ') == 'iOSSwift'"], "context": "Write a function to remove all whitespaces from the given string using regex.", "function_name": "import re\r\ndef remove_whitespaces(text1):", "gold_generation": "return (re.sub(r'\\s+', '',text1))", "ctxs": [{"id": "24422", "text": "Function: python.library.string#string.whitespace\nSnippet: string.whitespace A string containing all ASCII characters that are considered whitespace. This includes the characters space, tab, linefeed, return, formfeed, and vertical tab.", "score": "0.71744406"}, {"id": "24398", "text": "Function: python.library.string\nSnippet: characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", "score": "0.7138448"}, {"id": "25021", "text": "Function: python.library.textwrap#textwrap.dedent\nSnippet: textwrap.dedent(text) Remove any common leading whitespace from every line in text. This can be used to make triple-quoted strings line up with the left edge of the display, while still presenting them in the source code in indented form. Note that tabs and spaces are both treated as whitespace, but they are not equal: the lines \" hello\" and \"\\thello\" are considered to have no common leading whitespace. Lines containing only whitespace are ignored in the input and normalized to a single newline character in the output. For example: def test(): # end first line with \\ to avoid the empty line! s = '''\\ hello world ''' print(repr(s)) # prints ' hello\\n world\\n ' print(repr(dedent(s))) # prints 'hello\\n world\\n'", "score": "0.69929475"}, {"id": "25036", "text": "Function: python.library.textwrap#textwrap.TextWrapper.replace_whitespace\nSnippet: replace_whitespace (default: True) If true, after tab expansion but before wrapping, the wrap() method will replace each whitespace character with a single space. The whitespace characters replaced are as follows: tab, newline, vertical tab, formfeed, and carriage return ('\\t\\n\\v\\f\\r'). Note If expand_tabs is false and replace_whitespace is true, each tab character will be replaced by a single space, which is not the same as tab expansion. Note If replace_whitespace is false, newlines may appear in the middle of a line and cause strange output. For this reason, text should be split into paragraphs (using str.splitlines() or similar) which are wrapped separately.", "score": "0.6840707"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.6840282"}]}
{"task_id": "mbpp_452", "code": "def loss_amount(actual_cost,sale_amount): \r\n  if(sale_amount > actual_cost):\r\n    amount = sale_amount - actual_cost\r\n    return amount\r\n  else:\r\n    return None", "test_list": ["assert loss_amount(1500,1200)==None", "assert loss_amount(100,200)==100", "assert loss_amount(2000,5000)==3000"], "context": "Write a function that gives loss amount if the given amount has loss else return none.", "function_name": "def loss_amount(actual_cost,sale_amount):", "gold_generation": "if(sale_amount > actual_cost):\r\n    amount = sale_amount - actual_cost\r\n    return amount\r\n  else:\r\n    return None", "ctxs": [{"id": "7100", "text": "Function: torch.generated.torch.nn.marginrankingloss#torch.nn.MarginRankingLoss\nSnippet: class torch.nn.MarginRankingLoss(margin=0.0, size_average=None, reduce=None, reduction='mean') [source] Creates a criterion that measures the loss given inputs x1x1 , x2x2 , two 1D mini-batch Tensors, and a label 1D mini-batch tensor yy (containing 1 or -1). If y=1y = 1 then it assumed the first input should be ranked higher (have a larger value) than the second input, and vice-versa for y=−1y = -1 . The loss function for each pair of samples in the mini-batch is: loss(x1,x2,y)=max⁡(0,−y∗(x1−x2)+margin)\\text{loss}(x1, x2, y) = \\max(0, -y * (x1 - x2) + \\text{margin}) Parameters margin (float, optional) – Has a default value of 00 . size_average (bool, optional) – Deprecated (see reduction). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there are multiple elements per sample. If the field size_average is set to False, the losses are instead summed for each minibatch. Ignored when reduce is False. Default: True reduce (bool, optional) – Deprecated (see reduction). By default, the losses are averaged or summed over observations for each minibatch depending on size_average. When reduce is False, returns a loss per batch element instead and ignores size_average. Default: True reduction (string, optional) – Specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: size_average and reduce are in the process of being deprecated, and in the meantime, specifying either of those two args will override reduction. Default: 'mean' Shape: Input1: (N)(N) where N is the batch size. Input2: (N)(N) , same shape as the Input1. Target: (N)(N) , same shape as the inputs. Output: scalar. If reduction is 'none', then (N)(N) . Examples: >>> loss = nn.MarginRankingLoss() >>> input1 = torch.randn(3, requires_grad=True) >>> input2 = torch.randn(3, requires_grad=True) >>> target = torch.randn(3).sign() >>> output = loss(input1, input2, target) >>> output.backward()", "score": "0.66487086"}, {"id": "23324", "text": "Function: python.library.re#re.error.lineno\nSnippet: lineno The line corresponding to pos (may be None).", "score": "0.6632712"}, {"id": "6912", "text": "Function: torch.nn.functional\nSnippet: the losses are averaged or summed over observations for each minibatch depending on size_average. When reduce is False, returns a loss per batch element instead and ignores size_average. Default: True reduction (string, optional) – Specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: size_average and reduce are in the process of being deprecated, and in the meantime, specifying either of those two args will override reduction. Default: 'mean' Examples: >>> input = torch.randn((3, 2), requires_grad=True) >>> target = torch.rand((3, 2), requires_grad=False) >>> loss = F.binary_cross_entropy(F.sigmoid(input), target) >>> loss.backward() binary_cross_entropy_with_logits torch.nn.functional.binary_cross_entropy_with_logits(input, target, weight=None, size_average=None, reduce=None, reduction='mean', pos_weight=None) [source] Function that measures Binary Cross Entropy between target and output logits. See BCEWithLogitsLoss for details. Parameters input – Tensor of arbitrary shape target – Tensor of the same shape as input weight (Tensor, optional) – a manual rescaling weight if provided it’s repeated to match input tensor shape size_average (bool, optional) – Deprecated (see reduction). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field size_average is set to False, the losses are instead summed for each minibatch. Ignored when reduce is False. Default: True reduce (bool, optional) – Deprecated (see reduction). By default, the losses are averaged or summed over observations for each minibatch depending on size_average. When reduce is False, returns a loss per batch element instead and ignores size_average. Default: True reduction (string, optional) – Specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: size_average and reduce are in the process of being deprecated, and in the meantime, specifying either of those two args will override reduction. Default: 'mean' pos_weight (Tensor, optional) – a weight of positive examples. Must be a vector with length equal to the number of classes. Examples: >>> input = torch.randn(3, requires_grad=True) >>> target = torch.empty(3).random_(2) >>> loss = F.binary_cross_entropy_with_logits(input, target) >>> loss.backward() poisson_nll_loss torch.nn.functional.poisson_nll_loss(input, target, log_input=True, full=False, size_average=None, eps=1e-08, reduce=None, reduction='mean') [source] Poisson negative log likelihood loss. See PoissonNLLLoss for details. Parameters input – expectation of underlying Poisson distribution. target – random sample target∼Poisson(input)target \\sim \\text{Poisson}(input) . log_input – if True the loss is computed as exp⁡(input)−target∗input\\exp(\\text{input}) - \\text{target} * \\text{input} , if False then loss is input−target∗log⁡(input+eps)\\text{input} - \\text{target} * \\log(\\text{input}+\\text{eps}) . Default: True full – whether to compute full loss, i. e. to add the Stirling approximation term. Default: False target∗log⁡(target)−target+0.5∗log⁡(2∗π∗target)\\text{target} * \\log(\\text{target}) - \\text{target} + 0.5 * \\log(2 * \\pi * \\text{target}) . size_average (bool, optional) – Deprecated (see reduction). By default, the losses are averaged over each loss element in the batch. Note that for some losses,", "score": "0.6570989"}, {"id": "6913", "text": "Function: torch.nn.functional\nSnippet: there multiple elements per sample. If the field size_average is set to False, the losses are instead summed for each minibatch. Ignored when reduce is False. Default: True eps (float, optional) – Small value to avoid evaluation of log⁡(0)\\log(0) when log_input`=``False`. Default: 1e-8 reduce (bool, optional) – Deprecated (see reduction). By default, the losses are averaged or summed over observations for each minibatch depending on size_average. When reduce is False, returns a loss per batch element instead and ignores size_average. Default: True reduction (string, optional) – Specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: size_average and reduce are in the process of being deprecated, and in the meantime, specifying either of those two args will override reduction. Default: 'mean' cosine_embedding_loss torch.nn.functional.cosine_embedding_loss(input1, input2, target, margin=0, size_average=None, reduce=None, reduction='mean') → Tensor [source] See CosineEmbeddingLoss for details. cross_entropy torch.nn.functional.cross_entropy(input, target, weight=None, size_average=None, ignore_index=-100, reduce=None, reduction='mean') [source] This criterion combines log_softmax and nll_loss in a single function. See CrossEntropyLoss for details. Parameters input (Tensor) – (N,C)(N, C) where C = number of classes or (N,C,H,W)(N, C, H, W) in case of 2D Loss, or (N,C,d1,d2,...,dK)(N, C, d_1, d_2, ..., d_K) where K≥1K \\geq 1 in the case of K-dimensional loss. target (Tensor) – (N)(N) where each value is 0≤targets[i]≤C−10 \\leq \\text{targets}[i] \\leq C-1 , or (N,d1,d2,...,dK)(N, d_1, d_2, ..., d_K) where K≥1K \\geq 1 for K-dimensional loss. weight (Tensor, optional) – a manual rescaling weight given to each class. If given, has to be a Tensor of size C size_average (bool, optional) – Deprecated (see reduction). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field size_average is set to False, the losses are instead summed for each minibatch. Ignored when reduce is False. Default: True ignore_index (int, optional) – Specifies a target value that is ignored and does not contribute to the input gradient. When size_average is True, the loss is averaged over non-ignored targets. Default: -100 reduce (bool, optional) – Deprecated (see reduction). By default, the losses are averaged or summed over observations for each minibatch depending on size_average. When reduce is False, returns a loss per batch element instead and ignores size_average. Default: True reduction (string, optional) – Specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: size_average and reduce are in the process of being deprecated, and in the meantime, specifying either of those two args will override reduction. Default: 'mean' Examples: >>> input = torch.randn(3, 5, requires_grad=True) >>> target = torch.randint(5, (3,), dtype=torch.int64) >>> loss = F.cross_entropy(input, target) >>> loss.backward() ctc_loss torch.nn.functional.ctc_loss(log_probs, targets, input_lengths,", "score": "0.65285814"}, {"id": "919", "text": "Function: tensorflow.compat.v1.losses.get_total_loss\nSnippet: tf.compat.v1.losses.get_total_loss Returns a tensor whose value represents the total loss. tf.compat.v1.losses.get_total_loss( add_regularization_losses=True, name='total_loss', scope=None ) In particular, this adds any losses you have added with tf.add_loss() to any regularization losses that have been added by regularization parameters on layers constructors e.g. tf.layers. Be very sure to use this if you are constructing a loss_op manually. Otherwise regularization arguments on tf.layers methods will not function. Args add_regularization_losses A boolean indicating whether or not to use the regularization losses in the sum. name The name of the returned tensor. scope An optional scope name for filtering the losses to return. Note that this filters the losses added with tf.add_loss() as well as the regularization losses to that scope. Returns A Tensor whose value represents the total loss. Raises ValueError if losses is not iterable.", "score": "0.65212476"}]}
{"task_id": "mbpp_453", "code": "import math \r\ndef sumofFactors(n) : \r\n    if (n % 2 != 0) : \r\n        return 0\r\n    res = 1\r\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \r\n        count = 0\r\n        curr_sum = 1\r\n        curr_term = 1\r\n        while (n % i == 0) : \r\n            count= count + 1\r\n            n = n // i \r\n            if (i == 2 and count == 1) : \r\n                curr_sum = 0\r\n            curr_term = curr_term * i \r\n            curr_sum = curr_sum + curr_term \r\n        res = res * curr_sum  \r\n    if (n >= 2) : \r\n        res = res * (1 + n) \r\n    return res ", "test_list": ["assert sumofFactors(18) == 26", "assert sumofFactors(30) == 48", "assert sumofFactors(6) == 8"], "context": "Write a python function to find the sum of even factors of a number.", "function_name": "import math \r\ndef sumofFactors(n) :", "gold_generation": "if (n % 2 != 0) : \r\n        return 0\r\n    res = 1\r\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \r\n        count = 0\r\n        curr_sum = 1\r\n        curr_term = 1\r\n        while (n % i == 0) : \r\n            count= count + 1\r\n            n = n // i \r\n            if (i == 2 and count == 1) : \r\n                curr_sum = 0\r\n            curr_term = curr_term * i \r\n            curr_sum = curr_sum + curr_term \r\n        res = res * curr_sum  \r\n    if (n >= 2) : \r\n        res = res * (1 + n) \r\n    return res", "ctxs": [{"id": "19597", "text": "Function: python.library.decimal#decimal.ROUND_HALF_EVEN\nSnippet: decimal.ROUND_HALF_EVEN Round to nearest with ties going to nearest even integer.", "score": "0.6624336"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6620511"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.6614518"}, {"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.6544602"}, {"id": "21814", "text": "Function: python.library.math#math.ldexp\nSnippet: math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp().", "score": "0.65323585"}]}
{"task_id": "mbpp_454", "code": "import re\r\ndef text_match_wordz(text):\r\n        patterns = '\\w*z.\\w*'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')", "test_list": ["assert text_match_wordz(\"pythonz.\")==('Found a match!')", "assert text_match_wordz(\"xyz.\")==('Found a match!')", "assert text_match_wordz(\"  lang  .\")==('Not matched!')"], "context": "Write a function that matches a word containing 'z'.", "function_name": "import re\r\ndef text_match_wordz(text):", "gold_generation": "patterns = '\\w*z.\\w*'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')", "ctxs": [{"id": "23310", "text": "Function: python.library.re\nSnippet: for the first location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The optional second parameter pos gives an index in the string where the search is to start; it defaults to 0. This is not completely equivalent to slicing the string; the '^' pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start. The optional parameter endpos limits how far the string will be searched; it will be as if the string is endpos characters long, so only the characters from pos to endpos - 1 will be searched for a match. If endpos is less than pos, no match will be found; otherwise, if rx is a compiled regular expression object, rx.search(string, 0, 50) is equivalent to rx.search(string[:50], 0). >>> pattern = re.compile(\"d\") >>> pattern.search(\"dog\") # Match at index 0 <re.Match object; span=(0, 1), match='d'> >>> pattern.search(\"dog\", 1) # No match; search doesn't include the \"d\" Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()). Pattern.fullmatch(string[, pos[, endpos]]) If the whole string matches this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o[gh]\") >>> pattern.fullmatch(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.fullmatch(\"ogre\") # No match as not the full string matches. >>> pattern.fullmatch(\"doggie\", 1, 3) # Matches within given limits. <re.Match object; span=(1, 3), match='og'> New in version 3.4. Pattern.split(string, maxsplit=0) Identical to the split() function, using the compiled pattern. Pattern.findall(string[, pos[, endpos]]) Similar to the findall() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.finditer(string[, pos[, endpos]]) Similar to the finditer() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for search(). Pattern.sub(repl, string, count=0) Identical to the sub() function, using the compiled pattern. Pattern.subn(repl, string, count=0) Identical to the subn() function, using the compiled pattern. Pattern.flags The regex", "score": "0.66745317"}, {"id": "41763", "text": "Function: numpy.reference.generated.numpy.char.zfill\nSnippet: numpy.char.zfill char.zfill(a, width)[source] Return the numeric string left-filled with zeros Calls str.zfill element-wise. Parameters aarray_like, {str, unicode} Input array. widthint Width of string to left-fill elements in a. Returns outndarray, {str, unicode} Output array of str or unicode, depending on input type See also str.zfill", "score": "0.6632842"}, {"id": "24385", "text": "Function: python.library.stdtypes#str.zfill\nSnippet: str.zfill(width) Return a copy of the string left filled with ASCII '0' digits to make a string of length width. A leading sign prefix ('+'/'-') is handled by inserting the padding after the sign character rather than before. The original string is returned if width is less than or equal to len(s). For example: >>> \"42\".zfill(5) '00042' >>> \"-42\".zfill(5) '-0042'", "score": "0.6623465"}, {"id": "23359", "text": "Function: python.library.re#re.Pattern.match\nSnippet: Pattern.match(string[, pos[, endpos]]) If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match. The optional pos and endpos parameters have the same meaning as for the search() method. >>> pattern = re.compile(\"o\") >>> pattern.match(\"dog\") # No match as \"o\" is not at the start of \"dog\". >>> pattern.match(\"dog\", 1) # Match as \"o\" is the 2nd character of \"dog\". <re.Match object; span=(1, 2), match='o'> If you want to locate a match anywhere in string, use search() instead (see also search() vs. match()).", "score": "0.66033816"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.6512358"}]}
{"task_id": "mbpp_455", "code": "def check_monthnumb_number(monthnum2):\r\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\r\n    return True\r\n  else:\r\n    return False", "test_list": ["assert check_monthnumb_number(5)==True", "assert check_monthnumb_number(2)==False", "assert check_monthnumb_number(6)==False"], "context": "Write a function to check whether the given month number contains 31 days or not.", "function_name": "def check_monthnumb_number(monthnum2):", "gold_generation": "if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\r\n    return True\r\n  else:\r\n    return False", "ctxs": [{"id": "19312", "text": "Function: python.library.datetime#datetime.date.month\nSnippet: date.month Between 1 and 12 inclusive.", "score": "0.7020026"}, {"id": "15492", "text": "Function: pandas.reference.api.pandas.timestamp.days_in_month\nSnippet: pandas.Timestamp.days_in_month Timestamp.days_in_month Return the number of days in the month. Examples >>> ts = pd.Timestamp(2020, 3, 14) >>> ts.days_in_month 31", "score": "0.70061"}, {"id": "15493", "text": "Function: pandas.reference.api.pandas.timestamp.daysinmonth\nSnippet: pandas.Timestamp.daysinmonth Timestamp.daysinmonth Return the number of days in the month. Examples >>> ts = pd.Timestamp(2020, 3, 14) >>> ts.days_in_month 31", "score": "0.6920401"}, {"id": "19343", "text": "Function: python.library.datetime#datetime.datetime.month\nSnippet: datetime.month Between 1 and 12 inclusive.", "score": "0.6895424"}, {"id": "19302", "text": "Function: python.library.datetime#datetime.date.day\nSnippet: date.day Between 1 and the number of days in the given month of the given year.", "score": "0.686939"}]}
{"task_id": "mbpp_456", "code": "def reverse_string_list(stringlist):\r\n    result = [x[::-1] for x in stringlist]\r\n    return result", "test_list": ["assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])==['deR', 'neerG', 'eulB', 'etihW', 'kcalB']", "assert reverse_string_list(['john','amal','joel','george'])==['nhoj','lama','leoj','egroeg']", "assert reverse_string_list(['jack','john','mary'])==['kcaj','nhoj','yram']"], "context": "Write a function to reverse strings in a given list of string values.", "function_name": "def reverse_string_list(stringlist):", "gold_generation": "result = [x[::-1] for x in stringlist]\r\n    return result", "ctxs": [{"id": "17643", "text": "Function: python.library.array#array.array.reverse\nSnippet: array.reverse() Reverse the order of the items in the array.", "score": "0.72280455"}, {"id": "25738", "text": "Function: python.library.stdtypes\nSnippet: from s (2) s.remove(x) remove the first item from s where s[i] is equal to x (3) s.reverse() reverses the items of s in place (4) Notes: t must have the same length as the slice it is replacing. The optional argument i defaults to -1, so that by default the last item is removed and returned. remove() raises ValueError when x is not found in s. The reverse() method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence. clear() and copy() are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as dict and set). copy() is not part of the collections.abc.MutableSequence ABC, but most concrete mutable sequence classes provide it. New in version 3.3: clear() and copy() methods. The value n is an integer, or an object implementing __index__(). Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for s * n under Common Sequence Operations. Lists Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). class list([iterable]) Lists may be constructed in several ways: Using a pair of square brackets to denote the empty list: [] Using square brackets, separating items with commas: [a], [a, b, c] Using a list comprehension: [x for x in iterable] Using the type constructor: list() or list(iterable) The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to iterable[:]. For example, list('abc') returns ['a', 'b', 'c'] and list( (1, 2, 3) ) returns [1, 2, 3]. If no argument is given, the constructor creates a new empty list, []. Many other operations also produce lists, including the sorted() built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is", "score": "0.7191459"}, {"id": "24372", "text": "Function: python.library.stdtypes#str.rindex\nSnippet: str.rindex(sub[, start[, end]]) Like rfind() but raises ValueError when the substring sub is not found.", "score": "0.6884662"}, {"id": "16533", "text": "Function: pandas.reference.series\nSnippet: of strings in the Series/Index. Series.str.rpartition([sep, expand]) Split the string at the last occurrence of sep. Series.str.rstrip([to_strip]) Remove trailing characters. Series.str.slice([start, stop, step]) Slice substrings from each element in the Series or Index. Series.str.slice_replace([start, stop, repl]) Replace a positional slice of a string with another value. Series.str.split([pat, n, expand, regex]) Split strings around given separator/delimiter. Series.str.rsplit([pat, n, expand]) Split strings around given separator/delimiter. Series.str.startswith(pat[, na]) Test if the start of each string element matches a pattern. Series.str.strip([to_strip]) Remove leading and trailing characters. Series.str.swapcase() Convert strings in the Series/Index to be swapcased. Series.str.title() Convert strings in the Series/Index to titlecase. Series.str.translate(table) Map all characters in the string through the given mapping table. Series.str.upper() Convert strings in the Series/Index to uppercase. Series.str.wrap(width, **kwargs) Wrap strings in Series/Index at specified line width. Series.str.zfill(width) Pad strings in the Series/Index by prepending '0' characters. Series.str.isalnum() Check whether all characters in each string are alphanumeric. Series.str.isalpha() Check whether all characters in each string are alphabetic. Series.str.isdigit() Check whether all characters in each string are digits. Series.str.isspace() Check whether all characters in each string are whitespace. Series.str.islower() Check whether all characters in each string are lowercase. Series.str.isupper() Check whether all characters in each string are uppercase. Series.str.istitle() Check whether all characters in each string are titlecase. Series.str.isnumeric() Check whether all characters in each string are numeric. Series.str.isdecimal() Check whether all characters in each string are decimal. Series.str.get_dummies([sep]) Return DataFrame of dummy/indicator variables for Series. Categorical accessor Categorical-dtype specific methods and attributes are available under the Series.cat accessor. Series.cat.categories The categories of this categorical. Series.cat.ordered Whether the categories have an ordered relationship. Series.cat.codes Return Series of codes as well as the index. Series.cat.rename_categories(*args, **kwargs) Rename categories. Series.cat.reorder_categories(*args, **kwargs) Reorder categories as specified in new_categories. Series.cat.add_categories(*args, **kwargs) Add new categories. Series.cat.remove_categories(*args, **kwargs) Remove the specified categories. Series.cat.remove_unused_categories(*args, ...) Remove categories which are not used. Series.cat.set_categories(*args, **kwargs) Set the categories to the specified new_categories. Series.cat.as_ordered(*args, **kwargs) Set the Categorical to be ordered. Series.cat.as_unordered(*args, **kwargs) Set the Categorical to be unordered. Sparse accessor Sparse-dtype specific methods and attributes are provided under the Series.sparse accessor. Series.sparse.npoints The number of non- fill_value points. Series.sparse.density The percent of non- fill_value points, as decimal. Series.sparse.fill_value Elements in data that are fill_value are not stored. Series.sparse.sp_values An ndarray containing the non- fill_value values. Series.sparse.from_coo(A[, dense_index]) Create a Series with sparse values from a scipy.sparse.coo_matrix. Series.sparse.to_coo([row_levels, ...]) Create a scipy.sparse.coo_matrix from a Series with MultiIndex. Flags Flags refer to attributes of the pandas object. Properties of the dataset (like the date is was recorded, the URL it was accessed from, etc.) should be stored in Series.attrs. Flags(obj, *, allows_duplicate_labels) Flags that apply to pandas objects. Metadata Series.attrs is a dictionary for storing global metadata for this Series. Warning Series.attrs is considered experimental and may change without warning. Series.attrs Dictionary of global attributes of this dataset. Plotting Series.plot is both a callable method and a namespace attribute for specific plotting methods of the form Series.plot.<kind>. Series.plot([kind, ax, figsize, ....]) Series plotting accessor and method Series.plot.area([x, y]) Draw a", "score": "0.6861119"}, {"id": "25746", "text": "Function: python.library.stdtypes\nSnippet: Return -1 on failure. str.rindex(sub[, start[, end]]) Like rfind() but raises ValueError when the substring sub is not found. str.rjust(width[, fillchar]) Return the string right justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.rpartition(sep) Split the string at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself. str.rsplit(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any whitespace string is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below. str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty' str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3'] str.splitlines([keepends]) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. This", "score": "0.68028104"}]}
{"task_id": "mbpp_457", "code": "def Find_Min(lst): \r\n    minList = min((x) for x in lst) \r\n    return minList", "test_list": ["assert Find_Min([[1],[1,2],[1,2,3]]) == [1]", "assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]", "assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']"], "context": "Write a python function to find the sublist having minimum length.", "function_name": "def Find_Min(lst):", "gold_generation": "minList = min((x) for x in lst) \r\n    return minList", "ctxs": [{"id": "21919", "text": "Function: python.library.mmap#mmap.mmap.find\nSnippet: find(sub[, start[, end]]) Returns the lowest index in the object where the subsequence sub is found, such that sub is contained in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. Returns -1 on failure. Changed in version 3.5: Writable bytes-like object is now accepted.", "score": "0.7217346"}, {"id": "18264", "text": "Function: python.library.stdtypes#bytearray.find\nSnippet: bytes.find(sub[, start[, end]]) bytearray.find(sub[, start[, end]]) Return the lowest index in the data where the subsequence sub is found, such that sub is contained in the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> b'Py' in b'Python' True Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.7086038"}, {"id": "41654", "text": "Function: numpy.reference.generated.numpy.char.chararray.find\nSnippet: numpy.char.chararray.find method char.chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.7071616"}, {"id": "18308", "text": "Function: python.library.stdtypes#bytes.find\nSnippet: bytes.find(sub[, start[, end]]) bytearray.find(sub[, start[, end]]) Return the lowest index in the data where the subsequence sub is found, such that sub is contained in the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> b'Py' in b'Python' True Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.70635194"}, {"id": "41778", "text": "Function: numpy.reference.generated.numpy.chararray.find\nSnippet: numpy.chararray.find method chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.7062326"}]}
{"task_id": "mbpp_458", "code": "def rectangle_area(l,b):\r\n  area=l*b\r\n  return area", "test_list": ["assert rectangle_area(10,20)==200", "assert rectangle_area(10,5)==50", "assert rectangle_area(4,2)==8"], "context": "Write a function to find the area of a rectangle.", "function_name": "def rectangle_area(l,b):", "gold_generation": "area=l*b\r\n  return area", "ctxs": [{"id": "36509", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.OGRGeometry.area\nSnippet: area", "score": "0.6510722"}, {"id": "28816", "text": "Function: matplotlib.backend_pdf_api#matplotlib.backends.backend_pdf.Op.rectangle\nSnippet: rectangle=b're'[source]", "score": "0.64852935"}, {"id": "13857", "text": "Function: pygame.ref.surface#pygame.Surface.get_rect\nSnippet: get_rect() get the rectangular area of the Surface get_rect(**kwargs) -> Rect Returns a new rectangle covering the entire surface. This rectangle will always start at (0, 0) with a width and height the same size as the image. You can pass keyword argument values to this function. These named values will be applied to the attributes of the Rect before it is returned. An example would be mysurf.get_rect(center=(100, 100)) to create a rectangle for the Surface centered at a given position.", "score": "0.64553684"}, {"id": "19051", "text": "Function: python.library.curses\nSnippet: rectangle-drawing function useful for framing text boxes or for other purposes. The module curses.textpad defines the following function: curses.textpad.rectangle(win, uly, ulx, lry, lrx) Draw a rectangle. The first argument must be a window object; the remaining arguments are coordinates relative to that window. The second and third arguments are the y and x coordinates of the upper left hand corner of the rectangle to be drawn; the fourth and fifth arguments are the y and x coordinates of the lower right hand corner. The rectangle will be drawn using VT100/IBM PC forms characters on terminals that make this possible (including xterm and most other software terminal emulators). Otherwise it will be drawn with ASCII dashes, vertical bars, and plus signs. Textbox objects You can instantiate a Textbox object as follows: class curses.textpad.Textbox(win) Return a textbox widget object. The win argument should be a curses window object in which the textbox is to be contained. The edit cursor of the textbox is initially located at the upper left hand corner of the containing window, with coordinates (0, 0). The instance’s stripspaces flag is initially on. Textbox objects have the following methods: edit([validator]) This is the entry point you will normally use. It accepts editing keystrokes until one of the termination keystrokes is entered. If validator is supplied, it must be a function. It will be called for each keystroke entered with the keystroke as a parameter; command dispatch is done on the result. This method returns the window contents as a string; whether blanks in the window are included is affected by the stripspaces attribute. do_command(ch) Process a single command keystroke. Here are the supported special keystrokes: Keystroke Action Control-A Go to left edge of window. Control-B Cursor left, wrapping to previous line if appropriate. Control-D Delete character under cursor. Control-E Go to right edge (stripspaces off) or end of line (stripspaces on). Control-F Cursor right, wrapping to next line when appropriate. Control-G Terminate, returning the window contents. Control-H Delete character backward. Control-J Terminate if the window is 1 line, otherwise insert newline. Control-K If line is blank, delete it, otherwise clear to end of line. Control-L Refresh screen. Control-N Cursor down; move down one line. Control-O Insert a blank line at cursor location. Control-P Cursor up; move up one line. Move operations do nothing if the cursor is at an edge where the movement is not possible. The following synonyms are supported where possible: Constant Keystroke KEY_LEFT Control-B KEY_RIGHT Control-F KEY_UP Control-P KEY_DOWN Control-N KEY_BACKSPACE Control-h All other keystrokes are treated as a command to insert the given character and move right (with line wrapping). gather() Return the window contents as a string; whether blanks in the window are included is affected by the stripspaces member. stripspaces This attribute is a flag which controls the interpretation of blanks in the window. When it is on, trailing blanks on each line are ignored; any cursor motion that would land the cursor on a trailing blank goes to the end of that", "score": "0.6432566"}, {"id": "36333", "text": "Function: django.ref.contrib.gis.functions#django.contrib.gis.db.models.functions.Area\nSnippet: class Area(expression, **extra)", "score": "0.6410415"}]}
{"task_id": "mbpp_459", "code": "import re\r\ndef remove_uppercase(str1):\r\n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\r\n  result =  remove_upper(str1)\r\n  return (result)", "test_list": ["assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'", "assert remove_uppercase('wAtchTheinTernEtrAdIo') == 'wtchheinerntrdo'", "assert remove_uppercase('VoicESeaRchAndreComMendaTionS') == 'oiceachndreomendaion'"], "context": "Write a function to remove uppercase substrings from a given string by using regex.", "function_name": "import re\r\ndef remove_uppercase(str1):", "gold_generation": "remove_upper = lambda text: re.sub('[A-Z]', '', text)\r\n  result =  remove_upper(str1)\r\n  return (result)", "ctxs": [{"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.707604"}, {"id": "24384", "text": "Function: python.library.stdtypes#str.upper\nSnippet: str.upper() Return a copy of the string with all the cased characters 4 converted to uppercase. Note that s.upper().isupper() might be False if s contains uncased characters or if the Unicode category of the resulting character(s) is not “Lu” (Letter, uppercase), but e.g. “Lt” (Letter, titlecase). The uppercasing algorithm used is described in section 3.13 of the Unicode Standard.", "score": "0.70504403"}, {"id": "24361", "text": "Function: python.library.stdtypes#str.isupper\nSnippet: str.isupper() Return True if all cased characters 4 in the string are uppercase and there is at least one cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False", "score": "0.69256866"}, {"id": "23369", "text": "Function: python.library.re#re.sub\nSnippet: re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern are replaced only when not adjacent to a previous empty match, so sub('x*', '-', 'abxd') returns '-a-b--d-'. In string-type repl arguments, in addition to the character escapes and backreferences described above, \\g<name> will use the substring matched by the group named name, as defined by the (?P<name>...) syntax. \\g<number> uses the corresponding group number; \\g<2> is therefore equivalent to \\2, but isn’t ambiguous in a replacement such as \\g<2>0. \\20 would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character '0'. The backreference \\g<0> substitutes in the entire substring matched by the RE. Changed in version 3.1: Added the optional flags argument. Changed in version 3.5: Unmatched groups are replaced with an empty string. Changed in version 3.6: Unknown escapes in pattern consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Unknown escapes in repl consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Empty matches for the pattern are replaced when adjacent to a previous non-empty match.", "score": "0.691588"}, {"id": "25742", "text": "Function: python.library.stdtypes\nSnippet: Strings also support two styles of string formatting, one providing a large degree of flexibility and customization (see str.format(), Format String Syntax and Custom String Formatting) and the other based on C printf style formatting that handles a narrower range of types and is slightly harder to use correctly, but is often faster for the cases it can handle (printf-style String Formatting). The Text Processing Services section of the standard library covers a number of other modules that provide various text related utilities (including regular expression support in the re module). str.capitalize() Return a copy of the string with its first character capitalized and the rest lowercased. Changed in version 3.8: The first character is now put into titlecase rather than uppercase. This means that characters like digraphs will only have their first letter capitalized, instead of the full character. str.casefold() Return a casefolded copy of the string. Casefolded strings may be used for caseless matching. Casefolding is similar to lowercasing but more aggressive because it is intended to remove all case distinctions in a string. For example, the German lowercase letter 'ß' is equivalent to \"ss\". Since it is already lowercase, lower() would do nothing to 'ß'; casefold() converts it to \"ss\". The casefolding algorithm is described in section 3.13 of the Unicode Standard. New in version 3.3. str.center(width[, fillchar]) Return centered in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. str.encode(encoding=\"utf-8\", errors=\"strict\") Return an encoded version of the string as a bytes object. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other possible values are 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and any other name registered via codecs.register_error(), see section Error Handlers. For a list of possible encodings, see section Standard Encodings. By default, the errors argument is not checked for best performances, but only used at the first encoding error. Enable the Python Development Mode, or use a debug build to check errors. Changed in version 3.1: Support for keyword arguments added. Changed in version 3.9: The errors is now checked in development mode and in debug mode. str.endswith(suffix[, start[, end]]) Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. str.expandtabs(tabsize=8) Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. Tab positions occur every tabsize characters (default is 8, giving tab positions at columns 0, 8, 16 and so", "score": "0.68889314"}]}
{"task_id": "mbpp_460", "code": "def Extract(lst): \r\n    return [item[0] for item in lst] ", "test_list": ["assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]", "assert Extract([[1,2,3],[4, 5]]) == [1,4]", "assert Extract([[9,8,1],[1,2]]) == [9,1]"], "context": "Write a python function to get the first element of each sublist.", "function_name": "def Extract(lst):", "gold_generation": "return [item[0] for item in lst]", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.6988592"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.67687166"}, {"id": "22322", "text": "Function: python.library.operator#operator.indexOf\nSnippet: operator.indexOf(a, b) Return the index of the first of occurrence of b in a.", "score": "0.67198324"}, {"id": "21919", "text": "Function: python.library.mmap#mmap.mmap.find\nSnippet: find(sub[, start[, end]]) Returns the lowest index in the object where the subsequence sub is found, such that sub is contained in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. Returns -1 on failure. Changed in version 3.5: Writable bytes-like object is now accepted.", "score": "0.66728854"}, {"id": "24346", "text": "Function: python.library.stdtypes#str.find\nSnippet: str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True", "score": "0.66484463"}]}
{"task_id": "mbpp_461", "code": "def upper_ctr(str):\r\n    upper_ctr = 0\r\n    for i in range(len(str)):\r\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\r\n          return upper_ctr", "test_list": ["assert upper_ctr('PYthon') == 1", "assert upper_ctr('BigData') == 1", "assert upper_ctr('program') == 0"], "context": "Write a python function to count the upper case characters in a given string.", "function_name": "def upper_ctr(str):", "gold_generation": "upper_ctr = 0\r\n    for i in range(len(str)):\r\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\r\n          return upper_ctr", "ctxs": [{"id": "24361", "text": "Function: python.library.stdtypes#str.isupper\nSnippet: str.isupper() Return True if all cased characters 4 in the string are uppercase and there is at least one cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False", "score": "0.7711761"}, {"id": "41669", "text": "Function: numpy.reference.generated.numpy.char.chararray.isupper\nSnippet: numpy.char.chararray.isupper method char.chararray.isupper()[source] Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. See also char.isupper", "score": "0.7613352"}, {"id": "24384", "text": "Function: python.library.stdtypes#str.upper\nSnippet: str.upper() Return a copy of the string with all the cased characters 4 converted to uppercase. Note that s.upper().isupper() might be False if s contains uncased characters or if the Unicode category of the resulting character(s) is not “Lu” (Letter, uppercase), but e.g. “Lt” (Letter, titlecase). The uppercasing algorithm used is described in section 3.13 of the Unicode Standard.", "score": "0.76110256"}, {"id": "41792", "text": "Function: numpy.reference.generated.numpy.chararray.isupper\nSnippet: numpy.chararray.isupper method chararray.isupper()[source] Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. See also char.isupper", "score": "0.7575767"}, {"id": "41736", "text": "Function: numpy.reference.generated.numpy.char.isupper\nSnippet: numpy.char.isupper char.isupper(a)[source] Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. Call str.isupper element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like of str or unicode Returns outndarray Output array of bools See also str.isupper", "score": "0.7546216"}]}
{"task_id": "mbpp_462", "code": "def combinations_list(list1):\r\n    if len(list1) == 0:\r\n        return [[]]\r\n    result = []\r\n    for el in combinations_list(list1[1:]):\r\n        result += [el, el+[list1[0]]]\r\n    return result", "test_list": ["assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]", "assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]", "assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]"], "context": "Write a function to find all possible combinations of the elements of a given list.", "function_name": "def combinations_list(list1):", "gold_generation": "if len(list1) == 0:\r\n        return [[]]\r\n    result = []\r\n    for el in combinations_list(list1[1:]):\r\n        result += [el, el+[list1[0]]]\r\n    return result", "ctxs": [{"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.71965516"}, {"id": "21302", "text": "Function: python.library.itertools#itertools.combinations_with_replacement\nSnippet: itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1.", "score": "0.71949923"}, {"id": "21301", "text": "Function: python.library.itertools#itertools.combinations\nSnippet: itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.7189262"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.7152516"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.71444464"}]}
{"task_id": "mbpp_463", "code": "def max_subarray_product(arr):\r\n\tn = len(arr)\r\n\tmax_ending_here = 1\r\n\tmin_ending_here = 1\r\n\tmax_so_far = 0\r\n\tflag = 0\r\n\tfor i in range(0, n):\r\n\t\tif arr[i] > 0:\r\n\t\t\tmax_ending_here = max_ending_here * arr[i]\r\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\r\n\t\t\tflag = 1\r\n\t\telif arr[i] == 0:\r\n\t\t\tmax_ending_here = 1\r\n\t\t\tmin_ending_here = 1\r\n\t\telse:\r\n\t\t\ttemp = max_ending_here\r\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\r\n\t\t\tmin_ending_here = temp * arr[i]\r\n\t\tif (max_so_far < max_ending_here):\r\n\t\t\tmax_so_far = max_ending_here\r\n\tif flag == 0 and max_so_far == 0:\r\n\t\treturn 0\r\n\treturn max_so_far", "test_list": ["assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112", "assert max_subarray_product([6, -3, -10, 0, 2]) == 180 ", "assert max_subarray_product([-2, -40, 0, -2, -3]) == 80"], "context": "Write a function to find the maximum product subarray of the given array.", "function_name": "def max_subarray_product(arr):", "gold_generation": "n = len(arr)\r\n\tmax_ending_here = 1\r\n\tmin_ending_here = 1\r\n\tmax_so_far = 0\r\n\tflag = 0\r\n\tfor i in range(0, n):\r\n\t\tif arr[i] > 0:\r\n\t\t\tmax_ending_here = max_ending_here * arr[i]\r\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\r\n\t\t\tflag = 1\r\n\t\telif arr[i] == 0:\r\n\t\t\tmax_ending_here = 1\r\n\t\t\tmin_ending_here = 1\r\n\t\telse:\r\n\t\t\ttemp = max_ending_here\r\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\r\n\t\t\tmin_ending_here = temp * arr[i]\r\n\t\tif (max_so_far < max_ending_here):\r\n\t\t\tmax_so_far = max_ending_here\r\n\tif flag == 0 and max_so_far == 0:\r\n\t\treturn 0\r\n\treturn max_so_far", "ctxs": [{"id": "43865", "text": "Function: numpy.reference.generated.numpy.recarray.prod\nSnippet: numpy.recarray.prod method recarray.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True) Return the product of the array elements over the given axis Refer to numpy.prod for full documentation. See also numpy.prod equivalent function", "score": "0.7018937"}, {"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.6908358"}, {"id": "43857", "text": "Function: numpy.reference.generated.numpy.recarray.max\nSnippet: numpy.recarray.max method recarray.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the maximum along a given axis. Refer to numpy.amax for full documentation. See also numpy.amax equivalent function", "score": "0.68822795"}, {"id": "42551", "text": "Function: numpy.reference.generated.numpy.ndarray.prod\nSnippet: numpy.ndarray.prod method ndarray.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True) Return the product of the array elements over the given axis Refer to numpy.prod for full documentation. See also numpy.prod equivalent function", "score": "0.68754727"}, {"id": "42281", "text": "Function: numpy.reference.generated.numpy.ma.maskedarray.product\nSnippet: numpy.ma.MaskedArray.product method ma.MaskedArray.product(axis=None, dtype=None, out=None, keepdims=<no value>)[source] Return the product of the array elements over the given axis. Masked elements are set to 1 internally for computation. Refer to numpy.prod for full documentation. See also numpy.ndarray.prod corresponding function for ndarrays numpy.prod equivalent function Notes Arithmetic is modular when using integer types, and no error is raised on overflow.", "score": "0.67994565"}]}
{"task_id": "mbpp_464", "code": "def check_value(dict, n):\r\n    result = all(x == n for x in dict.values()) \r\n    return result", "test_list": ["assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False", "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True", "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False"], "context": "Write a function to check if all values are same in a dictionary.", "function_name": "def check_value(dict, n):", "gold_generation": "result = all(x == n for x in dict.values()) \r\n    return result", "ctxs": [{"id": "19621", "text": "Function: python.library.stdtypes#dict.values\nSnippet: values() Return a new view of the dictionary’s values. See the documentation of view objects. An equality comparison between one dict.values() view and another will always return False. This also applies when comparing dict.values() to itself: >>> d = {'a': 1} >>> d.values() == d.values() False", "score": "0.69436836"}, {"id": "19610", "text": "Function: python.library.stdtypes#dict\nSnippet: The values of other take priority when d and other share keys. New in version 3.9. Dictionaries compare equal if and only if they have the same (key, value) pairs (regardless of ordering). Order comparisons (‘<’, ‘<=’, ‘>=’, ‘>’) raise TypeError. Dictionaries preserve insertion order. Note that updating a key does not affect the order. Keys added after deletion are inserted at the end. >>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4} >>> d {'one': 1, 'two': 2, 'three': 3, 'four': 4} >>> list(d) ['one', 'two', 'three', 'four'] >>> list(d.values()) [1, 2, 3, 4] >>> d[\"one\"] = 42 >>> d {'one': 42, 'two': 2, 'three': 3, 'four': 4} >>> del d[\"two\"] >>> d[\"two\"] = None >>> d {'one': 42, 'three': 3, 'four': 4, 'two': None} Changed in version 3.7: Dictionary order is guaranteed to be insertion order. This behavior was an implementation detail of CPython from 3.6. Dictionaries and dictionary views are reversible. >>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4} >>> d {'one': 1, 'two': 2, 'three': 3, 'four': 4} >>> list(reversed(d)) ['four', 'three', 'two', 'one'] >>> list(reversed(d.values())) [4, 3, 2, 1] >>> list(reversed(d.items())) [('four', 4), ('three', 3), ('two', 2), ('one', 1)] Changed in version 3.8: Dictionaries are now reversible.", "score": "0.6887613"}, {"id": "14705", "text": "Function: pandas.reference.api.pandas.index.identical\nSnippet: pandas.Index.identical finalIndex.identical(other)[source] Similar to equals, but checks that object attributes and types are also equal. Returns bool If two Index objects have equal elements and same type True, otherwise False.", "score": "0.686955"}, {"id": "17577", "text": "Function: python.library.functions#all\nSnippet: all(iterable) Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to: def all(iterable): for element in iterable: if not element: return False return True", "score": "0.68473274"}, {"id": "25769", "text": "Function: python.library.stdtypes\nSnippet: New in version 3.9. d |= other Update the dictionary d with keys and values from other, which may be either a mapping or an iterable of key/value pairs. The values of other take priority when d and other share keys. New in version 3.9. Dictionaries compare equal if and only if they have the same (key, value) pairs (regardless of ordering). Order comparisons (‘<’, ‘<=’, ‘>=’, ‘>’) raise TypeError. Dictionaries preserve insertion order. Note that updating a key does not affect the order. Keys added after deletion are inserted at the end. >>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4} >>> d {'one': 1, 'two': 2, 'three': 3, 'four': 4} >>> list(d) ['one', 'two', 'three', 'four'] >>> list(d.values()) [1, 2, 3, 4] >>> d[\"one\"] = 42 >>> d {'one': 42, 'two': 2, 'three': 3, 'four': 4} >>> del d[\"two\"] >>> d[\"two\"] = None >>> d {'one': 42, 'three': 3, 'four': 4, 'two': None} Changed in version 3.7: Dictionary order is guaranteed to be insertion order. This behavior was an implementation detail of CPython from 3.6. Dictionaries and dictionary views are reversible. >>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4} >>> d {'one': 1, 'two': 2, 'three': 3, 'four': 4} >>> list(reversed(d)) ['four', 'three', 'two', 'one'] >>> list(reversed(d.values())) [4, 3, 2, 1] >>> list(reversed(d.items())) [('four', 4), ('three', 3), ('two', 2), ('one', 1)] Changed in version 3.8: Dictionaries are now reversible. See also types.MappingProxyType can be used to create a read-only view of a dict. Dictionary view objects The objects returned by dict.keys(), dict.values() and dict.items() are view objects. They provide a dynamic view on the dictionary’s entries, which means that when the dictionary changes, the view reflects these changes. Dictionary views can be iterated over to yield their respective data, and support membership tests: len(dictview) Return the number of entries in the dictionary. iter(dictview) Return an iterator over the keys, values or items (represented as tuples of (key, value)) in the dictionary. Keys and values are iterated over in insertion order. This allows the creation of (value, key) pairs using zip(): pairs = zip(d.values(), d.keys()). Another way to create the same list is pairs = [(v, k) for (k, v) in d.items()]. Iterating views while adding or deleting entries in the dictionary may raise a RuntimeError or fail to iterate over all entries. Changed in version 3.7: Dictionary order is guaranteed to be insertion order. x in dictview Return True if x is in the underlying dictionary’s keys, values or items (in the latter case, x should be a (key, value) tuple). reversed(dictview) Return a reverse iterator over the keys, values or items of the dictionary. The view will be iterated in reverse order of the insertion. Changed in version 3.8: Dictionary views are now reversible. Keys views are set-like since their entries are unique and hashable. If all values are hashable, so that (key, value) pairs are unique and hashable, then the items view is also set-like. (Values views are not treated as", "score": "0.68304116"}]}
{"task_id": "mbpp_465", "code": "def drop_empty(dict1):\r\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\r\n  return dict1", "test_list": ["assert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})=={'c1': 'Red', 'c2': 'Green'}", "assert drop_empty({'c1': 'Red', 'c2': None, 'c3':None})=={'c1': 'Red'}", "assert drop_empty({'c1': None, 'c2': 'Green', 'c3':None})=={ 'c2': 'Green'}"], "context": "Write a function to drop empty items from a given dictionary.", "function_name": "def drop_empty(dict1):", "gold_generation": "dict1 = {key:value for (key, value) in dict1.items() if value is not None}\r\n  return dict1", "ctxs": [{"id": "19611", "text": "Function: python.library.stdtypes#dict.clear\nSnippet: clear() Remove all items from the dictionary.", "score": "0.7406429"}, {"id": "25768", "text": "Function: python.library.stdtypes\nSnippet: The example above shows part of the implementation of collections.Counter. A different __missing__ method is used by collections.defaultdict. d[key] = value Set d[key] to value. del d[key] Remove d[key] from d. Raises a KeyError if key is not in the map. key in d Return True if d has a key key, else False. key not in d Equivalent to not key in d. iter(d) Return an iterator over the keys of the dictionary. This is a shortcut for iter(d.keys()). clear() Remove all items from the dictionary. copy() Return a shallow copy of the dictionary. classmethod fromkeys(iterable[, value]) Create a new dictionary with keys from iterable and values set to value. fromkeys() is a class method that returns a new dictionary. value defaults to None. All of the values refer to just a single instance, so it generally doesn’t make sense for value to be a mutable object such as an empty list. To get distinct values, use a dict comprehension instead. get(key[, default]) Return the value for key if key is in the dictionary, else default. If default is not given, it defaults to None, so that this method never raises a KeyError. items() Return a new view of the dictionary’s items ((key, value) pairs). See the documentation of view objects. keys() Return a new view of the dictionary’s keys. See the documentation of view objects. pop(key[, default]) If key is in the dictionary, remove it and return its value, else return default. If default is not given and key is not in the dictionary, a KeyError is raised. popitem() Remove and return a (key, value) pair from the dictionary. Pairs are returned in LIFO order. popitem() is useful to destructively iterate over a dictionary, as often used in set algorithms. If the dictionary is empty, calling popitem() raises a KeyError. Changed in version 3.7: LIFO order is now guaranteed. In prior versions, popitem() would return an arbitrary key/value pair. reversed(d) Return a reverse iterator over the keys of the dictionary. This is a shortcut for reversed(d.keys()). New in version 3.8. setdefault(key[, default]) If key is in the dictionary, return its value. If not, insert key with a value of default and return default. default defaults to None. update([other]) Update the dictionary with the key/value pairs from other, overwriting existing keys. Return None. update() accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those key/value pairs: d.update(red=1, blue=2). values() Return a new view of the dictionary’s values. See the documentation of view objects. An equality comparison between one dict.values() view and another will always return False. This also applies when comparing dict.values() to itself: >>> d = {'a': 1} >>> d.values() == d.values() False d | other Create a new dictionary with the merged keys and values of d and other, which must both be dictionaries. The values of other take priority when d and other share keys.", "score": "0.70446926"}, {"id": "19609", "text": "Function: python.library.stdtypes#dict\nSnippet: from d. Raises a KeyError if key is not in the map. key in d Return True if d has a key key, else False. key not in d Equivalent to not key in d. iter(d) Return an iterator over the keys of the dictionary. This is a shortcut for iter(d.keys()). clear() Remove all items from the dictionary. copy() Return a shallow copy of the dictionary. classmethod fromkeys(iterable[, value]) Create a new dictionary with keys from iterable and values set to value. fromkeys() is a class method that returns a new dictionary. value defaults to None. All of the values refer to just a single instance, so it generally doesn’t make sense for value to be a mutable object such as an empty list. To get distinct values, use a dict comprehension instead. get(key[, default]) Return the value for key if key is in the dictionary, else default. If default is not given, it defaults to None, so that this method never raises a KeyError. items() Return a new view of the dictionary’s items ((key, value) pairs). See the documentation of view objects. keys() Return a new view of the dictionary’s keys. See the documentation of view objects. pop(key[, default]) If key is in the dictionary, remove it and return its value, else return default. If default is not given and key is not in the dictionary, a KeyError is raised. popitem() Remove and return a (key, value) pair from the dictionary. Pairs are returned in LIFO order. popitem() is useful to destructively iterate over a dictionary, as often used in set algorithms. If the dictionary is empty, calling popitem() raises a KeyError. Changed in version 3.7: LIFO order is now guaranteed. In prior versions, popitem() would return an arbitrary key/value pair. reversed(d) Return a reverse iterator over the keys of the dictionary. This is a shortcut for reversed(d.keys()). New in version 3.8. setdefault(key[, default]) If key is in the dictionary, return its value. If not, insert key with a value of default and return default. default defaults to None. update([other]) Update the dictionary with the key/value pairs from other, overwriting existing keys. Return None. update() accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those key/value pairs: d.update(red=1, blue=2). values() Return a new view of the dictionary’s values. See the documentation of view objects. An equality comparison between one dict.values() view and another will always return False. This also applies when comparing dict.values() to itself: >>> d = {'a': 1} >>> d.values() == d.values() False d | other Create a new dictionary with the merged keys and values of d and other, which must both be dictionaries. The values of other take priority when d and other share keys. New in version 3.9. d |= other Update the dictionary d with keys and values from other, which may be either a mapping or an iterable of key/value pairs.", "score": "0.6887302"}, {"id": "14689", "text": "Function: pandas.reference.api.pandas.index.empty\nSnippet: pandas.Index.empty propertyIndex.empty", "score": "0.6828666"}, {"id": "21664", "text": "Function: python.library.mailbox#mailbox.Mailbox.discard\nSnippet: remove(key) __delitem__(key) discard(key) Delete the message corresponding to key from the mailbox. If no such message exists, a KeyError exception is raised if the method was called as remove() or __delitem__() but no exception is raised if the method was called as discard(). The behavior of discard() may be preferred if the underlying mailbox format supports concurrent modification by other processes.", "score": "0.66821486"}]}
{"task_id": "mbpp_466", "code": "def find_peak_util(arr, low, high, n): \r\n\tmid = low + (high - low)/2\r\n\tmid = int(mid) \r\n\tif ((mid == 0 or arr[mid - 1] <= arr[mid]) and\r\n\t\t(mid == n - 1 or arr[mid + 1] <= arr[mid])): \r\n\t\treturn mid \r\n\telif (mid > 0 and arr[mid - 1] > arr[mid]): \r\n\t\treturn find_peak_util(arr, low, (mid - 1), n) \r\n\telse: \r\n\t\treturn find_peak_util(arr, (mid + 1), high, n) \r\ndef find_peak(arr, n): \r\n\treturn find_peak_util(arr, 0, n - 1, n) ", "test_list": ["assert find_peak([1, 3, 20, 4, 1, 0], 6) == 2", "assert find_peak([2, 3, 4, 5, 6], 5) == 4", "assert find_peak([8, 9, 11, 12, 14, 15], 6) == 5 "], "context": "Write a function to find the peak element in the given array.", "function_name": "def find_peak_util(arr, low, high, n):", "gold_generation": "mid = low + (high - low)/2\r\n\tmid = int(mid) \r\n\tif ((mid == 0 or arr[mid - 1] <= arr[mid]) and\r\n\t\t(mid == n - 1 or arr[mid + 1] <= arr[mid])): \r\n\t\treturn mid \r\n\telif (mid > 0 and arr[mid - 1] > arr[mid]): \r\n\t\treturn find_peak_util(arr, low, (mid - 1), n) \r\n\telse: \r\n\t\treturn find_peak_util(arr, (mid + 1), high, n) \r\ndef find_peak(arr, n): \r\n\treturn find_peak_util(arr, 0, n - 1, n)", "ctxs": [{"id": "43866", "text": "Function: numpy.reference.generated.numpy.recarray.ptp\nSnippet: numpy.recarray.ptp method recarray.ptp(axis=None, out=None, keepdims=False) Peak to peak (maximum - minimum) value along a given axis. Refer to numpy.ptp for full documentation. See also numpy.ptp equivalent function", "score": "0.76906633"}, {"id": "42552", "text": "Function: numpy.reference.generated.numpy.ndarray.ptp\nSnippet: numpy.ndarray.ptp method ndarray.ptp(axis=None, out=None, keepdims=False) Peak to peak (maximum - minimum) value along a given axis. Refer to numpy.ptp for full documentation. See also numpy.ptp equivalent function", "score": "0.75221986"}, {"id": "43147", "text": "Function: numpy.reference.generated.numpy.recarray\nSnippet: Peak to peak (maximum - minimum) value along a given axis. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. reshape(shape[, order]) Returns an array containing the same data with a new shape. resize(new_shape[, refcheck]) Change shape and size of array in-place. round([decimals, out]) Return a with each element rounded to the given number of decimals. searchsorted(v[, side, sorter]) Find indices where elements of v should be inserted in a to maintain order. setfield(val, dtype[, offset]) Put a value into a specified place in a field defined by a data-type. setflags([write, align, uic]) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. sort([axis, kind, order]) Sort an array in-place. squeeze([axis]) Remove axes of length one from a. std([axis, dtype, out, ddof, keepdims, where]) Returns the standard deviation of the array elements along given axis. sum([axis, dtype, out, keepdims, initial, where]) Return the sum of the array elements over the given axis. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. tobytes([order]) Construct Python bytes containing the raw data bytes in the array. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. trace([offset, axis1, axis2, dtype, out]) Return the sum along diagonals of the array. transpose(*axes) Returns a view of the array with axes transposed. var([axis, dtype, out, ddof, keepdims, where]) Returns the variance of the array elements, along given axis. view([dtype][, type]) New view of array with the same data. dot field", "score": "0.74029565"}, {"id": "43111", "text": "Function: numpy.reference.generated.numpy.ptp\nSnippet: numpy.ptp numpy.ptp(a, axis=None, out=None, keepdims=<no value>)[source] Range of values (maximum - minimum) along an axis. The name of the function comes from the acronym for ‘peak to peak’. Warning ptp preserves the data type of the array. This means the return value for an input of signed integers with n bits (e.g. np.int8, np.int16, etc) is also a signed integer with n bits. In that case, peak-to-peak values greater than 2**(n-1)-1 will be returned as negative values. An example with a work-around is shown below. Parameters aarray_like Input values. axisNone or int or tuple of ints, optional Axis along which to find the peaks. By default, flatten the array. axis may be negative, in which case it counts from the last to the first axis. New in version 1.15.0. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before. outarray_like Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type of the output values will be cast if necessary. keepdimsbool, optional If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the ptp method of sub-classes of ndarray, however any non-default value will be. If the sub-class’ method does not implement keepdims any exceptions will be raised. Returns ptpndarray A new array holding the result, unless out was specified, in which case a reference to out is returned. Examples >>> x = np.array([[4, 9, 2, 10], ... [6, 9, 7, 12]]) >>> np.ptp(x, axis=1) array([8, 6]) >>> np.ptp(x, axis=0) array([2, 0, 5, 2]) >>> np.ptp(x) 10 This example shows that a negative value can be returned when the input is an array of signed integers. >>> y = np.array([[1, 127], ... [0, 127], ... [-1, 127], ... [-2, 127]], dtype=np.int8) >>> np.ptp(y, axis=1) array([ 126, 127, -128, -127], dtype=int8) A work-around is to use the view() method to view the result as unsigned integers with the same bit width: >>> np.ptp(y, axis=1).view(np.uint8) array([126, 127, 128, 129], dtype=uint8)", "score": "0.68503296"}, {"id": "16692", "text": "Function: skimage.api.skimage.feature\nSnippet: , 0. , 0. , 0. , 0. ]]) >>> peak_local_max(img1, min_distance=1) array([[3, 2], [3, 4]]) >>> peak_local_max(img1, min_distance=2) array([[3, 2]]) >>> img2 = np.zeros((20, 20, 20)) >>> img2[10, 10, 10] = 1 >>> img2[15, 15, 15] = 1 >>> peak_idx = peak_local_max(img2, exclude_border=0) >>> peak_idx array([[10, 10, 10], [15, 15, 15]]) >>> peak_mask = np.zeros_like(img2, dtype=bool) >>> peak_mask[tuple(peak_idx.T)] = True >>> np.argwhere(peak_mask) array([[10, 10, 10], [15, 15, 15]]) Examples using skimage.feature.peak_local_max Finding local maxima Watershed segmentation Segment human cells (in mitosis) plot_matches skimage.feature.plot_matches(ax, image1, image2, keypoints1, keypoints2, matches, keypoints_color='k', matches_color=None, only_matches=False, alignment='horizontal') [source] Plot matched features. Parameters axmatplotlib.axes.Axes Matches and image are drawn in this ax. image1(N, M [, 3]) array First grayscale or color image. image2(N, M [, 3]) array Second grayscale or color image. keypoints1(K1, 2) array First keypoint coordinates as (row, col). keypoints2(K2, 2) array Second keypoint coordinates as (row, col). matches(Q, 2) array Indices of corresponding matches in first and second set of descriptors, where matches[:, 0] denote the indices in the first and matches[:, 1] the indices in the second set of descriptors. keypoints_colormatplotlib color, optional Color for keypoint locations. matches_colormatplotlib color, optional Color for lines which connect keypoint matches. By default the color is chosen randomly. only_matchesbool, optional Whether to only plot matches and not plot the keypoint locations. alignment{‘horizontal’, ‘vertical’}, optional Whether to show images side by side, 'horizontal', or one above the other, 'vertical'. register_translation skimage.feature.register_translation(src_image, target_image, upsample_factor=1, space='real', return_error=True) [source] Deprecated function. Use skimage.registration.phase_cross_correlation instead. shape_index skimage.feature.shape_index(image, sigma=1, mode='constant', cval=0) [source] Compute the shape index. The shape index, as defined by Koenderink & van Doorn [1], is a single valued measure of local curvature, assuming the image as a 3D plane with intensities representing heights. It is derived from the eigen values of the Hessian, and its value ranges from -1 to 1 (and is undefined (=NaN) in flat regions), with following ranges representing following shapes: Ranges of the shape index and corresponding shapes. Interval (s in …) Shape [ -1, -7/8) Spherical cup [-7/8, -5/8) Through [-5/8, -3/8) Rut [-3/8, -1/8) Saddle rut [-1/8, +1/8) Saddle [+1/8, +3/8) Saddle ridge [+3/8, +5/8) Ridge [+5/8, +7/8) Dome [+7/8, +1] Spherical cap Parameters imagendarray Input image. sigmafloat, optional Standard deviation used for the Gaussian kernel, which is used for smoothing the input data before Hessian eigen value calculation. mode{‘constant’, ‘reflect’, ‘wrap’, ‘nearest’, ‘mirror’}, optional How to handle values outside the image borders cvalfloat, optional Used in conjunction with mode ‘constant’, the value outside the image boundaries. Returns sndarray Shape index References 1 Koenderink, J. J. & van Doorn, A. J., “Surface shape and curvature scales”, Image and Vision Computing, 1992, 10, 557-564. DOI:10.1016/0262-8856(92)90076-F Examples >>> from skimage.feature import shape_index >>> square = np.zeros((5, 5)) >>> square[2, 2] = 4 >>> s = shape_index(square, sigma=0.1) >>> s array([[ nan, nan, -0.5, nan, nan], [ nan, -0. , nan, -0. , nan], [-0.5, nan, -1. , nan, -0.5], [ nan, -0. , nan, -0. , nan], [ nan, nan, -0.5, nan, nan]]) structure_tensor", "score": "0.6826203"}]}
{"task_id": "mbpp_467", "code": "def decimal_to_Octal(deciNum):\r\n    octalNum = 0\r\n    countval = 1;\r\n    dNo = deciNum;\r\n    while (deciNum!= 0):\r\n        remainder= deciNum % 8;\r\n        octalNum+= remainder*countval;\r\n        countval= countval*10;\r\n        deciNum //= 8; \r\n    return (octalNum)", "test_list": ["assert decimal_to_Octal(10) == 12", "assert decimal_to_Octal(2) == 2", "assert decimal_to_Octal(33) == 41"], "context": "Write a python function to convert decimal number to octal number.", "function_name": "def decimal_to_Octal(deciNum):", "gold_generation": "octalNum = 0\r\n    countval = 1;\r\n    dNo = deciNum;\r\n    while (deciNum!= 0):\r\n        remainder= deciNum % 8;\r\n        octalNum+= remainder*countval;\r\n        countval= countval*10;\r\n        deciNum //= 8; \r\n    return (octalNum)", "ctxs": [{"id": "22291", "text": "Function: python.library.functions#oct\nSnippet: oct(x) Convert an integer number to an octal string prefixed with “0o”. The result is a valid Python expression. If x is not a Python int object, it has to define an __index__() method that returns an integer. For example: >>> oct(8) '0o10' >>> oct(-56) '-0o70' If you want to convert an integer number to octal string either with prefix “0o” or not, you can use either of the following ways. >>> '%#o' % 10, '%o' % 10 ('0o12', '12') >>> format(10, '#o'), format(10, 'o') ('0o12', '12') >>> f'{10:#o}', f'{10:o}' ('0o12', '12') See also format() for more information.", "score": "0.76951313"}, {"id": "24415", "text": "Function: python.library.string#string.octdigits\nSnippet: string.octdigits The string '01234567'.", "score": "0.74054956"}, {"id": "20287", "text": "Function: python.library.functions\nSnippet: is not a Python int object, it has to define an __index__() method that returns an integer. For example: >>> oct(8) '0o10' >>> oct(-56) '-0o70' If you want to convert an integer number to octal string either with prefix “0o” or not, you can use either of the following ways. >>> '%#o' % 10, '%o' % 10 ('0o12', '12') >>> format(10, '#o'), format(10, 'o') ('0o12', '12') >>> f'{10:#o}', f'{10:o}' ('0o12', '12') See also format() for more information. open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) Open file and return a corresponding file object. If the file cannot be opened, an OSError is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed, unless closefd is set to False.) mode is an optional string that specifies the mode in which the file is opened. It defaults to 'r' which means open for reading in text mode. Other common values are 'w' for writing (truncating the file if it already exists), 'x' for exclusive creation and 'a' for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform dependent: locale.getpreferredencoding(False) is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: Character Meaning 'r' open for reading (default) 'w' open for writing, truncating the file first 'x' open for exclusive creation, failing if the file already exists 'a' open for writing, appending to the end of the file if it exists 'b' binary mode 't' text mode (default) '+' open for updating (reading and writing) The default mode is 'r' (open for reading text, synonym of 'rt'). Modes 'w+' and 'w+b' open and truncate the file. Modes 'r+' and 'r+b' open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including 'b' in the mode argument) return contents as bytes objects without any decoding. In text mode (the default, or when 't' is included in the mode argument), the contents of the file are returned as str, the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. There is an additional mode character permitted, 'U', which no longer has any effect, and is considered deprecated. It previously enabled universal newlines in text mode, which became the default behaviour in Python 3.0. Refer to the documentation of the newline parameter for further details. Note Python doesn’t depend on the underlying operating system’s notion of text files; all the processing", "score": "0.7353262"}, {"id": "19499", "text": "Function: python.library.decimal#decimal.Context.normalize\nSnippet: normalize(x) Reduces x to its simplest form.", "score": "0.73227143"}, {"id": "19516", "text": "Function: python.library.decimal#decimal.Decimal\nSnippet: class decimal.Decimal(value=\"0\", context=None) Construct a new Decimal object based from value. value can be an integer, string, tuple, float, or another Decimal object. If no value is given, returns Decimal('0'). If value is a string, it should conform to the decimal numeric string syntax after leading and trailing whitespace characters, as well as underscores throughout, are removed: sign ::= '+' | '-' digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' indicator ::= 'e' | 'E' digits ::= digit [digit]... decimal-part ::= digits '.' [digits] | ['.'] digits exponent-part ::= indicator [sign] digits infinity ::= 'Infinity' | 'Inf' nan ::= 'NaN' [digits] | 'sNaN' [digits] numeric-value ::= decimal-part [exponent-part] | infinity numeric-string ::= [sign] numeric-value | [sign] nan Other Unicode decimal digits are also permitted where digit appears above. These include decimal digits from various other alphabets (for example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits '\\uff10' through '\\uff19'. If value is a tuple, it should have three components, a sign (0 for positive or 1 for negative), a tuple of digits, and an integer exponent. For example, Decimal((0, (1, 4, 1, 4), -3)) returns Decimal('1.414'). If value is a float, the binary floating point value is losslessly converted to its exact decimal equivalent. This conversion can often require 53 or more digits of precision. For example, Decimal(float('1.1')) converts to Decimal('1.100000000000000088817841970012523233890533447265625'). The context precision does not affect how many digits are stored. That is determined exclusively by the number of digits in value. For example, Decimal('3.00000') records all five zeros even if the context precision is only three. The purpose of the context argument is determining what to do if value is a malformed string. If the context traps InvalidOperation, an exception is raised; otherwise, the constructor returns a new Decimal with the value of NaN. Once constructed, Decimal objects are immutable. Changed in version 3.2: The argument to the constructor is now permitted to be a float instance. Changed in version 3.3: float arguments raise an exception if the FloatOperation trap is set. By default the trap is off. Changed in version 3.6: Underscores are allowed for grouping, as with integral and floating-point literals in code. Decimal floating point objects share many properties with the other built-in numeric types such as float and int. All of the usual math operations and special methods apply. Likewise, decimal objects can be copied, pickled, printed, used as dictionary keys, used as set elements, compared, sorted, and coerced to another type (such as float or int). There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator % is applied to Decimal objects, the sign of the result is the sign of the dividend rather than the sign of the divisor: >>> (-7) % 4 1 >>> Decimal(-7) % Decimal(4) Decimal('-3') The integer division operator // behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather", "score": "0.73020273"}]}
{"task_id": "mbpp_468", "code": "def max_product(arr, n ): \r\n\tmpis =[0] * (n) \r\n\tfor i in range(n): \r\n\t\tmpis[i] = arr[i] \r\n\tfor i in range(1, n): \r\n\t\tfor j in range(i): \r\n\t\t\tif (arr[i] > arr[j] and\r\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \r\n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \r\n\treturn max(mpis)", "test_list": ["assert max_product([3, 100, 4, 5, 150, 6], 6) == 45000 ", "assert max_product([4, 42, 55, 68, 80], 5) == 50265600", "assert max_product([10, 22, 9, 33, 21, 50, 41, 60], 8) == 21780000 "], "context": "Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.", "function_name": "def max_product(arr, n ):", "gold_generation": "mpis =[0] * (n) \r\n\tfor i in range(n): \r\n\t\tmpis[i] = arr[i] \r\n\tfor i in range(1, n): \r\n\t\tfor j in range(i): \r\n\t\t\tif (arr[i] > arr[j] and\r\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \r\n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \r\n\treturn max(mpis)", "ctxs": [{"id": "42808", "text": "Function: numpy.reference.generated.numpy.einsum_path\nSnippet: numpy.einsum_path numpy.einsum_path(subscripts, *operands, optimize='greedy')[source] Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays. Parameters subscriptsstr Specifies the subscripts for summation. *operandslist of array_like These are the arrays for the operation. optimize{bool, list, tuple, ‘greedy’, ‘optimal’} Choose the type of path. If a tuple is provided, the second argument is assumed to be the maximum intermediate size created. If only a single argument is provided the largest input or output array size is used as a maximum intermediate size. if a list is given that starts with einsum_path, uses this as the contraction path if False no optimization is taken if True defaults to the ‘greedy’ algorithm ‘optimal’ An algorithm that combinatorially explores all possible ways of contracting the listed tensors and choosest the least costly path. Scales exponentially with the number of terms in the contraction. ‘greedy’ An algorithm that chooses the best pair contraction at each step. Effectively, this algorithm searches the largest inner, Hadamard, and then outer products at each step. Scales cubically with the number of terms in the contraction. Equivalent to the ‘optimal’ path for most contractions. Default is ‘greedy’. Returns pathlist of tuples A list representation of the einsum path. string_reprstr A printable representation of the einsum path. See also einsum, linalg.multi_dot Notes The resulting path indicates which terms of the input contraction should be contracted first, the result of this contraction is then appended to the end of the contraction list. This list can then be iterated over until all intermediate contractions are complete. Examples We can begin with a chain dot example. In this case, it is optimal to contract the b and c tensors first as represented by the first element of the path (1, 2). The resulting tensor is added to the end of the contraction and the remaining contraction (0, 1) is then completed. >>> np.random.seed(123) >>> a = np.random.rand(2, 2) >>> b = np.random.rand(2, 5) >>> c = np.random.rand(5, 2) >>> path_info = np.einsum_path('ij,jk,kl->il', a, b, c, optimize='greedy') >>> print(path_info[0]) ['einsum_path', (1, 2), (0, 1)] >>> print(path_info[1]) Complete contraction: ij,jk,kl->il # may vary Naive scaling: 4 Optimized scaling: 3 Naive FLOP count: 1.600e+02 Optimized FLOP count: 5.600e+01 Theoretical speedup: 2.857 Largest intermediate: 4.000e+00 elements ------------------------------------------------------------------------- scaling current remaining ------------------------------------------------------------------------- 3 kl,jk->jl ij,jl->il 3 jl,ij->il il->il A more complex index transformation example. >>> I = np.random.rand(10, 10, 10, 10) >>> C = np.random.rand(10, 10) >>> path_info = np.einsum_path('ea,fb,abcd,gc,hd->efgh', C, C, I, C, C, ... optimize='greedy') >>> print(path_info[0]) ['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)] >>> print(path_info[1]) Complete contraction: ea,fb,abcd,gc,hd->efgh # may vary Naive scaling: 8 Optimized scaling: 5 Naive FLOP count: 8.000e+08 Optimized FLOP count: 8.000e+05 Theoretical speedup: 1000.000 Largest intermediate: 1.000e+04 elements -------------------------------------------------------------------------- scaling current remaining -------------------------------------------------------------------------- 5 abcd,ea->bcde fb,gc,hd,bcde->efgh 5 bcde,fb->cdef gc,hd,cdef->efgh 5 cdef,gc->defg hd,defg->efgh 5 defg,hd->efgh efgh->efgh", "score": "0.659513"}, {"id": "42330", "text": "Function: numpy.reference.generated.numpy.ma.prod\nSnippet: numpy.ma.prod ma.prod(self, axis=None, dtype=None, out=None, keepdims=<no value>) = <numpy.ma.core._frommethod object> Return the product of the array elements over the given axis. Masked elements are set to 1 internally for computation. Refer to numpy.prod for full documentation. See also numpy.ndarray.prod corresponding function for ndarrays numpy.prod equivalent function Notes Arithmetic is modular when using integer types, and no error is raised on overflow.", "score": "0.64919454"}, {"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.6479827"}, {"id": "43865", "text": "Function: numpy.reference.generated.numpy.recarray.prod\nSnippet: numpy.recarray.prod method recarray.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True) Return the product of the array elements over the given axis Refer to numpy.prod for full documentation. See also numpy.prod equivalent function", "score": "0.647218"}, {"id": "21311", "text": "Function: python.library.itertools#itertools.product\nSnippet: itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs.", "score": "0.646471"}]}
{"task_id": "mbpp_469", "code": "def max_profit(price, k):\r\n    n = len(price)\r\n    final_profit = [[None for x in range(n)] for y in range(k + 1)]\r\n    for i in range(k + 1):\r\n        for j in range(n):\r\n            if i == 0 or j == 0:\r\n                final_profit[i][j] = 0\r\n            else:\r\n                max_so_far = 0\r\n                for x in range(j):\r\n                    curr_price = price[j] - price[x] + final_profit[i-1][x]\r\n                    if max_so_far < curr_price:\r\n                        max_so_far = curr_price\r\n                final_profit[i][j] = max(final_profit[i][j-1], max_so_far)\r\n    return final_profit[k][n-1]", "test_list": ["assert max_profit([1, 5, 2, 3, 7, 6, 4, 5], 3) == 10", "assert max_profit([2, 4, 7, 5, 4, 3, 5], 2) == 7", "assert max_profit([10, 6, 8, 4, 2], 2) == 2"], "context": "Write a function to find the maximum profit earned from a maximum of k stock transactions", "function_name": "def max_profit(price, k):", "gold_generation": "n = len(price)\r\n    final_profit = [[None for x in range(n)] for y in range(k + 1)]\r\n    for i in range(k + 1):\r\n        for j in range(n):\r\n            if i == 0 or j == 0:\r\n                final_profit[i][j] = 0\r\n            else:\r\n                max_so_far = 0\r\n                for x in range(j):\r\n                    curr_price = price[j] - price[x] + final_profit[i-1][x]\r\n                    if max_so_far < curr_price:\r\n                        max_so_far = curr_price\r\n                final_profit[i][j] = max(final_profit[i][j-1], max_so_far)\r\n    return final_profit[k][n-1]", "ctxs": [{"id": "33950", "text": "Function: matplotlib.ticker_api#matplotlib.ticker.Locator.MAXTICKS\nSnippet: MAXTICKS=1000", "score": "0.6439438"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.63897103"}, {"id": "15720", "text": "Function: pandas.reference.api.pandas.tseries.offsets.businessmonthend.n\nSnippet: pandas.tseries.offsets.BusinessMonthEnd.n BusinessMonthEnd.n", "score": "0.6299677"}, {"id": "19587", "text": "Function: python.library.decimal#decimal.MAX_PREC\nSnippet: decimal.MAX_PREC", "score": "0.6256075"}, {"id": "15695", "text": "Function: pandas.reference.api.pandas.tseries.offsets.businessmonthbegin.n\nSnippet: pandas.tseries.offsets.BusinessMonthBegin.n BusinessMonthBegin.n", "score": "0.62479234"}]}
{"task_id": "mbpp_470", "code": "def add_pairwise(test_tup):\r\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\r\n  return (res) ", "test_list": ["assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)", "assert add_pairwise((2, 6, 8, 9, 11)) == (8, 14, 17, 20)", "assert add_pairwise((3, 7, 9, 10, 12)) == (10, 16, 19, 22)"], "context": "Write a function to find the pairwise addition of the elements of the given tuples.", "function_name": "def add_pairwise(test_tup):", "gold_generation": "res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\r\n  return (res)", "ctxs": [{"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.68671006"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.67794144"}, {"id": "21302", "text": "Function: python.library.itertools#itertools.combinations_with_replacement\nSnippet: itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1.", "score": "0.6713263"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.67037416"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.66893804"}]}
{"task_id": "mbpp_471", "code": "def find_remainder(arr, lens, n): \r\n    mul = 1\r\n    for i in range(lens):  \r\n        mul = (mul * (arr[i] % n)) % n \r\n    return mul % n ", "test_list": ["assert find_remainder([ 100, 10, 5, 25, 35, 14 ],6,11) ==9", "assert find_remainder([1,1,1],3,1) == 0", "assert find_remainder([1,2,1],3,2) == 0"], "context": "Write a python function to find remainder of array multiplication divided by n.", "function_name": "def find_remainder(arr, lens, n):", "gold_generation": "mul = 1\r\n    for i in range(lens):  \r\n        mul = (mul * (arr[i] % n)) % n \r\n    return mul % n", "ctxs": [{"id": "43151", "text": "Function: numpy.reference.generated.numpy.remainder\nSnippet: numpy.remainder numpy.remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'remainder'> Returns the element-wise remainder of division. Computes the remainder complementary to the floor_divide function. It is equivalent to the Python modulus operator``x1 % x2`` and has the same sign as the divisor x2. The MATLAB function equivalent to np.remainder is mod. Warning This should not be confused with: Python 3.7’s math.remainder and C’s remainder, which computes the IEEE remainder, which are the complement to round(x1 / x2). The MATLAB rem function and or the C % operator which is the complement to int(x1 / x2). Parameters x1array_like Dividend array. x2array_like Divisor array. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray The element-wise remainder of the quotient floor_divide(x1, x2). This is a scalar if both x1 and x2 are scalars. See also floor_divide Equivalent of Python // operator. divmod Simultaneous floor division and remainder. fmod Equivalent of the MATLAB rem function. divide, floor Notes Returns 0 when x2 is 0 and both x1 and x2 are (arrays of) integers. mod is an alias of remainder. Examples >>> np.remainder([4, 7], [2, 3]) array([0, 1]) >>> np.remainder(np.arange(7), 5) array([0, 1, 2, 3, 4, 0, 1]) The % operator can be used as a shorthand for np.remainder on ndarrays. >>> x1 = np.arange(7) >>> x1 % 5 array([0, 1, 2, 3, 4, 0, 1])", "score": "0.74369395"}, {"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.729618"}, {"id": "43025", "text": "Function: numpy.reference.generated.numpy.mod\nSnippet: numpy.mod numpy.mod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'remainder'> Returns the element-wise remainder of division. Computes the remainder complementary to the floor_divide function. It is equivalent to the Python modulus operator``x1 % x2`` and has the same sign as the divisor x2. The MATLAB function equivalent to np.remainder is mod. Warning This should not be confused with: Python 3.7’s math.remainder and C’s remainder, which computes the IEEE remainder, which are the complement to round(x1 / x2). The MATLAB rem function and or the C % operator which is the complement to int(x1 / x2). Parameters x1array_like Dividend array. x2array_like Divisor array. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray The element-wise remainder of the quotient floor_divide(x1, x2). This is a scalar if both x1 and x2 are scalars. See also floor_divide Equivalent of Python // operator. divmod Simultaneous floor division and remainder. fmod Equivalent of the MATLAB rem function. divide, floor Notes Returns 0 when x2 is 0 and both x1 and x2 are (arrays of) integers. mod is an alias of remainder. Examples >>> np.remainder([4, 7], [2, 3]) array([0, 1]) >>> np.remainder(np.arange(7), 5) array([0, 1, 2, 3, 4, 0, 1]) The % operator can be used as a shorthand for np.remainder on ndarrays. >>> x1 = np.arange(7) >>> x1 % 5 array([0, 1, 2, 3, 4, 0, 1])", "score": "0.7258717"}, {"id": "42843", "text": "Function: numpy.reference.generated.numpy.fmod\nSnippet: numpy.fmod numpy.fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'fmod'> Returns the element-wise remainder of division. This is the NumPy implementation of the C library function fmod, the remainder has the same sign as the dividend x1. It is equivalent to the Matlab(TM) rem function and should not be confused with the Python modulus operator x1 % x2. Parameters x1array_like Dividend. x2array_like Divisor. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yarray_like The remainder of the division of x1 by x2. This is a scalar if both x1 and x2 are scalars. See also remainder Equivalent to the Python % operator. divide Notes The result of the modulo operation for negative dividend and divisors is bound by conventions. For fmod, the sign of result is the sign of the dividend, while for remainder the sign of the result is the sign of the divisor. The fmod function is equivalent to the Matlab(TM) rem function. Examples >>> np.fmod([-3, -2, -1, 1, 2, 3], 2) array([-1, 0, -1, 1, 0, 1]) >>> np.remainder([-3, -2, -1, 1, 2, 3], 2) array([1, 0, 1, 1, 0, 1]) >>> np.fmod([5, 3], [2, 2.]) array([ 1., 1.]) >>> a = np.arange(-3, 3).reshape(3, 2) >>> a array([[-3, -2], [-1, 0], [ 1, 2]]) >>> np.fmod(a, [2,2]) array([[-1, 0], [-1, 0], [ 1, 0]])", "score": "0.7113553"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.69797987"}]}
{"task_id": "mbpp_472", "code": "def check_Consecutive(l): \r\n    return sorted(l) == list(range(min(l),max(l)+1)) ", "test_list": ["assert check_Consecutive([1,2,3,4,5]) == True", "assert check_Consecutive([1,2,3,5,6]) == False", "assert check_Consecutive([1,2,1]) == False"], "context": "Write a python function to check whether the given list contains consecutive numbers or not.", "function_name": "def check_Consecutive(l):", "gold_generation": "return sorted(l) == list(range(min(l),max(l)+1))", "ctxs": [{"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.7024867"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.68489337"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6827677"}, {"id": "21296", "text": "Function: python.library.itertools\nSnippet: D E B F C\" # Recipe credited to George Sakkis num_active = len(iterables) nexts = cycle(iter(it).__next__ for it in iterables) while num_active: try: for next in nexts: yield next() except StopIteration: # Remove the iterator we just exhausted from the cycle. num_active -= 1 nexts = cycle(islice(nexts, num_active)) def partition(pred, iterable): \"Use a predicate to partition entries into false entries and true entries\" # partition(is_odd, range(10)) --> 0 2 4 6 8 and 1 3 5 7 9 t1, t2 = tee(iterable) return filterfalse(pred, t1), filter(pred, t2) def powerset(iterable): \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\" s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s)+1)) def unique_everseen(iterable, key=None): \"List unique elements, preserving order. Remember all elements ever seen.\" # unique_everseen('AAAABBBCCDAABBB') --> A B C D # unique_everseen('ABBCcAD', str.lower) --> A B C D seen = set() seen_add = seen.add if key is None: for element in filterfalse(seen.__contains__, iterable): seen_add(element) yield element else: for element in iterable: k = key(element) if k not in seen: seen_add(k) yield element def unique_justseen(iterable, key=None): \"List unique elements, preserving order. Remember only the element just seen.\" # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B # unique_justseen('ABBCcAD', str.lower) --> A B C A D return map(next, map(operator.itemgetter(1), groupby(iterable, key))) def iter_except(func, exception, first=None): \"\"\" Call a function repeatedly until an exception is raised. Converts a call-until-exception interface to an iterator interface. Like builtins.iter(func, sentinel) but uses an exception instead of a sentinel to end the loop. Examples: iter_except(functools.partial(heappop, h), IndexError) # priority queue iterator iter_except(d.popitem, KeyError) # non-blocking dict iterator iter_except(d.popleft, IndexError) # non-blocking deque iterator iter_except(q.get_nowait, Queue.Empty) # loop over a producer Queue iter_except(s.pop, KeyError) # non-blocking set iterator \"\"\" try: if first is not None: yield first() # For database APIs needing an initial cast to db.first() while True: yield func() except exception: pass def first_true(iterable, default=False, pred=None): \"\"\"Returns the first true value in the iterable. If no true value is found, returns *default* If *pred* is not None, returns the first item for which pred(item) is true. \"\"\" # first_true([a,b,c], x) --> a or b or c or x # first_true([a,b], x, f) --> a if f(a) else b if f(b) else x return next(filter(pred, iterable), default) def random_product(*args, repeat=1): \"Random selection from itertools.product(*args, **kwds)\" pools = [tuple(pool) for pool in args] * repeat return tuple(map(random.choice, pools)) def random_permutation(iterable, r=None): \"Random selection from itertools.permutations(iterable, r)\" pool = tuple(iterable) r = len(pool) if r is None else r return tuple(random.sample(pool, r)) def random_combination(iterable, r): \"Random selection from itertools.combinations(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.sample(range(n), r)) return tuple(pool[i] for i in indices) def random_combination_with_replacement(iterable, r): \"Random selection from itertools.combinations_with_replacement(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.choices(range(n), k=r)) return tuple(pool[i] for i in indices) def nth_combination(iterable, r, index): \"Equivalent to list(combinations(iterable, r))[index]\" pool = tuple(iterable) n = len(pool) if r < 0 or r > n: raise ValueError c = 1 k = min(r, n-r) for i in range(1, k+1): c = c", "score": "0.6764548"}, {"id": "42916", "text": "Function: numpy.reference.generated.numpy.isfortran\nSnippet: numpy.isfortran numpy.isfortran(a)[source] Check if the array is Fortran contiguous but not C contiguous. This function is obsolete and, because of changes due to relaxed stride checking, its return value for the same array may differ for versions of NumPy >= 1.10.0 and previous versions. If you only want to check if an array is Fortran contiguous use a.flags.f_contiguous instead. Parameters andarray Input array. Returns isfortranbool Returns True if the array is Fortran contiguous but not C contiguous. Examples np.array allows to specify whether the array is written in C-contiguous order (last index varies the fastest), or FORTRAN-contiguous order in memory (first index varies the fastest). >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C') >>> a array([[1, 2, 3], [4, 5, 6]]) >>> np.isfortran(a) False >>> b = np.array([[1, 2, 3], [4, 5, 6]], order='F') >>> b array([[1, 2, 3], [4, 5, 6]]) >>> np.isfortran(b) True The transpose of a C-ordered array is a FORTRAN-ordered array. >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C') >>> a array([[1, 2, 3], [4, 5, 6]]) >>> np.isfortran(a) False >>> b = a.T >>> b array([[1, 4], [2, 5], [3, 6]]) >>> np.isfortran(b) True C-ordered arrays evaluate as False even if they are also FORTRAN-ordered. >>> np.isfortran(np.array([1, 2], order='F')) False", "score": "0.67562884"}]}
{"task_id": "mbpp_473", "code": "def tuple_intersection(test_list1, test_list2):\r\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\r\n  return (res)", "test_list": ["assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}", "assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}", "assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}"], "context": "Write a function to find the tuple intersection of elements in the given tuple list irrespective of their order.", "function_name": "def tuple_intersection(test_list1, test_list2):", "gold_generation": "res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\r\n  return (res)", "ctxs": [{"id": "20222", "text": "Function: python.library.stdtypes#frozenset.intersection\nSnippet: intersection(*others) set & other & ... Return a new set with elements common to the set and all others.", "score": "0.7059158"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.7033103"}, {"id": "21301", "text": "Function: python.library.itertools#itertools.combinations\nSnippet: itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.70323396"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.70028734"}, {"id": "21302", "text": "Function: python.library.itertools#itertools.combinations_with_replacement\nSnippet: itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1.", "score": "0.6970478"}]}
{"task_id": "mbpp_474", "code": "def replace_char(str1,ch,newch):\r\n str2 = str1.replace(ch, newch)\r\n return str2", "test_list": ["assert replace_char(\"polygon\",'y','l')==(\"pollgon\")", "assert replace_char(\"character\",'c','a')==(\"aharaater\")", "assert replace_char(\"python\",'l','a')==(\"python\")"], "context": "Write a function to replace characters in a string.", "function_name": "def replace_char(str1,ch,newch):", "gold_generation": "str2 = str1.replace(ch, newch)\r\n return str2", "ctxs": [{"id": "41747", "text": "Function: numpy.reference.generated.numpy.char.replace\nSnippet: numpy.char.replace char.replace(a, old, new, count=None)[source] For each element in a, return a copy of the string with all occurrences of substring old replaced by new. Calls str.replace element-wise. Parameters aarray-like of str or unicode old, newstr or unicode countint, optional If the optional argument count is given, only the first count occurrences are replaced. Returns outndarray Output array of str or unicode, depending on input type See also str.replace", "score": "0.7285464"}, {"id": "41683", "text": "Function: numpy.reference.generated.numpy.char.chararray.replace\nSnippet: numpy.char.chararray.replace method char.chararray.replace(old, new, count=None)[source] For each element in self, return a copy of the string with all occurrences of substring old replaced by new. See also char.replace", "score": "0.72671705"}, {"id": "41805", "text": "Function: numpy.reference.generated.numpy.chararray.replace\nSnippet: numpy.chararray.replace method chararray.replace(old, new, count=None)[source] For each element in self, return a copy of the string with all occurrences of substring old replaced by new. See also char.replace", "score": "0.71755815"}, {"id": "24370", "text": "Function: python.library.stdtypes#str.replace\nSnippet: str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced.", "score": "0.70529985"}, {"id": "24398", "text": "Function: python.library.string\nSnippet: characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", "score": "0.6955136"}]}
{"task_id": "mbpp_475", "code": "from collections import Counter\r\ndef sort_counter(dict1):\r\n x = Counter(dict1)\r\n sort_counter=x.most_common()\r\n return sort_counter", "test_list": ["assert sort_counter({'Math':81, 'Physics':83, 'Chemistry':87})==[('Chemistry', 87), ('Physics', 83), ('Math', 81)]", "assert sort_counter({'Math':400, 'Physics':300, 'Chemistry':250})==[('Math', 400), ('Physics', 300), ('Chemistry', 250)]", "assert sort_counter({'Math':900, 'Physics':1000, 'Chemistry':1250})==[('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]"], "context": "Write a function to sort counter by value.", "function_name": "from collections import Counter\r\ndef sort_counter(dict1):", "gold_generation": "x = Counter(dict1)\r\n sort_counter=x.most_common()\r\n return sort_counter", "ctxs": [{"id": "14495", "text": "Function: pandas.reference.api.pandas.dataframe.sort_values\nSnippet: B 9 9 c 0 A 2 0 a 1 A 1 1 B Sorting with a key function >>> df.sort_values(by='col4', key=lambda col: col.str.lower()) col1 col2 col3 col4 0 A 2 0 a 1 A 1 1 B 2 B 9 9 c 3 NaN 8 4 D 4 D 7 2 e 5 C 4 3 F Natural sort with the key argument, using the natsort <https://github.com/SethMMorton/natsort> package. >>> df = pd.DataFrame({ ... \"time\": ['0hr', '128hr', '72hr', '48hr', '96hr'], ... \"value\": [10, 20, 30, 40, 50] ... }) >>> df time value 0 0hr 10 1 128hr 20 2 72hr 30 3 48hr 40 4 96hr 50 >>> from natsort import index_natsorted >>> df.sort_values( ... by=\"time\", ... key=lambda x: np.argsort(index_natsorted(df[\"time\"])) ... ) time value 0 0hr 10 3 48hr 40 2 72hr 30 4 96hr 50 1 128hr 20", "score": "0.69371796"}, {"id": "14754", "text": "Function: pandas.reference.api.pandas.index.sort\nSnippet: pandas.Index.sort finalIndex.sort(*args, **kwargs)[source] Use sort_values instead.", "score": "0.68571055"}, {"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.68006486"}, {"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.6793628"}, {"id": "20478", "text": "Function: python.library.heapq\nSnippet: key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters. heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n]. heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n]. The latter two functions perform best for smaller values of n. For larger values, it is more efficient to use the sorted() function. Also, when n==1, it is more efficient to use the built-in min() and max() functions. If repeated usage of these functions is required, consider turning the iterable into an actual heap. Basic Examples A heapsort can be implemented by pushing all values onto a heap and then popping off the smallest values one at a time: >>> def heapsort(iterable): ... h = [] ... for value in iterable: ... heappush(h, value) ... return [heappop(h) for i in range(len(h))] ... >>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] This is similar to sorted(iterable), but unlike sorted(), this implementation is not stable. Heap elements can be tuples. This is useful for assigning comparison values (such as task priorities) alongside the main record being tracked: >>> h = [] >>> heappush(h, (5, 'write code')) >>> heappush(h, (7, 'release product')) >>> heappush(h, (1, 'write spec')) >>> heappush(h, (3, 'create tests')) >>> heappop(h) (1, 'write spec') Priority Queue Implementation Notes A priority queue is common use for a heap, and it presents several implementation challenges: Sort stability: how do you get two tasks with equal priorities to be returned in the order they were originally added? Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order. If the priority of a task changes, how do you move it to a new position in the heap? Or if a pending task needs to be deleted, how do you find it and remove it from the queue? A solution to the first two challenges is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were", "score": "0.6772533"}]}
{"task_id": "mbpp_476", "code": "def big_sum(nums):\r\n      sum= max(nums)+min(nums)\r\n      return sum", "test_list": ["assert big_sum([1,2,3]) == 4", "assert big_sum([-1,2,3,4]) == 3", "assert big_sum([2,3,6]) == 8"], "context": "Write a python function to find the sum of the largest and smallest value in a given array.", "function_name": "def big_sum(nums):", "gold_generation": "sum= max(nums)+min(nums)\r\n      return sum", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.6980299"}, {"id": "13013", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos#sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.6951521"}, {"id": "12778", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.6903419"}, {"id": "43023", "text": "Function: numpy.reference.generated.numpy.minimum\nSnippet: numpy.minimum numpy.minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'minimum'> Element-wise minimum of array elements. Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The minimum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also maximum Element-wise maximum of two arrays, propagates NaNs. fmin Element-wise minimum of two arrays, ignores NaNs. amin The minimum value of an array along a given axis, propagates NaNs. nanmin The minimum value of an array along a given axis, ignores NaNs. fmax, amax, nanmax Notes The minimum is equivalent to np.where(x1 <= x2, x1, x2) when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting. Examples >>> np.minimum([2, 3, 4], [1, 5, 2]) array([1, 3, 2]) >>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting array([[ 0.5, 0. ], [ 0. , 1. ]]) >>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.minimum(-np.Inf, 1) -inf", "score": "0.678172"}, {"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.6766445"}]}
{"task_id": "mbpp_477", "code": "def is_lower(string):\r\n  return (string.lower())", "test_list": ["assert is_lower(\"InValid\") == \"invalid\"", "assert is_lower(\"TruE\") == \"true\"", "assert is_lower(\"SenTenCE\") == \"sentence\""], "context": "Write a python function to convert the given string to lower case.", "function_name": "def is_lower(string):", "gold_generation": "return (string.lower())", "ctxs": [{"id": "24364", "text": "Function: python.library.stdtypes#str.lower\nSnippet: str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard.", "score": "0.8074446"}, {"id": "24400", "text": "Function: python.library.string#string.ascii_lowercase\nSnippet: string.ascii_lowercase The lowercase letters 'abcdefghijklmnopqrstuvwxyz'. This value is not locale-dependent and will not change.", "score": "0.7848549"}, {"id": "41741", "text": "Function: numpy.reference.generated.numpy.char.lower\nSnippet: numpy.char.lower char.lower(a)[source] Return an array with the elements converted to lowercase. Call str.lower element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like, {str, unicode} Input array. Returns outndarray, {str, unicode} Output array of str or unicode, depending on input type See also str.lower Examples >>> c = np.array(['A1B C', '1BCA', 'BCA1']); c array(['A1B C', '1BCA', 'BCA1'], dtype='<U5') >>> np.char.lower(c) array(['a1b c', '1bca', 'bca1'], dtype='<U5')", "score": "0.7581697"}, {"id": "15347", "text": "Function: pandas.reference.api.pandas.series.str.lower\nSnippet: pandas.Series.str.lower Series.str.lower()[source] Convert strings in the Series/Index to lowercase. Equivalent to str.lower(). Returns Series or Index of object See also Series.str.lower Converts all characters to lowercase. Series.str.upper Converts all characters to uppercase. Series.str.title Converts first character of each word to uppercase and remaining to lowercase. Series.str.capitalize Converts first character to uppercase and remaining to lowercase. Series.str.swapcase Converts uppercase to lowercase and lowercase to uppercase. Series.str.casefold Removes all case distinctions in the string. Examples >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe']) >>> s 0 lower 1 CAPITALS 2 this is a sentence 3 SwApCaSe dtype: object >>> s.str.lower() 0 lower 1 capitals 2 this is a sentence 3 swapcase dtype: object >>> s.str.upper() 0 LOWER 1 CAPITALS 2 THIS IS A SENTENCE 3 SWAPCASE dtype: object >>> s.str.title() 0 Lower 1 Capitals 2 This Is A Sentence 3 Swapcase dtype: object >>> s.str.capitalize() 0 Lower 1 Capitals 2 This is a sentence 3 Swapcase dtype: object >>> s.str.swapcase() 0 LOWER 1 capitals 2 THIS IS A SENTENCE 3 sWaPcAsE dtype: object", "score": "0.758025"}, {"id": "41674", "text": "Function: numpy.reference.generated.numpy.char.chararray.lower\nSnippet: numpy.char.chararray.lower method char.chararray.lower()[source] Return an array with the elements of self converted to lowercase. See also char.lower", "score": "0.753137"}]}
{"task_id": "mbpp_478", "code": "import re\r\ndef remove_lowercase(str1):\r\n remove_lower = lambda text: re.sub('[a-z]', '', text)\r\n result =  remove_lower(str1)\r\n return result", "test_list": ["assert remove_lowercase(\"PYTHon\")==('PYTH')", "assert remove_lowercase(\"FInD\")==('FID')", "assert remove_lowercase(\"STRinG\")==('STRG')"], "context": "Write a function to remove lowercase substrings from a given string.", "function_name": "import re\r\ndef remove_lowercase(str1):", "gold_generation": "remove_lower = lambda text: re.sub('[a-z]', '', text)\r\n result =  remove_lower(str1)\r\n return result", "ctxs": [{"id": "24364", "text": "Function: python.library.stdtypes#str.lower\nSnippet: str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard.", "score": "0.74895"}, {"id": "24400", "text": "Function: python.library.string#string.ascii_lowercase\nSnippet: string.ascii_lowercase The lowercase letters 'abcdefghijklmnopqrstuvwxyz'. This value is not locale-dependent and will not change.", "score": "0.72985226"}, {"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.7298227"}, {"id": "25742", "text": "Function: python.library.stdtypes\nSnippet: Strings also support two styles of string formatting, one providing a large degree of flexibility and customization (see str.format(), Format String Syntax and Custom String Formatting) and the other based on C printf style formatting that handles a narrower range of types and is slightly harder to use correctly, but is often faster for the cases it can handle (printf-style String Formatting). The Text Processing Services section of the standard library covers a number of other modules that provide various text related utilities (including regular expression support in the re module). str.capitalize() Return a copy of the string with its first character capitalized and the rest lowercased. Changed in version 3.8: The first character is now put into titlecase rather than uppercase. This means that characters like digraphs will only have their first letter capitalized, instead of the full character. str.casefold() Return a casefolded copy of the string. Casefolded strings may be used for caseless matching. Casefolding is similar to lowercasing but more aggressive because it is intended to remove all case distinctions in a string. For example, the German lowercase letter 'ß' is equivalent to \"ss\". Since it is already lowercase, lower() would do nothing to 'ß'; casefold() converts it to \"ss\". The casefolding algorithm is described in section 3.13 of the Unicode Standard. New in version 3.3. str.center(width[, fillchar]) Return centered in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. str.encode(encoding=\"utf-8\", errors=\"strict\") Return an encoded version of the string as a bytes object. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other possible values are 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and any other name registered via codecs.register_error(), see section Error Handlers. For a list of possible encodings, see section Standard Encodings. By default, the errors argument is not checked for best performances, but only used at the first encoding error. Enable the Python Development Mode, or use a debug build to check errors. Changed in version 3.1: Support for keyword arguments added. Changed in version 3.9: The errors is now checked in development mode and in debug mode. str.endswith(suffix[, start[, end]]) Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. str.expandtabs(tabsize=8) Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. Tab positions occur every tabsize characters (default is 8, giving tab positions at columns 0, 8, 16 and so", "score": "0.7215402"}, {"id": "15347", "text": "Function: pandas.reference.api.pandas.series.str.lower\nSnippet: pandas.Series.str.lower Series.str.lower()[source] Convert strings in the Series/Index to lowercase. Equivalent to str.lower(). Returns Series or Index of object See also Series.str.lower Converts all characters to lowercase. Series.str.upper Converts all characters to uppercase. Series.str.title Converts first character of each word to uppercase and remaining to lowercase. Series.str.capitalize Converts first character to uppercase and remaining to lowercase. Series.str.swapcase Converts uppercase to lowercase and lowercase to uppercase. Series.str.casefold Removes all case distinctions in the string. Examples >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe']) >>> s 0 lower 1 CAPITALS 2 this is a sentence 3 SwApCaSe dtype: object >>> s.str.lower() 0 lower 1 capitals 2 this is a sentence 3 swapcase dtype: object >>> s.str.upper() 0 LOWER 1 CAPITALS 2 THIS IS A SENTENCE 3 SWAPCASE dtype: object >>> s.str.title() 0 Lower 1 Capitals 2 This Is A Sentence 3 Swapcase dtype: object >>> s.str.capitalize() 0 Lower 1 Capitals 2 This is a sentence 3 Swapcase dtype: object >>> s.str.swapcase() 0 LOWER 1 capitals 2 THIS IS A SENTENCE 3 sWaPcAsE dtype: object", "score": "0.710869"}]}
{"task_id": "mbpp_479", "code": "def first_Digit(n) :  \r\n    while n >= 10:  \r\n        n = n / 10; \r\n    return int(n) ", "test_list": ["assert first_Digit(123) == 1", "assert first_Digit(456) == 4", "assert first_Digit(12) == 1"], "context": "Write a python function to find the first digit of a given number.", "function_name": "def first_Digit(n) :", "gold_generation": "while n >= 10:  \r\n        n = n / 10; \r\n    return int(n)", "ctxs": [{"id": "24403", "text": "Function: python.library.string#string.digits\nSnippet: string.digits The string '0123456789'.", "score": "0.734212"}, {"id": "24415", "text": "Function: python.library.string#string.octdigits\nSnippet: string.octdigits The string '01234567'.", "score": "0.6915339"}, {"id": "24414", "text": "Function: python.library.string#string.hexdigits\nSnippet: string.hexdigits The string '0123456789abcdefABCDEF'.", "score": "0.67984486"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6700103"}, {"id": "20284", "text": "Function: python.library.functions\nSnippet: hexadecimal string prefixed with “0x”. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> hex(255) '0xff' >>> hex(-42) '-0x2a' If you want to convert an integer number to an uppercase or lower hexadecimal string with prefix or not, you can use either of the following ways: >>> '%#x' % 255, '%x' % 255, '%X' % 255 ('0xff', 'ff', 'FF') >>> format(255, '#x'), format(255, 'x'), format(255, 'X') ('0xff', 'ff', 'FF') >>> f'{255:#x}', f'{255:x}', f'{255:X}' ('0xff', 'ff', 'FF') See also format() for more information. See also int() for converting a hexadecimal string to an integer using a base of 16. Note To obtain a hexadecimal string representation for a float, use the float.hex() method. id(object) Return the “identity” of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value. CPython implementation detail: This is the address of the object in memory. Raises an auditing event builtins.id with argument id. input([prompt]) If the prompt argument is present, it is written to standard output without a trailing newline. The function then reads a line from input, converts it to a string (stripping a trailing newline), and returns that. When EOF is read, EOFError is raised. Example: >>> s = input('--> ') --> Monty Python's Flying Circus >>> s \"Monty Python's Flying Circus\" If the readline module was loaded, then input() will use it to provide elaborate line editing and history features. Raises an auditing event builtins.input with argument prompt before reading input Raises an auditing event builtins.input/result with the result after successfully reading input. class int([x]) class int(x, base=10) Return an integer object constructed from a number or string x, or return 0 if no arguments are given. If x defines __int__(), int(x) returns x.__int__(). If x defines __index__(), it returns x.__index__(). If x defines __trunc__(), it returns x.__trunc__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in radix base. Optionally, the literal can be preceded by + or - (with no space in between) and surrounded by whitespace. A base-n literal consists of the digits 0 to n-1, with a to z (or A to Z) having values 10 to 35. The default base is 10. The allowed values are 0 and 2–36. Base-2, -8, and -16 literals can be optionally prefixed with 0b/0B, 0o/0O, or 0x/0X, as with integer literals in code. Base 0 means to interpret exactly as a code literal, so that the actual base is 2, 8, 10, or 16, and so that int('010', 0) is not legal, while int('010') is, as well as int('010', 8). The integer type is described in Numeric Types — int, float, complex. Changed in version 3.4: If base is not an instance of int", "score": "0.6642356"}]}
{"task_id": "mbpp_480", "code": "def get_max_occuring_char(str1):\r\n  ASCII_SIZE = 256\r\n  ctr = [0] * ASCII_SIZE\r\n  max = -1\r\n  ch = ''\r\n  for i in str1:\r\n    ctr[ord(i)]+=1;\r\n  for i in str1:\r\n    if max < ctr[ord(i)]:\r\n      max = ctr[ord(i)]\r\n      ch = i\r\n  return ch", "test_list": ["assert get_max_occuring_char(\"data\") == \"a\"", "assert get_max_occuring_char(\"create\") == \"e\"", "assert get_max_occuring_char(\"brilliant girl\") == \"i\""], "context": "Write a python function to find the maximum occurring character in a given string.", "function_name": "def get_max_occuring_char(str1):", "gold_generation": "ASCII_SIZE = 256\r\n  ctr = [0] * ASCII_SIZE\r\n  max = -1\r\n  ch = ''\r\n  for i in str1:\r\n    ctr[ord(i)]+=1;\r\n  for i in str1:\r\n    if max < ctr[ord(i)]:\r\n      max = ctr[ord(i)]\r\n      ch = i\r\n  return ch", "ctxs": [{"id": "41686", "text": "Function: numpy.reference.generated.numpy.char.chararray.rfind\nSnippet: numpy.char.chararray.rfind method char.chararray.rfind(sub, start=0, end=None)[source] For each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. See also char.rfind", "score": "0.69983196"}, {"id": "41808", "text": "Function: numpy.reference.generated.numpy.chararray.rfind\nSnippet: numpy.chararray.rfind method chararray.rfind(sub, start=0, end=None)[source] For each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. See also char.rfind", "score": "0.69260734"}, {"id": "24371", "text": "Function: python.library.stdtypes#str.rfind\nSnippet: str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.", "score": "0.6865911"}, {"id": "23421", "text": "Function: python.library.reprlib#reprlib.Repr.maxstring\nSnippet: Repr.maxstring Limit on the number of characters in the representation of the string. Note that the “normal” representation of the string is used as the character source: if escape sequences are needed in the representation, these may be mangled when the representation is shortened. The default is 30.", "score": "0.6848149"}, {"id": "41748", "text": "Function: numpy.reference.generated.numpy.char.rfind\nSnippet: numpy.char.rfind char.rfind(a, sub, start=0, end=None)[source] For each element in a, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. Calls str.rfind element-wise. Parameters aarray-like of str or unicode substr or unicode start, endint, optional Optional arguments start and end are interpreted as in slice notation. Returns outndarray Output array of ints. Return -1 on failure. See also str.rfind", "score": "0.6837944"}]}
{"task_id": "mbpp_481", "code": "def is_subset_sum(set, n, sum):\r\n\tif (sum == 0):\r\n\t\treturn True\r\n\tif (n == 0):\r\n\t\treturn False\r\n\tif (set[n - 1] > sum):\r\n\t\treturn is_subset_sum(set, n - 1, sum)\r\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "test_list": ["assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 9) == True", "assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 30) == False", "assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 15) == True"], "context": "Write a function to determine if there is a subset of the given set with sum equal to the given sum.", "function_name": "def is_subset_sum(set, n, sum):", "gold_generation": "if (sum == 0):\r\n\t\treturn True\r\n\tif (n == 0):\r\n\t\treturn False\r\n\tif (set[n - 1] > sum):\r\n\t\treturn is_subset_sum(set, n - 1, sum)\r\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])", "ctxs": [{"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.6908492"}, {"id": "20225", "text": "Function: python.library.stdtypes#frozenset.issubset\nSnippet: issubset(other) set <= other Test whether every element in the set is in other.", "score": "0.6858961"}, {"id": "20226", "text": "Function: python.library.stdtypes#frozenset.issuperset\nSnippet: issuperset(other) set >= other Test whether every element in other is in the set.", "score": "0.6808697"}, {"id": "20229", "text": "Function: python.library.stdtypes#frozenset.symmetric_difference\nSnippet: symmetric_difference(other) set ^ other Return a new set with elements in either the set or other but not both.", "score": "0.64411163"}, {"id": "23563", "text": "Function: python.library.stdtypes#set\nSnippet: class set([iterable]) class frozenset([iterable]) Return a new set or frozenset object whose elements are taken from iterable. The elements of a set must be hashable. To represent sets of sets, the inner sets must be frozenset objects. If iterable is not specified, a new empty set is returned. Sets can be created by several means: Use a comma-separated list of elements within braces: {'jack', 'sjoerd'} Use a set comprehension: {c for c in 'abracadabra' if c not in 'abc'} Use the type constructor: set(), set('foobar'), set(['a', 'b', 'foo']) Instances of set and frozenset provide the following operations: len(s) Return the number of elements in set s (cardinality of s). x in s Test x for membership in s. x not in s Test x for non-membership in s. isdisjoint(other) Return True if the set has no elements in common with other. Sets are disjoint if and only if their intersection is the empty set. issubset(other) set <= other Test whether every element in the set is in other. set < other Test whether the set is a proper subset of other, that is, set <= other and set != other. issuperset(other) set >= other Test whether every element in other is in the set. set > other Test whether the set is a proper superset of other, that is, set >= other and set != other. union(*others) set | other | ... Return a new set with elements from the set and all others. intersection(*others) set & other & ... Return a new set with elements common to the set and all others. difference(*others) set - other - ... Return a new set with elements in the set that are not in the others. symmetric_difference(other) set ^ other Return a new set with elements in either the set or other but not both. copy() Return a shallow copy of the set. Note, the non-operator versions of union(), intersection(), difference(), and symmetric_difference(), issubset(), and issuperset() methods will accept any iterable as an argument. In contrast, their operator based counterparts require their arguments to be sets. This precludes error-prone constructions like set('abc') & 'cbs' in favor of the more readable set('abc').intersection('cbs'). Both set and frozenset support set to set comparisons. Two sets are equal if and only if every element of each set is contained in the other (each is a subset of the other). A set is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal", "score": "0.63780034"}]}
{"task_id": "mbpp_482", "code": "import re \r\ndef match(text): \r\n\t\tpattern = '[A-Z]+[a-z]+$'\r\n\t\tif re.search(pattern, text): \r\n\t\t\t\treturn('Yes') \r\n\t\telse: \r\n\t\t\t\treturn('No') ", "test_list": ["assert match(\"Geeks\") == 'Yes'", "assert match(\"geeksforGeeks\") == 'Yes'", "assert match(\"geeks\") == 'No'"], "context": "Write a function to find sequences of one upper case letter followed by lower case letters in the given string by using regex.", "function_name": "import re \r\ndef match(text):", "gold_generation": "pattern = '[A-Z]+[a-z]+$'\r\n\t\tif re.search(pattern, text): \r\n\t\t\t\treturn('Yes') \r\n\t\telse: \r\n\t\t\t\treturn('No')", "ctxs": [{"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.68965304"}, {"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.6877137"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.6842253"}, {"id": "24361", "text": "Function: python.library.stdtypes#str.isupper\nSnippet: str.isupper() Return True if all cased characters 4 in the string are uppercase and there is at least one cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False", "score": "0.68398464"}, {"id": "25742", "text": "Function: python.library.stdtypes\nSnippet: Strings also support two styles of string formatting, one providing a large degree of flexibility and customization (see str.format(), Format String Syntax and Custom String Formatting) and the other based on C printf style formatting that handles a narrower range of types and is slightly harder to use correctly, but is often faster for the cases it can handle (printf-style String Formatting). The Text Processing Services section of the standard library covers a number of other modules that provide various text related utilities (including regular expression support in the re module). str.capitalize() Return a copy of the string with its first character capitalized and the rest lowercased. Changed in version 3.8: The first character is now put into titlecase rather than uppercase. This means that characters like digraphs will only have their first letter capitalized, instead of the full character. str.casefold() Return a casefolded copy of the string. Casefolded strings may be used for caseless matching. Casefolding is similar to lowercasing but more aggressive because it is intended to remove all case distinctions in a string. For example, the German lowercase letter 'ß' is equivalent to \"ss\". Since it is already lowercase, lower() would do nothing to 'ß'; casefold() converts it to \"ss\". The casefolding algorithm is described in section 3.13 of the Unicode Standard. New in version 3.3. str.center(width[, fillchar]) Return centered in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. str.encode(encoding=\"utf-8\", errors=\"strict\") Return an encoded version of the string as a bytes object. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other possible values are 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and any other name registered via codecs.register_error(), see section Error Handlers. For a list of possible encodings, see section Standard Encodings. By default, the errors argument is not checked for best performances, but only used at the first encoding error. Enable the Python Development Mode, or use a debug build to check errors. Changed in version 3.1: Support for keyword arguments added. Changed in version 3.9: The errors is now checked in development mode and in debug mode. str.endswith(suffix[, start[, end]]) Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. str.expandtabs(tabsize=8) Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. Tab positions occur every tabsize characters (default is 8, giving tab positions at columns 0, 8, 16 and so", "score": "0.6836207"}]}
{"task_id": "mbpp_483", "code": "def first_Factorial_Divisible_Number(x): \r\n    i = 1;\r\n    fact = 1; \r\n    for i in range(1,x): \r\n        fact = fact * i \r\n        if (fact % x == 0): \r\n            break\r\n    return i ", "test_list": ["assert first_Factorial_Divisible_Number(10) == 5", "assert first_Factorial_Divisible_Number(15) == 5", "assert first_Factorial_Divisible_Number(5) == 4"], "context": "Write a python function to find the first natural number whose factorial is divisible by x.", "function_name": "def first_Factorial_Divisible_Number(x):", "gold_generation": "i = 1;\r\n    fact = 1; \r\n    for i in range(1,x): \r\n        fact = fact * i \r\n        if (fact % x == 0): \r\n            break\r\n    return i", "ctxs": [{"id": "21799", "text": "Function: python.library.math#math.factorial\nSnippet: math.factorial(x) Return x factorial as an integer. Raises ValueError if x is not integral or is negative. Deprecated since version 3.9: Accepting floats with integral values (like 5.0) is deprecated.", "score": "0.7142391"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.69493175"}, {"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.6829686"}, {"id": "22280", "text": "Function: python.library.numbers#numbers.Rational.denominator\nSnippet: denominator Abstract.", "score": "0.67609096"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6702028"}]}
{"task_id": "mbpp_484", "code": "def remove_matching_tuple(test_list1, test_list2):\r\n  res = [sub for sub in test_list1 if sub not in test_list2]\r\n  return (res) ", "test_list": ["assert remove_matching_tuple([('Hello', 'dude'), ('How', 'are'), ('you', '?')], [('Hello', 'dude'), ('How', 'are')]) == [('you', '?')]", "assert remove_matching_tuple([('Part', 'of'), ('the', 'journey'), ('is ', 'end')], [('Journey', 'the'), ('is', 'end')]) == [('Part', 'of'), ('the', 'journey'), ('is ', 'end')]", "assert remove_matching_tuple([('Its', 'been'), ('a', 'long'), ('day', 'without')], [('a', 'long'), ('my', 'friend')]) == [('Its', 'been'), ('day', 'without')]"], "context": "Write a function to remove the matching tuples from the given two tuples.", "function_name": "def remove_matching_tuple(test_list1, test_list2):", "gold_generation": "res = [sub for sub in test_list1 if sub not in test_list2]\r\n  return (res)", "ctxs": [{"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.65242255"}, {"id": "18674", "text": "Function: python.library.collections#collections.deque.remove\nSnippet: remove(value) Remove the first occurrence of value. If not found, raises a ValueError.", "score": "0.6521396"}, {"id": "25738", "text": "Function: python.library.stdtypes\nSnippet: from s (2) s.remove(x) remove the first item from s where s[i] is equal to x (3) s.reverse() reverses the items of s in place (4) Notes: t must have the same length as the slice it is replacing. The optional argument i defaults to -1, so that by default the last item is removed and returned. remove() raises ValueError when x is not found in s. The reverse() method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence. clear() and copy() are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as dict and set). copy() is not part of the collections.abc.MutableSequence ABC, but most concrete mutable sequence classes provide it. New in version 3.3: clear() and copy() methods. The value n is an integer, or an object implementing __index__(). Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for s * n under Common Sequence Operations. Lists Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). class list([iterable]) Lists may be constructed in several ways: Using a pair of square brackets to denote the empty list: [] Using square brackets, separating items with commas: [a], [a, b, c] Using a list comprehension: [x for x in iterable] Using the type constructor: list() or list(iterable) The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to iterable[:]. For example, list('abc') returns ['a', 'b', 'c'] and list( (1, 2, 3) ) returns [1, 2, 3]. If no argument is given, the constructor creates a new empty list, []. Many other operations also produce lists, including the sorted() built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is", "score": "0.64703065"}, {"id": "23564", "text": "Function: python.library.stdtypes#set\nSnippet: and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem.", "score": "0.6459706"}, {"id": "19611", "text": "Function: python.library.stdtypes#dict.clear\nSnippet: clear() Remove all items from the dictionary.", "score": "0.6418978"}]}
{"task_id": "mbpp_485", "code": "def is_palindrome(n) : \r\n\tdivisor = 1\r\n\twhile (n / divisor >= 10) : \r\n\t\tdivisor *= 10\r\n\twhile (n != 0) : \r\n\t\tleading = n // divisor \r\n\t\ttrailing = n % 10\r\n\t\tif (leading != trailing) : \r\n\t\t\treturn False\r\n\t\tn = (n % divisor) // 10\r\n\t\tdivisor = divisor // 100\r\n\treturn True\r\ndef largest_palindrome(A, n) : \r\n\tA.sort() \r\n\tfor i in range(n - 1, -1, -1) : \r\n\t\tif (is_palindrome(A[i])) : \r\n\t\t\treturn A[i] \r\n\treturn -1", "test_list": ["assert largest_palindrome([1, 232, 54545, 999991], 4) == 54545", "assert largest_palindrome([1, 2, 3, 4, 5, 50], 6) == 5", "assert largest_palindrome([1, 3, 7, 9, 45], 5)  == 9"], "context": "Write a function to find the largest palindromic number in the given array.", "function_name": "def is_palindrome(n) :", "gold_generation": "divisor = 1\r\n\twhile (n / divisor >= 10) : \r\n\t\tdivisor *= 10\r\n\twhile (n != 0) : \r\n\t\tleading = n // divisor \r\n\t\ttrailing = n % 10\r\n\t\tif (leading != trailing) : \r\n\t\t\treturn False\r\n\t\tn = (n % divisor) // 10\r\n\t\tdivisor = divisor // 100\r\n\treturn True\r\ndef largest_palindrome(A, n) : \r\n\tA.sort() \r\n\tfor i in range(n - 1, -1, -1) : \r\n\t\tif (is_palindrome(A[i])) : \r\n\t\t\treturn A[i] \r\n\treturn -1", "ctxs": [{"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6690503"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6677505"}, {"id": "42691", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: same data with a new shape. resize(new_shape[, refcheck]) Change shape and size of array in-place. rfind(sub[, start, end]) For each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. rindex(sub[, start, end]) Like rfind, but raises ValueError when the substring sub is not found. rjust(width[, fillchar]) Return an array with the elements of self right-justified in a string of length width. rsplit([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. rstrip([chars]) For each element in self, return a copy with the trailing characters removed. searchsorted(v[, side, sorter]) Find indices where elements of v should be inserted in a to maintain order. setfield(val, dtype[, offset]) Put a value into a specified place in a field defined by a data-type. setflags([write, align, uic]) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. sort([axis, kind, order]) Sort an array in-place. split([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. splitlines([keepends]) For each element in self, return a list of the lines in the element, breaking at line boundaries. squeeze([axis]) Remove axes of length one from a. startswith(prefix[, start, end]) Returns a boolean array which is True where the string element in self starts with prefix, otherwise False. strip([chars]) For each element in self, return a copy with the leading and trailing characters removed. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. swapcase() For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. title() For each element in self, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. translate(table[, deletechars]) For each element in self, return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table. transpose(*axes) Returns a view of the array with axes transposed. upper() Return an array with the elements of self converted to uppercase. view([dtype][, type]) New view of array with the same data. zfill(width) Return the numeric string left-filled with zeros in a string of length width.", "score": "0.65527"}, {"id": "42688", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: same data with a new shape. resize(new_shape[, refcheck]) Change shape and size of array in-place. rfind(sub[, start, end]) For each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. rindex(sub[, start, end]) Like rfind, but raises ValueError when the substring sub is not found. rjust(width[, fillchar]) Return an array with the elements of self right-justified in a string of length width. rsplit([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. rstrip([chars]) For each element in self, return a copy with the trailing characters removed. searchsorted(v[, side, sorter]) Find indices where elements of v should be inserted in a to maintain order. setfield(val, dtype[, offset]) Put a value into a specified place in a field defined by a data-type. setflags([write, align, uic]) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. sort([axis, kind, order]) Sort an array in-place. split([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. splitlines([keepends]) For each element in self, return a list of the lines in the element, breaking at line boundaries. squeeze([axis]) Remove axes of length one from a. startswith(prefix[, start, end]) Returns a boolean array which is True where the string element in self starts with prefix, otherwise False. strip([chars]) For each element in self, return a copy with the leading and trailing characters removed. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. swapcase() For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. title() For each element in self, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. translate(table[, deletechars]) For each element in self, return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table. transpose(*axes) Returns a view of the array with axes transposed. upper() Return an array with the elements of self converted to uppercase. view([dtype][, type]) New view of array with the same data. zfill(width) Return the numeric string left-filled with zeros in a string of length width.", "score": "0.6548879"}, {"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.6536513"}]}
{"task_id": "mbpp_486", "code": "def nCr(n, r): \r\n\tif (r > n / 2): \r\n\t\tr = n - r \r\n\tanswer = 1 \r\n\tfor i in range(1, r + 1): \r\n\t\tanswer *= (n - r + i) \r\n\t\tanswer /= i \r\n\treturn answer \r\ndef binomial_probability(n, k, p): \r\n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ", "test_list": ["assert binomial_probability(10, 5, 1.0/3) == 0.13656454808718185", "assert binomial_probability(11, 6, 2.0/4) == 0.2255859375", "assert binomial_probability(12, 7, 3.0/5) == 0.227030335488"], "context": "Write a function to compute binomial probability for the given number.", "function_name": "def nCr(n, r):", "gold_generation": "if (r > n / 2): \r\n\t\tr = n - r \r\n\tanswer = 1 \r\n\tfor i in range(1, r + 1): \r\n\t\tanswer *= (n - r + i) \r\n\t\tanswer /= i \r\n\treturn answer \r\ndef binomial_probability(n, k, p): \r\n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k))", "ctxs": [{"id": "43752", "text": "Function: numpy.reference.random.generated.numpy.random.randomstate.binomial\nSnippet: numpy.random.RandomState.binomial method random.RandomState.binomial(n, p, size=None) Draw samples from a binomial distribution. Samples are drawn from a binomial distribution with specified parameters, n trials and p probability of success where n an integer >= 0 and p is in the interval [0,1]. (n may be input as a float, but it is truncated to an integer in use) Note New code should use the binomial method of a default_rng() instance instead; please see the Quick Start. Parameters nint or array_like of ints Parameter of the distribution, >= 0. Floats are also accepted, but they will be truncated to integers. pfloat or array_like of floats Parameter of the distribution, >= 0 and <=1. sizeint or tuple of ints, optional Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn. Returns outndarray or scalar Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials. See also scipy.stats.binom probability density function, distribution or cumulative density function, etc. Generator.binomial which should be used for new code. Notes The probability density for the binomial distribution is \\[P(N) = \\binom{n}{N}p^N(1-p)^{n-N},\\] where \\(n\\) is the number of trials, \\(p\\) is the probability of success, and \\(N\\) is the number of successes. When estimating the standard error of a proportion in a population by using a random sample, the normal distribution works well unless the product p*n <=5, where p = population proportion estimate, and n = number of samples, in which case the binomial distribution is used instead. For example, a sample of 15 people shows 4 who are left handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4, so the binomial distribution should be used in this case. References 1 Dalgaard, Peter, “Introductory Statistics with R”, Springer-Verlag, 2002. 2 Glantz, Stanton A. “Primer of Biostatistics.”, McGraw-Hill, Fifth Edition, 2002. 3 Lentner, Marvin, “Elementary Applied Statistics”, Bogden and Quigley, 1972. 4 Weisstein, Eric W. “Binomial Distribution.” From MathWorld–A Wolfram Web Resource. http://mathworld.wolfram.com/BinomialDistribution.html 5 Wikipedia, “Binomial distribution”, https://en.wikipedia.org/wiki/Binomial_distribution Examples Draw samples from the distribution: >>> n, p = 10, .5 # number of trials, probability of each trial >>> s = np.random.binomial(n, p, 1000) # result of flipping a coin 10 times, tested 1000 times. A real world example. A company drills 9 wild-cat oil exploration wells, each with an estimated probability of success of 0.1. All nine wells fail. What is the probability of that happening? Let’s do 20,000 trials of the model, and count the number that generate zero positive results. >>> sum(np.random.binomial(9, 0.1, 20000) == 0)/20000. # answer = 0.38885, or 38%.", "score": "0.7181368"}, {"id": "43644", "text": "Function: numpy.reference.random.generated.numpy.random.binomial\nSnippet: numpy.random.binomial random.binomial(n, p, size=None) Draw samples from a binomial distribution. Samples are drawn from a binomial distribution with specified parameters, n trials and p probability of success where n an integer >= 0 and p is in the interval [0,1]. (n may be input as a float, but it is truncated to an integer in use) Note New code should use the binomial method of a default_rng() instance instead; please see the Quick Start. Parameters nint or array_like of ints Parameter of the distribution, >= 0. Floats are also accepted, but they will be truncated to integers. pfloat or array_like of floats Parameter of the distribution, >= 0 and <=1. sizeint or tuple of ints, optional Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn. Returns outndarray or scalar Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials. See also scipy.stats.binom probability density function, distribution or cumulative density function, etc. Generator.binomial which should be used for new code. Notes The probability density for the binomial distribution is \\[P(N) = \\binom{n}{N}p^N(1-p)^{n-N},\\] where \\(n\\) is the number of trials, \\(p\\) is the probability of success, and \\(N\\) is the number of successes. When estimating the standard error of a proportion in a population by using a random sample, the normal distribution works well unless the product p*n <=5, where p = population proportion estimate, and n = number of samples, in which case the binomial distribution is used instead. For example, a sample of 15 people shows 4 who are left handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4, so the binomial distribution should be used in this case. References 1 Dalgaard, Peter, “Introductory Statistics with R”, Springer-Verlag, 2002. 2 Glantz, Stanton A. “Primer of Biostatistics.”, McGraw-Hill, Fifth Edition, 2002. 3 Lentner, Marvin, “Elementary Applied Statistics”, Bogden and Quigley, 1972. 4 Weisstein, Eric W. “Binomial Distribution.” From MathWorld–A Wolfram Web Resource. http://mathworld.wolfram.com/BinomialDistribution.html 5 Wikipedia, “Binomial distribution”, https://en.wikipedia.org/wiki/Binomial_distribution Examples Draw samples from the distribution: >>> n, p = 10, .5 # number of trials, probability of each trial >>> s = np.random.binomial(n, p, 1000) # result of flipping a coin 10 times, tested 1000 times. A real world example. A company drills 9 wild-cat oil exploration wells, each with an estimated probability of success of 0.1. All nine wells fail. What is the probability of that happening? Let’s do 20,000 trials of the model, and count the number that generate zero positive results. >>> sum(np.random.binomial(9, 0.1, 20000) == 0)/20000. # answer = 0.38885, or 38%.", "score": "0.71018803"}, {"id": "43655", "text": "Function: numpy.reference.random.generated.numpy.random.generator.binomial\nSnippet: numpy.random.Generator.binomial method random.Generator.binomial(n, p, size=None) Draw samples from a binomial distribution. Samples are drawn from a binomial distribution with specified parameters, n trials and p probability of success where n an integer >= 0 and p is in the interval [0,1]. (n may be input as a float, but it is truncated to an integer in use) Parameters nint or array_like of ints Parameter of the distribution, >= 0. Floats are also accepted, but they will be truncated to integers. pfloat or array_like of floats Parameter of the distribution, >= 0 and <=1. sizeint or tuple of ints, optional Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn. Returns outndarray or scalar Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials. See also scipy.stats.binom probability density function, distribution or cumulative density function, etc. Notes The probability density for the binomial distribution is \\[P(N) = \\binom{n}{N}p^N(1-p)^{n-N},\\] where \\(n\\) is the number of trials, \\(p\\) is the probability of success, and \\(N\\) is the number of successes. When estimating the standard error of a proportion in a population by using a random sample, the normal distribution works well unless the product p*n <=5, where p = population proportion estimate, and n = number of samples, in which case the binomial distribution is used instead. For example, a sample of 15 people shows 4 who are left handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4, so the binomial distribution should be used in this case. References 1 Dalgaard, Peter, “Introductory Statistics with R”, Springer-Verlag, 2002. 2 Glantz, Stanton A. “Primer of Biostatistics.”, McGraw-Hill, Fifth Edition, 2002. 3 Lentner, Marvin, “Elementary Applied Statistics”, Bogden and Quigley, 1972. 4 Weisstein, Eric W. “Binomial Distribution.” From MathWorld–A Wolfram Web Resource. http://mathworld.wolfram.com/BinomialDistribution.html 5 Wikipedia, “Binomial distribution”, https://en.wikipedia.org/wiki/Binomial_distribution Examples Draw samples from the distribution: >>> rng = np.random.default_rng() >>> n, p = 10, .5 # number of trials, probability of each trial >>> s = rng.binomial(n, p, 1000) # result of flipping a coin 10 times, tested 1000 times. A real world example. A company drills 9 wild-cat oil exploration wells, each with an estimated probability of success of 0.1. All nine wells fail. What is the probability of that happening? Let’s do 20,000 trials of the model, and count the number that generate zero positive results. >>> sum(rng.binomial(9, 0.1, 20000) == 0)/20000. # answer = 0.38885, or 39%.", "score": "0.7039311"}, {"id": "5949", "text": "Function: torch.distributions#torch.distributions.binomial.Binomial.log_prob\nSnippet: log_prob(value) [source]", "score": "0.69067276"}, {"id": "43722", "text": "Function: numpy.reference.random.generated.numpy.random.negative_binomial\nSnippet: numpy.random.negative_binomial random.negative_binomial(n, p, size=None) Draw samples from a negative binomial distribution. Samples are drawn from a negative binomial distribution with specified parameters, n successes and p probability of success where n is > 0 and p is in the interval [0, 1]. Note New code should use the negative_binomial method of a default_rng() instance instead; please see the Quick Start. Parameters nfloat or array_like of floats Parameter of the distribution, > 0. pfloat or array_like of floats Parameter of the distribution, >= 0 and <=1. sizeint or tuple of ints, optional Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn. Returns outndarray or scalar Drawn samples from the parameterized negative binomial distribution, where each sample is equal to N, the number of failures that occurred before a total of n successes was reached. See also Generator.negative_binomial which should be used for new code. Notes The probability mass function of the negative binomial distribution is \\[P(N;n,p) = \\frac{\\Gamma(N+n)}{N!\\Gamma(n)}p^{n}(1-p)^{N},\\] where \\(n\\) is the number of successes, \\(p\\) is the probability of success, \\(N+n\\) is the number of trials, and \\(\\Gamma\\) is the gamma function. When \\(n\\) is an integer, \\(\\frac{\\Gamma(N+n)}{N!\\Gamma(n)} = \\binom{N+n-1}{N}\\), which is the more common form of this term in the the pmf. The negative binomial distribution gives the probability of N failures given n successes, with a success on the last trial. If one throws a die repeatedly until the third time a “1” appears, then the probability distribution of the number of non-“1”s that appear before the third “1” is a negative binomial distribution. References 1 Weisstein, Eric W. “Negative Binomial Distribution.” From MathWorld–A Wolfram Web Resource. http://mathworld.wolfram.com/NegativeBinomialDistribution.html 2 Wikipedia, “Negative binomial distribution”, https://en.wikipedia.org/wiki/Negative_binomial_distribution Examples Draw samples from the distribution: A real world example. A company drills wild-cat oil exploration wells, each with an estimated probability of success of 0.1. What is the probability of having one success for each successive well, that is what is the probability of a single success after drilling 5 wells, after 6 wells, etc.? >>> s = np.random.negative_binomial(1, 0.1, 100000) >>> for i in range(1, 11): ... probability = sum(s<i) / 100000. ... print(i, \"wells drilled, probability of one success =\", probability)", "score": "0.6873139"}]}
{"task_id": "mbpp_487", "code": "def sort_tuple(tup): \r\n\tlst = len(tup) \r\n\tfor i in range(0, lst): \r\n\t\tfor j in range(0, lst-i-1): \r\n\t\t\tif (tup[j][-1] > tup[j + 1][-1]): \r\n\t\t\t\ttemp = tup[j] \r\n\t\t\t\ttup[j]= tup[j + 1] \r\n\t\t\t\ttup[j + 1]= temp \r\n\treturn tup", "test_list": ["assert sort_tuple([(1, 3), (3, 2), (2, 1)] ) == [(2, 1), (3, 2), (1, 3)]", "assert sort_tuple([(2, 4), (3, 3), (1, 1)] ) == [(1, 1), (3, 3), (2, 4)]", "assert sort_tuple([(3, 9), (6, 7), (4, 3)] ) == [(4, 3), (6, 7), (3, 9)]"], "context": "Write a function to sort a list of tuples in increasing order by the last element in each tuple.", "function_name": "def sort_tuple(tup):", "gold_generation": "lst = len(tup) \r\n\tfor i in range(0, lst): \r\n\t\tfor j in range(0, lst-i-1): \r\n\t\t\tif (tup[j][-1] > tup[j + 1][-1]): \r\n\t\t\t\ttemp = tup[j] \r\n\t\t\t\ttup[j]= tup[j + 1] \r\n\t\t\t\ttup[j + 1]= temp \r\n\treturn tup", "ctxs": [{"id": "25739", "text": "Function: python.library.stdtypes\nSnippet: a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort. Tuples Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a set or dict instance). class tuple([iterable]) Tuples may be constructed in a number of ways: Using a pair of parentheses to denote the empty tuple: () Using a trailing comma for a singleton tuple: a, or (a,) Separating items with commas: a, b, c or (a, b, c) Using the tuple() built-in: tuple() or tuple(iterable) The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, tuple('abc') returns ('a', 'b', 'c') and tuple( [1, 2, 3] ) returns (1, 2, 3). If no argument is given, the constructor creates a new empty tuple, (). Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, f(a, b, c) is a function call with three arguments, while f((a, b, c)) is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, collections.namedtuple() may be a more appropriate choice than a simple tuple object. Ranges The range type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops. class range(stop) class range(start, stop[, step]) The arguments to the range constructor must be integers (either built-in int or any object that implements the __index__ special method). If the step argument is omitted, it defaults to 1. If the start argument is", "score": "0.69763803"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.68501914"}, {"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.68207204"}, {"id": "20478", "text": "Function: python.library.heapq\nSnippet: key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters. heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n]. heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n]. The latter two functions perform best for smaller values of n. For larger values, it is more efficient to use the sorted() function. Also, when n==1, it is more efficient to use the built-in min() and max() functions. If repeated usage of these functions is required, consider turning the iterable into an actual heap. Basic Examples A heapsort can be implemented by pushing all values onto a heap and then popping off the smallest values one at a time: >>> def heapsort(iterable): ... h = [] ... for value in iterable: ... heappush(h, value) ... return [heappop(h) for i in range(len(h))] ... >>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] This is similar to sorted(iterable), but unlike sorted(), this implementation is not stable. Heap elements can be tuples. This is useful for assigning comparison values (such as task priorities) alongside the main record being tracked: >>> h = [] >>> heappush(h, (5, 'write code')) >>> heappush(h, (7, 'release product')) >>> heappush(h, (1, 'write spec')) >>> heappush(h, (3, 'create tests')) >>> heappop(h) (1, 'write spec') Priority Queue Implementation Notes A priority queue is common use for a heap, and it presents several implementation challenges: Sort stability: how do you get two tasks with equal priorities to be returned in the order they were originally added? Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order. If the priority of a task changes, how do you move it to a new position in the heap? Or if a pending task needs to be deleted, how do you find it and remove it from the queue? A solution to the first two challenges is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were", "score": "0.6812453"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.6803636"}]}
{"task_id": "mbpp_488", "code": "import math\r\ndef area_pentagon(a):\r\n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\r\n  return area", "test_list": ["assert area_pentagon(5)==43.01193501472417", "assert area_pentagon(10)==172.0477400588967", "assert area_pentagon(15)==387.10741513251753"], "context": "Write a function to find the area of a pentagon.", "function_name": "import math\r\ndef area_pentagon(a):", "gold_generation": "area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\r\n  return area", "ctxs": [{"id": "14476", "text": "Function: pandas.reference.api.pandas.dataframe.rpow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6507075"}, {"id": "14410", "text": "Function: pandas.reference.api.pandas.dataframe.multiply\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6396223"}, {"id": "14507", "text": "Function: pandas.reference.api.pandas.dataframe.sub\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6359852"}, {"id": "14447", "text": "Function: pandas.reference.api.pandas.dataframe.radd\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.63494664"}, {"id": "14467", "text": "Function: pandas.reference.api.pandas.dataframe.rfloordiv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6346267"}]}
{"task_id": "mbpp_489", "code": "def frequency_Of_Largest(n,arr): \r\n    mn = arr[0] \r\n    freq = 1\r\n    for i in range(1,n): \r\n        if (arr[i] >mn): \r\n            mn = arr[i] \r\n            freq = 1\r\n        elif (arr[i] == mn): \r\n            freq += 1\r\n    return freq ", "test_list": ["assert frequency_Of_Largest(5,[1,2,3,4,4]) == 2", "assert frequency_Of_Largest(3,[5,6,5]) == 1", "assert frequency_Of_Largest(4,[2,7,7,7]) == 3"], "context": "Write a python function to find the frequency of the largest value in a given array.", "function_name": "def frequency_Of_Largest(n,arr):", "gold_generation": "mn = arr[0] \r\n    freq = 1\r\n    for i in range(1,n): \r\n        if (arr[i] >mn): \r\n            mn = arr[i] \r\n            freq = 1\r\n        elif (arr[i] == mn): \r\n            freq += 1\r\n    return freq", "ctxs": [{"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.69364053"}, {"id": "17632", "text": "Function: python.library.array#array.array.count\nSnippet: array.count(x) Return the number of occurrences of x in the array.", "score": "0.6841265"}, {"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.6806789"}, {"id": "23654", "text": "Function: python.library.signal#signal.NSIG\nSnippet: signal.NSIG One more than the number of the highest signal number.", "score": "0.6778444"}, {"id": "15240", "text": "Function: pandas.reference.api.pandas.series.nlargest\nSnippet: pandas.Series.nlargest Series.nlargest(n=5, keep='first')[source] Return the largest n elements. Parameters n:int, default 5 Return this many descending sorted values. keep:{‘first’, ‘last’, ‘all’}, default ‘first’ When there are duplicate values that cannot all fit in a Series of n elements: first : return the first n occurrences in order of appearance. last : return the last n occurrences in reverse order of appearance. all : keep all occurrences. This can result in a Series of size larger than n. Returns Series The n largest values in the Series, sorted in decreasing order. See also Series.nsmallest Get the n smallest elements. Series.sort_values Sort Series by values. Series.head Return the first n rows. Notes Faster than .sort_values(ascending=False).head(n) for small n relative to the size of the Series object. Examples >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000, ... \"Malta\": 434000, \"Maldives\": 434000, ... \"Brunei\": 434000, \"Iceland\": 337000, ... \"Nauru\": 11300, \"Tuvalu\": 11300, ... \"Anguilla\": 11300, \"Montserrat\": 5200} >>> s = pd.Series(countries_population) >>> s Italy 59000000 France 65000000 Malta 434000 Maldives 434000 Brunei 434000 Iceland 337000 Nauru 11300 Tuvalu 11300 Anguilla 11300 Montserrat 5200 dtype: int64 The n largest elements where n=5 by default. >>> s.nlargest() France 65000000 Italy 59000000 Malta 434000 Maldives 434000 Brunei 434000 dtype: int64 The n largest elements where n=3. Default keep value is ‘first’ so Malta will be kept. >>> s.nlargest(3) France 65000000 Italy 59000000 Malta 434000 dtype: int64 The n largest elements where n=3 and keeping the last duplicates. Brunei will be kept since it is the last with value 434000 based on the index order. >>> s.nlargest(3, keep='last') France 65000000 Italy 59000000 Brunei 434000 dtype: int64 The n largest elements where n=3 with all duplicates kept. Note that the returned Series has five elements due to the three duplicates. >>> s.nlargest(3, keep='all') France 65000000 Italy 59000000 Malta 434000 Maldives 434000 Brunei 434000 dtype: int64", "score": "0.6769728"}]}
{"task_id": "mbpp_490", "code": "def extract_symmetric(test_list):\r\n  temp = set(test_list) & {(b, a) for a, b in test_list}\r\n  res = {(a, b) for a, b in temp if a < b}\r\n  return (res) ", "test_list": ["assert extract_symmetric([(6, 7), (2, 3), (7, 6), (9, 8), (10, 2), (8, 9)] ) == {(8, 9), (6, 7)}", "assert extract_symmetric([(7, 8), (3, 4), (8, 7), (10, 9), (11, 3), (9, 10)] ) == {(9, 10), (7, 8)}", "assert extract_symmetric([(8, 9), (4, 5), (9, 8), (11, 10), (12, 4), (10, 11)] ) == {(8, 9), (10, 11)}"], "context": "Write a function to extract all the pairs which are symmetric in the given tuple list.", "function_name": "def extract_symmetric(test_list):", "gold_generation": "temp = set(test_list) & {(b, a) for a, b in test_list}\r\n  res = {(a, b) for a, b in temp if a < b}\r\n  return (res)", "ctxs": [{"id": "20229", "text": "Function: python.library.stdtypes#frozenset.symmetric_difference\nSnippet: symmetric_difference(other) set ^ other Return a new set with elements in either the set or other but not both.", "score": "0.70003724"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.68240416"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.67364365"}, {"id": "19648", "text": "Function: python.library.difflib#difflib.SequenceMatcher.get_matching_blocks\nSnippet: get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]", "score": "0.67068946"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.6693164"}]}
{"task_id": "mbpp_491", "code": "import math\r\ndef sum_gp(a,n,r):\r\n total = (a * (1 - math.pow(r, n ))) / (1- r)\r\n return total", "test_list": ["assert sum_gp(1,5,2)==31", "assert sum_gp(1,5,4)==341", "assert sum_gp(2,6,3)==728"], "context": "Write a function to find the sum of geometric progression series.", "function_name": "import math\r\ndef sum_gp(a,n,r):", "gold_generation": "total = (a * (1 - math.pow(r, n ))) / (1- r)\r\n return total", "ctxs": [{"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.64113456"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6384644"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.63455224"}, {"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.63372535"}, {"id": "15379", "text": "Function: pandas.reference.api.pandas.series.sum\nSnippet: pandas.Series.sum Series.sum(axis=None, skipna=True, level=None, numeric_only=None, min_count=0, **kwargs)[source] Return the sum of the values over the requested axis. This is equivalent to the method numpy.sum. Parameters axis:{index (0)} Axis for the function to be applied on. skipna:bool, default True Exclude NA/null values when computing the result. level:int or level name, default None If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar. numeric_only:bool, default None Include only float, int, boolean columns. If None, will attempt to use everything, then use only numeric data. Not implemented for Series. min_count:int, default 0 The required number of valid values to perform the operation. If fewer than min_count non-NA values are present the result will be NA. **kwargs Additional keyword arguments to be passed to the function. Returns scalar or Series (if level specified) See also Series.sum Return the sum. Series.min Return the minimum. Series.max Return the maximum. Series.idxmin Return the index of the minimum. Series.idxmax Return the index of the maximum. DataFrame.sum Return the sum over the requested axis. DataFrame.min Return the minimum over the requested axis. DataFrame.max Return the maximum over the requested axis. DataFrame.idxmin Return the index of the minimum over the requested axis. DataFrame.idxmax Return the index of the maximum over the requested axis. Examples >>> idx = pd.MultiIndex.from_arrays([ ... ['warm', 'warm', 'cold', 'cold'], ... ['dog', 'falcon', 'fish', 'spider']], ... names=['blooded', 'animal']) >>> s = pd.Series([4, 2, 0, 8], name='legs', index=idx) >>> s blooded animal warm dog 4 falcon 2 cold fish 0 spider 8 Name: legs, dtype: int64 >>> s.sum() 14 By default, the sum of an empty or all-NA Series is 0. >>> pd.Series([], dtype=\"float64\").sum() # min_count=0 is the default 0.0 This can be controlled with the min_count parameter. For example, if you’d like the sum of an empty series to be NaN, pass min_count=1. >>> pd.Series([], dtype=\"float64\").sum(min_count=1) nan Thanks to the skipna parameter, min_count handles all-NA and empty series identically. >>> pd.Series([np.nan]).sum() 0.0 >>> pd.Series([np.nan]).sum(min_count=1) nan", "score": "0.62143165"}]}
{"task_id": "mbpp_492", "code": "def binary_search(item_list,item):\r\n\tfirst = 0\r\n\tlast = len(item_list)-1\r\n\tfound = False\r\n\twhile( first<=last and not found):\r\n\t\tmid = (first + last)//2\r\n\t\tif item_list[mid] == item :\r\n\t\t\tfound = True\r\n\t\telse:\r\n\t\t\tif item < item_list[mid]:\r\n\t\t\t\tlast = mid - 1\r\n\t\t\telse:\r\n\t\t\t\tfirst = mid + 1\t\r\n\treturn found", "test_list": ["assert binary_search([1,2,3,5,8], 6) == False", "assert binary_search([7, 8, 9, 10, 13], 10) == True", "assert binary_search([11, 13, 14, 19, 22, 36], 23) == False"], "context": "Write a function to search an element in the given array by using binary search.", "function_name": "def binary_search(item_list,item):", "gold_generation": "first = 0\r\n\tlast = len(item_list)-1\r\n\tfound = False\r\n\twhile( first<=last and not found):\r\n\t\tmid = (first + last)//2\r\n\t\tif item_list[mid] == item :\r\n\t\t\tfound = True\r\n\t\telse:\r\n\t\t\tif item < item_list[mid]:\r\n\t\t\t\tlast = mid - 1\r\n\t\t\telse:\r\n\t\t\t\tfirst = mid + 1\t\r\n\treturn found", "ctxs": [{"id": "41778", "text": "Function: numpy.reference.generated.numpy.chararray.find\nSnippet: numpy.chararray.find method chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.68335366"}, {"id": "41691", "text": "Function: numpy.reference.generated.numpy.char.chararray.searchsorted\nSnippet: numpy.char.chararray.searchsorted method char.chararray.searchsorted(v, side='left', sorter=None) Find indices where elements of v should be inserted in a to maintain order. For full documentation, see numpy.searchsorted See also numpy.searchsorted equivalent function", "score": "0.6833202"}, {"id": "41813", "text": "Function: numpy.reference.generated.numpy.chararray.searchsorted\nSnippet: numpy.chararray.searchsorted method chararray.searchsorted(v, side='left', sorter=None) Find indices where elements of v should be inserted in a to maintain order. For full documentation, see numpy.searchsorted See also numpy.searchsorted equivalent function", "score": "0.6825756"}, {"id": "41654", "text": "Function: numpy.reference.generated.numpy.char.chararray.find\nSnippet: numpy.char.chararray.find method char.chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.6816564"}, {"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.6807219"}]}
{"task_id": "mbpp_493", "code": "import math\r\ndef calculate_polygons(startx, starty, endx, endy, radius):\r\n    sl = (2 * radius) * math.tan(math.pi / 6)\r\n    p = sl * 0.5\r\n    b = sl * math.cos(math.radians(30))\r\n    w = b * 2\r\n    h = 2 * sl   \r\n    startx = startx - w\r\n    starty = starty - h\r\n    endx = endx + w\r\n    endy = endy + h\r\n    origx = startx\r\n    origy = starty\r\n    xoffset = b\r\n    yoffset = 3 * p\r\n    polygons = []\r\n    row = 1\r\n    counter = 0\r\n    while starty < endy:\r\n        if row % 2 == 0:\r\n            startx = origx + xoffset\r\n        else:\r\n            startx = origx\r\n        while startx < endx:\r\n            p1x = startx\r\n            p1y = starty + p\r\n            p2x = startx\r\n            p2y = starty + (3 * p)\r\n            p3x = startx + b\r\n            p3y = starty + h\r\n            p4x = startx + w\r\n            p4y = starty + (3 * p)\r\n            p5x = startx + w\r\n            p5y = starty + p\r\n            p6x = startx + b\r\n            p6y = starty\r\n            poly = [\r\n                (p1x, p1y),\r\n                (p2x, p2y),\r\n                (p3x, p3y),\r\n                (p4x, p4y),\r\n                (p5x, p5y),\r\n                (p6x, p6y),\r\n                (p1x, p1y)]\r\n            polygons.append(poly)\r\n            counter += 1\r\n            startx += w\r\n        starty += yoffset\r\n        row += 1\r\n    return polygons", "test_list": ["assert calculate_polygons(1,1, 4, 4, 3)==[[(-5.0, -4.196152422706632), (-5.0, -0.7320508075688767), (-2.0, 1.0), (1.0, -0.7320508075688767), (1.0, -4.196152422706632), (-2.0, -5.928203230275509), (-5.0, -4.196152422706632)], [(1.0, -4.196152422706632), (1.0, -0.7320508075688767), (4.0, 1.0), (7.0, -0.7320508075688767), (7.0, -4.196152422706632), (4.0, -5.928203230275509), (1.0, -4.196152422706632)], [(7.0, -4.196152422706632), (7.0, -0.7320508075688767), (10.0, 1.0), (13.0, -0.7320508075688767), (13.0, -4.196152422706632), (10.0, -5.928203230275509), (7.0, -4.196152422706632)], [(-2.0, 1.0000000000000004), (-2.0, 4.464101615137755), (1.0, 6.196152422706632), (4.0, 4.464101615137755), (4.0, 1.0000000000000004), (1.0, -0.7320508075688767), (-2.0, 1.0000000000000004)], [(4.0, 1.0000000000000004), (4.0, 4.464101615137755), (7.0, 6.196152422706632), (10.0, 4.464101615137755), (10.0, 1.0000000000000004), (7.0, -0.7320508075688767), (4.0, 1.0000000000000004)], [(-5.0, 6.196152422706632), (-5.0, 9.660254037844387), (-2.0, 11.392304845413264), (1.0, 9.660254037844387), (1.0, 6.196152422706632), (-2.0, 4.464101615137755), (-5.0, 6.196152422706632)], [(1.0, 6.196152422706632), (1.0, 9.660254037844387), (4.0, 11.392304845413264), (7.0, 9.660254037844387), (7.0, 6.196152422706632), (4.0, 4.464101615137755), (1.0, 6.196152422706632)], [(7.0, 6.196152422706632), (7.0, 9.660254037844387), (10.0, 11.392304845413264), (13.0, 9.660254037844387), (13.0, 6.196152422706632), (10.0, 4.464101615137755), (7.0, 6.196152422706632)], [(-2.0, 11.392304845413264), (-2.0, 14.85640646055102), (1.0, 16.588457268119896), (4.0, 14.85640646055102), (4.0, 11.392304845413264), (1.0, 9.660254037844387), (-2.0, 11.392304845413264)], [(4.0, 11.392304845413264), (4.0, 14.85640646055102), (7.0, 16.588457268119896), (10.0, 14.85640646055102), (10.0, 11.392304845413264), (7.0, 9.660254037844387), (4.0, 11.392304845413264)]]", "assert calculate_polygons(5,4,7,9,8)==[[(-11.0, -9.856406460551018), (-11.0, -0.6188021535170058), (-3.0, 4.0), (5.0, -0.6188021535170058), (5.0, -9.856406460551018), (-3.0, -14.475208614068023), (-11.0, -9.856406460551018)], [(5.0, -9.856406460551018), (5.0, -0.6188021535170058), (13.0, 4.0), (21.0, -0.6188021535170058), (21.0, -9.856406460551018), (13.0, -14.475208614068023), (5.0, -9.856406460551018)], [(21.0, -9.856406460551018), (21.0, -0.6188021535170058), (29.0, 4.0), (37.0, -0.6188021535170058), (37.0, -9.856406460551018), (29.0, -14.475208614068023), (21.0, -9.856406460551018)], [(-3.0, 4.0), (-3.0, 13.237604307034012), (5.0, 17.856406460551018), (13.0, 13.237604307034012), (13.0, 4.0), (5.0, -0.6188021535170058), (-3.0, 4.0)], [(13.0, 4.0), (13.0, 13.237604307034012), (21.0, 17.856406460551018), (29.0, 13.237604307034012), (29.0, 4.0), (21.0, -0.6188021535170058), (13.0, 4.0)], [(-11.0, 17.856406460551018), (-11.0, 27.09401076758503), (-3.0, 31.712812921102035), (5.0, 27.09401076758503), (5.0, 17.856406460551018), (-3.0, 13.237604307034012), (-11.0, 17.856406460551018)], [(5.0, 17.856406460551018), (5.0, 27.09401076758503), (13.0, 31.712812921102035), (21.0, 27.09401076758503), (21.0, 17.856406460551018), (13.0, 13.237604307034012), (5.0, 17.856406460551018)], [(21.0, 17.856406460551018), (21.0, 27.09401076758503), (29.0, 31.712812921102035), (37.0, 27.09401076758503), (37.0, 17.856406460551018), (29.0, 13.237604307034012), (21.0, 17.856406460551018)], [(-3.0, 31.712812921102035), (-3.0, 40.95041722813605), (5.0, 45.569219381653056), (13.0, 40.95041722813605), (13.0, 31.712812921102035), (5.0, 27.09401076758503), (-3.0, 31.712812921102035)], [(13.0, 31.712812921102035), (13.0, 40.95041722813605), (21.0, 45.569219381653056), (29.0, 40.95041722813605), (29.0, 31.712812921102035), (21.0, 27.09401076758503), (13.0, 31.712812921102035)]]", "assert calculate_polygons(9,6,4,3,2)==[[(5.0, 2.5358983848622456), (5.0, 4.8452994616207485), (7.0, 6.0), (9.0, 4.8452994616207485), (9.0, 2.5358983848622456), (7.0, 1.3811978464829942), (5.0, 2.5358983848622456)], [(7.0, 6.0), (7.0, 8.309401076758503), (9.0, 9.464101615137753), (11.0, 8.309401076758503), (11.0, 6.0), (9.0, 4.8452994616207485), (7.0, 6.0)]]"], "context": "Write a function to calculate a grid of hexagon coordinates where function returns a list of lists containing 6 tuples of x, y point coordinates.", "function_name": "import math\r\ndef calculate_polygons(startx, starty, endx, endy, radius):", "gold_generation": "sl = (2 * radius) * math.tan(math.pi / 6)\r\n    p = sl * 0.5\r\n    b = sl * math.cos(math.radians(30))\r\n    w = b * 2\r\n    h = 2 * sl   \r\n    startx = startx - w\r\n    starty = starty - h\r\n    endx = endx + w\r\n    endy = endy + h\r\n    origx = startx\r\n    origy = starty\r\n    xoffset = b\r\n    yoffset = 3 * p\r\n    polygons = []\r\n    row = 1\r\n    counter = 0\r\n    while starty < endy:\r\n        if row % 2 == 0:\r\n            startx = origx + xoffset\r\n        else:\r\n            startx = origx\r\n        while startx < endx:\r\n            p1x = startx\r\n            p1y = starty + p\r\n            p2x = startx\r\n            p2y = starty + (3 * p)\r\n            p3x = startx + b\r\n            p3y = starty + h\r\n            p4x = startx + w\r\n            p4y = starty + (3 * p)\r\n            p5x = startx + w\r\n            p5y = starty + p\r\n            p6x = startx + b\r\n            p6y = starty\r\n            poly = [\r\n                (p1x, p1y),\r\n                (p2x, p2y),\r\n                (p3x, p3y),\r\n                (p4x, p4y),\r\n                (p5x, p5y),\r\n                (p6x, p6y),\r\n                (p1x, p1y)]\r\n            polygons.append(poly)\r\n            counter += 1\r\n            startx += w\r\n        starty += yoffset\r\n        row += 1\r\n    return polygons", "ctxs": [{"id": "27626", "text": "Function: matplotlib._as_gen.matplotlib.axes.axes.hexbin\nSnippet: matplotlib.axes.Axes.hexbin Axes.hexbin(x, y, C=None, gridsize=100, bins=None, xscale='linear', yscale='linear', extent=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, edgecolors='face', reduce_C_function=<function mean>, mincnt=None, marginals=False, *, data=None, **kwargs)[source] Make a 2D hexagonal binning plot of points x, y. If C is None, the value of the hexagon is determined by the number of points in the hexagon. Otherwise, C specifies values at the coordinate (x[i], y[i]). For each hexagon, these values are reduced using reduce_C_function. Parameters x, yarray-like The data positions. x and y must be of the same length. Carray-like, optional If given, these values are accumulated in the bins. Otherwise, every point has a value of 1. Must be of the same length as x and y. gridsizeint or (int, int), default: 100 If a single int, the number of hexagons in the x-direction. The number of hexagons in the y-direction is chosen such that the hexagons are approximately regular. Alternatively, if a tuple (nx, ny), the number of hexagons in the x-direction and the y-direction. bins'log' or int or sequence, default: None Discretization of the hexagon values. If None, no binning is applied; the color of each hexagon directly corresponds to its count value. If 'log', use a logarithmic scale for the colormap. Internally, \\(log_{10}(i+1)\\) is used to determine the hexagon color. This is equivalent to norm=LogNorm(). If an integer, divide the counts in the specified number of bins, and color the hexagons accordingly. If a sequence of values, the values of the lower bound of the bins to be used. xscale{'linear', 'log'}, default: 'linear' Use a linear or log10 scale on the horizontal axis. yscale{'linear', 'log'}, default: 'linear' Use a linear or log10 scale on the vertical axis. mincntint > 0, default: None If not None, only display cells with more than mincnt number of points in the cell. marginalsbool, default: False If marginals is True, plot the marginal density as colormapped rectangles along the bottom of the x-axis and left of the y-axis. extent4-tuple of float, default: None The limits of the bins (xmin, xmax, ymin, ymax). The default assigns the limits based on gridsize, x, y, xscale and yscale. If xscale or yscale is set to 'log', the limits are expected to be the exponent for a power of 10. E.g. for x-limits of 1 and 50 in 'linear' scale and y-limits of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3). Returns PolyCollection A PolyCollection defining the hexagonal bins. PolyCollection.get_offsets contains a Mx2 array containing the x, y positions of the M hexagon centers. PolyCollection.get_array contains the values of the M hexagons. If marginals is True, horizontal bar and vertical bar (both PolyCollections) will be attached to the return collection as attributes hbar and vbar. Other Parameters cmapstr or Colormap, default: rcParams[\"image.cmap\"] (default: 'viridis') The Colormap instance or registered colormap name used to map the bin values to colors. normNormalize, optional The Normalize instance scales the bin values to the canonical colormap range [0, 1] for mapping to colors. By default, the data range is mapped", "score": "0.7457751"}, {"id": "33344", "text": "Function: matplotlib._as_gen.matplotlib.pyplot.hexbin\nSnippet: matplotlib.pyplot.hexbin matplotlib.pyplot.hexbin(x, y, C=None, gridsize=100, bins=None, xscale='linear', yscale='linear', extent=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, edgecolors='face', reduce_C_function=<function mean>, mincnt=None, marginals=False, *, data=None, **kwargs)[source] Make a 2D hexagonal binning plot of points x, y. If C is None, the value of the hexagon is determined by the number of points in the hexagon. Otherwise, C specifies values at the coordinate (x[i], y[i]). For each hexagon, these values are reduced using reduce_C_function. Parameters x, yarray-like The data positions. x and y must be of the same length. Carray-like, optional If given, these values are accumulated in the bins. Otherwise, every point has a value of 1. Must be of the same length as x and y. gridsizeint or (int, int), default: 100 If a single int, the number of hexagons in the x-direction. The number of hexagons in the y-direction is chosen such that the hexagons are approximately regular. Alternatively, if a tuple (nx, ny), the number of hexagons in the x-direction and the y-direction. bins'log' or int or sequence, default: None Discretization of the hexagon values. If None, no binning is applied; the color of each hexagon directly corresponds to its count value. If 'log', use a logarithmic scale for the colormap. Internally, \\(log_{10}(i+1)\\) is used to determine the hexagon color. This is equivalent to norm=LogNorm(). If an integer, divide the counts in the specified number of bins, and color the hexagons accordingly. If a sequence of values, the values of the lower bound of the bins to be used. xscale{'linear', 'log'}, default: 'linear' Use a linear or log10 scale on the horizontal axis. yscale{'linear', 'log'}, default: 'linear' Use a linear or log10 scale on the vertical axis. mincntint > 0, default: None If not None, only display cells with more than mincnt number of points in the cell. marginalsbool, default: False If marginals is True, plot the marginal density as colormapped rectangles along the bottom of the x-axis and left of the y-axis. extent4-tuple of float, default: None The limits of the bins (xmin, xmax, ymin, ymax). The default assigns the limits based on gridsize, x, y, xscale and yscale. If xscale or yscale is set to 'log', the limits are expected to be the exponent for a power of 10. E.g. for x-limits of 1 and 50 in 'linear' scale and y-limits of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3). Returns PolyCollection A PolyCollection defining the hexagonal bins. PolyCollection.get_offsets contains a Mx2 array containing the x, y positions of the M hexagon centers. PolyCollection.get_array contains the values of the M hexagons. If marginals is True, horizontal bar and vertical bar (both PolyCollections) will be attached to the return collection as attributes hbar and vbar. Other Parameters cmapstr or Colormap, default: rcParams[\"image.cmap\"] (default: 'viridis') The Colormap instance or registered colormap name used to map the bin values to colors. normNormalize, optional The Normalize instance scales the bin values to the canonical colormap range [0, 1] for mapping to colors. By default, the data range is mapped", "score": "0.7431378"}, {"id": "14432", "text": "Function: pandas.reference.api.pandas.dataframe.plot.hexbin\nSnippet: pandas.DataFrame.plot.hexbin DataFrame.plot.hexbin(x, y, C=None, reduce_C_function=None, gridsize=None, **kwargs)[source] Generate a hexagonal binning plot. Generate a hexagonal binning plot of x versus y. If C is None (the default), this is a histogram of the number of occurrences of the observations at (x[i], y[i]). If C is specified, specifies values at given coordinates (x[i], y[i]). These values are accumulated for each hexagonal bin and then reduced according to reduce_C_function, having as default the NumPy’s mean function (numpy.mean()). (If C is specified, it must also be a 1-D sequence of the same length as x and y, or a column label.) Parameters x:int or str The column label or position for x points. y:int or str The column label or position for y points. C:int or str, optional The column label or position for the value of (x, y) point. reduce_C_function:callable, default np.mean Function of one argument that reduces all the values in a bin to a single number (e.g. np.mean, np.max, np.sum, np.std). gridsize:int or tuple of (int, int), default 100 The number of hexagons in the x-direction. The corresponding number of hexagons in the y-direction is chosen in a way that the hexagons are approximately regular. Alternatively, gridsize can be a tuple with two elements specifying the number of hexagons in the x-direction and the y-direction. **kwargs Additional keyword arguments are documented in DataFrame.plot(). Returns matplotlib.AxesSubplot The matplotlib Axes on which the hexbin is plotted. See also DataFrame.plot Make plots of a DataFrame. matplotlib.pyplot.hexbin Hexagonal binning plot using matplotlib, the matplotlib function that is used under the hood. Examples The following examples are generated with random data from a normal distribution. >>> n = 10000 >>> df = pd.DataFrame({'x': np.random.randn(n), ... 'y': np.random.randn(n)}) >>> ax = df.plot.hexbin(x='x', y='y', gridsize=20) The next example uses C and np.sum as reduce_C_function. Note that ‘observations’ values ranges from 1 to 5 but the result plot shows values up to more than 25. This is because of the reduce_C_function. >>> n = 500 >>> df = pd.DataFrame({ ... 'coord_x': np.random.uniform(-3, 3, size=n), ... 'coord_y': np.random.uniform(30, 50, size=n), ... 'observations': np.random.randint(1,5, size=n) ... }) >>> ax = df.plot.hexbin(x='coord_x', ... y='coord_y', ... C='observations', ... reduce_C_function=np.sum, ... gridsize=10, ... cmap=\"viridis\")", "score": "0.71634126"}, {"id": "30729", "text": "Function: matplotlib.collections_api#matplotlib.collections.QuadMesh.get_coordinates\nSnippet: get_coordinates()[source] Return the vertices of the mesh as an (M+1, N+1, 2) array. M, N are the number of quadrilaterals in the rows / columns of the mesh, corresponding to (M+1, N+1) vertices. The last dimension specifies the components (x, y).", "score": "0.697315"}, {"id": "14467", "text": "Function: pandas.reference.api.pandas.dataframe.rfloordiv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.69312644"}]}
{"task_id": "mbpp_494", "code": "def binary_to_integer(test_tup):\r\n  res = int(\"\".join(str(ele) for ele in test_tup), 2)\r\n  return (str(res)) ", "test_list": ["assert binary_to_integer((1, 1, 0, 1, 0, 0, 1)) == '105'", "assert binary_to_integer((0, 1, 1, 0, 0, 1, 0, 1)) == '101'", "assert binary_to_integer((1, 1, 0, 1, 0, 1)) == '53'"], "context": "Write a function to convert the given binary tuple to integer.", "function_name": "def binary_to_integer(test_tup):", "gold_generation": "res = int(\"\".join(str(ele) for ele in test_tup), 2)\r\n  return (str(res))", "ctxs": [{"id": "25732", "text": "Function: python.library.stdtypes\nSnippet: there were an infinite number of sign bits. Additional Methods on Integer Types The int type implements the numbers.Integral abstract base class. In addition, it provides a few more methods: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1. int.to_bytes(length, byteorder, *, signed=False) Return an array of bytes representing an integer. >>> (1024).to_bytes(2, byteorder='big') b'\\x04\\x00' >>> (1024).to_bytes(10, byteorder='big') b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00' >>> (-1024).to_bytes(10, byteorder='big', signed=True) b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00' >>> x = 1000 >>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little') b'\\xe8\\x03' The integer is represented using length bytes. An OverflowError is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument determines whether two’s complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. The default value for signed is False. New in version 3.2. classmethod int.from_bytes(bytes, byteorder, *, signed=False) Return the integer represented by the given array of bytes. >>> int.from_bytes(b'\\x00\\x10', byteorder='big') 16 >>> int.from_bytes(b'\\x00\\x10', byteorder='little') 4096 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True) -1024 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False) 64512 >>> int.from_bytes([255, 0, 0], byteorder='big') 16711680 The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. New in version 3.2. int.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original integer and with a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. New in version 3.8. Additional Methods on Float The float type implements the numbers.Real abstract base class. float also has the following additional methods. float.as_integer_ratio() Return a pair of integers whose", "score": "0.7066502"}, {"id": "21071", "text": "Function: python.library.stdtypes#int.bit_length\nSnippet: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1.", "score": "0.6917729"}, {"id": "18215", "text": "Function: python.library.functions#bin\nSnippet: bin(x) Convert an integer number to a binary string prefixed with “0b”. The result is a valid Python expression. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> bin(3) '0b11' >>> bin(-10) '-0b1010' If prefix “0b” is desired or not, you can use either of the following ways. >>> format(14, '#b'), format(14, 'b') ('0b1110', '1110') >>> f'{14:#b}', f'{14:b}' ('0b1110', '1110') See also format() for more information.", "score": "0.6912142"}, {"id": "20204", "text": "Function: python.library.fractions#fractions.Fraction.as_integer_ratio\nSnippet: as_integer_ratio() Return a tuple of two integers, whose ratio is equal to the Fraction and with a positive denominator. New in version 3.8.", "score": "0.6843246"}, {"id": "21984", "text": "Function: python.library.msilib#msilib.Record.GetInteger\nSnippet: Record.GetInteger(field) Return the value of field as an integer where possible. field must be an integer.", "score": "0.67869264"}]}
{"task_id": "mbpp_495", "code": "import re\r\ndef remove_lowercase(str1):\r\n  remove_lower = lambda text: re.sub('[a-z]', '', text)\r\n  result =  remove_lower(str1)\r\n  return (result)", "test_list": ["assert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'", "assert remove_lowercase('ProducTnamEstreAmIngMediAplAYer') == 'PTEAIMAAY'", "assert remove_lowercase('maNufacTuredbYSheZenTechNolOGIes') == 'NTYSZTNOGI'"], "context": "Write a function to remove lowercase substrings from a given string by using regex.", "function_name": "import re\r\ndef remove_lowercase(str1):", "gold_generation": "remove_lower = lambda text: re.sub('[a-z]', '', text)\r\n  result =  remove_lower(str1)\r\n  return (result)", "ctxs": [{"id": "24364", "text": "Function: python.library.stdtypes#str.lower\nSnippet: str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard.", "score": "0.72032684"}, {"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.7127105"}, {"id": "23369", "text": "Function: python.library.re#re.sub\nSnippet: re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern are replaced only when not adjacent to a previous empty match, so sub('x*', '-', 'abxd') returns '-a-b--d-'. In string-type repl arguments, in addition to the character escapes and backreferences described above, \\g<name> will use the substring matched by the group named name, as defined by the (?P<name>...) syntax. \\g<number> uses the corresponding group number; \\g<2> is therefore equivalent to \\2, but isn’t ambiguous in a replacement such as \\g<2>0. \\20 would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character '0'. The backreference \\g<0> substitutes in the entire substring matched by the RE. Changed in version 3.1: Added the optional flags argument. Changed in version 3.5: Unmatched groups are replaced with an empty string. Changed in version 3.6: Unknown escapes in pattern consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Unknown escapes in repl consisting of '\\' and an ASCII letter now are errors. Changed in version 3.7: Empty matches for the pattern are replaced when adjacent to a previous non-empty match.", "score": "0.7038032"}, {"id": "25742", "text": "Function: python.library.stdtypes\nSnippet: Strings also support two styles of string formatting, one providing a large degree of flexibility and customization (see str.format(), Format String Syntax and Custom String Formatting) and the other based on C printf style formatting that handles a narrower range of types and is slightly harder to use correctly, but is often faster for the cases it can handle (printf-style String Formatting). The Text Processing Services section of the standard library covers a number of other modules that provide various text related utilities (including regular expression support in the re module). str.capitalize() Return a copy of the string with its first character capitalized and the rest lowercased. Changed in version 3.8: The first character is now put into titlecase rather than uppercase. This means that characters like digraphs will only have their first letter capitalized, instead of the full character. str.casefold() Return a casefolded copy of the string. Casefolded strings may be used for caseless matching. Casefolding is similar to lowercasing but more aggressive because it is intended to remove all case distinctions in a string. For example, the German lowercase letter 'ß' is equivalent to \"ss\". Since it is already lowercase, lower() would do nothing to 'ß'; casefold() converts it to \"ss\". The casefolding algorithm is described in section 3.13 of the Unicode Standard. New in version 3.3. str.center(width[, fillchar]) Return centered in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. str.encode(encoding=\"utf-8\", errors=\"strict\") Return an encoded version of the string as a bytes object. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other possible values are 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and any other name registered via codecs.register_error(), see section Error Handlers. For a list of possible encodings, see section Standard Encodings. By default, the errors argument is not checked for best performances, but only used at the first encoding error. Enable the Python Development Mode, or use a debug build to check errors. Changed in version 3.1: Support for keyword arguments added. Changed in version 3.9: The errors is now checked in development mode and in debug mode. str.endswith(suffix[, start[, end]]) Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. str.expandtabs(tabsize=8) Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. Tab positions occur every tabsize characters (default is 8, giving tab positions at columns 0, 8, 16 and so", "score": "0.7027757"}, {"id": "24400", "text": "Function: python.library.string#string.ascii_lowercase\nSnippet: string.ascii_lowercase The lowercase letters 'abcdefghijklmnopqrstuvwxyz'. This value is not locale-dependent and will not change.", "score": "0.6957118"}]}
{"task_id": "mbpp_496", "code": "import heapq as hq\r\ndef heap_queue_smallest(nums,n):\r\n  smallest_nums = hq.nsmallest(n, nums)\r\n  return smallest_nums", "test_list": ["assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 25, 58],3)==[14, 22, 25] ", "assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 25, 58],2)==[14, 22]", "assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[14, 22, 22, 25, 35]"], "context": "Write a function to find the smallest integers from a given list of numbers using heap queue algorithm.", "function_name": "import heapq as hq\r\ndef heap_queue_smallest(nums,n):", "gold_generation": "smallest_nums = hq.nsmallest(n, nums)\r\n  return smallest_nums", "ctxs": [{"id": "20477", "text": "Function: python.library.heapq\nSnippet: heapq — Heap queue algorithm Source code: Lib/heapq.py This module provides an implementation of the heap queue algorithm, also known as the priority queue algorithm. Heaps are binary trees for which every parent node has a value less than or equal to any of its children. This implementation uses arrays for which heap[k] <= heap[2*k+1] and heap[k] <= heap[2*k+2] for all k, counting elements from zero. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that its smallest element is always the root, heap[0]. The API below differs from textbook heap algorithms in two aspects: (a) We use zero-based indexing. This makes the relationship between the index for a node and the indexes for its children slightly less obvious, but is more suitable since Python uses zero-based indexing. (b) Our pop method returns the smallest item, not the largest (called a “min heap” in textbooks; a “max heap” is more common in texts because of its suitability for in-place sorting). These two make it possible to view the heap as a regular Python list without surprises: heap[0] is the smallest item, and heap.sort() maintains the heap invariant! To create a heap, use a list initialized to [], or you can transform a populated list into a heap via function heapify(). The following functions are provided: heapq.heappush(heap, item) Push the value item onto the heap, maintaining the heap invariant. heapq.heappop(heap) Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0]. heapq.heappushpop(heap, item) Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop(). heapq.heapify(x) Transform list x into a heap, in-place, in linear time. heapq.heapreplace(heap, item) Pop and return the smallest item from the heap, and also push the new item. The heap size doesn’t change. If the heap is empty, IndexError is raised. This one step operation is more efficient than a heappop() followed by heappush() and can be more appropriate when using a fixed-size heap. The pop/push combination always returns an element from the heap and replaces it with item. The value returned may be larger than the item added. If that isn’t desired, consider using heappushpop() instead. Its push/pop combination returns the smaller of the two values, leaving the larger value on the heap. The module also offers three general purpose functions based on heaps. heapq.merge(*iterables, key=None, reverse=False) Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an iterator over the sorted values. Similar to sorted(itertools.chain(*iterables)) but returns an iterable, does not pull the data into memory all at once, and assumes that each of the input streams is already sorted (smallest to largest). Has two optional arguments which must be specified as keyword arguments. key specifies a", "score": "0.784977"}, {"id": "20489", "text": "Function: python.library.heapq#heapq.nsmallest\nSnippet: heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n].", "score": "0.73294026"}, {"id": "20483", "text": "Function: python.library.heapq#heapq.heappop\nSnippet: heapq.heappop(heap) Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0].", "score": "0.7288597"}, {"id": "20478", "text": "Function: python.library.heapq\nSnippet: key function of one argument that is used to extract a comparison key from each input element. The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the input elements are merged as if each comparison were reversed. To achieve behavior similar to sorted(itertools.chain(*iterables), reverse=True), all iterables must be sorted from largest to smallest. Changed in version 3.5: Added the optional key and reverse parameters. heapq.nlargest(n, iterable, key=None) Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n]. heapq.nsmallest(n, iterable, key=None) Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n]. The latter two functions perform best for smaller values of n. For larger values, it is more efficient to use the sorted() function. Also, when n==1, it is more efficient to use the built-in min() and max() functions. If repeated usage of these functions is required, consider turning the iterable into an actual heap. Basic Examples A heapsort can be implemented by pushing all values onto a heap and then popping off the smallest values one at a time: >>> def heapsort(iterable): ... h = [] ... for value in iterable: ... heappush(h, value) ... return [heappop(h) for i in range(len(h))] ... >>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] This is similar to sorted(iterable), but unlike sorted(), this implementation is not stable. Heap elements can be tuples. This is useful for assigning comparison values (such as task priorities) alongside the main record being tracked: >>> h = [] >>> heappush(h, (5, 'write code')) >>> heappush(h, (7, 'release product')) >>> heappush(h, (1, 'write spec')) >>> heappush(h, (3, 'create tests')) >>> heappop(h) (1, 'write spec') Priority Queue Implementation Notes A priority queue is common use for a heap, and it presents several implementation challenges: Sort stability: how do you get two tasks with equal priorities to be returned in the order they were originally added? Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order. If the priority of a task changes, how do you move it to a new position in the heap? Or if a pending task needs to be deleted, how do you find it and remove it from the queue? A solution to the first two challenges is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were", "score": "0.7199597"}, {"id": "20485", "text": "Function: python.library.heapq#heapq.heappushpop\nSnippet: heapq.heappushpop(heap, item) Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop().", "score": "0.7191586"}]}
{"task_id": "mbpp_497", "code": "import math\r\ndef surfacearea_cone(r,h):\r\n  l = math.sqrt(r * r + h * h)\r\n  SA = math.pi * r * (r + l)\r\n  return SA", "test_list": ["assert surfacearea_cone(5,12)==282.7433388230814", "assert surfacearea_cone(10,15)==880.5179353159282", "assert surfacearea_cone(19,17)==2655.923961165254"], "context": "Write a function to find the surface area of a cone.", "function_name": "import math\r\ndef surfacearea_cone(r,h):", "gold_generation": "l = math.sqrt(r * r + h * h)\r\n  SA = math.pi * r * (r + l)\r\n  return SA", "ctxs": [{"id": "17024", "text": "Function: skimage.api.skimage.measure#skimage.measure.mesh_surface_area\nSnippet: skimage.measure.mesh_surface_area(verts, faces) [source] Compute surface area, given vertices & triangular faces Parameters verts(V, 3) array of floats Array containing (x, y, z) coordinates for V unique mesh vertices. faces(F, 3) array of ints List of length-3 lists of integers, referencing vertex coordinates as provided in verts Returns areafloat Surface area of mesh. Units now [coordinate units] ** 2. See also skimage.measure.marching_cubes skimage.measure.marching_cubes_classic Notes The arguments expected by this function are the first two outputs from skimage.measure.marching_cubes. For unit correct output, ensure correct spacing was passed to skimage.measure.marching_cubes. This algorithm works properly only if the faces provided are all triangles.", "score": "0.6640667"}, {"id": "13179", "text": "Function: pygame.ref.draw\nSnippet: the given surface. The line has a thickness of one pixel and the endpoints have a height and width of one pixel each. The way a line and it's endpoints are drawn: If both endpoints are equal, only a single pixel is drawn (after rounding floats to nearest integer). Otherwise if the line is not steep (i.e. if the length along the x-axis is greater than the height along the y-axis): For each endpoint: If x, the endpoint's x-coordinate, is a whole number find which pixels would be covered by it and draw them. Otherwise: Calculate the position of the nearest point with a whole number for it's x-coordinate, when extending the line past the endpoint. Find which pixels would be covered and how much by that point. If the endpoint is the left one, multiply the coverage by (1 - the decimal part of x). Otherwise multiply the coverage by the decimal part of x. Then draw those pixels. e.g.: The left endpoint of the line ((1, 1.3), (5, 3)) would cover 70% of the pixel (1, 1) and 30% of the pixel (1, 2) while the right one would cover 100% of the pixel (5, 3). The left endpoint of the line ((1.2, 1.4), (4.6, 3.1)) would cover 56% (i.e. 0.8 * 70%) of the pixel (1, 1) and 24% (i.e. 0.8 * 30%) of the pixel (1, 2) while the right one would cover 42% (i.e. 0.6 * 70%) of the pixel (5, 3) and 18% (i.e. 0.6 * 30%) of the pixel (5, 4) while the right Then for each point between the endpoints, along the line, whose x-coordinate is a whole number: Find which pixels would be covered and how much by that point and draw them. e.g.: The points along the line ((1, 1), (4, 2.5)) would be (2, 1.5) and (3, 2) and would cover 50% of the pixel (2, 1), 50% of the pixel (2, 2) and 100% of the pixel (3, 2). The points along the line ((1.2, 1.4), (4.6, 3.1)) would be (2, 1.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)), (3, 2.3) (covering 70% of the pixel (3, 2) and 30% of the pixel (3, 3)) and (4, 2.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)) Otherwise do the same for steep lines as for non-steep lines except along the y-axis instead of the x-axis (using y instead of x, top instead of left and bottom instead of right). Note Regarding float values for coordinates, a point with coordinate consisting of two whole numbers is considered being right in the center of said pixel (and having a height and width of 1 pixel would therefore completely cover it), while a point with coordinate where one (or both) of the numbers have non-zero decimal parts would be partially covering two (or four if both numbers have decimal parts) adjacent pixels, e.g. the point (1.4, 2) covers", "score": "0.6276965"}, {"id": "33487", "text": "Function: matplotlib._as_gen.matplotlib.quiver.barbs#matplotlib.quiver.Barbs.barbs_doc\nSnippet: barbs_doc='\\nPlot a 2D field of barbs.\\n\\nCall signature::\\n\\n barbs([X, Y], U, V, [C], **kw)\\n\\nWhere *X*, *Y* define the barb locations, *U*, *V* define the barb\\ndirections, and *C* optionally sets the color.\\n\\nAll arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked\\n*X*, *Y* are not supported at present.\\n\\nBarbs are traditionally used in meteorology as a way to plot the speed\\nand direction of wind observations, but can technically be used to\\nplot any two dimensional vector quantity. As opposed to arrows, which\\ngive vector magnitude by the length of the arrow, the barbs give more\\nquantitative information about the vector magnitude by putting slanted\\nlines or a triangle for various increments in magnitude, as show\\nschematically below::\\n\\n : /\\\\ \\\\\\n : / \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : / \\\\ \\\\ \\\\\\n : ------------------------------\\n\\nThe largest increment is given by a triangle (or \"flag\"). After those\\ncome full lines (barbs). The smallest increment is a half line. There\\nis only, of course, ever at most 1 half line. If the magnitude is\\nsmall and only needs a single half-line and no full lines or\\ntriangles, the half-line is offset from the end of the barb so that it\\ncan be easily distinguished from barbs with a single full line. The\\nmagnitude for the barb shown above would nominally be 65, using the\\nstandard increments of 50, 10, and 5.\\n\\nSee also https://en.wikipedia.org/wiki/Wind_barb.\\n\\nParameters\\n----------\\nX, Y : 1D or 2D array-like, optional\\n The x and y coordinates of the barb locations. See *pivot* for how the\\n barbs are drawn to the x, y positions.\\n\\n If not given, they will be generated as a uniform integer meshgrid based\\n on the dimensions of *U* and *V*.\\n\\n If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D\\n using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``\\n must match the column and row dimensions of *U* and *V*.\\n\\nU, V : 1D or 2D array-like\\n The x and y components of the barb shaft.\\n\\nC : 1D or 2D array-like, optional\\n Numeric data that defines the barb colors by colormapping via *norm* and\\n *cmap*.\\n\\n This does not support explicit colors. If you want to set colors directly,\\n use *barbcolor* instead.\\n\\nlength : float, default: 7\\n Length of the barb in points; the other parts of the barb\\n are scaled against this.\\n\\npivot : {\\'tip\\', \\'middle\\'} or float, default: \\'tip\\'\\n The part of the arrow that is anchored to the *X*, *Y* grid. The barb\\n rotates about this point. This can also be a number, which shifts the\\n start of the barb that many points away from grid point.\\n\\nbarbcolor : color or color sequence\\n The color of all parts of the barb except for the flags. This parameter\\n is analogous to the *edgecolor* parameter for polygons, which can be used\\n instead. However this parameter will override facecolor.\\n\\nflagcolor : color or color sequence\\n The color of any flags on the barb. This parameter is analogous to the\\n *facecolor* parameter for polygons, which can be used instead. However,\\n this parameter will override facecolor. If", "score": "0.6267463"}, {"id": "21832", "text": "Function: python.library.math#math.tan\nSnippet: math.tan(x) Return the tangent of x radians.", "score": "0.6199727"}, {"id": "13483", "text": "Function: pygame.ref.math\nSnippet: vector is the zero vector (i.e. has length 0 thus no direction) a ValueError is raised. reflect() returns a vector reflected of a given normal. reflect(Vector2) -> Vector2 Returns a new vector that points in the direction as if self would bounce of a surface characterized by the given surface normal. The length of the new vector is the same as self's. reflect_ip() reflect the vector of a given normal in place. reflect_ip(Vector2) -> None Changes the direction of self as if it would have been reflected of a surface with the given surface normal. distance_to() calculates the Euclidean distance to a given vector. distance_to(Vector2) -> float distance_squared_to() calculates the squared Euclidean distance to a given vector. distance_squared_to(Vector2) -> float lerp() returns a linear interpolation to the given vector. lerp(Vector2, float) -> Vector2 Returns a Vector which is a linear interpolation between self and the given Vector. The second parameter determines how far between self and other the result is going to be. It must be a value between 0 and 1 where 0 means self and 1 means other will be returned. slerp() returns a spherical interpolation to the given vector. slerp(Vector2, float) -> Vector2 Calculates the spherical interpolation from self to the given Vector. The second argument - often called t - must be in the range [-1, 1]. It parametrizes where - in between the two vectors - the result should be. If a negative value is given the interpolation will not take the complement of the shortest path. elementwise() The next operation will be performed elementwise. elementwise() -> VectorElementwiseProxy Applies the following operation to each element of the vector. rotate() rotates a vector by a given angle in degrees. rotate(angle) -> Vector2 Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in degrees. rotate_rad() rotates a vector by a given angle in radians. rotate_rad(angle) -> Vector2 Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in radians. New in pygame 2.0.0. rotate_ip() rotates the vector by a given angle in degrees in place. rotate_ip(angle) -> None Rotates the vector counterclockwise by the given angle in degrees. The length of the vector is not changed. rotate_ip_rad() rotates the vector by a given angle in radians in place. rotate_ip_rad(angle) -> None Rotates the vector counterclockwise by the given angle in radians. The length of the vector is not changed. New in pygame 2.0.0. angle_to() calculates the angle to a given vector in degrees. angle_to(Vector2) -> float Returns the angle between self and the given vector. as_polar() returns a tuple with radial distance and azimuthal angle. as_polar() -> (r, phi) Returns a tuple (r, phi) where r is the radial distance, and phi is the azimuthal angle. from_polar() Sets x and y from a polar coordinates tuple. from_polar((r, phi)) -> None Sets x and y from a tuple (r, phi) where r is the radial distance, and phi is the azimuthal", "score": "0.6146015"}]}
{"task_id": "mbpp_498", "code": "def gcd(x, y):\r\n    gcd = 1\r\n    if x % y == 0:\r\n        return y\r\n    for k in range(int(y / 2), 0, -1):\r\n        if x % k == 0 and y % k == 0:\r\n            gcd = k\r\n            break  \r\n    return gcd", "test_list": ["assert gcd(12, 17) == 1", "assert gcd(4,6) == 2", "assert gcd(2,9) == 1"], "context": "Write a python function to find gcd of two positive integers.", "function_name": "def gcd(x, y):", "gold_generation": "gcd = 1\r\n    if x % y == 0:\r\n        return y\r\n    for k in range(int(y / 2), 0, -1):\r\n        if x % k == 0 and y % k == 0:\r\n            gcd = k\r\n            break  \r\n    return gcd", "ctxs": [{"id": "21805", "text": "Function: python.library.math#math.gcd\nSnippet: math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported.", "score": "0.78977156"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.7185966"}, {"id": "42857", "text": "Function: numpy.reference.generated.numpy.gcd\nSnippet: numpy.gcd numpy.gcd(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'gcd'> Returns the greatest common divisor of |x1| and |x2| Parameters x1, x2array_like, int Arrays of values. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). Returns yndarray or scalar The greatest common divisor of the absolute value of the inputs This is a scalar if both x1 and x2 are scalars. See also lcm The lowest common multiple Examples >>> np.gcd(12, 20) 4 >>> np.gcd.reduce([15, 25, 35]) 5 >>> np.gcd(np.arange(6), 20) array([20, 1, 2, 1, 4, 5])", "score": "0.7167709"}, {"id": "6576", "text": "Function: torch.generated.torch.gcd#torch.gcd\nSnippet: torch.gcd(input, other, *, out=None) → Tensor Computes the element-wise greatest common divisor (GCD) of input and other. Both input and other must have integer types. Note This defines gcd(0,0)=0gcd(0, 0) = 0 . Parameters input (Tensor) – the input tensor. other (Tensor) – the second input tensor Keyword Arguments out (Tensor, optional) – the output tensor. Example: >>> a = torch.tensor([5, 10, 15]) >>> b = torch.tensor([3, 4, 5]) >>> torch.gcd(a, b) tensor([1, 2, 5]) >>> c = torch.tensor([3]) >>> torch.gcd(a, c) tensor([1, 1, 3])", "score": "0.7051203"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.701954"}]}
{"task_id": "mbpp_499", "code": "def diameter_circle(r):\r\n  diameter=2*r\r\n  return diameter", "test_list": ["assert diameter_circle(10)==20", "assert diameter_circle(40)==80", "assert diameter_circle(15)==30"], "context": "Write a function to find the diameter of a circle.", "function_name": "def diameter_circle(r):", "gold_generation": "diameter=2*r\r\n  return diameter", "ctxs": [{"id": "25627", "text": "Function: python.library.turtle#turtle.dot\nSnippet: turtle.dot(size=None, *color) Parameters size – an integer >= 1 (if given) color – a colorstring or a numeric color tuple Draw a circular dot with diameter size, using color. If size is not given, the maximum of pensize+4 and 2*pensize is used. >>> turtle.home() >>> turtle.dot() >>> turtle.fd(50); turtle.dot(20, \"blue\"); turtle.fd(50) >>> turtle.position() (100.00,-0.00) >>> turtle.heading() 0.0", "score": "0.67412835"}, {"id": "25592", "text": "Function: python.library.turtle\nSnippet: steps – an integer (or None) Draw a circle with given radius. The center is radius units left of the turtle; extent – an angle – determines which part of the circle is drawn. If extent is not given, draw the entire circle. If extent is not a full circle, one endpoint of the arc is the current pen position. Draw the arc in counterclockwise direction if radius is positive, otherwise in clockwise direction. Finally the direction of the turtle is changed by the amount of extent. As the circle is approximated by an inscribed regular polygon, steps determines the number of steps to use. If not given, it will be calculated automatically. May be used to draw regular polygons. >>> turtle.home() >>> turtle.position() (0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(50) >>> turtle.position() (-0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(120, 180) # draw a semicircle >>> turtle.position() (0.00,240.00) >>> turtle.heading() 180.0 turtle.dot(size=None, *color) Parameters size – an integer >= 1 (if given) color – a colorstring or a numeric color tuple Draw a circular dot with diameter size, using color. If size is not given, the maximum of pensize+4 and 2*pensize is used. >>> turtle.home() >>> turtle.dot() >>> turtle.fd(50); turtle.dot(20, \"blue\"); turtle.fd(50) >>> turtle.position() (100.00,-0.00) >>> turtle.heading() 0.0 turtle.stamp() Stamp a copy of the turtle shape onto the canvas at the current turtle position. Return a stamp_id for that stamp, which can be used to delete it by calling clearstamp(stamp_id). >>> turtle.color(\"blue\") >>> turtle.stamp() 11 >>> turtle.fd(50) turtle.clearstamp(stampid) Parameters stampid – an integer, must be return value of previous stamp() call Delete stamp with given stampid. >>> turtle.position() (150.00,-0.00) >>> turtle.color(\"blue\") >>> astamp = turtle.stamp() >>> turtle.fd(50) >>> turtle.position() (200.00,-0.00) >>> turtle.clearstamp(astamp) >>> turtle.position() (200.00,-0.00) turtle.clearstamps(n=None) Parameters n – an integer (or None) Delete all or first/last n of turtle’s stamps. If n is None, delete all stamps, if n > 0 delete first n stamps, else if n < 0 delete last n stamps. >>> for i in range(8): ... turtle.stamp(); turtle.fd(30) 13 14 15 16 17 18 19 20 >>> turtle.clearstamps(2) >>> turtle.clearstamps(-2) >>> turtle.clearstamps() turtle.undo() Undo (repeatedly) the last turtle action(s). Number of available undo actions is determined by the size of the undobuffer. >>> for i in range(4): ... turtle.fd(50); turtle.lt(80) ... >>> for i in range(8): ... turtle.undo() turtle.speed(speed=None) Parameters speed – an integer in the range 0..10 or a speedstring (see below) Set the turtle’s speed to an integer value in the range 0..10. If no argument is given, return current speed. If input is a number greater than 10 or smaller than 0.5, speed is set to 0. Speedstrings are mapped to speedvalues as follows: “fastest”: 0 “fast”: 10 “normal”: 6 “slow”: 3 “slowest”: 1 Speeds from 1 to 10 enforce increasingly faster animation of line drawing and turtle turning. Attention: speed = 0 means that no animation takes place. forward/back makes turtle jump and likewise left/right make the turtle turn instantly. >>> turtle.speed() 3 >>> turtle.speed('normal') >>> turtle.speed() 6 >>> turtle.speed(9) >>> turtle.speed() 9", "score": "0.6639808"}, {"id": "16993", "text": "Function: skimage.api.skimage.measure#skimage.measure.CircleModel\nSnippet: class skimage.measure.CircleModel [source] Bases: skimage.measure.fit.BaseModel Total least squares estimator for 2D circles. The functional model of the circle is: r**2 = (x - xc)**2 + (y - yc)**2 This estimator minimizes the squared distances from all points to the circle: min{ sum((r - sqrt((x_i - xc)**2 + (y_i - yc)**2))**2) } A minimum number of 3 points is required to solve for the parameters. Examples >>> t = np.linspace(0, 2 * np.pi, 25) >>> xy = CircleModel().predict_xy(t, params=(2, 3, 4)) >>> model = CircleModel() >>> model.estimate(xy) True >>> tuple(np.round(model.params, 5)) (2.0, 3.0, 4.0) >>> res = model.residuals(xy) >>> np.abs(np.round(res, 9)) array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) Attributes paramstuple Circle model parameters in the following order xc, yc, r. __init__() [source] Initialize self. See help(type(self)) for accurate signature. estimate(data) [source] Estimate circle model from data using total least squares. Parameters data(N, 2) array N points with (x, y) coordinates, respectively. Returns successbool True, if model estimation succeeds. predict_xy(t, params=None) [source] Predict x- and y-coordinates using the estimated model. Parameters tarray Angles in circle in radians. Angles start to count from positive x-axis to positive y-axis in a right-handed system. params(3, ) array, optional Optional custom parameter set. Returns xy(…, 2) array Predicted x- and y-coordinates. residuals(data) [source] Determine residuals of data to model. For each point the shortest distance to the circle is returned. Parameters data(N, 2) array N points with (x, y) coordinates, respectively. Returns residuals(N, ) array Residual for each data point.", "score": "0.65856916"}, {"id": "25615", "text": "Function: python.library.turtle#turtle.circle\nSnippet: turtle.circle(radius, extent=None, steps=None) Parameters radius – a number extent – a number (or None) steps – an integer (or None) Draw a circle with given radius. The center is radius units left of the turtle; extent – an angle – determines which part of the circle is drawn. If extent is not given, draw the entire circle. If extent is not a full circle, one endpoint of the arc is the current pen position. Draw the arc in counterclockwise direction if radius is positive, otherwise in clockwise direction. Finally the direction of the turtle is changed by the amount of extent. As the circle is approximated by an inscribed regular polygon, steps determines the number of steps to use. If not given, it will be calculated automatically. May be used to draw regular polygons. >>> turtle.home() >>> turtle.position() (0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(50) >>> turtle.position() (-0.00,0.00) >>> turtle.heading() 0.0 >>> turtle.circle(120, 180) # draw a semicircle >>> turtle.position() (0.00,240.00) >>> turtle.heading() 180.0", "score": "0.65486085"}, {"id": "21777", "text": "Function: python.library.math\nSnippet: Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers. math.sqrt(x) Return the square root of x. Trigonometric functions math.acos(x) Return the arc cosine of x, in radians. The result is between 0 and pi. math.asin(x) Return the arc sine of x, in radians. The result is between -pi/2 and pi/2. math.atan(x) Return the arc tangent of x, in radians. The result is between -pi/2 and pi/2. math.atan2(y, x) Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4. math.cos(x) Return the cosine of x radians. math.dist(p, q) Return the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Roughly equivalent to: sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q))) New in version 3.8. math.hypot(*coordinates) Return the Euclidean norm, sqrt(sum(x**2 for x in coordinates)). This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point (x, y), this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, sqrt(x*x + y*y). Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. math.sin(x) Return the sine of x radians. math.tan(x) Return the tangent of x radians. Angular conversion math.degrees(x) Convert angle x from radians to degrees. math.radians(x) Convert angle x from degrees to radians. Hyperbolic functions Hyperbolic functions are analogs of trigonometric functions that are based on hyperbolas instead of circles. math.acosh(x) Return the inverse hyperbolic cosine of x. math.asinh(x) Return the inverse hyperbolic sine of x. math.atanh(x) Return the inverse hyperbolic tangent of x. math.cosh(x) Return the hyperbolic cosine of x. math.sinh(x) Return the hyperbolic sine of x. math.tanh(x) Return the hyperbolic tangent of x. Special functions math.erf(x) Return the error function at x. The erf() function can be used to compute traditional statistical functions such as the cumulative standard normal distribution: def phi(x): 'Cumulative distribution function for the standard normal distribution' return (1.0 + erf(x / sqrt(2.0))) / 2.0 New in version 3.2. math.erfc(x) Return the complementary error function at x. The complementary error function is defined as 1.0 - erf(x). It is used for large values of x where a subtraction from one would cause a loss of significance. New in version 3.2. math.gamma(x) Return the Gamma function at x. New in version 3.2. math.lgamma(x) Return the natural logarithm of the absolute value of the Gamma function at x. New in version 3.2. Constants math.pi The mathematical constant π =", "score": "0.6471499"}]}
{"task_id": "mbpp_500", "code": "def concatenate_elements(list):\r\n  ans = ' '\r\n  for i in list:\r\n    ans = ans+ ' '+i\r\n  return (ans) ", "test_list": ["assert concatenate_elements(['hello','there','have','a','rocky','day'] ) == '  hello there have a rocky day'", "assert concatenate_elements([ 'Hi', 'there', 'How','are', 'you'] ) == '  Hi there How are you'", "assert concatenate_elements([ 'Part', 'of', 'the','journey', 'is', 'end'] ) == '  Part of the journey is end'"], "context": "Write a function to concatenate all elements of the given list into a string.", "function_name": "def concatenate_elements(list):", "gold_generation": "ans = ' '\r\n  for i in list:\r\n    ans = ans+ ' '+i\r\n  return (ans)", "ctxs": [{"id": "18601", "text": "Function: python.library.codecs#codecs.StreamWriter.writelines\nSnippet: writelines(list) Writes the concatenated list of strings to the stream (possibly by reusing the write() method). The standard bytes-to-bytes codecs do not support this method.", "score": "0.7157676"}, {"id": "41672", "text": "Function: numpy.reference.generated.numpy.char.chararray.join\nSnippet: numpy.char.chararray.join method char.chararray.join(seq)[source] Return a string which is the concatenation of the strings in the sequence seq. See also char.join", "score": "0.68898994"}, {"id": "24362", "text": "Function: python.library.stdtypes#str.join\nSnippet: str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method.", "score": "0.68857753"}, {"id": "25737", "text": "Function: python.library.stdtypes\nSnippet: a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str objects, you can build a list and use str.join() at the end or else write to an io.StringIO instance and retrieve its value when complete if concatenating bytes objects, you can similarly use bytes.join() or io.BytesIO, or you can do in-place concatenation with a bytearray object. bytearray objects are mutable and have an efficient overallocation mechanism if concatenating tuple objects, extend a list instead for other types, investigate the relevant class documentation Some sequence types (such as range) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition. index raises ValueError when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using s[i:j].index(x), only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. Immutable Sequence Types The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the hash() built-in. This support allows immutable sequences, such as tuple instances, to be used as dict keys and stored in set and frozenset instances. Attempting to hash an immutable sequence that contains unhashable values will result in TypeError. Mutable Sequence Types The operations in the following table are defined on mutable sequence types. The collections.abc.MutableSequence ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, bytearray only accepts integers that meet the value restriction 0 <= x <= 255). Operation Result Notes s[i] = x item i of s is replaced by x s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t del s[i:j] same as s[i:j] = [] s[i:j:k] = t the elements of s[i:j:k] are replaced by those of t (1) del s[i:j:k] removes the elements of s[i:j:k] from the list s.append(x) appends x to the end of the sequence (same as s[len(s):len(s)] = [x]) s.clear() removes all items from s (same as del s[:]) (5) s.copy() creates a shallow copy of s (same as s[:]) (5) s.extend(t) or s += t extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t) s *= n updates s with its contents repeated n times (6) s.insert(i, x) inserts x into s at the index given by i (same as s[i:i] = [x]) s.pop([i]) retrieves the item at i and also removes it", "score": "0.684312"}, {"id": "41795", "text": "Function: numpy.reference.generated.numpy.chararray.join\nSnippet: numpy.chararray.join method chararray.join(seq)[source] Return a string which is the concatenation of the strings in the sequence seq. See also char.join", "score": "0.6827179"}]}
{"task_id": "mbpp_501", "code": "def ngcd(x,y):\r\n    i=1\r\n    while(i<=x and i<=y):\r\n        if(x%i==0 and y%i == 0):\r\n            gcd=i;\r\n        i+=1\r\n    return gcd;\r\ndef num_comm_div(x,y):\r\n  n = ngcd(x,y)\r\n  result = 0\r\n  z = int(n**0.5)\r\n  i = 1\r\n  while(i <= z):\r\n    if(n % i == 0):\r\n      result += 2 \r\n      if(i == n/i):\r\n        result-=1\r\n    i+=1\r\n  return result", "test_list": ["assert num_comm_div(2,4) == 2", "assert num_comm_div(2,8) == 2", "assert num_comm_div(12,24) == 6"], "context": "Write a python function to find common divisor between two numbers in a given pair.", "function_name": "def ngcd(x,y):", "gold_generation": "i=1\r\n    while(i<=x and i<=y):\r\n        if(x%i==0 and y%i == 0):\r\n            gcd=i;\r\n        i+=1\r\n    return gcd;\r\ndef num_comm_div(x,y):\r\n  n = ngcd(x,y)\r\n  result = 0\r\n  z = int(n**0.5)\r\n  i = 1\r\n  while(i <= z):\r\n    if(n % i == 0):\r\n      result += 2 \r\n      if(i == n/i):\r\n        result-=1\r\n    i+=1\r\n  return result", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.68775076"}, {"id": "42857", "text": "Function: numpy.reference.generated.numpy.gcd\nSnippet: numpy.gcd numpy.gcd(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'gcd'> Returns the greatest common divisor of |x1| and |x2| Parameters x1, x2array_like, int Arrays of values. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). Returns yndarray or scalar The greatest common divisor of the absolute value of the inputs This is a scalar if both x1 and x2 are scalars. See also lcm The lowest common multiple Examples >>> np.gcd(12, 20) 4 >>> np.gcd.reduce([15, 25, 35]) 5 >>> np.gcd(np.arange(6), 20) array([20, 1, 2, 1, 4, 5])", "score": "0.6823894"}, {"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.68102455"}, {"id": "19495", "text": "Function: python.library.decimal#decimal.Context.multiply\nSnippet: multiply(x, y) Return the product of x and y.", "score": "0.6767882"}, {"id": "19565", "text": "Function: python.library.decimal#decimal.Decimal.remainder_near\nSnippet: remainder_near(other, context=None) Return the remainder from dividing self by other. This differs from self % other in that the sign of the remainder is chosen so as to minimize its absolute value. More precisely, the return value is self - n * other where n is the integer nearest to the exact value of self / other, and if two integers are equally near then the even one is chosen. If the result is zero then its sign will be the sign of self. >>> Decimal(18).remainder_near(Decimal(10)) Decimal('-2') >>> Decimal(25).remainder_near(Decimal(10)) Decimal('5') >>> Decimal(35).remainder_near(Decimal(10)) Decimal('-5')", "score": "0.67267287"}]}
{"task_id": "mbpp_502", "code": "def find(n,m):\r\n  r = n%m\r\n  return (r)", "test_list": ["assert find(3,3) == 0", "assert find(10,3) == 1", "assert find(16,5) == 1"], "context": "Write a python function to find remainder of two numbers.", "function_name": "def find(n,m):", "gold_generation": "r = n%m\r\n  return (r)", "ctxs": [{"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.7535684"}, {"id": "19565", "text": "Function: python.library.decimal#decimal.Decimal.remainder_near\nSnippet: remainder_near(other, context=None) Return the remainder from dividing self by other. This differs from self % other in that the sign of the remainder is chosen so as to minimize its absolute value. More precisely, the return value is self - n * other where n is the integer nearest to the exact value of self / other, and if two integers are equally near then the even one is chosen. If the result is zero then its sign will be the sign of self. >>> Decimal(18).remainder_near(Decimal(10)) Decimal('-2') >>> Decimal(25).remainder_near(Decimal(10)) Decimal('5') >>> Decimal(35).remainder_near(Decimal(10)) Decimal('-5')", "score": "0.7422193"}, {"id": "19506", "text": "Function: python.library.decimal#decimal.Context.remainder_near\nSnippet: remainder_near(x, y) Returns x - y * n, where n is the integer nearest the exact value of x / y (if the result is 0 then its sign will be the sign of x).", "score": "0.73773843"}, {"id": "19505", "text": "Function: python.library.decimal#decimal.Context.remainder\nSnippet: remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend.", "score": "0.7354729"}, {"id": "19432", "text": "Function: python.library.decimal\nSnippet: be necessary. In this case, the rounding mode is determined by the rounding argument if given, else by the given context argument; if neither argument is given the rounding mode of the current thread’s context is used. An error is returned whenever the resulting exponent is greater than Emax or less than Etiny. radix() Return Decimal(10), the radix (base) in which the Decimal class does all its arithmetic. Included for compatibility with the specification. remainder_near(other, context=None) Return the remainder from dividing self by other. This differs from self % other in that the sign of the remainder is chosen so as to minimize its absolute value. More precisely, the return value is self - n * other where n is the integer nearest to the exact value of self / other, and if two integers are equally near then the even one is chosen. If the result is zero then its sign will be the sign of self. >>> Decimal(18).remainder_near(Decimal(10)) Decimal('-2') >>> Decimal(25).remainder_near(Decimal(10)) Decimal('5') >>> Decimal(35).remainder_near(Decimal(10)) Decimal('-5') rotate(other, context=None) Return the result of rotating the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to rotate. If the second operand is positive then rotation is to the left; otherwise rotation is to the right. The coefficient of the first operand is padded on the left with zeros to length precision if necessary. The sign and exponent of the first operand are unchanged. same_quantum(other, context=None) Test whether self and other have the same exponent or whether both are NaN. This operation is unaffected by context and is quiet: no flags are changed and no rounding is performed. As an exception, the C version may raise InvalidOperation if the second operand cannot be converted exactly. scaleb(other, context=None) Return the first operand with exponent adjusted by the second. Equivalently, return the first operand multiplied by 10**other. The second operand must be an integer. shift(other, context=None) Return the result of shifting the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to shift. If the second operand is positive then the shift is to the left; otherwise the shift is to the right. Digits shifted into the coefficient are zeros. The sign and exponent of the first operand are unchanged. sqrt(context=None) Return the square root of the argument to full precision. to_eng_string(context=None) Convert to a string, using engineering notation if an exponent is needed. Engineering notation has an exponent which is a multiple of 3. This can leave up to 3 digits to the left of the decimal place and may require the addition of either one or two trailing zeros. For example, this converts Decimal('123E+1') to Decimal('1.23E+3'). to_integral(rounding=None, context=None) Identical to the to_integral_value() method. The", "score": "0.7158818"}]}
{"task_id": "mbpp_503", "code": "def add_consecutive_nums(nums):\r\n    result = [b+a for a, b in zip(nums[:-1], nums[1:])]\r\n    return result", "test_list": ["assert add_consecutive_nums([1, 1, 3, 4, 4, 5, 6, 7])==[2, 4, 7, 8, 9, 11, 13]", "assert add_consecutive_nums([4, 5, 8, 9, 6, 10])==[9, 13, 17, 15, 16]", "assert add_consecutive_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[3, 5, 7, 9, 11, 13, 15, 17, 19]"], "context": "Write a function to add consecutive numbers of a given list.", "function_name": "def add_consecutive_nums(nums):", "gold_generation": "result = [b+a for a, b in zip(nums[:-1], nums[1:])]\r\n    return result", "ctxs": [{"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.68970346"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.6814006"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.6739352"}, {"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.67062473"}, {"id": "21304", "text": "Function: python.library.itertools#itertools.count\nSnippet: itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments.", "score": "0.66707724"}]}
{"task_id": "mbpp_504", "code": "def sum_Of_Series(n): \r\n    sum = 0\r\n    for i in range(1,n + 1): \r\n        sum += i * i*i       \r\n    return sum", "test_list": ["assert sum_Of_Series(5) == 225", "assert sum_Of_Series(2) == 9", "assert sum_Of_Series(3) == 36"], "context": "Write a python function to find the cube sum of first n natural numbers.", "function_name": "def sum_Of_Series(n):", "gold_generation": "sum = 0\r\n    for i in range(1,n + 1): \r\n        sum += i * i*i       \r\n    return sum", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.68169975"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6640764"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.6632798"}, {"id": "42569", "text": "Function: numpy.reference.generated.numpy.ndarray.sum\nSnippet: numpy.ndarray.sum method ndarray.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True) Return the sum of the array elements over the given axis. Refer to numpy.sum for full documentation. See also numpy.sum equivalent function", "score": "0.6609222"}, {"id": "43881", "text": "Function: numpy.reference.generated.numpy.recarray.sum\nSnippet: numpy.recarray.sum method recarray.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True) Return the sum of the array elements over the given axis. Refer to numpy.sum for full documentation. See also numpy.sum equivalent function", "score": "0.6564049"}]}
{"task_id": "mbpp_505", "code": "def re_order(A):\r\n    k = 0\r\n    for i in A:\r\n        if i:\r\n            A[k] = i\r\n            k = k + 1\r\n    for i in range(k, len(A)):\r\n        A[i] = 0\r\n    return A", "test_list": ["assert re_order([6, 0, 8, 2, 3, 0, 4, 0, 1]) == [6, 8, 2, 3, 4, 1, 0, 0, 0]", "assert re_order([4, 0, 2, 7, 0, 9, 0, 12, 0]) == [4, 2, 7, 9, 12, 0, 0, 0, 0]", "assert re_order([3, 11, 0, 74, 14, 0, 1, 0, 2]) == [3, 11, 74, 14, 1, 2, 0, 0, 0]"], "context": "Write a function to move all zeroes to the end of the given array.", "function_name": "def re_order(A):", "gold_generation": "k = 0\r\n    for i in A:\r\n        if i:\r\n            A[k] = i\r\n            k = k + 1\r\n    for i in range(k, len(A)):\r\n        A[i] = 0\r\n    return A", "ctxs": [{"id": "43147", "text": "Function: numpy.reference.generated.numpy.recarray\nSnippet: Peak to peak (maximum - minimum) value along a given axis. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. reshape(shape[, order]) Returns an array containing the same data with a new shape. resize(new_shape[, refcheck]) Change shape and size of array in-place. round([decimals, out]) Return a with each element rounded to the given number of decimals. searchsorted(v[, side, sorter]) Find indices where elements of v should be inserted in a to maintain order. setfield(val, dtype[, offset]) Put a value into a specified place in a field defined by a data-type. setflags([write, align, uic]) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. sort([axis, kind, order]) Sort an array in-place. squeeze([axis]) Remove axes of length one from a. std([axis, dtype, out, ddof, keepdims, where]) Returns the standard deviation of the array elements along given axis. sum([axis, dtype, out, keepdims, initial, where]) Return the sum of the array elements over the given axis. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. tobytes([order]) Construct Python bytes containing the raw data bytes in the array. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. trace([offset, axis1, axis2, dtype, out]) Return the sum along diagonals of the array. transpose(*axes) Returns a view of the array with axes transposed. var([axis, dtype, out, ddof, keepdims, where]) Returns the variance of the array elements, along given axis. view([dtype][, type]) New view of array with the same data. dot field", "score": "0.66652036"}, {"id": "42355", "text": "Function: numpy.reference.generated.numpy.ma.zeros_like\nSnippet: numpy.ma.zeros_like ma.zeros_like(*args, **kwargs) = <numpy.ma.core._convert2ma object> Return an array of zeros with the same shape and type as a given array. Parameters aarray_like The shape and data-type of a define these same attributes of the returned array. dtypedata-type, optional Overrides the data type of the result. New in version 1.6.0. order{‘C’, ‘F’, ‘A’, or ‘K’}, optional Overrides the memory layout of the result. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. New in version 1.6.0. subokbool, optional. If True, then the newly created array will use the sub-class type of a, otherwise it will be a base-class array. Defaults to True. shapeint or sequence of ints, optional. Overrides the shape of the result. If order=’K’ and the number of dimensions is unchanged, will try to keep order, otherwise, order=’C’ is implied. New in version 1.17.0. Returns outMaskedArray Array of zeros with the same shape and type as a. See also empty_like Return an empty array with shape and type of input. ones_like Return an array of ones with shape and type of input. full_like Return a new array with shape of input filled with value. zeros Return a new array setting values to zero. Examples >>> x = np.arange(6) >>> x = x.reshape((2, 3)) >>> x array([[0, 1, 2], [3, 4, 5]]) >>> np.zeros_like(x) array([[0, 0, 0], [0, 0, 0]]) >>> y = np.arange(3, dtype=float) >>> y array([0., 1., 2.]) >>> np.zeros_like(y) array([0., 0., 0.])", "score": "0.6622889"}, {"id": "17629", "text": "Function: python.library.array#array.array.append\nSnippet: array.append(x) Append a new item with value x to the end of the array.", "score": "0.6604446"}, {"id": "41679", "text": "Function: numpy.reference.generated.numpy.char.chararray.put\nSnippet: numpy.char.chararray.put method char.chararray.put(indices, values, mode='raise') Set a.flat[n] = values[n] for all n in indices. Refer to numpy.put for full documentation. See also numpy.put equivalent function", "score": "0.65922236"}, {"id": "42283", "text": "Function: numpy.reference.generated.numpy.ma.maskedarray.put\nSnippet: numpy.ma.MaskedArray.put method ma.MaskedArray.put(indices, values, mode='raise')[source] Set storage-indexed locations to corresponding values. Sets self._data.flat[n] = values[n] for each n in indices. If values is shorter than indices then it will repeat. If values has some masked values, the initial mask is updated in consequence, else the corresponding values are unmasked. Parameters indices1-D array_like Target indices, interpreted as integers. valuesarray_like Values to place in self._data copy at target indices. mode{‘raise’, ‘wrap’, ‘clip’}, optional Specifies how out-of-bounds indices will behave. ‘raise’ : raise an error. ‘wrap’ : wrap around. ‘clip’ : clip to the range. Notes values can be a scalar or length 1 array. Examples >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4) >>> x masked_array( data=[[1, --, 3], [--, 5, --], [7, --, 9]], mask=[[False, True, False], [ True, False, True], [False, True, False]], fill_value=999999) >>> x.put([0,4,8],[10,20,30]) >>> x masked_array( data=[[10, --, 3], [--, 20, --], [7, --, 30]], mask=[[False, True, False], [ True, False, True], [False, True, False]], fill_value=999999) >>> x.put(4,999) >>> x masked_array( data=[[10, --, 3], [--, 999, --], [7, --, 30]], mask=[[False, True, False], [ True, False, True], [False, True, False]], fill_value=999999)", "score": "0.65904"}]}
{"task_id": "mbpp_506", "code": "def permutation_coefficient(n, k): \r\n\tP = [[0 for i in range(k + 1)] \r\n\t\t\tfor j in range(n + 1)] \r\n\tfor i in range(n + 1): \r\n\t\tfor j in range(min(i, k) + 1): \r\n\t\t\tif (j == 0): \r\n\t\t\t\tP[i][j] = 1\r\n\t\t\telse: \r\n\t\t\t\tP[i][j] = P[i - 1][j] + ( \r\n\t\t\t\t\t\tj * P[i - 1][j - 1]) \r\n\t\t\tif (j < k): \r\n\t\t\t\tP[i][j + 1] = 0\r\n\treturn P[n][k] ", "test_list": ["assert permutation_coefficient(10, 2) == 90", "assert permutation_coefficient(10, 3) == 720", "assert permutation_coefficient(10, 1) == 10"], "context": "Write a function to calculate the permutation coefficient of given p(n, k).", "function_name": "def permutation_coefficient(n, k):", "gold_generation": "P = [[0 for i in range(k + 1)] \r\n\t\t\tfor j in range(n + 1)] \r\n\tfor i in range(n + 1): \r\n\t\tfor j in range(min(i, k) + 1): \r\n\t\t\tif (j == 0): \r\n\t\t\t\tP[i][j] = 1\r\n\t\t\telse: \r\n\t\t\t\tP[i][j] = P[i - 1][j] + ( \r\n\t\t\t\t\t\tj * P[i - 1][j - 1]) \r\n\t\t\tif (j < k): \r\n\t\t\t\tP[i][j + 1] = 0\r\n\treturn P[n][k]", "ctxs": [{"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.70524156"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.7031438"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6984283"}, {"id": "11837", "text": "Function: sklearn.modules.generated.sklearn.model_selection.permutation_test_score#sklearn.model_selection.permutation_test_score\nSnippet: obtained by chance. This is calculated as: (C + 1) / (n_permutations + 1) Where C is the number of permutations whose score >= the true score. The best possible p-value is 1/(n_permutations + 1), the worst is 1.0. Notes This function implements Test 1 in: Ojala and Garriga. Permutation Tests for Studying Classifier Performance. The Journal of Machine Learning Research (2010) vol. 11", "score": "0.6944032"}, {"id": "21787", "text": "Function: python.library.math#math.comb\nSnippet: math.comb(n, k) Return the number of ways to choose k items from n items without repetition and without order. Evaluates to n! / (k! * (n - k)!) when k <= n and evaluates to zero when k > n. Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of the expression (1 + x) ** n. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6876156"}]}
{"task_id": "mbpp_507", "code": "def remove_words(list1, removewords):\r\n    for word in list(list1):\r\n        if word in removewords:\r\n            list1.remove(word)\r\n    return list1  ", "test_list": ["assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['white', 'orange'])==['red', 'green', 'blue', 'black']", "assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['black', 'orange'])==['red', 'green', 'blue', 'white']", "assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['blue', 'white'])==['red', 'green', 'black', 'orange']"], "context": "Write a function to remove specific words from a given list.", "function_name": "def remove_words(list1, removewords):", "gold_generation": "for word in list(list1):\r\n        if word in removewords:\r\n            list1.remove(word)\r\n    return list1", "ctxs": [{"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.7002928"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.66616"}, {"id": "25756", "text": "Function: python.library.stdtypes\nSnippet: binary sequence of byte values to remove may be any bytes-like object. See removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> b'Monty Python'.rstrip(b' Python') b'M' >>> b'Monty Python'.removesuffix(b' Python') b'Monty' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3'] bytes.strip([chars]) bytearray.strip([chars]) Return a copy of the sequence with specified leading and trailing bytes removed. The chars argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters. If omitted or None, the chars argument defaults to removing ASCII whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> b' spacious '.strip() b'spacious' >>> b'www.example.com'.strip(b'cmowz.') b'example' The binary sequence of byte values to remove may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.capitalize() bytearray.capitalize() Return a copy of the sequence with each byte interpreted as an ASCII character, and the first byte capitalized and the rest", "score": "0.65930074"}, {"id": "18674", "text": "Function: python.library.collections#collections.deque.remove\nSnippet: remove(value) Remove the first occurrence of value. If not found, raises a ValueError.", "score": "0.6538897"}, {"id": "24398", "text": "Function: python.library.string\nSnippet: characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", "score": "0.6534225"}]}
{"task_id": "mbpp_508", "code": "def same_order(l1, l2):\r\n    common_elements = set(l1) & set(l2)\r\n    l1 = [e for e in l1 if e in common_elements]\r\n    l2 = [e for e in l2 if e in common_elements]\r\n    return l1 == l2", "test_list": ["assert same_order([\"red\",\"green\",\"black\",\"orange\"],[\"red\",\"pink\",\"green\",\"white\",\"black\"])==True", "assert same_order([\"red\",\"pink\",\"green\",\"white\",\"black\"],[\"white\",\"orange\",\"pink\",\"black\"])==False", "assert same_order([\"red\",\"green\",\"black\",\"orange\"],[\"red\",\"pink\",\"green\",\"white\",\"black\"])==True"], "context": "Write a function to check if the common elements between two given lists are in the same order or not.", "function_name": "def same_order(l1, l2):", "gold_generation": "common_elements = set(l1) & set(l2)\r\n    l1 = [e for e in l1 if e in common_elements]\r\n    l2 = [e for e in l2 if e in common_elements]\r\n    return l1 == l2", "ctxs": [{"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.7075851"}, {"id": "19651", "text": "Function: python.library.difflib#difflib.SequenceMatcher.ratio\nSnippet: ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5", "score": "0.68076277"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.6806464"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.680637"}, {"id": "19648", "text": "Function: python.library.difflib#difflib.SequenceMatcher.get_matching_blocks\nSnippet: get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]", "score": "0.67945564"}]}
{"task_id": "mbpp_509", "code": "def average_Odd(n) : \r\n    if (n%2==0) : \r\n        return (\"Invalid Input\") \r\n        return -1 \r\n    sm =0\r\n    count =0\r\n    while (n>=1) : \r\n        count=count+1\r\n        sm = sm + n \r\n        n = n-2\r\n    return sm//count ", "test_list": ["assert average_Odd(9) == 5", "assert average_Odd(5) == 3", "assert average_Odd(11) == 6"], "context": "Write a python function to find the average of odd numbers till a given odd number.", "function_name": "def average_Odd(n) :", "gold_generation": "if (n%2==0) : \r\n        return (\"Invalid Input\") \r\n        return -1 \r\n    sm =0\r\n    count =0\r\n    while (n>=1) : \r\n        count=count+1\r\n        sm = sm + n \r\n        n = n-2\r\n    return sm//count", "ctxs": [{"id": "42657", "text": "Function: numpy.reference.generated.numpy.average\nSnippet: >>> avg = np.average(a, weights=w) >>> print(avg.dtype) complex256", "score": "0.6839055"}, {"id": "19597", "text": "Function: python.library.decimal#decimal.ROUND_HALF_EVEN\nSnippet: decimal.ROUND_HALF_EVEN Round to nearest with ties going to nearest even integer.", "score": "0.6827142"}, {"id": "42656", "text": "Function: numpy.reference.generated.numpy.average\nSnippet: numpy.average numpy.average(a, axis=None, weights=None, returned=False)[source] Compute the weighted average along the specified axis. Parameters aarray_like Array containing data to be averaged. If a is not an array, a conversion is attempted. axisNone or int or tuple of ints, optional Axis or axes along which to average a. The default, axis=None, will average over all of the elements of the input array. If axis is negative it counts from the last to the first axis. New in version 1.7.0. If axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before. weightsarray_like, optional An array of weights associated with the values in a. Each value in a contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of a along the given axis) or of the same shape as a. If weights=None, then all data in a are assumed to have a weight equal to one. The 1-D calculation is: avg = sum(a * weights) / sum(weights) The only constraint on weights is that sum(weights) must not be 0. returnedbool, optional Default is False. If True, the tuple (average, sum_of_weights) is returned, otherwise only the average is returned. If weights=None, sum_of_weights is equivalent to the number of elements over which the average is taken. Returns retval, [sum_of_weights]array_type or double Return the average along the specified axis. When returned is True, return a tuple with the average as the first element and the sum of the weights as the second element. sum_of_weights is of the same type as retval. The result dtype follows a genereal pattern. If weights is None, the result dtype will be that of a , or float64 if a is integral. Otherwise, if weights is not None and a is non- integral, the result type will be the type of lowest precision capable of representing values of both a and weights. If a happens to be integral, the previous rules still applies but the result dtype will at least be float64. Raises ZeroDivisionError When all weights along axis are zero. See numpy.ma.average for a version robust to this type of error. TypeError When the length of 1D weights is not the same as the shape of a along axis. See also mean ma.average average for masked arrays – useful if your data contains “missing” values numpy.result_type Returns the type that results from applying the numpy type promotion rules to the arguments. Examples >>> data = np.arange(1, 5) >>> data array([1, 2, 3, 4]) >>> np.average(data) 2.5 >>> np.average(np.arange(1, 11), weights=np.arange(10, 0, -1)) 4.0 >>> data = np.arange(6).reshape((3,2)) >>> data array([[0, 1], [2, 3], [4, 5]]) >>> np.average(data, axis=1, weights=[1./4, 3./4]) array([0.75, 2.75, 4.75]) >>> np.average(data, weights=[1./4, 3./4]) Traceback (most recent call last): ... TypeError: Axis must be specified when shapes of a and weights differ. >>> a = np.ones(5, dtype=np.float128) >>> w = np.ones(5, dtype=np.complex64)", "score": "0.6770625"}, {"id": "15976", "text": "Function: pandas.reference.api.pandas.tseries.offsets.easter.n\nSnippet: pandas.tseries.offsets.Easter.n Easter.n", "score": "0.66848195"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6616814"}]}
{"task_id": "mbpp_510", "code": "def no_of_subsequences(arr, k): \r\n\tn = len(arr) \r\n\tdp = [[0 for i in range(n + 1)] \r\n\t\t\tfor j in range(k + 1)] \r\n\tfor i in range(1, k + 1): \r\n\t\tfor j in range(1, n + 1): \r\n\t\t\tdp[i][j] = dp[i][j - 1] \r\n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \r\n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\r\n\treturn dp[k][n]", "test_list": ["assert no_of_subsequences([1,2,3,4], 10) == 11", "assert no_of_subsequences([4,8,7,2], 50) == 9", "assert no_of_subsequences([5,6,7,8], 15) == 4"], "context": "Write a function to find the number of subsequences having product smaller than k for the given non negative array.", "function_name": "def no_of_subsequences(arr, k):", "gold_generation": "n = len(arr) \r\n\tdp = [[0 for i in range(n + 1)] \r\n\t\t\tfor j in range(k + 1)] \r\n\tfor i in range(1, k + 1): \r\n\t\tfor j in range(1, n + 1): \r\n\t\t\tdp[i][j] = dp[i][j - 1] \r\n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0: \r\n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\r\n\treturn dp[k][n]", "ctxs": [{"id": "18260", "text": "Function: python.library.stdtypes#bytearray.count\nSnippet: bytes.count(sub[, start[, end]]) bytearray.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.67448866"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6699806"}, {"id": "18304", "text": "Function: python.library.stdtypes#bytes.count\nSnippet: bytes.count(sub[, start[, end]]) bytearray.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.6666975"}, {"id": "18264", "text": "Function: python.library.stdtypes#bytearray.find\nSnippet: bytes.find(sub[, start[, end]]) bytearray.find(sub[, start[, end]]) Return the lowest index in the data where the subsequence sub is found, such that sub is contained in the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> b'Py' in b'Python' True Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.6636654"}, {"id": "18308", "text": "Function: python.library.stdtypes#bytes.find\nSnippet: bytes.find(sub[, start[, end]]) bytearray.find(sub[, start[, end]]) Return the lowest index in the data where the subsequence sub is found, such that sub is contained in the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> b'Py' in b'Python' True Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.6595208"}]}
