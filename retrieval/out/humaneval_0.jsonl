{"task_id": "humaneval_0", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n", "entry_point": "has_close_elements", "gold_generation": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n", "context": "Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "function_name": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:", "ctxs": [{"id": "18470", "text": "Function: python.library.cmath#cmath.isclose\nSnippet: cmath.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality", "score": "0.76403606"}, {"id": "21808", "text": "Function: python.library.math#math.isclose\nSnippet: math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality", "score": "0.7579555"}, {"id": "6619", "text": "Function: torch.generated.torch.isclose#torch.isclose\nSnippet: torch.isclose(input, other, rtol=1e-05, atol=1e-08, equal_nan=False) → Tensor Returns a new tensor with boolean elements representing if each element of input is “close” to the corresponding element of other. Closeness is defined as: ∣input−other∣≤atol+rtol×∣other∣\\lvert \\text{input} - \\text{other} \\rvert \\leq \\texttt{atol} + \\texttt{rtol} \\times \\lvert \\text{other} \\rvert where input and other are finite. Where input and/or other are nonfinite they are close if and only if they are equal, with NaNs being considered equal to each other when equal_nan is True. Parameters input (Tensor) – first tensor to compare other (Tensor) – second tensor to compare atol (float, optional) – absolute tolerance. Default: 1e-08 rtol (float, optional) – relative tolerance. Default: 1e-05 equal_nan (bool, optional) – if True, then two NaN s will be considered equal. Default: False Examples: >>> torch.isclose(torch.tensor((1., 2, 3)), torch.tensor((1 + 1e-10, 3, 4))) tensor([ True, False, False]) >>> torch.isclose(torch.tensor((float('inf'), 4)), torch.tensor((float('inf'), 6)), rtol=.5) tensor([True, True])", "score": "0.7250455"}, {"id": "42613", "text": "Function: numpy.reference.generated.numpy.allclose\nSnippet: numpy.allclose numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)[source] Returns True if two arrays are element-wise equal within a tolerance. The tolerance values are positive, typically very small numbers. The relative difference (rtol * abs(b)) and the absolute difference atol are added together to compare against the absolute difference between a and b. NaNs are treated as equal if they are in the same place and if equal_nan=True. Infs are treated as equal if they are in the same place and of the same sign in both arrays. Parameters a, barray_like Input arrays to compare. rtolfloat The relative tolerance parameter (see Notes). atolfloat The absolute tolerance parameter (see Notes). equal_nanbool Whether to compare NaN’s as equal. If True, NaN’s in a will be considered equal to NaN’s in b in the output array. New in version 1.10.0. Returns allclosebool Returns True if the two arrays are equal within the given tolerance; False otherwise. See also isclose, all, any, equal Notes If the following equation is element-wise True, then allclose returns True. absolute(a - b) <= (atol + rtol * absolute(b)) The above equation is not symmetric in a and b, so that allclose(a, b) might be different from allclose(b, a) in some rare cases. The comparison of a and b uses standard broadcasting, which means that a and b need not have the same shape in order for allclose(a, b) to evaluate to True. The same is true for equal but not array_equal. allclose is not defined for non-numeric data types. bool is considered a numeric data-type for this purpose. Examples >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8]) False >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9]) True >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9]) False >>> np.allclose([1.0, np.nan], [1.0, np.nan]) False >>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True) True", "score": "0.72126544"}, {"id": "42912", "text": "Function: numpy.reference.generated.numpy.isclose\nSnippet: numpy.isclose numpy.isclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)[source] Returns a boolean array where two arrays are element-wise equal within a tolerance. The tolerance values are positive, typically very small numbers. The relative difference (rtol * abs(b)) and the absolute difference atol are added together to compare against the absolute difference between a and b. Warning The default atol is not appropriate for comparing numbers that are much smaller than one (see Notes). Parameters a, barray_like Input arrays to compare. rtolfloat The relative tolerance parameter (see Notes). atolfloat The absolute tolerance parameter (see Notes). equal_nanbool Whether to compare NaN’s as equal. If True, NaN’s in a will be considered equal to NaN’s in b in the output array. Returns yarray_like Returns a boolean array of where a and b are equal within the given tolerance. If both a and b are scalars, returns a single boolean value. See also allclose math.isclose Notes New in version 1.7.0. For finite values, isclose uses the following equation to test whether two floating point values are equivalent. absolute(a - b) <= (atol + rtol * absolute(b)) Unlike the built-in math.isclose, the above equation is not symmetric in a and b – it assumes b is the reference value – so that isclose(a, b) might be different from isclose(b, a). Furthermore, the default value of atol is not zero, and is used to determine what small values should be considered close to zero. The default value is appropriate for expected values of order unity: if the expected values are significantly smaller than one, it can result in false positives. atol should be carefully selected for the use case at hand. A zero value for atol will result in False if either a or b is zero. isclose is not defined for non-numeric data types. bool is considered a numeric data-type for this purpose. Examples >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8]) array([ True, False]) >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9]) array([ True, True]) >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9]) array([False, True]) >>> np.isclose([1.0, np.nan], [1.0, np.nan]) array([ True, False]) >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True) array([ True, True]) >>> np.isclose([1e-8, 1e-7], [0.0, 0.0]) array([ True, False]) >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0) array([False, False]) >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0]) array([ True, True]) >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0) array([False, True])", "score": "0.7145623"}]}
{"task_id": "humaneval_1", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n", "entry_point": "separate_paren_groups", "gold_generation": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n", "context": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "function_name": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:", "ctxs": [{"id": "23341", "text": "Function: python.library.re#re.Match.group\nSnippet: Match.group([group1, ...]) Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an IndexError exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is None. If a group is contained in a part of the pattern that matched multiple times, the last match is returned. >>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\") >>> m.group(0) # The entire match 'Isaac Newton' >>> m.group(1) # The first parenthesized subgroup. 'Isaac' >>> m.group(2) # The second parenthesized subgroup. 'Newton' >>> m.group(1, 2) # Multiple arguments give us a tuple. ('Isaac', 'Newton') If the regular expression uses the (?P<name>...) syntax, the groupN arguments may also be strings identifying groups by their group name. If a string argument is not used as a group name in the pattern, an IndexError exception is raised. A moderately complicated example: >>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm Reynolds\") >>> m.group('first_name') 'Malcolm' >>> m.group('last_name') 'Reynolds' Named groups can also be referred to by their index: >>> m.group(1) 'Malcolm' >>> m.group(2) 'Reynolds' If a group matches multiple times, only the last match is accessible: >>> m = re.match(r\"(..)+\", \"a1b2c3\") # Matches 3 times. >>> m.group(1) # Returns only the last match. 'c3'", "score": "0.71373785"}, {"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.70902115"}, {"id": "24398", "text": "Function: python.library.string\nSnippet: characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", "score": "0.6861882"}, {"id": "15367", "text": "Function: pandas.reference.api.pandas.series.str.split\nSnippet: pandas.Series.str.split Series.str.split(pat=None, n=- 1, expand=False, *, regex=None)[source] Split strings around given separator/delimiter. Splits the string in the Series/Index from the beginning, at the specified delimiter string. Parameters pat:str or compiled regex, optional String or regular expression to split on. If not specified, split on whitespace. n:int, default -1 (all) Limit number of splits in output. None, 0 and -1 will be interpreted as return all splits. expand:bool, default False Expand the split strings into separate columns. If True, return DataFrame/MultiIndex expanding dimensionality. If False, return Series/Index, containing lists of strings. regex:bool, default None Determines if the passed-in pattern is a regular expression: If True, assumes the passed-in pattern is a regular expression If False, treats the pattern as a literal string. If None and pat length is 1, treats pat as a literal string. If None and pat length is not 1, treats pat as a regular expression. Cannot be set to False if pat is a compiled regex New in version 1.4.0. Returns Series, Index, DataFrame or MultiIndex Type matches caller unless expand=True (see Notes). Raises ValueError if regex is False and pat is a compiled regex See also Series.str.split Split strings around given separator/delimiter. Series.str.rsplit Splits string around given separator/delimiter, starting from the right. Series.str.join Join lists contained as elements in the Series/Index with passed delimiter. str.split Standard library version for split. str.rsplit Standard library version for rsplit. Notes The handling of the n keyword depends on the number of found splits: If found splits > n, make first n splits only If found splits <= n, make all splits If for a certain row the number of found splits < n, append None for padding up to n if expand=True If using expand=True, Series and Index callers return DataFrame and MultiIndex objects, respectively. Use of regex=False with a pat as a compiled regex will raise an error. Examples >>> s = pd.Series( ... [ ... \"this is a regular sentence\", ... \"https://docs.python.org/3/tutorial/index.html\", ... np.nan ... ] ... ) >>> s 0 this is a regular sentence 1 https://docs.python.org/3/tutorial/index.html 2 NaN dtype: object In the default setting, the string is split by whitespace. >>> s.str.split() 0 [this, is, a, regular, sentence] 1 [https://docs.python.org/3/tutorial/index.html] 2 NaN dtype: object Without the n parameter, the outputs of rsplit and split are identical. >>> s.str.rsplit() 0 [this, is, a, regular, sentence] 1 [https://docs.python.org/3/tutorial/index.html] 2 NaN dtype: object The n parameter can be used to limit the number of splits on the delimiter. The outputs of split and rsplit are different. >>> s.str.split(n=2) 0 [this, is, a regular sentence] 1 [https://docs.python.org/3/tutorial/index.html] 2 NaN dtype: object >>> s.str.rsplit(n=2) 0 [this is a, regular, sentence] 1 [https://docs.python.org/3/tutorial/index.html] 2 NaN dtype: object The pat parameter can be used to split by other characters. >>> s.str.split(pat=\"/\") 0 [this is a regular sentence] 1 [https:, , docs.python.org, 3, tutorial, index... 2 NaN dtype: object When using expand=True, the split elements will expand out into separate columns. If NaN is present, it is propagated throughout the columns during the", "score": "0.68286586"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.681883"}]}
{"task_id": "humaneval_2", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n", "entry_point": "truncate_number", "gold_generation": "    return number % 1.0\n", "context": "Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5", "function_name": "def truncate_number(number: float) -> float:", "ctxs": [{"id": "19467", "text": "Function: python.library.decimal#decimal.Context.divide_int\nSnippet: divide_int(x, y) Return x divided by y, truncated to an integer.", "score": "0.7627426"}, {"id": "19496", "text": "Function: python.library.decimal#decimal.Context.next_minus\nSnippet: next_minus(x) Returns the largest representable number smaller than x.", "score": "0.7506951"}, {"id": "19558", "text": "Function: python.library.decimal#decimal.Decimal.next_minus\nSnippet: next_minus(context=None) Return the largest number representable in the given context (or in the current thread’s context if no context is given) that is smaller than the given operand.", "score": "0.74679786"}, {"id": "21835", "text": "Function: python.library.math#math.trunc\nSnippet: math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__().", "score": "0.73095596"}, {"id": "19516", "text": "Function: python.library.decimal#decimal.Decimal\nSnippet: class decimal.Decimal(value=\"0\", context=None) Construct a new Decimal object based from value. value can be an integer, string, tuple, float, or another Decimal object. If no value is given, returns Decimal('0'). If value is a string, it should conform to the decimal numeric string syntax after leading and trailing whitespace characters, as well as underscores throughout, are removed: sign ::= '+' | '-' digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' indicator ::= 'e' | 'E' digits ::= digit [digit]... decimal-part ::= digits '.' [digits] | ['.'] digits exponent-part ::= indicator [sign] digits infinity ::= 'Infinity' | 'Inf' nan ::= 'NaN' [digits] | 'sNaN' [digits] numeric-value ::= decimal-part [exponent-part] | infinity numeric-string ::= [sign] numeric-value | [sign] nan Other Unicode decimal digits are also permitted where digit appears above. These include decimal digits from various other alphabets (for example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits '\\uff10' through '\\uff19'. If value is a tuple, it should have three components, a sign (0 for positive or 1 for negative), a tuple of digits, and an integer exponent. For example, Decimal((0, (1, 4, 1, 4), -3)) returns Decimal('1.414'). If value is a float, the binary floating point value is losslessly converted to its exact decimal equivalent. This conversion can often require 53 or more digits of precision. For example, Decimal(float('1.1')) converts to Decimal('1.100000000000000088817841970012523233890533447265625'). The context precision does not affect how many digits are stored. That is determined exclusively by the number of digits in value. For example, Decimal('3.00000') records all five zeros even if the context precision is only three. The purpose of the context argument is determining what to do if value is a malformed string. If the context traps InvalidOperation, an exception is raised; otherwise, the constructor returns a new Decimal with the value of NaN. Once constructed, Decimal objects are immutable. Changed in version 3.2: The argument to the constructor is now permitted to be a float instance. Changed in version 3.3: float arguments raise an exception if the FloatOperation trap is set. By default the trap is off. Changed in version 3.6: Underscores are allowed for grouping, as with integral and floating-point literals in code. Decimal floating point objects share many properties with the other built-in numeric types such as float and int. All of the usual math operations and special methods apply. Likewise, decimal objects can be copied, pickled, printed, used as dictionary keys, used as set elements, compared, sorted, and coerced to another type (such as float or int). There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator % is applied to Decimal objects, the sign of the result is the sign of the dividend rather than the sign of the divisor: >>> (-7) % 4 1 >>> Decimal(-7) % Decimal(4) Decimal('-3') The integer division operator // behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather", "score": "0.7208394"}]}
{"task_id": "humaneval_3", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "entry_point": "below_zero", "gold_generation": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "context": "You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "function_name": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:", "ctxs": [{"id": "19546", "text": "Function: python.library.decimal#decimal.Decimal.is_zero\nSnippet: is_zero() Return True if the argument is a (positive or negative) zero and False otherwise.", "score": "0.743661"}, {"id": "19482", "text": "Function: python.library.decimal#decimal.Context.is_zero\nSnippet: is_zero(x) Returns True if x is a zero; otherwise returns False.", "score": "0.73100066"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.6988301"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.6953344"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.6947286"}]}
{"task_id": "humaneval_4", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n", "entry_point": "mean_absolute_deviation", "gold_generation": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n", "context": "For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "function_name": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:", "ctxs": [{"id": "14121", "text": "Function: pandas.reference.api.pandas.core.groupby.dataframegroupby.mad\nSnippet: pandas.core.groupby.DataFrameGroupBy.mad propertyDataFrameGroupBy.mad Return the mean absolute deviation of the values over the requested axis. Parameters axis:{index (0), columns (1)} Axis for the function to be applied on. skipna:bool, default True Exclude NA/null values when computing the result. level:int or level name, default None If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a Series. Returns Series or DataFrame (if level specified)", "score": "0.76614106"}, {"id": "14393", "text": "Function: pandas.reference.api.pandas.dataframe.mad\nSnippet: pandas.DataFrame.mad DataFrame.mad(axis=None, skipna=True, level=None)[source] Return the mean absolute deviation of the values over the requested axis. Parameters axis:{index (0), columns (1)} Axis for the function to be applied on. skipna:bool, default True Exclude NA/null values when computing the result. level:int or level name, default None If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a Series. Returns Series or DataFrame (if level specified)", "score": "0.7491016"}, {"id": "15224", "text": "Function: pandas.reference.api.pandas.series.mad\nSnippet: pandas.Series.mad Series.mad(axis=None, skipna=True, level=None)[source] Return the mean absolute deviation of the values over the requested axis. Parameters axis:{index (0)} Axis for the function to be applied on. skipna:bool, default True Exclude NA/null values when computing the result. level:int or level name, default None If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar. Returns scalar or Series (if level specified)", "score": "0.7360598"}, {"id": "24307", "text": "Function: python.library.statistics#statistics.mean\nSnippet: statistics.mean(data) Return the sample arithmetic mean of data which can be a sequence or iterable. The arithmetic mean is the sum of the data divided by the number of data points. It is commonly called “the average”, although it is only one of many different mathematical averages. It is a measure of the central location of the data. If data is empty, StatisticsError will be raised. Some examples of use: >>> mean([1, 2, 3, 4, 4]) 2.8 >>> mean([-1.0, 2.5, 3.25, 5.75]) 2.625 >>> from fractions import Fraction as F >>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)]) Fraction(13, 21) >>> from decimal import Decimal as D >>> mean([D(\"0.5\"), D(\"0.75\"), D(\"0.625\"), D(\"0.375\")]) Decimal('0.5625') Note The mean is strongly affected by outliers and is not a robust estimator for central location: the mean is not necessarily a typical example of the data points. For more robust measures of central location, see median() and mode(). The sample mean gives an unbiased estimate of the true population mean, so that when taken on average over all the possible samples, mean(sample) converges on the true mean of the entire population. If data represents the entire population rather than a sample, then mean(data) is equivalent to calculating the true population mean μ.", "score": "0.71215856"}, {"id": "42344", "text": "Function: numpy.reference.generated.numpy.ma.std\nSnippet: numpy.ma.std ma.std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>) = <numpy.ma.core._frommethod object> Returns the standard deviation of the array elements along given axis. Masked entries are ignored. Refer to numpy.std for full documentation. See also numpy.ndarray.std corresponding function for ndarrays numpy.std Equivalent function", "score": "0.7099263"}]}
{"task_id": "humaneval_5", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n", "entry_point": "intersperse", "gold_generation": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n", "context": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]", "function_name": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:", "ctxs": [{"id": "17639", "text": "Function: python.library.array#array.array.insert\nSnippet: array.insert(i, x) Insert a new item with value x in the array before position i. Negative values are treated as being relative to the end of the array.", "score": "0.6987909"}, {"id": "21291", "text": "Function: python.library.itertools\nSnippet: = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1. itertools.compress(data, selectors) Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F return (d for d, s in zip(data, selectors) if s) New in version 3.1. itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments. itertools.cycle(iterable) Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') --> A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable). itertools.dropwhile(predicate, iterable) Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to: def dropwhile(predicate, iterable): # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None) Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function. The operation of groupby() is similar to the uniq filter in Unix. It generates a", "score": "0.6875606"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.6801597"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.67271066"}, {"id": "42900", "text": "Function: numpy.reference.generated.numpy.insert\nSnippet: numpy.insert numpy.insert(arr, obj, values, axis=None)[source] Insert values along the given axis before the given indices. Parameters arrarray_like Input array. objint, slice or sequence of ints Object that defines the index or indices before which values is inserted. New in version 1.8.0. Support for multiple insertions when obj is a single scalar or a sequence with one element (similar to calling insert multiple times). valuesarray_like Values to insert into arr. If the type of values is different from that of arr, values is converted to the type of arr. values should be shaped so that arr[...,obj,...] = values is legal. axisint, optional Axis along which to insert values. If axis is None then arr is flattened first. Returns outndarray A copy of arr with values inserted. Note that insert does not occur in-place: a new array is returned. If axis is None, out is a flattened array. See also append Append elements at the end of an array. concatenate Join a sequence of arrays along an existing axis. delete Delete elements from an array. Notes Note that for higher dimensional inserts obj=0 behaves very different from obj=[0] just like arr[:,0,:] = values is different from arr[:,[0],:] = values. Examples >>> a = np.array([[1, 1], [2, 2], [3, 3]]) >>> a array([[1, 1], [2, 2], [3, 3]]) >>> np.insert(a, 1, 5) array([1, 5, 1, ..., 2, 3, 3]) >>> np.insert(a, 1, 5, axis=1) array([[1, 5, 1], [2, 5, 2], [3, 5, 3]]) Difference between sequence and scalars: >>> np.insert(a, [1], [[1],[2],[3]], axis=1) array([[1, 1, 1], [2, 2, 2], [3, 3, 3]]) >>> np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1), ... np.insert(a, [1], [[1],[2],[3]], axis=1)) True >>> b = a.flatten() >>> b array([1, 1, 2, 2, 3, 3]) >>> np.insert(b, [2, 2], [5, 6]) array([1, 1, 5, ..., 2, 3, 3]) >>> np.insert(b, slice(2, 4), [5, 6]) array([1, 1, 5, ..., 2, 3, 3]) >>> np.insert(b, [2, 2], [7.13, False]) # type casting array([1, 1, 7, ..., 2, 3, 3]) >>> x = np.arange(8).reshape(2, 4) >>> idx = (1, 3) >>> np.insert(x, idx, 999, axis=1) array([[ 0, 999, 1, 2, 999, 3], [ 4, 999, 5, 6, 999, 7]])", "score": "0.67239296"}]}
{"task_id": "humaneval_6", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n", "entry_point": "parse_nested_parens", "gold_generation": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n", "context": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]", "function_name": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:", "ctxs": [{"id": "24412", "text": "Function: python.library.string#string.Formatter.parse\nSnippet: parse(format_string) Loop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields. The values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None.", "score": "0.687164"}, {"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.681047"}, {"id": "23341", "text": "Function: python.library.re#re.Match.group\nSnippet: Match.group([group1, ...]) Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an IndexError exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is None. If a group is contained in a part of the pattern that matched multiple times, the last match is returned. >>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\") >>> m.group(0) # The entire match 'Isaac Newton' >>> m.group(1) # The first parenthesized subgroup. 'Isaac' >>> m.group(2) # The second parenthesized subgroup. 'Newton' >>> m.group(1, 2) # Multiple arguments give us a tuple. ('Isaac', 'Newton') If the regular expression uses the (?P<name>...) syntax, the groupN arguments may also be strings identifying groups by their group name. If a string argument is not used as a group name in the pattern, an IndexError exception is raised. A moderately complicated example: >>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm Reynolds\") >>> m.group('first_name') 'Malcolm' >>> m.group('last_name') 'Reynolds' Named groups can also be referred to by their index: >>> m.group(1) 'Malcolm' >>> m.group(2) 'Reynolds' If a group matches multiple times, only the last match is accessible: >>> m = re.match(r\"(..)+\", \"a1b2c3\") # Matches 3 times. >>> m.group(1) # Returns only the last match. 'c3'", "score": "0.6717904"}, {"id": "23302", "text": "Function: python.library.re\nSnippet: a FutureWarning will be raised in ambiguous cases for the time being. That includes sets starting with a literal '[' or containing literal character sequences '--', '&&', '~~', and '||'. To avoid a warning escape them with a backslash. Changed in version 3.7: FutureWarning is raised if a character set contains constructs that will change semantically in the future. | A|B, where A and B can be arbitrary REs, creates a regular expression that will match either A or B. An arbitrary number of REs can be separated by the '|' in this way. This can be used inside groups (see below) as well. As the target string is scanned, REs separated by '|' are tried from left to right. When one pattern completely matches, that branch is accepted. This means that once A matches, B will not be tested further, even if it would produce a longer overall match. In other words, the '|' operator is never greedy. To match a literal '|', use \\|, or enclose it inside a character class, as in [|]. (...) Matches whatever regular expression is inside the parentheses, and indicates the start and end of a group; the contents of a group can be retrieved after a match has been performed, and can be matched later in the string with the \\number special sequence, described below. To match the literals '(' or ')', use \\( or \\), or enclose them inside a character class: [(], [)]. (?...) This is an extension notation (a '?' following a '(' is not meaningful otherwise). The first character after the '?' determines what the meaning and further syntax of the construct is. Extensions usually do not create a new group; (?P<name>...) is the only exception to this rule. Following are the currently supported extensions. (?aiLmsux) (One or more letters from the set 'a', 'i', 'L', 'm', 's', 'u', 'x'.) The group matches the empty string; the letters set the corresponding flags: re.A (ASCII-only matching), re.I (ignore case), re.L (locale dependent), re.M (multi-line), re.S (dot matches all), re.U (Unicode matching), and re.X (verbose), for the entire regular expression. (The flags are described in Module Contents.) This is useful if you wish to include the flags as part of the regular expression, instead of passing a flag argument to the re.compile() function. Flags should be used first in the expression string. (?:...) A non-capturing version of regular parentheses. Matches whatever regular expression is inside the parentheses, but the substring matched by the group cannot be retrieved after performing a match or referenced later in the pattern. (?aiLmsux-imsx:...) (Zero or more letters from the set 'a', 'i', 'L', 'm', 's', 'u', 'x', optionally followed by '-' followed by one or more letters from the 'i', 'm', 's', 'x'.) The letters set or remove the corresponding flags: re.A (ASCII-only matching), re.I (ignore case), re.L (locale dependent), re.M (multi-line), re.S (dot matches all), re.U (Unicode matching), and re.X (verbose), for the part of the expression. (The flags are described in Module Contents.)", "score": "0.669647"}, {"id": "15362", "text": "Function: pandas.reference.api.pandas.series.str.rsplit\nSnippet: pandas.Series.str.rsplit Series.str.rsplit(pat=None, n=- 1, expand=False)[source] Split strings around given separator/delimiter. Splits the string in the Series/Index from the end, at the specified delimiter string. Parameters pat:str or compiled regex, optional String or regular expression to split on. If not specified, split on whitespace. n:int, default -1 (all) Limit number of splits in output. None, 0 and -1 will be interpreted as return all splits. expand:bool, default False Expand the split strings into separate columns. If True, return DataFrame/MultiIndex expanding dimensionality. If False, return Series/Index, containing lists of strings. regex:bool, default None Determines if the passed-in pattern is a regular expression: If True, assumes the passed-in pattern is a regular expression If False, treats the pattern as a literal string. If None and pat length is 1, treats pat as a literal string. If None and pat length is not 1, treats pat as a regular expression. Cannot be set to False if pat is a compiled regex New in version 1.4.0. Returns Series, Index, DataFrame or MultiIndex Type matches caller unless expand=True (see Notes). Raises ValueError if regex is False and pat is a compiled regex See also Series.str.split Split strings around given separator/delimiter. Series.str.rsplit Splits string around given separator/delimiter, starting from the right. Series.str.join Join lists contained as elements in the Series/Index with passed delimiter. str.split Standard library version for split. str.rsplit Standard library version for rsplit. Notes The handling of the n keyword depends on the number of found splits: If found splits > n, make first n splits only If found splits <= n, make all splits If for a certain row the number of found splits < n, append None for padding up to n if expand=True If using expand=True, Series and Index callers return DataFrame and MultiIndex objects, respectively. Use of regex=False with a pat as a compiled regex will raise an error. Examples >>> s = pd.Series( ... [ ... \"this is a regular sentence\", ... \"https://docs.python.org/3/tutorial/index.html\", ... np.nan ... ] ... ) >>> s 0 this is a regular sentence 1 https://docs.python.org/3/tutorial/index.html 2 NaN dtype: object In the default setting, the string is split by whitespace. >>> s.str.split() 0 [this, is, a, regular, sentence] 1 [https://docs.python.org/3/tutorial/index.html] 2 NaN dtype: object Without the n parameter, the outputs of rsplit and split are identical. >>> s.str.rsplit() 0 [this, is, a, regular, sentence] 1 [https://docs.python.org/3/tutorial/index.html] 2 NaN dtype: object The n parameter can be used to limit the number of splits on the delimiter. The outputs of split and rsplit are different. >>> s.str.split(n=2) 0 [this, is, a regular sentence] 1 [https://docs.python.org/3/tutorial/index.html] 2 NaN dtype: object >>> s.str.rsplit(n=2) 0 [this is a, regular, sentence] 1 [https://docs.python.org/3/tutorial/index.html] 2 NaN dtype: object The pat parameter can be used to split by other characters. >>> s.str.split(pat=\"/\") 0 [this is a regular sentence] 1 [https:, , docs.python.org, 3, tutorial, index... 2 NaN dtype: object When using expand=True, the split elements will expand out into separate columns. If NaN is present, it is propagated throughout the columns during the split. >>>", "score": "0.6691365"}]}
{"task_id": "humaneval_7", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n", "entry_point": "filter_by_substring", "gold_generation": "    return [x for x in strings if substring in x]\n", "context": "Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']", "function_name": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:", "ctxs": [{"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6923384"}, {"id": "24349", "text": "Function: python.library.stdtypes#str.index\nSnippet: str.index(sub[, start[, end]]) Like find(), but raise ValueError when the substring is not found.", "score": "0.69074553"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6863683"}, {"id": "24346", "text": "Function: python.library.stdtypes#str.find\nSnippet: str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True", "score": "0.68186224"}, {"id": "41778", "text": "Function: numpy.reference.generated.numpy.chararray.find\nSnippet: numpy.chararray.find method chararray.find(sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. See also char.find", "score": "0.6786493"}]}
{"task_id": "humaneval_8", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "entry_point": "sum_product", "gold_generation": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "context": "For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)", "function_name": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:", "ctxs": [{"id": "21826", "text": "Function: python.library.math#math.prod\nSnippet: math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8.", "score": "0.7342825"}, {"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.7028711"}, {"id": "42345", "text": "Function: numpy.reference.generated.numpy.ma.sum\nSnippet: numpy.ma.sum ma.sum(self, axis=None, dtype=None, out=None, keepdims=<no value>) = <numpy.ma.core._frommethod object> Return the sum of the array elements over the given axis. Masked elements are set to 0 internally. Refer to numpy.sum for full documentation. See also numpy.ndarray.sum corresponding function for ndarrays numpy.sum equivalent function Examples >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4) >>> x masked_array( data=[[1, --, 3], [--, 5, --], [7, --, 9]], mask=[[False, True, False], [ True, False, True], [False, True, False]], fill_value=999999) >>> x.sum() 25 >>> x.sum(axis=1) masked_array(data=[4, 5, 16], mask=[False, False, False], fill_value=999999) >>> x.sum(axis=0) masked_array(data=[8, 5, 12], mask=[False, False, False], fill_value=999999) >>> print(type(x.sum(axis=0, dtype=np.int64)[0])) <class 'numpy.int64'>", "score": "0.69475377"}, {"id": "43210", "text": "Function: numpy.reference.generated.numpy.sum\nSnippet: numpy.sum numpy.sum(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)[source] Sum of array elements over a given axis. Parameters aarray_like Elements to sum. axisNone or int or tuple of ints, optional Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis. New in version 1.7.0. If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before. dtypedtype, optional The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. outndarray, optional Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary. keepdimsbool, optional If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the sum method of sub-classes of ndarray, however any non-default value will be. If the sub-class’ method does not implement keepdims any exceptions will be raised. initialscalar, optional Starting value for the sum. See reduce for details. New in version 1.15.0. wherearray_like of bool, optional Elements to include in the sum. See reduce for details. New in version 1.17.0. Returns sum_along_axisndarray An array with the same shape as a, with the specified axis removed. If a is a 0-d array, or if axis is None, a scalar is returned. If an output array is specified, a reference to out is returned. See also ndarray.sum Equivalent method. add.reduce Equivalent functionality of add. cumsum Cumulative sum of array elements. trapz Integration of array values using the composite trapezoidal rule. mean, average Notes Arithmetic is modular when using integer types, and no error is raised on overflow. The sum of an empty array is the neutral element 0: >>> np.sum([]) 0.0 For floating point numbers the numerical precision of sum (and np.add.reduce) is in general limited by directly adding each number individually to the result causing rounding errors in every step. However, often numpy will use a numerically better approach (partial pairwise summation) leading to improved precision in many use-cases. This improved precision is always provided when no axis is given. When axis is given, it will depend on which axis is summed. Technically, to provide the best speed possible, the improved precision is only used when", "score": "0.6889119"}, {"id": "42298", "text": "Function: numpy.reference.generated.numpy.ma.maskedarray.sum\nSnippet: numpy.ma.MaskedArray.sum method ma.MaskedArray.sum(axis=None, dtype=None, out=None, keepdims=<no value>)[source] Return the sum of the array elements over the given axis. Masked elements are set to 0 internally. Refer to numpy.sum for full documentation. See also numpy.ndarray.sum corresponding function for ndarrays numpy.sum equivalent function Examples >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4) >>> x masked_array( data=[[1, --, 3], [--, 5, --], [7, --, 9]], mask=[[False, True, False], [ True, False, True], [False, True, False]], fill_value=999999) >>> x.sum() 25 >>> x.sum(axis=1) masked_array(data=[4, 5, 16], mask=[False, False, False], fill_value=999999) >>> x.sum(axis=0) masked_array(data=[8, 5, 12], mask=[False, False, False], fill_value=999999) >>> print(type(x.sum(axis=0, dtype=np.int64)[0])) <class 'numpy.int64'>", "score": "0.68830717"}]}
{"task_id": "humaneval_9", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n", "entry_point": "rolling_max", "gold_generation": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n", "context": "From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]", "function_name": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:", "ctxs": [{"id": "43160", "text": "Function: numpy.reference.generated.numpy.roll\nSnippet: numpy.roll numpy.roll(a, shift, axis=None)[source] Roll array elements along a given axis. Elements that roll beyond the last position are re-introduced at the first. Parameters aarray_like Input array. shiftint or tuple of ints The number of places by which elements are shifted. If a tuple, then axis must be a tuple of the same size, and each of the given axes is shifted by the corresponding number. If an int while axis is a tuple of ints, then the same value is used for all given axes. axisint or tuple of ints, optional Axis or axes along which elements are shifted. By default, the array is flattened before shifting, after which the original shape is restored. Returns resndarray Output array, with the same shape as a. See also rollaxis Roll the specified axis backwards, until it lies in a given position. Notes New in version 1.12.0. Supports rolling over multiple dimensions simultaneously. Examples >>> x = np.arange(10) >>> np.roll(x, 2) array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7]) >>> np.roll(x, -2) array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1]) >>> x2 = np.reshape(x, (2, 5)) >>> x2 array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) >>> np.roll(x2, 1) array([[9, 0, 1, 2, 3], [4, 5, 6, 7, 8]]) >>> np.roll(x2, -1) array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 0]]) >>> np.roll(x2, 1, axis=0) array([[5, 6, 7, 8, 9], [0, 1, 2, 3, 4]]) >>> np.roll(x2, -1, axis=0) array([[5, 6, 7, 8, 9], [0, 1, 2, 3, 4]]) >>> np.roll(x2, 1, axis=1) array([[4, 0, 1, 2, 3], [9, 5, 6, 7, 8]]) >>> np.roll(x2, -1, axis=1) array([[1, 2, 3, 4, 0], [6, 7, 8, 9, 5]]) >>> np.roll(x2, (1, 1), axis=(1, 0)) array([[9, 5, 6, 7, 8], [4, 0, 1, 2, 3]]) >>> np.roll(x2, (2, 1), axis=(1, 0)) array([[8, 9, 5, 6, 7], [3, 4, 0, 1, 2]])", "score": "0.6915004"}, {"id": "42615", "text": "Function: numpy.reference.generated.numpy.amax\nSnippet: >>> np.amax([5], initial=6) 6 >>> max([5], default=6) 5", "score": "0.67739403"}, {"id": "14250", "text": "Function: pandas.reference.api.pandas.core.window.rolling.rolling.max\nSnippet: pandas.core.window.rolling.Rolling.max Rolling.max(*args, engine=None, engine_kwargs=None, **kwargs)[source] Calculate the rolling maximum. Parameters *args For NumPy compatibility and will not have an effect on the result. engine:str, default None 'cython' : Runs the operation through C-extensions from cython. 'numba' : Runs the operation through JIT compiled code from numba. None : Defaults to 'cython' or globally setting compute.use_numba New in version 1.3.0. engine_kwargs:dict, default None For 'cython' engine, there are no accepted engine_kwargs For 'numba' engine, the engine can accept nopython, nogil and parallel dictionary keys. The values must either be True or False. The default engine_kwargs for the 'numba' engine is {'nopython': True, 'nogil': False, 'parallel': False} New in version 1.3.0. **kwargs For NumPy compatibility and will not have an effect on the result. Returns Series or DataFrame Return type is the same as the original object with np.float64 dtype. See also pandas.Series.rolling Calling rolling with Series data. pandas.DataFrame.rolling Calling rolling with DataFrames. pandas.Series.max Aggregating max for Series. pandas.DataFrame.max Aggregating max for DataFrame. Notes See Numba engine and Numba (JIT compilation) for extended documentation and performance considerations for the Numba engine.", "score": "0.6724793"}, {"id": "43857", "text": "Function: numpy.reference.generated.numpy.recarray.max\nSnippet: numpy.recarray.max method recarray.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the maximum along a given axis. Refer to numpy.amax for full documentation. See also numpy.amax equivalent function", "score": "0.66576695"}, {"id": "43686", "text": "Function: numpy.reference.random.generated.numpy.random.generator.permutation\nSnippet: numpy.random.Generator.permutation method random.Generator.permutation(x, axis=0) Randomly permute a sequence, or return a permuted range. Parameters xint or array_like If x is an integer, randomly permute np.arange(x). If x is an array, make a copy and shuffle the elements randomly. axisint, optional The axis which x is shuffled along. Default is 0. Returns outndarray Permuted sequence or array range. Examples >>> rng = np.random.default_rng() >>> rng.permutation(10) array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random >>> rng.permutation([1, 4, 9, 12, 15]) array([15, 1, 9, 4, 12]) # random >>> arr = np.arange(9).reshape((3, 3)) >>> rng.permutation(arr) array([[6, 7, 8], # random [0, 1, 2], [3, 4, 5]]) >>> rng.permutation(\"abc\") Traceback (most recent call last): ... numpy.AxisError: axis 0 is out of bounds for array of dimension 0 >>> arr = np.arange(9).reshape((3, 3)) >>> rng.permutation(arr, axis=1) array([[0, 2, 1], # random [3, 5, 4], [6, 8, 7]])", "score": "0.6629889"}]}
{"task_id": "humaneval_10", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n", "entry_point": "make_palindrome", "gold_generation": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n", "context": "Test if given string is a palindrome", "function_name": "def is_palindrome(string: str) -> bool:\n    \n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:", "ctxs": [{"id": "24344", "text": "Function: python.library.stdtypes#str.endswith\nSnippet: str.endswith(suffix[, start[, end]]) Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position.", "score": "0.6562313"}, {"id": "24880", "text": "Function: python.library.test#test.support.check_syntax_error\nSnippet: test.support.check_syntax_error(testcase, statement, errtext='', *, lineno=None, offset=None) Test for syntax errors in statement by attempting to compile statement. testcase is the unittest instance for the test. errtext is the regular expression which should match the string representation of the raised SyntaxError. If lineno is not None, compares to the line of the exception. If offset is not None, compares to the offset of the exception.", "score": "0.6519326"}, {"id": "24379", "text": "Function: python.library.stdtypes#str.startswith\nSnippet: str.startswith(prefix[, start[, end]]) Return True if string starts with the prefix, otherwise return False. prefix can also be a tuple of prefixes to look for. With optional start, test string beginning at that position. With optional end, stop comparing string at that position.", "score": "0.6510619"}, {"id": "24881", "text": "Function: python.library.test#test.support.check_syntax_warning\nSnippet: test.support.check_syntax_warning(testcase, statement, errtext='', *, lineno=1, offset=None) Test for syntax warning in statement by attempting to compile statement. Test also that the SyntaxWarning is emitted only once, and that it will be converted to a SyntaxError when turned into error. testcase is the unittest instance for the test. errtext is the regular expression which should match the string representation of the emitted SyntaxWarning and raised SyntaxError. If lineno is not None, compares to the line of the warning and exception. If offset is not None, compares to the offset of the exception. New in version 3.8.", "score": "0.6489965"}, {"id": "25435", "text": "Function: python.library.token#token.LEFTSHIFTEQUAL\nSnippet: token.LEFTSHIFTEQUAL Token value for \"<<=\".", "score": "0.6404014"}]}
{"task_id": "humaneval_11", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "entry_point": "string_xor", "gold_generation": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "context": "Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'", "function_name": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:", "ctxs": [{"id": "22353", "text": "Function: python.library.operator#operator.xor\nSnippet: operator.xor(a, b) operator.__xor__(a, b) Return the bitwise exclusive or of a and b.", "score": "0.7685419"}, {"id": "22398", "text": "Function: python.library.operator#operator.__xor__\nSnippet: operator.xor(a, b) operator.__xor__(a, b) Return the bitwise exclusive or of a and b.", "score": "0.7600049"}, {"id": "19553", "text": "Function: python.library.decimal#decimal.Decimal.logical_xor\nSnippet: logical_xor(other, context=None) logical_xor() is a logical operation which takes two logical operands (see Logical operands). The result is the digit-wise exclusive or of the two operands.", "score": "0.73518354"}, {"id": "42665", "text": "Function: numpy.reference.generated.numpy.bitwise_xor\nSnippet: numpy.bitwise_xor numpy.bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'bitwise_xor'> Compute the bit-wise XOR of two arrays element-wise. Computes the bit-wise XOR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator ^. Parameters x1, x2array_like Only integer and boolean types are handled. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray or scalar Result. This is a scalar if both x1 and x2 are scalars. See also logical_xor bitwise_and bitwise_or binary_repr Return the binary representation of the input number as a string. Examples The number 13 is represented by 00001101. Likewise, 17 is represented by 00010001. The bit-wise XOR of 13 and 17 is therefore 00011100, or 28: >>> np.bitwise_xor(13, 17) 28 >>> np.binary_repr(28) '11100' >>> np.bitwise_xor(31, 5) 26 >>> np.bitwise_xor([31,3], 5) array([26, 6]) >>> np.bitwise_xor([31,3], [5,6]) array([26, 5]) >>> np.bitwise_xor([True, True], [False, True]) array([ True, False]) The ^ operator can be used as a shorthand for np.bitwise_xor on ndarrays. >>> x1 = np.array([True, True]) >>> x2 = np.array([False, True]) >>> x1 ^ x2 array([ True, False])", "score": "0.7236627"}, {"id": "19489", "text": "Function: python.library.decimal#decimal.Context.logical_xor\nSnippet: logical_xor(x, y) Applies the logical operation xor between each operand’s digits.", "score": "0.71711254"}]}
{"task_id": "humaneval_12", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "entry_point": "longest", "gold_generation": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "context": "Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'", "function_name": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:", "ctxs": [{"id": "19646", "text": "Function: python.library.difflib#difflib.SequenceMatcher.find_longest_match\nSnippet: find_longest_match(alo=0, ahi=None, blo=0, bhi=None) Find longest matching block in a[alo:ahi] and b[blo:bhi]. If isjunk was omitted or None, find_longest_match() returns (i, j, k) such that a[i:i+k] is equal to b[j:j+k], where alo <= i <= i+k <= ahi and blo <= j <= j+k <= bhi. For all (i', j', k') meeting those conditions, the additional conditions k >= k', i <= i', and if i == i', j <= j' are also met. In other words, of all maximal matching blocks, return one that starts earliest in a, and of all those maximal matching blocks that start earliest in a, return the one that starts earliest in b. >>> s = SequenceMatcher(None, \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=0, b=4, size=5) If isjunk was provided, first the longest matching block is determined as above, but with the additional restriction that no junk element appears in the block. Then that block is extended as far as possible by matching (only) junk elements on both sides. So the resulting block never matches on junk except as identical junk happens to be adjacent to an interesting match. Here’s the same example as before, but considering blanks to be junk. That prevents ' abcd' from matching the ' abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments.", "score": "0.70606893"}, {"id": "21316", "text": "Function: python.library.itertools#itertools.zip_longest\nSnippet: itertools.zip_longest(*iterables, fillvalue=None) Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. Roughly equivalent to: def zip_longest(*args, fillvalue=None): # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D- iterators = [iter(it) for it in args] num_active = len(iterators) if not num_active: return while True: values = [] for i, it in enumerate(iterators): try: value = next(it) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values.append(value) yield tuple(values) If one of the iterables is potentially infinite, then the zip_longest() function should be wrapped with something that limits the number of calls (for example islice() or takewhile()). If not specified, fillvalue defaults to None.", "score": "0.70452106"}, {"id": "41686", "text": "Function: numpy.reference.generated.numpy.char.chararray.rfind\nSnippet: numpy.char.chararray.rfind method char.chararray.rfind(sub, start=0, end=None)[source] For each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. See also char.rfind", "score": "0.68585396"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.68389624"}, {"id": "22639", "text": "Function: python.library.os.path#os.path.commonprefix\nSnippet: os.path.commonprefix(list) Return the longest path prefix (taken character-by-character) that is a prefix of all paths in list. If list is empty, return the empty string (''). Note This function may return invalid paths because it works a character at a time. To obtain a valid path, see commonpath(). >>> os.path.commonprefix(['/usr/lib', '/usr/local/lib']) '/usr/l' >>> os.path.commonpath(['/usr/lib', '/usr/local/lib']) '/usr' Changed in version 3.6: Accepts a path-like object.", "score": "0.6829526"}]}
{"task_id": "humaneval_13", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "entry_point": "greatest_common_divisor", "gold_generation": "    while b:\n        a, b = b, a % b\n    return a\n", "context": "Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5", "function_name": "def greatest_common_divisor(a: int, b: int) -> int:", "ctxs": [{"id": "21805", "text": "Function: python.library.math#math.gcd\nSnippet: math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported.", "score": "0.7217046"}, {"id": "42857", "text": "Function: numpy.reference.generated.numpy.gcd\nSnippet: numpy.gcd numpy.gcd(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'gcd'> Returns the greatest common divisor of |x1| and |x2| Parameters x1, x2array_like, int Arrays of values. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). Returns yndarray or scalar The greatest common divisor of the absolute value of the inputs This is a scalar if both x1 and x2 are scalars. See also lcm The lowest common multiple Examples >>> np.gcd(12, 20) 4 >>> np.gcd.reduce([15, 25, 35]) 5 >>> np.gcd(np.arange(6), 20) array([20, 1, 2, 1, 4, 5])", "score": "0.7007643"}, {"id": "6576", "text": "Function: torch.generated.torch.gcd#torch.gcd\nSnippet: torch.gcd(input, other, *, out=None) → Tensor Computes the element-wise greatest common divisor (GCD) of input and other. Both input and other must have integer types. Note This defines gcd(0,0)=0gcd(0, 0) = 0 . Parameters input (Tensor) – the input tensor. other (Tensor) – the second input tensor Keyword Arguments out (Tensor, optional) – the output tensor. Example: >>> a = torch.tensor([5, 10, 15]) >>> b = torch.tensor([3, 4, 5]) >>> torch.gcd(a, b) tensor([1, 2, 5]) >>> c = torch.tensor([3]) >>> torch.gcd(a, c) tensor([1, 1, 3])", "score": "0.6788018"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.66289675"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.66100407"}]}
{"task_id": "humaneval_14", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n", "entry_point": "all_prefixes", "gold_generation": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n", "context": "Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']", "function_name": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:", "ctxs": [{"id": "22639", "text": "Function: python.library.os.path#os.path.commonprefix\nSnippet: os.path.commonprefix(list) Return the longest path prefix (taken character-by-character) that is a prefix of all paths in list. If list is empty, return the empty string (''). Note This function may return invalid paths because it works a character at a time. To obtain a valid path, see commonpath(). >>> os.path.commonprefix(['/usr/lib', '/usr/local/lib']) '/usr/l' >>> os.path.commonpath(['/usr/lib', '/usr/local/lib']) '/usr' Changed in version 3.6: Accepts a path-like object.", "score": "0.66112417"}, {"id": "41756", "text": "Function: numpy.reference.generated.numpy.char.startswith\nSnippet: numpy.char.startswith char.startswith(a, prefix, start=0, end=None)[source] Returns a boolean array which is True where the string element in a starts with prefix, otherwise False. Calls str.startswith element-wise. Parameters aarray_like of str or unicode prefixstr start, endint, optional With optional start, test beginning at that position. With optional end, stop comparing at that position. Returns outndarray Array of booleans See also str.startswith", "score": "0.658622"}, {"id": "24379", "text": "Function: python.library.stdtypes#str.startswith\nSnippet: str.startswith(prefix[, start[, end]]) Return True if string starts with the prefix, otherwise return False. prefix can also be a tuple of prefixes to look for. With optional start, test string beginning at that position. With optional end, stop comparing string at that position.", "score": "0.6519702"}, {"id": "26669", "text": "Function: python.library.xml.dom#xml.dom.Attr.prefix\nSnippet: Attr.prefix The part of the name preceding the colon if there is one, else the empty string.", "score": "0.64270955"}, {"id": "41700", "text": "Function: numpy.reference.generated.numpy.char.chararray.startswith\nSnippet: numpy.char.chararray.startswith method char.chararray.startswith(prefix, start=0, end=None)[source] Returns a boolean array which is True where the string element in self starts with prefix, otherwise False. See also char.startswith", "score": "0.6423665"}]}
{"task_id": "humaneval_15", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n", "entry_point": "string_sequence", "gold_generation": "    return ' '.join([str(x) for x in range(n + 1)])\n", "context": "Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'", "function_name": "def string_sequence(n: int) -> str:", "ctxs": [{"id": "18335", "text": "Function: python.library.stdtypes#bytes.split\nSnippet: bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3']", "score": "0.72025037"}, {"id": "18291", "text": "Function: python.library.stdtypes#bytearray.split\nSnippet: bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3']", "score": "0.71822864"}, {"id": "24377", "text": "Function: python.library.stdtypes#str.split\nSnippet: str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3']", "score": "0.7072114"}, {"id": "25756", "text": "Function: python.library.stdtypes\nSnippet: binary sequence of byte values to remove may be any bytes-like object. See removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> b'Monty Python'.rstrip(b' Python') b'M' >>> b'Monty Python'.removesuffix(b' Python') b'Monty' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.split(sep=None, maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3'] bytes.strip([chars]) bytearray.strip([chars]) Return a copy of the sequence with specified leading and trailing bytes removed. The chars argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters. If omitted or None, the chars argument defaults to removing ASCII whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> b' spacious '.strip() b'spacious' >>> b'www.example.com'.strip(b'cmowz.') b'example' The binary sequence of byte values to remove may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.capitalize() bytearray.capitalize() Return a copy of the sequence with each byte interpreted as an ASCII character, and the first byte capitalized and the rest", "score": "0.6951438"}, {"id": "18289", "text": "Function: python.library.stdtypes#bytearray.rsplit\nSnippet: bytes.rsplit(sep=None, maxsplit=-1) bytearray.rsplit(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any subsequence consisting solely of ASCII whitespace is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below.", "score": "0.6910613"}]}
{"task_id": "humaneval_16", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n", "entry_point": "count_distinct_characters", "gold_generation": "    return len(set(string.lower()))\n", "context": "Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4", "function_name": "def count_distinct_characters(string: str) -> int:", "ctxs": [{"id": "41643", "text": "Function: numpy.reference.generated.numpy.char.chararray.count\nSnippet: numpy.char.chararray.count method char.chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.71921337"}, {"id": "41718", "text": "Function: numpy.reference.generated.numpy.char.count\nSnippet: numpy.char.count char.count(a, sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. Calls str.count element-wise. Parameters aarray_like of str or unicode substr or unicode The substring to search for. start, endint, optional Optional arguments start and end are interpreted as slice notation to specify the range in which to count. Returns outndarray Output array of ints. See also str.count Examples >>> c = np.array(['aAaAaA', ' aA ', 'abBABba']) >>> c array(['aAaAaA', ' aA ', 'abBABba'], dtype='<U7') >>> np.char.count(c, 'A') array([3, 1, 1]) >>> np.char.count(c, 'aA') array([3, 1, 0]) >>> np.char.count(c, 'A', start=1, end=4) array([2, 1, 1]) >>> np.char.count(c, 'A', start=1, end=3) array([1, 0, 0])", "score": "0.71585685"}, {"id": "41768", "text": "Function: numpy.reference.generated.numpy.chararray.count\nSnippet: numpy.chararray.count method chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.715737"}, {"id": "24361", "text": "Function: python.library.stdtypes#str.isupper\nSnippet: str.isupper() Return True if all cased characters 4 in the string are uppercase and there is at least one cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False", "score": "0.7043292"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.70188785"}]}
{"task_id": "humaneval_17", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n", "entry_point": "parse_music", "gold_generation": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n", "context": "Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]", "function_name": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:", "ctxs": [{"id": "13627", "text": "Function: pygame.ref.music#pygame.mixer.music.play\nSnippet: pygame.mixer.music.play() Start the playback of the music stream play(loops=0, start=0.0, fade_ms = 0) -> None This will play the loaded music stream. If the music is already playing it will be restarted. loops is an optional integer argument, which is 0 by default, it tells how many times to repeat the music. The music repeats indefinately if this argument is set to -1. start is an optional float argument, which is 0.0 by default, which denotes the position in time, the music starts playing from. The starting position depends on the format of the music played. MP3 and OGG use the position as time in seconds. For mp3s the start time position selected may not be accurate as things like variable bit rate encoding and ID3 tags can throw off the timing calculations. For MOD music it is the pattern order number. Passing a start position will raise a NotImplementedError if the start position cannot be set. fade_ms is an optional integer argument, which is 0 by default, makes the music start playing at 0 volume and fade up to full volume over the given time. The sample may end before the fade-in is complete. Changed in pygame 2.0.0: Added optional fade_ms argument", "score": "0.71399605"}, {"id": "13623", "text": "Function: pygame.ref.music#pygame.mixer.music.get_pos\nSnippet: pygame.mixer.music.get_pos() get the music play time get_pos() -> time This gets the number of milliseconds that the music has been playing for. The returned time only represents how long the music has been playing; it does not take into account any starting position offsets.", "score": "0.7016789"}, {"id": "24412", "text": "Function: python.library.string#string.Formatter.parse\nSnippet: parse(format_string) Loop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields. The values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None.", "score": "0.6944538"}, {"id": "13617", "text": "Function: pygame.ref.music\nSnippet: pygame.mixer.music pygame module for controlling streamed audio The music module is closely tied to pygame.mixer. Use the music module to control the playback of music in the sound mixer. The difference between the music playback and regular Sound playback is that the music is streamed, and never actually loaded all at once. The mixer system only supports a single music stream at once. Be aware that MP3 support is limited. On some systems an unsupported format can crash the program, e.g. Debian Linux. Consider using OGG instead. pygame.mixer.music.load() Load a music file for playback load(filename) -> None load(object) -> None This will load a music filename/file object and prepare it for playback. If a music stream is already playing it will be stopped. This does not start the music playing. pygame.mixer.music.unload() Unload the currently loaded music to free up resources unload() -> None This closes resources like files for any music that may be loaded. New in pygame 2.0.0. pygame.mixer.music.play() Start the playback of the music stream play(loops=0, start=0.0, fade_ms = 0) -> None This will play the loaded music stream. If the music is already playing it will be restarted. loops is an optional integer argument, which is 0 by default, it tells how many times to repeat the music. The music repeats indefinately if this argument is set to -1. start is an optional float argument, which is 0.0 by default, which denotes the position in time, the music starts playing from. The starting position depends on the format of the music played. MP3 and OGG use the position as time in seconds. For mp3s the start time position selected may not be accurate as things like variable bit rate encoding and ID3 tags can throw off the timing calculations. For MOD music it is the pattern order number. Passing a start position will raise a NotImplementedError if the start position cannot be set. fade_ms is an optional integer argument, which is 0 by default, makes the music start playing at 0 volume and fade up to full volume over the given time. The sample may end before the fade-in is complete. Changed in pygame 2.0.0: Added optional fade_ms argument pygame.mixer.music.rewind() restart music rewind() -> None Resets playback of the current music to the beginning. pygame.mixer.music.stop() stop the music playback stop() -> None Stops the music playback if it is currently playing. It Won't Unload the music. pygame.mixer.music.pause() temporarily stop music playback pause() -> None Temporarily stop playback of the music stream. It can be resumed with the pygame.mixer.music.unpause() function. pygame.mixer.music.unpause() resume paused music unpause() -> None This will resume the playback of a music stream after it has been paused. pygame.mixer.music.fadeout() stop music playback after fading out fadeout(time) -> None Fade out and stop the currently playing music. The time argument denotes the integer milliseconds for which the fading effect is generated. Note, that this function blocks until the music has faded out. Calls to fadeout() and set_volume() will have no effect during this time. If an", "score": "0.69395256"}, {"id": "13093", "text": "Function: pygame.ref.cdrom\nSnippet: the track contains audio data. The start, end, and length values are floating point numbers in seconds. Start and end represent absolute times on the entire disc. get_track_start() start time of a cdrom track get_track_start(track) -> seconds Return the absolute time in seconds where at start of the cdrom track. Note, track 0 is the first track on the CD. Track numbers start at zero. get_track_length() length of a cdrom track get_track_length(track) -> seconds Return a floating point value in seconds of the length of the cdrom track. Note, track 0 is the first track on the CD. Track numbers start at zero.", "score": "0.69080406"}]}
{"task_id": "humaneval_18", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n", "entry_point": "how_many_times", "gold_generation": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n", "context": "Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3", "function_name": "def how_many_times(string: str, substring: str) -> int:", "ctxs": [{"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.74960655"}, {"id": "41643", "text": "Function: numpy.reference.generated.numpy.char.chararray.count\nSnippet: numpy.char.chararray.count method char.chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.7365366"}, {"id": "41768", "text": "Function: numpy.reference.generated.numpy.chararray.count\nSnippet: numpy.chararray.count method chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.7294502"}, {"id": "41718", "text": "Function: numpy.reference.generated.numpy.char.count\nSnippet: numpy.char.count char.count(a, sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. Calls str.count element-wise. Parameters aarray_like of str or unicode substr or unicode The substring to search for. start, endint, optional Optional arguments start and end are interpreted as slice notation to specify the range in which to count. Returns outndarray Output array of ints. See also str.count Examples >>> c = np.array(['aAaAaA', ' aA ', 'abBABba']) >>> c array(['aAaAaA', ' aA ', 'abBABba'], dtype='<U7') >>> np.char.count(c, 'A') array([3, 1, 1]) >>> np.char.count(c, 'aA') array([3, 1, 0]) >>> np.char.count(c, 'A', start=1, end=4) array([2, 1, 1]) >>> np.char.count(c, 'A', start=1, end=3) array([1, 0, 0])", "score": "0.7236617"}, {"id": "24346", "text": "Function: python.library.stdtypes#str.find\nSnippet: str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True", "score": "0.70405453"}]}
{"task_id": "humaneval_19", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "entry_point": "sort_numbers", "gold_generation": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "context": "Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'", "function_name": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:", "ctxs": [{"id": "15305", "text": "Function: pandas.reference.api.pandas.series.sort_index\nSnippet: s = pd.Series([1, 2, 3, 4], index=['A', 'b', 'C', 'd']) >>> s.sort_index(key=lambda x : x.str.lower()) A 1 b 2 C 3 d 4 dtype: int64", "score": "0.7185289"}, {"id": "43196", "text": "Function: numpy.reference.generated.numpy.sort\nSnippet: sorted. It, along with ‘mergesort’ is currently mapped to timsort or radix sort depending on the data type. API forward compatibility currently limits the ability to select the implementation and it is hardwired for the different data types. New in version 1.17.0. Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For timsort details, refer to CPython listsort.txt. ‘mergesort’ and ‘stable’ are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n). Changed in version 1.18.0. NaT now sorts to the end of arrays for consistency with NaN. Examples >>> a = np.array([[1,4],[3,1]]) >>> np.sort(a) # sort along the last axis array([[1, 4], [1, 3]]) >>> np.sort(a, axis=None) # sort the flattened array array([1, 1, 3, 4]) >>> np.sort(a, axis=0) # sort along the first axis array([[1, 1], [3, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> dtype = [('name', 'S10'), ('height', float), ('age', int)] >>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38), ... ('Galahad', 1.7, 38)] >>> a = np.array(values, dtype=dtype) # create a structured array >>> np.sort(a, order='height') array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41), ('Lancelot', 1.8999999999999999, 38)], dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')]) Sort by age, then height if ages are equal: >>> np.sort(a, order=['age', 'height']) array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38), ('Arthur', 1.8, 41)], dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])", "score": "0.7137004"}, {"id": "14909", "text": "Function: pandas.reference.api.pandas.multiindex.sortlevel\nSnippet: pandas.MultiIndex.sortlevel MultiIndex.sortlevel(level=0, ascending=True, sort_remaining=True)[source] Sort MultiIndex at the requested level. The result will respect the original ordering of the associated factor at that level. Parameters level:list-like, int or str, default 0 If a string is given, must be a name of the level. If list-like must be names or ints of levels. ascending:bool, default True False to sort in descending order. Can also be a list to specify a directed ordering. sort_remaining:sort by the remaining levels after level Returns sorted_index:pd.MultiIndex Resulting index. indexer:np.ndarray[np.intp] Indices of output values in original index. Examples >>> mi = pd.MultiIndex.from_arrays([[0, 0], [2, 1]]) >>> mi MultiIndex([(0, 2), (0, 1)], ) >>> mi.sortlevel() (MultiIndex([(0, 1), (0, 2)], ), array([1, 0])) >>> mi.sortlevel(sort_remaining=False) (MultiIndex([(0, 2), (0, 1)], ), array([0, 1])) >>> mi.sortlevel(1) (MultiIndex([(0, 1), (0, 2)], ), array([1, 0])) >>> mi.sortlevel(1, ascending=False) (MultiIndex([(0, 2), (0, 1)], ), array([0, 1]))", "score": "0.70449144"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.70244044"}, {"id": "41696", "text": "Function: numpy.reference.generated.numpy.char.chararray.sort\nSnippet: numpy.char.chararray.sort method char.chararray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.6959113"}]}
{"task_id": "humaneval_20", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n", "entry_point": "find_closest_elements", "gold_generation": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n", "context": "From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)", "function_name": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:", "ctxs": [{"id": "19498", "text": "Function: python.library.decimal#decimal.Context.next_toward\nSnippet: next_toward(x, y) Returns the number closest to x, in direction towards y.", "score": "0.68569887"}, {"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.6832685"}, {"id": "34423", "text": "Function: matplotlib.widgets_api#matplotlib.widgets.ToolHandles.closest\nSnippet: closest(x, y)[source] Return index and pixel distance to closest index.", "score": "0.6811792"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.679916"}, {"id": "19560", "text": "Function: python.library.decimal#decimal.Decimal.next_toward\nSnippet: next_toward(other, context=None) If the two operands are unequal, return the number closest to the first operand in the direction of the second operand. If both operands are numerically equal, return a copy of the first operand with the sign set to be the same as the sign of the second operand.", "score": "0.6750696"}]}
{"task_id": "humaneval_21", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "entry_point": "rescale_to_unit", "gold_generation": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "context": "Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]", "function_name": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:", "ctxs": [{"id": "12370", "text": "Function: sklearn.modules.generated.sklearn.preprocessing.minmax_scale#sklearn.preprocessing.minmax_scale\nSnippet: sklearn.preprocessing.minmax_scale(X, feature_range=0, 1, *, axis=0, copy=True) [source] Transform features by scaling each feature to a given range. This estimator scales and translates each feature individually such that it is in the given range on the training set, i.e. between zero and one. The transformation is given by (when axis=0): X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0)) X_scaled = X_std * (max - min) + min where min, max = feature_range. The transformation is calculated as (when axis=0): X_scaled = scale * X + min - X.min(axis=0) * scale where scale = (max - min) / (X.max(axis=0) - X.min(axis=0)) This transformation is often used as an alternative to zero mean, unit variance scaling. Read more in the User Guide. New in version 0.17: minmax_scale function interface to MinMaxScaler. Parameters Xarray-like of shape (n_samples, n_features) The data. feature_rangetuple (min, max), default=(0, 1) Desired range of transformed data. axisint, default=0 Axis used to scale along. If 0, independently scale each feature, otherwise (if 1) scale each sample. copybool, default=True Set to False to perform inplace scaling and avoid a copy (if the input is already a numpy array). Returns X_trndarray of shape (n_samples, n_features) The transformed data. Warning Risk of data leak Do not use minmax_scale unless you know what you are doing. A common mistake is to apply it to the entire data before splitting into training and test sets. This will bias the model evaluation because information would have leaked from the test set to the training set. In general, we recommend using MinMaxScaler within a Pipeline in order to prevent most risks of data leaking: pipe = make_pipeline(MinMaxScaler(), LogisticRegression()). See also MinMaxScaler Performs scaling to a given range using the Transformer API (e.g. as part of a preprocessing Pipeline). Notes For a comparison of the different scalers, transformers, and normalizers, see examples/preprocessing/plot_all_scaling.py.", "score": "0.70764637"}, {"id": "12763", "text": "Function: sklearn.modules.generated.sklearn.preprocessing.minmax_scale\nSnippet: sklearn.preprocessing.minmax_scale sklearn.preprocessing.minmax_scale(X, feature_range=0, 1, *, axis=0, copy=True) [source] Transform features by scaling each feature to a given range. This estimator scales and translates each feature individually such that it is in the given range on the training set, i.e. between zero and one. The transformation is given by (when axis=0): X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0)) X_scaled = X_std * (max - min) + min where min, max = feature_range. The transformation is calculated as (when axis=0): X_scaled = scale * X + min - X.min(axis=0) * scale where scale = (max - min) / (X.max(axis=0) - X.min(axis=0)) This transformation is often used as an alternative to zero mean, unit variance scaling. Read more in the User Guide. New in version 0.17: minmax_scale function interface to MinMaxScaler. Parameters Xarray-like of shape (n_samples, n_features) The data. feature_rangetuple (min, max), default=(0, 1) Desired range of transformed data. axisint, default=0 Axis used to scale along. If 0, independently scale each feature, otherwise (if 1) scale each sample. copybool, default=True Set to False to perform inplace scaling and avoid a copy (if the input is already a numpy array). Returns X_trndarray of shape (n_samples, n_features) The transformed data. Warning Risk of data leak Do not use minmax_scale unless you know what you are doing. A common mistake is to apply it to the entire data before splitting into training and test sets. This will bias the model evaluation because information would have leaked from the test set to the training set. In general, we recommend using MinMaxScaler within a Pipeline in order to prevent most risks of data leaking: pipe = make_pipeline(MinMaxScaler(), LogisticRegression()). See also MinMaxScaler Performs scaling to a given range using the Transformer API (e.g. as part of a preprocessing Pipeline). Notes For a comparison of the different scalers, transformers, and normalizers, see examples/preprocessing/plot_all_scaling.py. Examples using sklearn.preprocessing.minmax_scale Compare the effect of different scalers on data with outliers", "score": "0.706081"}, {"id": "12359", "text": "Function: sklearn.modules.generated.sklearn.preprocessing.minmaxscaler#sklearn.preprocessing.MinMaxScaler\nSnippet: class sklearn.preprocessing.MinMaxScaler(feature_range=0, 1, *, copy=True, clip=False) [source] Transform features by scaling each feature to a given range. This estimator scales and translates each feature individually such that it is in the given range on the training set, e.g. between zero and one. The transformation is given by: X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0)) X_scaled = X_std * (max - min) + min where min, max = feature_range. This transformation is often used as an alternative to zero mean, unit variance scaling. Read more in the User Guide. Parameters feature_rangetuple (min, max), default=(0, 1) Desired range of transformed data. copybool, default=True Set to False to perform inplace row normalization and avoid a copy (if the input is already a numpy array). clip: bool, default=False Set to True to clip transformed values of held-out data to provided feature range. New in version 0.24. Attributes min_ndarray of shape (n_features,) Per feature adjustment for minimum. Equivalent to min - X.min(axis=0) * self.scale_ scale_ndarray of shape (n_features,) Per feature relative scaling of the data. Equivalent to (max - min) / (X.max(axis=0) - X.min(axis=0)) New in version 0.17: scale_ attribute. data_min_ndarray of shape (n_features,) Per feature minimum seen in the data New in version 0.17: data_min_ data_max_ndarray of shape (n_features,) Per feature maximum seen in the data New in version 0.17: data_max_ data_range_ndarray of shape (n_features,) Per feature range (data_max_ - data_min_) seen in the data New in version 0.17: data_range_ n_samples_seen_int The number of samples processed by the estimator. It will be reset on new calls to fit, but increments across partial_fit calls. See also minmax_scale Equivalent function without the estimator API. Notes NaNs are treated as missing values: disregarded in fit, and maintained in transform. For a comparison of the different scalers, transformers, and normalizers, see examples/preprocessing/plot_all_scaling.py. Examples >>> from sklearn.preprocessing import MinMaxScaler >>> data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]] >>> scaler = MinMaxScaler() >>> print(scaler.fit(data)) MinMaxScaler() >>> print(scaler.data_max_) [ 1. 18.] >>> print(scaler.transform(data)) [[0. 0. ] [0.25 0.25] [0.5 0.5 ] [1. 1. ]] >>> print(scaler.transform([[2, 2]])) [[1.5 0. ]] Methods fit(X[, y]) Compute the minimum and maximum to be used for later scaling. fit_transform(X[, y]) Fit to data, then transform it. get_params([deep]) Get parameters for this estimator. inverse_transform(X) Undo the scaling of X according to feature_range. partial_fit(X[, y]) Online computation of min and max on X for later scaling. set_params(**params) Set the parameters of this estimator. transform(X) Scale features of X according to feature_range. fit(X, y=None) [source] Compute the minimum and maximum to be used for later scaling. Parameters Xarray-like of shape (n_samples, n_features) The data used to compute the per-feature minimum and maximum used for later scaling along the features axis. yNone Ignored. Returns selfobject Fitted scaler. fit_transform(X, y=None, **fit_params) [source] Fit to data, then transform it. Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X. Parameters Xarray-like of shape (n_samples, n_features) Input samples. yarray-like of shape (n_samples,) or (n_samples, n_outputs), default=None Target values (None for", "score": "0.6972474"}, {"id": "12369", "text": "Function: sklearn.modules.generated.sklearn.preprocessing.minmaxscaler#sklearn.preprocessing.MinMaxScaler.transform\nSnippet: transform(X) [source] Scale features of X according to feature_range. Parameters Xarray-like of shape (n_samples, n_features) Input data that will be transformed. Returns Xtndarray of shape (n_samples, n_features) Transformed data.", "score": "0.6965451"}, {"id": "12382", "text": "Function: sklearn.modules.generated.sklearn.preprocessing.normalizer#sklearn.preprocessing.Normalizer\nSnippet: class sklearn.preprocessing.Normalizer(norm='l2', *, copy=True) [source] Normalize samples individually to unit norm. Each sample (i.e. each row of the data matrix) with at least one non zero component is rescaled independently of other samples so that its norm (l1, l2 or inf) equals one. This transformer is able to work both with dense numpy arrays and scipy.sparse matrix (use CSR format if you want to avoid the burden of a copy / conversion). Scaling inputs to unit norms is a common operation for text classification or clustering for instance. For instance the dot product of two l2-normalized TF-IDF vectors is the cosine similarity of the vectors and is the base similarity metric for the Vector Space Model commonly used by the Information Retrieval community. Read more in the User Guide. Parameters norm{‘l1’, ‘l2’, ‘max’}, default=’l2’ The norm to use to normalize each non zero sample. If norm=’max’ is used, values will be rescaled by the maximum of the absolute values. copybool, default=True set to False to perform inplace row normalization and avoid a copy (if the input is already a numpy array or a scipy.sparse CSR matrix). See also normalize Equivalent function without the estimator API. Notes This estimator is stateless (besides constructor parameters), the fit method does nothing but is useful when used in a pipeline. For a comparison of the different scalers, transformers, and normalizers, see examples/preprocessing/plot_all_scaling.py. Examples >>> from sklearn.preprocessing import Normalizer >>> X = [[4, 1, 2, 2], ... [1, 3, 9, 3], ... [5, 7, 5, 1]] >>> transformer = Normalizer().fit(X) # fit does nothing. >>> transformer Normalizer() >>> transformer.transform(X) array([[0.8, 0.2, 0.4, 0.4], [0.1, 0.3, 0.9, 0.3], [0.5, 0.7, 0.5, 0.1]]) Methods fit(X[, y]) Do nothing and return the estimator unchanged fit_transform(X[, y]) Fit to data, then transform it. get_params([deep]) Get parameters for this estimator. set_params(**params) Set the parameters of this estimator. transform(X[, copy]) Scale each non zero row of X to unit norm fit(X, y=None) [source] Do nothing and return the estimator unchanged This method is just there to implement the usual API and hence work in pipelines. Parameters X{array-like, sparse matrix} of shape (n_samples, n_features) The data to estimate the normalization parameters. yNone Ignored. Returns selfobject Fitted transformer. fit_transform(X, y=None, **fit_params) [source] Fit to data, then transform it. Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X. Parameters Xarray-like of shape (n_samples, n_features) Input samples. yarray-like of shape (n_samples,) or (n_samples, n_outputs), default=None Target values (None for unsupervised transformations). **fit_paramsdict Additional fit parameters. Returns X_newndarray array of shape (n_samples, n_features_new) Transformed array. get_params(deep=True) [source] Get parameters for this estimator. Parameters deepbool, default=True If True, will return the parameters for this estimator and contained subobjects that are estimators. Returns paramsdict Parameter names mapped to their values. set_params(**params) [source] Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it’s possible to update each component of", "score": "0.6957766"}]}
{"task_id": "humaneval_22", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n", "entry_point": "filter_integers", "gold_generation": "    return [x for x in values if isinstance(x, int)]\n", "context": "Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]", "function_name": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:", "ctxs": [{"id": "21307", "text": "Function: python.library.itertools#itertools.filterfalse\nSnippet: itertools.filterfalse(predicate, iterable) Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Roughly equivalent to: def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x", "score": "0.68972343"}, {"id": "20192", "text": "Function: python.library.stdtypes#float.is_integer\nSnippet: float.is_integer() Return True if the float instance is finite with integral value, and False otherwise: >>> (-2.0).is_integer() True >>> (3.2).is_integer() False", "score": "0.6781202"}, {"id": "15183", "text": "Function: pandas.reference.api.pandas.series.filter\nSnippet: pandas.Series.filter Series.filter(items=None, like=None, regex=None, axis=None)[source] Subset the dataframe rows or columns according to the specified index labels. Note that this routine does not filter a dataframe on its contents. The filter is applied to the labels of the index. Parameters items:list-like Keep labels from axis which are in items. like:str Keep labels from axis for which “like in label == True”. regex:str (regular expression) Keep labels from axis for which re.search(regex, label) == True. axis:{0 or ‘index’, 1 or ‘columns’, None}, default None The axis to filter on, expressed either as an index (int) or axis name (str). By default this is the info axis, ‘index’ for Series, ‘columns’ for DataFrame. Returns same type as input object See also DataFrame.loc Access a group of rows and columns by label(s) or a boolean array. Notes The items, like, and regex parameters are enforced to be mutually exclusive. axis defaults to the info axis that is used when indexing with []. Examples >>> df = pd.DataFrame(np.array(([1, 2, 3], [4, 5, 6])), ... index=['mouse', 'rabbit'], ... columns=['one', 'two', 'three']) >>> df one two three mouse 1 2 3 rabbit 4 5 6 >>> # select columns by name >>> df.filter(items=['one', 'three']) one three mouse 1 3 rabbit 4 6 >>> # select columns by regular expression >>> df.filter(regex='e$', axis=1) one three mouse 1 3 rabbit 4 6 >>> # select rows containing 'bbi' >>> df.filter(like='bbi', axis=0) one two three rabbit 4 5 6", "score": "0.6712406"}, {"id": "14019", "text": "Function: pandas.reference.api.pandas.api.types.is_integer\nSnippet: pandas.api.types.is_integer pandas.api.types.is_integer() Return True if given object is integer. Returns bool", "score": "0.668943"}, {"id": "14714", "text": "Function: pandas.reference.api.pandas.index.is_integer\nSnippet: pandas.Index.is_integer finalIndex.is_integer()[source] Check if the Index only consists of integers. Returns bool Whether or not the Index only consists of integers. See also is_boolean Check if the Index only consists of booleans. is_floating Check if the Index is a floating type. is_numeric Check if the Index only consists of numeric data. is_object Check if the Index is of the object dtype. is_categorical Check if the Index holds categorical data. is_interval Check if the Index holds Interval objects. is_mixed Check if the Index holds data with mixed data types. Examples >>> idx = pd.Index([1, 2, 3, 4]) >>> idx.is_integer() True >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0]) >>> idx.is_integer() False >>> idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"]) >>> idx.is_integer() False", "score": "0.666242"}]}
{"task_id": "humaneval_23", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n", "entry_point": "strlen", "gold_generation": "    return len(string)\n", "context": "Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3", "function_name": "def strlen(string: str) -> int:", "ctxs": [{"id": "41757", "text": "Function: numpy.reference.generated.numpy.char.str_len\nSnippet: numpy.char.str_len char.str_len(a)[source] Return len(a) element-wise. Parameters aarray_like of str or unicode Returns outndarray Output array of integers See also builtins.len", "score": "0.7098081"}, {"id": "18944", "text": "Function: python.library.ctypes#ctypes.Array._length_\nSnippet: _length_ A positive integer specifying the number of elements in the array. Out-of-range subscripts result in an IndexError. Will be returned by len().", "score": "0.69101423"}, {"id": "15345", "text": "Function: pandas.reference.api.pandas.series.str.len\nSnippet: pandas.Series.str.len Series.str.len()[source] Compute the length of each element in the Series/Index. The element may be a sequence (such as a string, tuple or list) or a collection (such as a dictionary). Returns Series or Index of int A Series or Index of integer values indicating the length of each element in the Series or Index. See also str.len Python built-in function returning the length of an object. Series.size Returns the length of the Series. Examples Returns the length (number of characters) in a string. Returns the number of entries for dictionaries, lists or tuples. >>> s = pd.Series(['dog', ... '', ... 5, ... {'foo' : 'bar'}, ... [2, 3, 5, 7], ... ('one', 'two', 'three')]) >>> s 0 dog 1 2 5 3 {'foo': 'bar'} 4 [2, 3, 5, 7] 5 (one, two, three) dtype: object >>> s.str.len() 0 3.0 1 0.0 2 NaN 3 1.0 4 4.0 5 3.0 dtype: float64", "score": "0.67922544"}, {"id": "23421", "text": "Function: python.library.reprlib#reprlib.Repr.maxstring\nSnippet: Repr.maxstring Limit on the number of characters in the representation of the string. Note that the “normal” representation of the string is used as the character source: if escape sequences are needed in the representation, these may be mangled when the representation is shortened. The default is 30.", "score": "0.6771436"}, {"id": "14788", "text": "Function: pandas.reference.api.pandas.interval.length\nSnippet: pandas.Interval.length Interval.length Return the length of the Interval.", "score": "0.6771159"}]}
{"task_id": "humaneval_24", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n", "entry_point": "largest_divisor", "gold_generation": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n", "context": "For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5", "function_name": "def largest_divisor(n: int) -> int:", "ctxs": [{"id": "42840", "text": "Function: numpy.reference.generated.numpy.floor_divide\nSnippet: numpy.floor_divide numpy.floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'floor_divide'> Return the largest integer smaller or equal to the division of the inputs. It is equivalent to the Python // operator and pairs with the Python % (remainder), function so that a = a % b + b * (a // b) up to roundoff. Parameters x1array_like Numerator. x2array_like Denominator. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray y = floor(x1/x2) This is a scalar if both x1 and x2 are scalars. See also remainder Remainder complementary to floor_divide. divmod Simultaneous floor division and remainder. divide Standard division. floor Round a number to the nearest integer toward minus infinity. ceil Round a number to the nearest integer toward infinity. Examples >>> np.floor_divide(7,3) 2 >>> np.floor_divide([1., 2., 3., 4.], 2.5) array([ 0., 0., 1., 1.]) The // operator can be used as a shorthand for np.floor_divide on ndarrays. >>> x1 = np.array([1., 2., 3., 4.]) >>> x1 // 2.5 array([0., 0., 1., 1.])", "score": "0.66439223"}, {"id": "21805", "text": "Function: python.library.math#math.gcd\nSnippet: math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported.", "score": "0.65064"}, {"id": "19496", "text": "Function: python.library.decimal#decimal.Context.next_minus\nSnippet: next_minus(x) Returns the largest representable number smaller than x.", "score": "0.64931965"}, {"id": "19558", "text": "Function: python.library.decimal#decimal.Decimal.next_minus\nSnippet: next_minus(context=None) Return the largest number representable in the given context (or in the current thread’s context if no context is given) that is smaller than the given operand.", "score": "0.634596"}, {"id": "21812", "text": "Function: python.library.math#math.isqrt\nSnippet: math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8.", "score": "0.6329584"}]}
{"task_id": "humaneval_25", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n", "entry_point": "factorize", "gold_generation": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n", "context": "Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]", "function_name": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:", "ctxs": [{"id": "15179", "text": "Function: pandas.reference.api.pandas.series.factorize\nSnippet: pandas.Series.factorize Series.factorize(sort=False, na_sentinel=- 1)[source] Encode the object as an enumerated type or categorical variable. This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct values. factorize is available as both a top-level function pandas.factorize(), and as a method Series.factorize() and Index.factorize(). Parameters sort:bool, default False Sort uniques and shuffle codes to maintain the relationship. na_sentinel:int or None, default -1 Value to mark “not found”. If None, will not drop the NaN from the uniques of the values. Changed in version 1.1.2. Returns codes:ndarray An integer ndarray that’s an indexer into uniques. uniques.take(codes) will have the same values as values. uniques:ndarray, Index, or Categorical The unique valid values. When values is Categorical, uniques is a Categorical. When values is some other pandas object, an Index is returned. Otherwise, a 1-D ndarray is returned. Note Even if there’s a missing value in values, uniques will not contain an entry for it. See also cut Discretize continuous-valued array. unique Find the unique value in an array. Examples These examples all show factorize as a top-level method like pd.factorize(values). The results are identical for methods like Series.factorize(). >>> codes, uniques = pd.factorize(['b', 'b', 'a', 'c', 'b']) >>> codes array([0, 0, 1, 2, 0]...) >>> uniques array(['b', 'a', 'c'], dtype=object) With sort=True, the uniques will be sorted, and codes will be shuffled so that the relationship is the maintained. >>> codes, uniques = pd.factorize(['b', 'b', 'a', 'c', 'b'], sort=True) >>> codes array([1, 1, 0, 2, 1]...) >>> uniques array(['a', 'b', 'c'], dtype=object) Missing values are indicated in codes with na_sentinel (-1 by default). Note that missing values are never included in uniques. >>> codes, uniques = pd.factorize(['b', None, 'a', 'c', 'b']) >>> codes array([ 0, -1, 1, 2, 0]...) >>> uniques array(['b', 'a', 'c'], dtype=object) Thus far, we’ve only factorized lists (which are internally coerced to NumPy arrays). When factorizing pandas objects, the type of uniques will differ. For Categoricals, a Categorical is returned. >>> cat = pd.Categorical(['a', 'a', 'c'], categories=['a', 'b', 'c']) >>> codes, uniques = pd.factorize(cat) >>> codes array([0, 0, 1]...) >>> uniques ['a', 'c'] Categories (3, object): ['a', 'b', 'c'] Notice that 'b' is in uniques.categories, despite not being present in cat.values. For all other pandas objects, an Index of the appropriate type is returned. >>> cat = pd.Series(['a', 'a', 'c']) >>> codes, uniques = pd.factorize(cat) >>> codes array([0, 0, 1]...) >>> uniques Index(['a', 'c'], dtype='object') If NaN is in the values, and we want to include NaN in the uniques of the values, it can be achieved by setting na_sentinel=None. >>> values = np.array([1, 2, 1, np.nan]) >>> codes, uniques = pd.factorize(values) # default: na_sentinel=-1 >>> codes array([ 0, 1, 0, -1]) >>> uniques array([1., 2.]) >>> codes, uniques = pd.factorize(values, na_sentinel=None) >>> codes array([0, 1, 0, 2]) >>> uniques array([ 1., 2., nan])", "score": "0.6633272"}, {"id": "14691", "text": "Function: pandas.reference.api.pandas.index.factorize\nSnippet: pandas.Index.factorize Index.factorize(sort=False, na_sentinel=- 1)[source] Encode the object as an enumerated type or categorical variable. This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct values. factorize is available as both a top-level function pandas.factorize(), and as a method Series.factorize() and Index.factorize(). Parameters sort:bool, default False Sort uniques and shuffle codes to maintain the relationship. na_sentinel:int or None, default -1 Value to mark “not found”. If None, will not drop the NaN from the uniques of the values. Changed in version 1.1.2. Returns codes:ndarray An integer ndarray that’s an indexer into uniques. uniques.take(codes) will have the same values as values. uniques:ndarray, Index, or Categorical The unique valid values. When values is Categorical, uniques is a Categorical. When values is some other pandas object, an Index is returned. Otherwise, a 1-D ndarray is returned. Note Even if there’s a missing value in values, uniques will not contain an entry for it. See also cut Discretize continuous-valued array. unique Find the unique value in an array. Examples These examples all show factorize as a top-level method like pd.factorize(values). The results are identical for methods like Series.factorize(). >>> codes, uniques = pd.factorize(['b', 'b', 'a', 'c', 'b']) >>> codes array([0, 0, 1, 2, 0]...) >>> uniques array(['b', 'a', 'c'], dtype=object) With sort=True, the uniques will be sorted, and codes will be shuffled so that the relationship is the maintained. >>> codes, uniques = pd.factorize(['b', 'b', 'a', 'c', 'b'], sort=True) >>> codes array([1, 1, 0, 2, 1]...) >>> uniques array(['a', 'b', 'c'], dtype=object) Missing values are indicated in codes with na_sentinel (-1 by default). Note that missing values are never included in uniques. >>> codes, uniques = pd.factorize(['b', None, 'a', 'c', 'b']) >>> codes array([ 0, -1, 1, 2, 0]...) >>> uniques array(['b', 'a', 'c'], dtype=object) Thus far, we’ve only factorized lists (which are internally coerced to NumPy arrays). When factorizing pandas objects, the type of uniques will differ. For Categoricals, a Categorical is returned. >>> cat = pd.Categorical(['a', 'a', 'c'], categories=['a', 'b', 'c']) >>> codes, uniques = pd.factorize(cat) >>> codes array([0, 0, 1]...) >>> uniques ['a', 'c'] Categories (3, object): ['a', 'b', 'c'] Notice that 'b' is in uniques.categories, despite not being present in cat.values. For all other pandas objects, an Index of the appropriate type is returned. >>> cat = pd.Series(['a', 'a', 'c']) >>> codes, uniques = pd.factorize(cat) >>> codes array([0, 0, 1]...) >>> uniques Index(['a', 'c'], dtype='object') If NaN is in the values, and we want to include NaN in the uniques of the values, it can be achieved by setting na_sentinel=None. >>> values = np.array([1, 2, 1, np.nan]) >>> codes, uniques = pd.factorize(values) # default: na_sentinel=-1 >>> codes array([ 0, 1, 0, -1]) >>> uniques array([1., 2.]) >>> codes, uniques = pd.factorize(values, na_sentinel=None) >>> codes array([0, 1, 0, 2]) >>> uniques array([ 1., 2., nan])", "score": "0.66277874"}, {"id": "14646", "text": "Function: pandas.reference.api.pandas.factorize\nSnippet: pandas.factorize pandas.factorize(values, sort=False, na_sentinel=- 1, size_hint=None)[source] Encode the object as an enumerated type or categorical variable. This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct values. factorize is available as both a top-level function pandas.factorize(), and as a method Series.factorize() and Index.factorize(). Parameters values:sequence A 1-D sequence. Sequences that aren’t pandas objects are coerced to ndarrays before factorization. sort:bool, default False Sort uniques and shuffle codes to maintain the relationship. na_sentinel:int or None, default -1 Value to mark “not found”. If None, will not drop the NaN from the uniques of the values. Changed in version 1.1.2. size_hint:int, optional Hint to the hashtable sizer. Returns codes:ndarray An integer ndarray that’s an indexer into uniques. uniques.take(codes) will have the same values as values. uniques:ndarray, Index, or Categorical The unique valid values. When values is Categorical, uniques is a Categorical. When values is some other pandas object, an Index is returned. Otherwise, a 1-D ndarray is returned. Note Even if there’s a missing value in values, uniques will not contain an entry for it. See also cut Discretize continuous-valued array. unique Find the unique value in an array. Examples These examples all show factorize as a top-level method like pd.factorize(values). The results are identical for methods like Series.factorize(). >>> codes, uniques = pd.factorize(['b', 'b', 'a', 'c', 'b']) >>> codes array([0, 0, 1, 2, 0]...) >>> uniques array(['b', 'a', 'c'], dtype=object) With sort=True, the uniques will be sorted, and codes will be shuffled so that the relationship is the maintained. >>> codes, uniques = pd.factorize(['b', 'b', 'a', 'c', 'b'], sort=True) >>> codes array([1, 1, 0, 2, 1]...) >>> uniques array(['a', 'b', 'c'], dtype=object) Missing values are indicated in codes with na_sentinel (-1 by default). Note that missing values are never included in uniques. >>> codes, uniques = pd.factorize(['b', None, 'a', 'c', 'b']) >>> codes array([ 0, -1, 1, 2, 0]...) >>> uniques array(['b', 'a', 'c'], dtype=object) Thus far, we’ve only factorized lists (which are internally coerced to NumPy arrays). When factorizing pandas objects, the type of uniques will differ. For Categoricals, a Categorical is returned. >>> cat = pd.Categorical(['a', 'a', 'c'], categories=['a', 'b', 'c']) >>> codes, uniques = pd.factorize(cat) >>> codes array([0, 0, 1]...) >>> uniques ['a', 'c'] Categories (3, object): ['a', 'b', 'c'] Notice that 'b' is in uniques.categories, despite not being present in cat.values. For all other pandas objects, an Index of the appropriate type is returned. >>> cat = pd.Series(['a', 'a', 'c']) >>> codes, uniques = pd.factorize(cat) >>> codes array([0, 0, 1]...) >>> uniques Index(['a', 'c'], dtype='object') If NaN is in the values, and we want to include NaN in the uniques of the values, it can be achieved by setting na_sentinel=None. >>> values = np.array([1, 2, 1, np.nan]) >>> codes, uniques = pd.factorize(values) # default: na_sentinel=-1 >>> codes array([ 0, 1, 0, -1]) >>> uniques array([1., 2.]) >>> codes, uniques = pd.factorize(values, na_sentinel=None) >>> codes array([0, 1, 0, 2]) >>> uniques array([ 1., 2., nan])", "score": "0.65512544"}, {"id": "18118", "text": "Function: python.library.audioop#audioop.findfactor\nSnippet: audioop.findfactor(fragment, reference) Return a factor F such that rms(add(fragment, mul(reference, -F))) is minimal, i.e., return the factor with which you should multiply reference to make it match as well as possible to fragment. The fragments should both contain 2-byte samples. The time taken by this routine is proportional to len(fragment).", "score": "0.63529265"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.63138574"}]}
{"task_id": "humaneval_26", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n", "entry_point": "remove_duplicates", "gold_generation": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n", "context": "From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]", "function_name": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:", "ctxs": [{"id": "17642", "text": "Function: python.library.array#array.array.remove\nSnippet: array.remove(x) Remove the first occurrence of x from the array.", "score": "0.7343623"}, {"id": "21302", "text": "Function: python.library.itertools#itertools.combinations_with_replacement\nSnippet: itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1.", "score": "0.70545703"}, {"id": "18674", "text": "Function: python.library.collections#collections.deque.remove\nSnippet: remove(value) Remove the first occurrence of value. If not found, raises a ValueError.", "score": "0.69897336"}, {"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.6977763"}, {"id": "42960", "text": "Function: numpy.user.basics.rec#numpy.lib.recfunctions.find_duplicates\nSnippet: numpy.lib.recfunctions.find_duplicates(a, key=None, ignoremask=True, return_index=False)[source] Find the duplicates in a structured array along a given key Parameters aarray-like Input array key{string, None}, optional Name of the fields along which to check the duplicates. If None, the search is performed by records ignoremask{True, False}, optional Whether masked data should be discarded or considered as duplicates. return_index{False, True}, optional Whether to return the indices of the duplicated values. Examples >>> from numpy.lib import recfunctions as rfn >>> ndtype = [('a', int)] >>> a = np.ma.array([1, 1, 1, 2, 2, 3, 3], ... mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) >>> rfn.find_duplicates(a, ignoremask=True, return_index=True) (masked_array(data=[(1,), (1,), (2,), (2,)], mask=[(False,), (False,), (False,), (False,)], fill_value=(999999,), dtype=[('a', '<i8')]), array([0, 1, 3, 4]))", "score": "0.6955785"}]}
{"task_id": "humaneval_27", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "entry_point": "flip_case", "gold_generation": "    return string.swapcase()\n", "context": "For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'", "function_name": "def flip_case(string: str) -> str:", "ctxs": [{"id": "24381", "text": "Function: python.library.stdtypes#str.swapcase\nSnippet: str.swapcase() Return a copy of the string with uppercase characters converted to lowercase and vice versa. Note that it is not necessarily true that s.swapcase().swapcase() == s.", "score": "0.79453576"}, {"id": "41825", "text": "Function: numpy.reference.generated.numpy.chararray.swapcase\nSnippet: numpy.chararray.swapcase method chararray.swapcase()[source] For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. See also char.swapcase", "score": "0.79027045"}, {"id": "41704", "text": "Function: numpy.reference.generated.numpy.char.chararray.swapcase\nSnippet: numpy.char.chararray.swapcase method char.chararray.swapcase()[source] For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. See also char.swapcase", "score": "0.7859198"}, {"id": "41759", "text": "Function: numpy.reference.generated.numpy.char.swapcase\nSnippet: numpy.char.swapcase char.swapcase(a)[source] Return element-wise a copy of the string with uppercase characters converted to lowercase and vice versa. Calls str.swapcase element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like, {str, unicode} Input array. Returns outndarray, {str, unicode} Output array of str or unicode, depending on input type See also str.swapcase Examples >>> c=np.array(['a1B c','1b Ca','b Ca1','cA1b'],'S5'); c array(['a1B c', '1b Ca', 'b Ca1', 'cA1b'], dtype='|S5') >>> np.char.swapcase(c) array(['A1b C', '1B cA', 'B cA1', 'Ca1B'], dtype='|S5')", "score": "0.7655488"}, {"id": "24364", "text": "Function: python.library.stdtypes#str.lower\nSnippet: str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard.", "score": "0.7625256"}]}
{"task_id": "humaneval_28", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n", "entry_point": "concatenate", "gold_generation": "    return ''.join(strings)\n", "context": "Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'", "function_name": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:", "ctxs": [{"id": "41672", "text": "Function: numpy.reference.generated.numpy.char.chararray.join\nSnippet: numpy.char.chararray.join method char.chararray.join(seq)[source] Return a string which is the concatenation of the strings in the sequence seq. See also char.join", "score": "0.7198366"}, {"id": "41795", "text": "Function: numpy.reference.generated.numpy.chararray.join\nSnippet: numpy.chararray.join method chararray.join(seq)[source] Return a string which is the concatenation of the strings in the sequence seq. See also char.join", "score": "0.71976733"}, {"id": "41737", "text": "Function: numpy.reference.generated.numpy.char.join\nSnippet: numpy.char.join char.join(sep, seq)[source] Return a string which is the concatenation of the strings in the sequence seq. Calls str.join element-wise. Parameters separray_like of str or unicode seqarray_like of str or unicode Returns outndarray Output array of str or unicode, depending on input types See also str.join", "score": "0.6928698"}, {"id": "41634", "text": "Function: numpy.reference.generated.numpy.char.add\nSnippet: numpy.char.add char.add(x1, x2)[source] Return element-wise string concatenation for two arrays of str or unicode. Arrays x1 and x2 must have the same shape. Parameters x1array_like of str or unicode Input array. x2array_like of str or unicode Input array. Returns addndarray Output array of string_ or unicode_, depending on input types of the same shape as x1 and x2.", "score": "0.6911685"}, {"id": "42705", "text": "Function: numpy.reference.generated.numpy.concatenate\nSnippet: numpy.concatenate numpy.concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting=\"same_kind\") Join a sequence of arrays along an existing axis. Parameters a1, a2, …sequence of array_like The arrays must have the same shape, except in the dimension corresponding to axis (the first, by default). axisint, optional The axis along which the arrays will be joined. If axis is None, arrays are flattened before use. Default is 0. outndarray, optional If provided, the destination to place the result. The shape must be correct, matching that of what concatenate would have returned if no out argument were specified. dtypestr or dtype If provided, the destination array will have this dtype. Cannot be provided together with out. New in version 1.20.0. casting{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional Controls what kind of data casting may occur. Defaults to ‘same_kind’. New in version 1.20.0. Returns resndarray The concatenated array. See also ma.concatenate Concatenate function that preserves input masks. array_split Split an array into multiple sub-arrays of equal or near-equal size. split Split array into a list of multiple sub-arrays of equal size. hsplit Split array into multiple sub-arrays horizontally (column wise). vsplit Split array into multiple sub-arrays vertically (row wise). dsplit Split array into multiple sub-arrays along the 3rd axis (depth). stack Stack a sequence of arrays along a new axis. block Assemble arrays from blocks. hstack Stack arrays in sequence horizontally (column wise). vstack Stack arrays in sequence vertically (row wise). dstack Stack arrays in sequence depth wise (along third dimension). column_stack Stack 1-D arrays as columns into a 2-D array. Notes When one or more of the arrays to be concatenated is a MaskedArray, this function will return a MaskedArray object instead of an ndarray, but the input masks are not preserved. In cases where a MaskedArray is expected as input, use the ma.concatenate function from the masked array module instead. Examples >>> a = np.array([[1, 2], [3, 4]]) >>> b = np.array([[5, 6]]) >>> np.concatenate((a, b), axis=0) array([[1, 2], [3, 4], [5, 6]]) >>> np.concatenate((a, b.T), axis=1) array([[1, 2, 5], [3, 4, 6]]) >>> np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) This function will not preserve masking of MaskedArray inputs. >>> a = np.ma.arange(3) >>> a[1] = np.ma.masked >>> b = np.arange(2, 5) >>> a masked_array(data=[0, --, 2], mask=[False, True, False], fill_value=999999) >>> b array([2, 3, 4]) >>> np.concatenate([a, b]) masked_array(data=[0, 1, 2, 2, 3, 4], mask=False, fill_value=999999) >>> np.ma.concatenate([a, b]) masked_array(data=[0, --, 2, 2, 3, 4], mask=[False, True, False, False, False, False], fill_value=999999)", "score": "0.6907548"}]}
{"task_id": "humaneval_29", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n", "entry_point": "filter_by_prefix", "gold_generation": "    return [x for x in strings if x.startswith(prefix)]\n", "context": "Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']", "function_name": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:", "ctxs": [{"id": "24379", "text": "Function: python.library.stdtypes#str.startswith\nSnippet: str.startswith(prefix[, start[, end]]) Return True if string starts with the prefix, otherwise return False. prefix can also be a tuple of prefixes to look for. With optional start, test string beginning at that position. With optional end, stop comparing string at that position.", "score": "0.7411933"}, {"id": "41756", "text": "Function: numpy.reference.generated.numpy.char.startswith\nSnippet: numpy.char.startswith char.startswith(a, prefix, start=0, end=None)[source] Returns a boolean array which is True where the string element in a starts with prefix, otherwise False. Calls str.startswith element-wise. Parameters aarray_like of str or unicode prefixstr start, endint, optional With optional start, test beginning at that position. With optional end, stop comparing at that position. Returns outndarray Array of booleans See also str.startswith", "score": "0.73429227"}, {"id": "41821", "text": "Function: numpy.reference.generated.numpy.chararray.startswith\nSnippet: numpy.chararray.startswith method chararray.startswith(prefix, start=0, end=None)[source] Returns a boolean array which is True where the string element in self starts with prefix, otherwise False. See also char.startswith", "score": "0.7322184"}, {"id": "41700", "text": "Function: numpy.reference.generated.numpy.char.chararray.startswith\nSnippet: numpy.char.chararray.startswith method char.chararray.startswith(prefix, start=0, end=None)[source] Returns a boolean array which is True where the string element in self starts with prefix, otherwise False. See also char.startswith", "score": "0.7318399"}, {"id": "18293", "text": "Function: python.library.stdtypes#bytearray.startswith\nSnippet: bytes.startswith(prefix[, start[, end]]) bytearray.startswith(prefix[, start[, end]]) Return True if the binary data starts with the specified prefix, otherwise return False. prefix can also be a tuple of prefixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. The prefix(es) to search for may be any bytes-like object.", "score": "0.7197743"}]}
{"task_id": "humaneval_30", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "entry_point": "get_positive", "gold_generation": "    return [e for e in l if e > 0]\n", "context": "Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]", "function_name": "def get_positive(l: list):", "ctxs": [{"id": "43105", "text": "Function: numpy.reference.generated.numpy.positive\nSnippet: numpy.positive numpy.positive(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'positive'> Numerical positive, element-wise. New in version 1.13.0. Parameters xarray_like or scalar Input array. Returns yndarray or scalar Returned array or scalar: y = +x. This is a scalar if x is a scalar. Notes Equivalent to x.copy(), but only defined for types that support arithmetic. Examples >>> x1 = np.array(([1., -1.])) >>> np.positive(x1) array([ 1., -1.]) The unary + operator can be used as a shorthand for np.positive on ndarrays. >>> x1 = np.array(([1., -1.])) >>> +x1 array([ 1., -1.])", "score": "0.6941178"}, {"id": "22392", "text": "Function: python.library.operator#operator.__pos__\nSnippet: operator.pos(obj) operator.__pos__(obj) Return obj positive (+obj).", "score": "0.6811649"}, {"id": "22346", "text": "Function: python.library.operator#operator.pos\nSnippet: operator.pos(obj) operator.__pos__(obj) Return obj positive (+obj).", "score": "0.679056"}, {"id": "43115", "text": "Function: numpy.reference.constants#numpy.PZERO\nSnippet: numpy.PZERO IEEE 754 floating point representation of positive zero. Returns yfloat A floating point representation of positive zero. See Also NZERO : Defines negative zero. isinf : Shows which elements are positive or negative infinity. isposinf : Shows which elements are positive infinity. isneginf : Shows which elements are negative infinity. isnan : Shows which elements are Not a Number. isfiniteShows which elements are finite - not one of Not a Number, positive infinity and negative infinity. Notes NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). Positive zero is considered to be a finite number. Examples >>> np.PZERO 0.0 >>> np.NZERO -0.0 >>> np.isfinite([np.PZERO]) array([ True]) >>> np.isnan([np.PZERO]) array([False]) >>> np.isinf([np.PZERO]) array([False])", "score": "0.6710578"}, {"id": "35937", "text": "Function: django.ref.models.fields#django.db.models.PositiveIntegerField\nSnippet: class PositiveIntegerField(**options)", "score": "0.6660719"}]}
{"task_id": "humaneval_31", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "entry_point": "is_prime", "gold_generation": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "context": "Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False", "function_name": "def is_prime(n):", "ctxs": [{"id": "14026", "text": "Function: pandas.reference.api.pandas.api.types.is_number\nSnippet: pandas.api.types.is_number pandas.api.types.is_number(obj)[source] Check if the object is a number. Returns True when the object is a number, and False if is not. Parameters obj:any type The object to check if is a number. Returns is_number:bool Whether obj is a number or not. See also api.types.is_integer Checks a subgroup of numbers. Examples >>> from pandas.api.types import is_number >>> is_number(1) True >>> is_number(7.15) True Booleans are valid because they are int subclass. >>> is_number(False) True >>> is_number(\"foo\") False >>> is_number(\"5\") False", "score": "0.71842146"}, {"id": "19474", "text": "Function: python.library.decimal#decimal.Context.is_finite\nSnippet: is_finite(x) Returns True if x is finite; otherwise returns False.", "score": "0.68446726"}, {"id": "14019", "text": "Function: pandas.reference.api.pandas.api.types.is_integer\nSnippet: pandas.api.types.is_integer pandas.api.types.is_integer() Return True if given object is integer. Returns bool", "score": "0.6834785"}, {"id": "19538", "text": "Function: python.library.decimal#decimal.Decimal.is_finite\nSnippet: is_finite() Return True if the argument is a finite number, and False if the argument is an infinity or a NaN.", "score": "0.6699678"}, {"id": "21811", "text": "Function: python.library.math#math.isnan\nSnippet: math.isnan(x) Return True if x is a NaN (not a number), and False otherwise.", "score": "0.66548735"}]}
{"task_id": "humaneval_32", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n", "entry_point": "find_zero", "gold_generation": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n", "context": "Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n", "function_name": "import math\n\n\ndef poly(xs: list, x: float):\n    \n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):", "ctxs": [{"id": "43626", "text": "Function: numpy.reference.generated.numpy.polynomial.polynomial.polyvalfromroots\nSnippet: numpy.polynomial.polynomial.polyvalfromroots polynomial.polynomial.polyvalfromroots(x, r, tensor=True)[source] Evaluate a polynomial specified by its roots at points x. If r is of length N, this function returns the value \\[p(x) = \\prod_{n=1}^{N} (x - r_n)\\] The parameter x is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either x or its elements must support multiplication and addition both with themselves and with the elements of r. If r is a 1-D array, then p(x) will have the same shape as x. If r is multidimensional, then the shape of the result depends on the value of tensor. If tensor is ``True` the shape will be r.shape[1:] + x.shape; that is, each polynomial is evaluated at every value of x. If tensor is False, the shape will be r.shape[1:]; that is, each polynomial is evaluated only for the corresponding broadcast value of x. Note that scalars have shape (,). New in version 1.12. Parameters xarray_like, compatible object If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of r. rarray_like Array of roots. If r is multidimensional the first index is the root index, while the remaining indices enumerate multiple polynomials. For instance, in the two dimensional case the roots of each polynomial may be thought of as stored in the columns of r. tensorboolean, optional If True, the shape of the roots array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in r is evaluated for every element of x. If False, x is broadcast over the columns of r for the evaluation. This keyword is useful when r is multidimensional. The default value is True. Returns valuesndarray, compatible object The shape of the returned array is described above. See also polyroots, polyfromroots, polyval Examples >>> from numpy.polynomial.polynomial import polyvalfromroots >>> polyvalfromroots(1, [1,2,3]) 0.0 >>> a = np.arange(4).reshape(2,2) >>> a array([[0, 1], [2, 3]]) >>> polyvalfromroots(a, [-1, 0, 1]) array([[-0., 0.], [ 6., 24.]]) >>> r = np.arange(-2, 2).reshape(2,2) # multidimensional coefficients >>> r # each column of r defines one polynomial array([[-2, -1], [ 0, 1]]) >>> b = [-2, 1] >>> polyvalfromroots(b, r, tensor=True) array([[-0., 3.], [ 3., 0.]]) >>> polyvalfromroots(b, r, tensor=False) array([-0., 0.])", "score": "0.7187178"}, {"id": "43623", "text": "Function: numpy.reference.generated.numpy.polynomial.polynomial.polyval\nSnippet: numpy.polynomial.polynomial.polyval polynomial.polynomial.polyval(x, c, tensor=True)[source] Evaluate a polynomial at points x. If c is of length n + 1, this function returns the value \\[p(x) = c_0 + c_1 * x + ... + c_n * x^n\\] The parameter x is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either x or its elements must support multiplication and addition both with themselves and with the elements of c. If c is a 1-D array, then p(x) will have the same shape as x. If c is multidimensional, then the shape of the result depends on the value of tensor. If tensor is true the shape will be c.shape[1:] + x.shape. If tensor is false the shape will be c.shape[1:]. Note that scalars have shape (,). Trailing zeros in the coefficients will be used in the evaluation, so they should be avoided if efficiency is a concern. Parameters xarray_like, compatible object If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of c. carray_like Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of c. tensorboolean, optional If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in c is evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation. This keyword is useful when c is multidimensional. The default value is True. New in version 1.7.0. Returns valuesndarray, compatible object The shape of the returned array is described above. See also polyval2d, polygrid2d, polyval3d, polygrid3d Notes The evaluation uses Horner’s method. Examples >>> from numpy.polynomial.polynomial import polyval >>> polyval(1, [1,2,3]) 6.0 >>> a = np.arange(4).reshape(2,2) >>> a array([[0, 1], [2, 3]]) >>> polyval(a, [1,2,3]) array([[ 1., 6.], [17., 34.]]) >>> coef = np.arange(4).reshape(2,2) # multidimensional coefficients >>> coef array([[0, 1], [2, 3]]) >>> polyval([1,2], coef, tensor=True) array([[2., 4.], [4., 7.]]) >>> polyval([1,2], coef, tensor=False) array([2., 7.])", "score": "0.71499366"}, {"id": "43605", "text": "Function: numpy.reference.generated.numpy.polynomial.polynomial.polynomial.fromroots\nSnippet: numpy.polynomial.polynomial.Polynomial.fromroots method classmethod polynomial.polynomial.Polynomial.fromroots(roots, domain=[], window=None)[source] Return series instance that has the specified roots. Returns a series representing the product (x - r[0])*(x - r[1])*...*(x - r[n-1]), where r is a list of roots. Parameters rootsarray_like List of roots. domain{[], None, array_like}, optional Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is []. window{None, array_like}, optional Window for the returned series. If None the class window is used. The default is None. Returns new_seriesseries Series with the specified roots.", "score": "0.70759577"}, {"id": "43591", "text": "Function: numpy.reference.generated.numpy.polynomial.polynomial.polyint\nSnippet: numpy.polynomial.polynomial.polyint polynomial.polynomial.polyint(c, m=1, k=[], lbnd=0, scl=1, axis=0)[source] Integrate a polynomial. Returns the polynomial coefficients c integrated m times from lbnd along axis. At each iteration the resulting series is multiplied by scl and an integration constant, k, is added. The scaling factor is for use in a linear change of variable. (“Buyer beware”: note that, depending on what one is doing, one may want scl to be the reciprocal of what one might expect; for more information, see the Notes section below.) The argument c is an array of coefficients, from low to high degree along each axis, e.g., [1,2,3] represents the polynomial 1 + 2*x + 3*x**2 while [[1,2],[1,2]] represents 1 + 1*x + 2*y + 2*x*y if axis=0 is x and axis=1 is y. Parameters carray_like 1-D array of polynomial coefficients, ordered from low to high. mint, optional Order of integration, must be positive. (Default: 1) k{[], list, scalar}, optional Integration constant(s). The value of the first integral at zero is the first value in the list, the value of the second integral at zero is the second value, etc. If k == [] (the default), all constants are set to zero. If m == 1, a single scalar can be given instead of a list. lbndscalar, optional The lower bound of the integral. (Default: 0) sclscalar, optional Following each integration the result is multiplied by scl before the integration constant is added. (Default: 1) axisint, optional Axis over which the integral is taken. (Default: 0). New in version 1.7.0. Returns Sndarray Coefficient array of the integral. Raises ValueError If m < 1, len(k) > m, np.ndim(lbnd) != 0, or np.ndim(scl) != 0. See also polyder Notes Note that the result of each integration is multiplied by scl. Why is this important to note? Say one is making a linear change of variable \\(u = ax + b\\) in an integral relative to x. Then \\(dx = du/a\\), so one will need to set scl equal to \\(1/a\\) - perhaps not what one would have first thought. Examples >>> from numpy.polynomial import polynomial as P >>> c = (1,2,3) >>> P.polyint(c) # should return array([0, 1, 1, 1]) array([0., 1., 1., 1.]) >>> P.polyint(c,3) # should return array([0, 0, 0, 1/6, 1/12, 1/20]) array([ 0. , 0. , 0. , 0.16666667, 0.08333333, # may vary 0.05 ]) >>> P.polyint(c,k=3) # should return array([3, 1, 1, 1]) array([3., 1., 1., 1.]) >>> P.polyint(c,lbnd=-2) # should return array([6, 1, 1, 1]) array([6., 1., 1., 1.]) >>> P.polyint(c,scl=-2) # should return array([0, -2, -2, -2]) array([ 0., -2., -2., -2.])", "score": "0.7062741"}, {"id": "43625", "text": "Function: numpy.reference.generated.numpy.polynomial.polynomial.polyval3d\nSnippet: numpy.polynomial.polynomial.polyval3d polynomial.polynomial.polyval3d(x, y, z, c)[source] Evaluate a 3-D polynomial at points (x, y, z). This function returns the values: \\[p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * x^i * y^j * z^k\\] The parameters x, y, and z are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either x, y, and z or their elements must support multiplication and addition both with themselves and with the elements of c. If c has fewer than 3 dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape. Parameters x, y, zarray_like, compatible object The three dimensional series is evaluated at the points (x, y, z), where x, y, and z must have the same shape. If any of x, y, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is treated as a scalar. carray_like Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in c[i,j,k]. If c has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients. Returns valuesndarray, compatible object The values of the multidimensional polynomial on points formed with triples of corresponding values from x, y, and z. See also polyval, polyval2d, polygrid2d, polygrid3d Notes New in version 1.7.0.", "score": "0.7037261"}]}
{"task_id": "humaneval_33", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n", "entry_point": "sort_third", "gold_generation": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n", "context": "This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]", "function_name": "def sort_third(l: list):", "ctxs": [{"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.70208603"}, {"id": "25739", "text": "Function: python.library.stdtypes\nSnippet: a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort. Tuples Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a set or dict instance). class tuple([iterable]) Tuples may be constructed in a number of ways: Using a pair of parentheses to denote the empty tuple: () Using a trailing comma for a singleton tuple: a, or (a,) Separating items with commas: a, b, c or (a, b, c) Using the tuple() built-in: tuple() or tuple(iterable) The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, tuple('abc') returns ('a', 'b', 'c') and tuple( [1, 2, 3] ) returns (1, 2, 3). If no argument is given, the constructor creates a new empty tuple, (). Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, f(a, b, c) is a function call with three arguments, while f((a, b, c)) is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, collections.namedtuple() may be a more appropriate choice than a simple tuple object. Ranges The range type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops. class range(stop) class range(start, stop[, step]) The arguments to the range constructor must be integers (either built-in int or any object that implements the __index__ special method). If the step argument is omitted, it defaults to 1. If the start argument is", "score": "0.70050657"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.68740463"}, {"id": "43173", "text": "Function: numpy.reference.generated.numpy.searchsorted\nSnippet: numpy.searchsorted numpy.searchsorted(a, v, side='left', sorter=None)[source] Find indices where elements should be inserted to maintain order. Find the indices into a sorted array a such that, if the corresponding elements in v were inserted before the indices, the order of a would be preserved. Assuming that a is sorted: side returned index i satisfies left a[i-1] < v <= a[i] right a[i-1] <= v < a[i] Parameters a1-D array_like Input array. If sorter is None, then it must be sorted in ascending order, otherwise sorter must be an array of indices that sort it. varray_like Values to insert into a. side{‘left’, ‘right’}, optional If ‘left’, the index of the first suitable location found is given. If ‘right’, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of a). sorter1-D array_like, optional Optional array of integer indices that sort array a into ascending order. They are typically the result of argsort. New in version 1.7.0. Returns indicesint or array of ints Array of insertion points with the same shape as v, or an integer if v is a scalar. See also sort Return a sorted copy of an array. histogram Produce histogram from 1-D data. Notes Binary search is used to find the required insertion points. As of NumPy 1.4.0 searchsorted works with real/complex arrays containing nan values. The enhanced sort order is documented in sort. This function uses the same algorithm as the builtin python bisect.bisect_left (side='left') and bisect.bisect_right (side='right') functions, which is also vectorized in the v argument. Examples >>> np.searchsorted([1,2,3,4,5], 3) 2 >>> np.searchsorted([1,2,3,4,5], 3, side='right') 3 >>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3]) array([0, 5, 1, 2])", "score": "0.6863589"}, {"id": "18247", "text": "Function: python.library.bisect#bisect.insort_left\nSnippet: bisect.insort_left(a, x, lo=0, hi=len(a)) Insert x in a in sorted order. This is equivalent to a.insert(bisect.bisect_left(a, x, lo, hi), x) assuming that a is already sorted. Keep in mind that the O(log n) search is dominated by the slow O(n) insertion step.", "score": "0.6853696"}]}
{"task_id": "humaneval_34", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "entry_point": "unique", "gold_generation": "    return sorted(list(set(l)))\n", "context": "Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]", "function_name": "def unique(l: list):", "ctxs": [{"id": "43259", "text": "Function: numpy.reference.generated.numpy.unique\nSnippet: numpy.unique numpy.unique(ar, return_index=False, return_inverse=False, return_counts=False, axis=None)[source] Find the unique elements of an array. Returns the sorted unique elements of an array. There are three optional outputs in addition to the unique elements: the indices of the input array that give the unique values the indices of the unique array that reconstruct the input array the number of times each unique value comes up in the input array Parameters ararray_like Input array. Unless axis is specified, this will be flattened if it is not already 1-D. return_indexbool, optional If True, also return the indices of ar (along the specified axis, if provided, or in the flattened array) that result in the unique array. return_inversebool, optional If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct ar. return_countsbool, optional If True, also return the number of times each unique item appears in ar. New in version 1.9.0. axisint or None, optional The axis to operate on. If None, ar will be flattened. If an integer, the subarrays indexed by the given axis will be flattened and treated as the elements of a 1-D array with the dimension of the given axis, see the notes for more details. Object arrays or structured arrays that contain objects are not supported if the axis kwarg is used. The default is None. New in version 1.13.0. Returns uniquendarray The sorted unique values. unique_indicesndarray, optional The indices of the first occurrences of the unique values in the original array. Only provided if return_index is True. unique_inversendarray, optional The indices to reconstruct the original array from the unique array. Only provided if return_inverse is True. unique_countsndarray, optional The number of times each of the unique values comes up in the original array. Only provided if return_counts is True. New in version 1.9.0. See also numpy.lib.arraysetops Module with a number of other functions for performing set operations on arrays. repeat Repeat elements of an array. Notes When an axis is specified the subarrays indexed by the axis are sorted. This is done by making the specified axis the first dimension of the array (move the axis to the first dimension to keep the order of the other axes) and then flattening the subarrays in C order. The flattened subarrays are then viewed as a structured type with each element given a label, with the effect that we end up with a 1-D array of structured types that can be treated in the same way as any other 1-D array. The result is that the flattened subarrays are sorted in lexicographic order starting with the first element. Examples >>> np.unique([1, 1, 2, 2, 3, 3]) array([1, 2, 3]) >>> a = np.array([[1, 1], [2, 3]]) >>> np.unique(a) array([1, 2, 3]) Return the unique rows of a 2D array >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]]) >>> np.unique(a, axis=0) array([[1, 0, 0], [2, 3, 4]]) Return the indices of the original array that give", "score": "0.722904"}, {"id": "14770", "text": "Function: pandas.reference.api.pandas.index.unique\nSnippet: pandas.Index.unique Index.unique(level=None)[source] Return unique values in the index. Unique values are returned in order of appearance, this does NOT sort. Parameters level:int or hashable, optional Only return values from specified level (for MultiIndex). If int, gets the level by integer position, else by level name. Returns Index See also unique Numpy array of unique values in that column. Series.unique Return unique values of Series object.", "score": "0.7206538"}, {"id": "43260", "text": "Function: numpy.reference.generated.numpy.unique\nSnippet: the unique values: >>> a = np.array(['a', 'b', 'b', 'c', 'a']) >>> u, indices = np.unique(a, return_index=True) >>> u array(['a', 'b', 'c'], dtype='<U1') >>> indices array([0, 1, 3]) >>> a[indices] array(['a', 'b', 'c'], dtype='<U1') Reconstruct the input array from the unique values and inverse: >>> a = np.array([1, 2, 6, 4, 2, 3, 2]) >>> u, indices = np.unique(a, return_inverse=True) >>> u array([1, 2, 3, 4, 6]) >>> indices array([0, 1, 4, 3, 1, 2, 1]) >>> u[indices] array([1, 2, 6, 4, 2, 3, 2]) Reconstruct the input values from the unique values and counts: >>> a = np.array([1, 2, 6, 4, 2, 3, 2]) >>> values, counts = np.unique(a, return_counts=True) >>> values array([1, 2, 3, 4, 6]) >>> counts array([1, 3, 1, 1, 1]) >>> np.repeat(values, counts) array([1, 2, 2, 2, 3, 4, 6]) # original order not preserved", "score": "0.7148996"}, {"id": "8201", "text": "Function: torch.generated.torch.unique#torch.unique\nSnippet: torch.unique(*args, **kwargs) Returns the unique elements of the input tensor. Note This function is different from torch.unique_consecutive() in the sense that this function also eliminates non-consecutive duplicate values. Note Currently in the CUDA implementation and the CPU implementation when dim is specified, torch.unique always sort the tensor at the beginning regardless of the sort argument. Sorting could be slow, so if your input tensor is already sorted, it is recommended to use torch.unique_consecutive() which avoids the sorting. Parameters input (Tensor) – the input tensor sorted (bool) – Whether to sort the unique elements in ascending order before returning as output. return_inverse (bool) – Whether to also return the indices for where elements in the original input ended up in the returned unique list. return_counts (bool) – Whether to also return the counts for each unique element. dim (int) – the dimension to apply unique. If None, the unique of the flattened input is returned. default: None Returns A tensor or a tuple of tensors containing output (Tensor): the output list of unique scalar elements. inverse_indices (Tensor): (optional) if return_inverse is True, there will be an additional returned tensor (same shape as input) representing the indices for where elements in the original input map to in the output; otherwise, this function will only return a single tensor. counts (Tensor): (optional) if return_counts is True, there will be an additional returned tensor (same shape as output or output.size(dim), if dim was specified) representing the number of occurrences for each unique value or tensor. Return type (Tensor, Tensor (optional), Tensor (optional)) Example: >>> output = torch.unique(torch.tensor([1, 3, 2, 3], dtype=torch.long)) >>> output tensor([ 2, 3, 1]) >>> output, inverse_indices = torch.unique( ... torch.tensor([1, 3, 2, 3], dtype=torch.long), sorted=True, return_inverse=True) >>> output tensor([ 1, 2, 3]) >>> inverse_indices tensor([ 0, 2, 1, 2]) >>> output, inverse_indices = torch.unique( ... torch.tensor([[1, 3], [2, 3]], dtype=torch.long), sorted=True, return_inverse=True) >>> output tensor([ 1, 2, 3]) >>> inverse_indices tensor([[ 0, 2], [ 1, 2]])", "score": "0.7128111"}, {"id": "8166", "text": "Function: torch.tensors#torch.Tensor.unique\nSnippet: unique(sorted=True, return_inverse=False, return_counts=False, dim=None) [source] Returns the unique elements of the input tensor. See torch.unique()", "score": "0.71223104"}]}
{"task_id": "humaneval_35", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n", "entry_point": "max_element", "gold_generation": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n", "context": "Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123", "function_name": "def max_element(l: list):", "ctxs": [{"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.71876734"}, {"id": "43857", "text": "Function: numpy.reference.generated.numpy.recarray.max\nSnippet: numpy.recarray.max method recarray.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the maximum along a given axis. Refer to numpy.amax for full documentation. See also numpy.amax equivalent function", "score": "0.7018105"}, {"id": "42615", "text": "Function: numpy.reference.generated.numpy.amax\nSnippet: >>> np.amax([5], initial=6) 6 >>> max([5], default=6) 5", "score": "0.69789696"}, {"id": "42531", "text": "Function: numpy.reference.generated.numpy.ndarray.max\nSnippet: numpy.ndarray.max method ndarray.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the maximum along a given axis. Refer to numpy.amax for full documentation. See also numpy.amax equivalent function", "score": "0.6943878"}, {"id": "19490", "text": "Function: python.library.decimal#decimal.Context.max\nSnippet: max(x, y) Compares two values numerically and returns the maximum.", "score": "0.6863295"}]}
{"task_id": "humaneval_36", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n", "entry_point": "fizz_buzz", "gold_generation": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n", "context": "Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3", "function_name": "def fizz_buzz(n: int):", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6656252"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.64262784"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.641238"}, {"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.63967305"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6392085"}]}
{"task_id": "humaneval_37", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n", "entry_point": "sort_even", "gold_generation": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n", "context": "This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]", "function_name": "def sort_even(l: list):", "ctxs": [{"id": "18247", "text": "Function: python.library.bisect#bisect.insort_left\nSnippet: bisect.insort_left(a, x, lo=0, hi=len(a)) Insert x in a in sorted order. This is equivalent to a.insert(bisect.bisect_left(a, x, lo, hi), x) assuming that a is already sorted. Keep in mind that the O(log n) search is dominated by the slow O(n) insertion step.", "score": "0.7127498"}, {"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.70943254"}, {"id": "13972", "text": "Function: pandas.reference.api.pandas.api.extensions.extensionarray.searchsorted\nSnippet: pandas.api.extensions.ExtensionArray.searchsorted ExtensionArray.searchsorted(value, side='left', sorter=None)[source] Find indices where elements should be inserted to maintain order. Find the indices into a sorted array self (a) such that, if the corresponding elements in value were inserted before the indices, the order of self would be preserved. Assuming that self is sorted: side returned index i satisfies left self[i-1] < value <= self[i] right self[i-1] <= value < self[i] Parameters value:array-like, list or scalar Value(s) to insert into self. side:{‘left’, ‘right’}, optional If ‘left’, the index of the first suitable location found is given. If ‘right’, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of self). sorter:1-D array-like, optional Optional array of integer indices that sort array a into ascending order. They are typically the result of argsort. Returns array of ints or int If value is array-like, array of insertion points. If value is scalar, a single integer. See also numpy.searchsorted Similar method from NumPy.", "score": "0.70133257"}, {"id": "43173", "text": "Function: numpy.reference.generated.numpy.searchsorted\nSnippet: numpy.searchsorted numpy.searchsorted(a, v, side='left', sorter=None)[source] Find indices where elements should be inserted to maintain order. Find the indices into a sorted array a such that, if the corresponding elements in v were inserted before the indices, the order of a would be preserved. Assuming that a is sorted: side returned index i satisfies left a[i-1] < v <= a[i] right a[i-1] <= v < a[i] Parameters a1-D array_like Input array. If sorter is None, then it must be sorted in ascending order, otherwise sorter must be an array of indices that sort it. varray_like Values to insert into a. side{‘left’, ‘right’}, optional If ‘left’, the index of the first suitable location found is given. If ‘right’, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of a). sorter1-D array_like, optional Optional array of integer indices that sort array a into ascending order. They are typically the result of argsort. New in version 1.7.0. Returns indicesint or array of ints Array of insertion points with the same shape as v, or an integer if v is a scalar. See also sort Return a sorted copy of an array. histogram Produce histogram from 1-D data. Notes Binary search is used to find the required insertion points. As of NumPy 1.4.0 searchsorted works with real/complex arrays containing nan values. The enhanced sort order is documented in sort. This function uses the same algorithm as the builtin python bisect.bisect_left (side='left') and bisect.bisect_right (side='right') functions, which is also vectorized in the v argument. Examples >>> np.searchsorted([1,2,3,4,5], 3) 2 >>> np.searchsorted([1,2,3,4,5], 3, side='right') 3 >>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3]) array([0, 5, 1, 2])", "score": "0.69944715"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.69740313"}]}
{"task_id": "humaneval_38", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n", "entry_point": "decode_cyclic", "gold_generation": "    return encode_cyclic(encode_cyclic(s))\n", "context": "returns encoded string by cycling groups of three characters.", "function_name": "def encode_cyclic(s: str):\n    \n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):", "ctxs": [{"id": "31465", "text": "Function: matplotlib.dviread#matplotlib.dviread.PsFont.encoding\nSnippet: encoding Alias for field number 3", "score": "0.68261516"}, {"id": "41650", "text": "Function: numpy.reference.generated.numpy.char.chararray.encode\nSnippet: numpy.char.chararray.encode method char.chararray.encode(encoding=None, errors=None)[source] Calls str.encode element-wise. See also char.encode", "score": "0.68248546"}, {"id": "41774", "text": "Function: numpy.reference.generated.numpy.chararray.encode\nSnippet: numpy.chararray.encode method chararray.encode(encoding=None, errors=None)[source] Calls str.encode element-wise. See also char.encode", "score": "0.67975837"}, {"id": "18535", "text": "Function: python.library.codecs\nSnippet: from the underlying stream. Encodings and Unicode Strings are stored internally as sequences of code points in range 0x0–0x10FFFF. (See PEP 393 for more details about the implementation.) Once a string object is used outside of CPU and memory, endianness and how these arrays are stored as bytes become an issue. As with other codecs, serialising a string into a sequence of bytes is known as encoding, and recreating the string from the sequence of bytes is known as decoding. There are a variety of different text serialisation codecs, which are collectivity referred to as text encodings. The simplest text encoding (called 'latin-1' or 'iso-8859-1') maps the code points 0–255 to the bytes 0x0–0xff, which means that a string object that contains code points above U+00FF can’t be encoded with this codec. Doing so will raise a UnicodeEncodeError that looks like the following (although the details of the error message may differ): UnicodeEncodeError: 'latin-1' codec can't encode character '\\u1234' in position 3: ordinal not in range(256). There’s another group of encodings (the so called charmap encodings) that choose a different subset of all Unicode code points and how these code points are mapped to the bytes 0x0–0xff. To see how this is done simply open e.g. encodings/cp1252.py (which is an encoding that is used primarily on Windows). There’s a string constant with 256 characters that shows you which character is mapped to which byte value. All of these encodings can only encode 256 of the 1114112 code points defined in Unicode. A simple and straightforward way that can store each Unicode code point, is to store each code point as four consecutive bytes. There are two possibilities: store the bytes in big endian or in little endian order. These two encodings are called UTF-32-BE and UTF-32-LE respectively. Their disadvantage is that if e.g. you use UTF-32-BE on a little endian machine you will always have to swap bytes on encoding and decoding. UTF-32 avoids this problem: bytes will always be in natural endianness. When these bytes are read by a CPU with a different endianness, then bytes have to be swapped though. To be able to detect the endianness of a UTF-16 or UTF-32 byte sequence, there’s the so called BOM (“Byte Order Mark”). This is the Unicode character U+FEFF. This character can be prepended to every UTF-16 or UTF-32 byte sequence. The byte swapped version of this character (0xFFFE) is an illegal character that may not appear in a Unicode text. So when the first character in an UTF-16 or UTF-32 byte sequence appears to be a U+FFFE the bytes have to be swapped on decoding. Unfortunately the character U+FEFF had a second purpose as a ZERO WIDTH NO-BREAK SPACE: a character that has no width and doesn’t allow a word to be split. It can e.g. be used to give hints to a ligature algorithm. With Unicode 4.0 using U+FEFF as a ZERO WIDTH NO-BREAK SPACE has been deprecated (with U+2060 (WORD JOINER) assuming this role). Nevertheless Unicode", "score": "0.65138674"}, {"id": "18140", "text": "Function: python.library.base64#base64.a85encode\nSnippet: base64.a85encode(b, *, foldspaces=False, wrapcol=0, pad=False, adobe=False) Encode the bytes-like object b using Ascii85 and return the encoded bytes. foldspaces is an optional flag that uses the special short sequence ‘y’ instead of 4 consecutive spaces (ASCII 0x20) as supported by ‘btoa’. This feature is not supported by the “standard” Ascii85 encoding. wrapcol controls whether the output should have newline (b'\\n') characters added to it. If this is non-zero, each output line will be at most this many characters long. pad controls whether the input is padded to a multiple of 4 before encoding. Note that the btoa implementation always pads. adobe controls whether the encoded byte sequence is framed with <~ and ~>, which is used by the Adobe implementation. New in version 3.4.", "score": "0.6506456"}]}
{"task_id": "humaneval_39", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "entry_point": "prime_fib", "gold_generation": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "context": "prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89", "function_name": "def prime_fib(n: int):", "ctxs": [{"id": "20299", "text": "Function: python.library.functools\nSnippet: in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991: ... pep = get_pep(n) ... print(n, len(pep)) >>> get_pep.cache_info() CacheInfo(hits=3, misses=8, maxsize=32, currsize=8) Example of efficiently computing Fibonacci numbers using a cache to implement a dynamic programming technique: @lru_cache(maxsize=None) def fib(n): if n < 2: return n return fib(n-1) + fib(n-2) >>> [fib(n) for n in range(16)] [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610] >>> fib.cache_info() CacheInfo(hits=28, misses=16, maxsize=None, currsize=16) New in version 3.2. Changed in version 3.3: Added the typed option. Changed in version 3.8: Added the user_function option. New in version 3.9: Added the function cache_parameters() @functools.total_ordering Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest. This simplifies the effort involved in specifying all of the possible rich comparison operations: The class must define one of __lt__(), __le__(), __gt__(), or __ge__(). In addition, the class should supply an __eq__() method. For example: @total_ordering class Student: def _is_valid_operand(self, other): return (hasattr(other, \"lastname\") and hasattr(other, \"firstname\")) def __eq__(self, other): if not self._is_valid_operand(other): return NotImplemented return ((self.lastname.lower(), self.firstname.lower()) == (other.lastname.lower(), other.firstname.lower())) def __lt__(self, other): if not self._is_valid_operand(other): return NotImplemented return ((self.lastname.lower(), self.firstname.lower()) < (other.lastname.lower(), other.firstname.lower())) Note While this decorator makes it easy to create well behaved totally ordered types, it does come at the cost of slower execution and more complex stack traces for the derived comparison methods. If performance benchmarking indicates this is a bottleneck for a given application, implementing all six rich comparison methods instead is likely to provide an easy speed boost. New in version 3.2. Changed in version 3.4: Returning NotImplemented from the underlying comparison function for unrecognised types is now supported. functools.partial(func, /, *args, **keywords) Return a new partial object which when called will behave like func called with the positional arguments args and keyword arguments keywords. If more arguments are supplied to the call, they are appended to args. If additional keyword arguments are supplied, they extend and override keywords. Roughly equivalent to: def partial(func, /, *args, **keywords): def newfunc(*fargs, **fkeywords): newkeywords = {**keywords, **fkeywords} return func(*args, *fargs, **newkeywords) newfunc.func = func newfunc.args = args newfunc.keywords = keywords return newfunc The partial() is used for partial function application which “freezes” some portion of a function’s arguments and/or keywords resulting in a new object with a simplified signature. For example, partial() can be used to create a callable that behaves like the int() function where the base argument defaults to two: >>> from functools import partial >>> basetwo = partial(int, base=2) >>> basetwo.__doc__ = 'Convert base 2 string to an int.' >>> basetwo('10010') 18 class functools.partialmethod(func, /, *args, **keywords) Return a new partialmethod descriptor which behaves like partial except that it is designed to be used as a method definition rather than being directly callable. func must be a descriptor or a callable (objects which are both, like normal functions, are handled as descriptors). When func is a descriptor (such as a normal Python function, classmethod(), staticmethod(),", "score": "0.6336514"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.6252171"}, {"id": "7524", "text": "Function: torch.generated.torch.polygamma#torch.polygamma\nSnippet: torch.polygamma(n, input, *, out=None) → Tensor Computes the nthn^{th} derivative of the digamma function on input. n≥0n \\geq 0 is called the order of the polygamma function. ψ(n)(x)=d(n)dx(n)ψ(x)\\psi^{(n)}(x) = \\frac{d^{(n)}}{dx^{(n)}} \\psi(x) Note This function is implemented only for nonnegative integers n≥0n \\geq 0 . Parameters n (int) – the order of the polygamma function input (Tensor) – the input tensor. Keyword Arguments out (Tensor, optional) – the output tensor. Example:: >>> a = torch.tensor([1, 0.5]) >>> torch.polygamma(1, a) tensor([1.64493, 4.9348]) >>> torch.polygamma(2, a) tensor([ -2.4041, -16.8288]) >>> torch.polygamma(3, a) tensor([ 6.4939, 97.4091]) >>> torch.polygamma(4, a) tensor([ -24.8863, -771.4742])", "score": "0.6235478"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.62149644"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6196184"}]}
{"task_id": "humaneval_40", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "entry_point": "triples_sum_to_zero", "gold_generation": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "context": "triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False", "function_name": "def triples_sum_to_zero(l: list):", "ctxs": [{"id": "42915", "text": "Function: numpy.reference.generated.numpy.isfinite\nSnippet: numpy.isfinite numpy.isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'isfinite'> Test element-wise for finiteness (not infinity and not Not a Number). The result is returned as a boolean array. Parameters xarray_like Input values. outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray, bool True where x is not positive infinity, negative infinity, or NaN; false otherwise. This is a scalar if x is a scalar. See also isinf, isneginf, isposinf, isnan Notes Not a Number, positive infinity and negative infinity are considered to be non-finite. NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Also that positive infinity is not equivalent to negative infinity. But infinity is equivalent to positive infinity. Errors result if the second argument is also supplied when x is a scalar input, or if first and second arguments have different shapes. Examples >>> np.isfinite(1) True >>> np.isfinite(0) True >>> np.isfinite(np.nan) False >>> np.isfinite(np.inf) False >>> np.isfinite(np.NINF) False >>> np.isfinite([np.log(-1.),1.,np.log(0)]) array([False, True, False]) >>> x = np.array([-np.inf, 0., np.inf]) >>> y = np.array([2, 2, 2]) >>> np.isfinite(x, y) array([0, 1, 0]) >>> y array([0, 1, 0])", "score": "0.6922368"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.6920584"}, {"id": "19482", "text": "Function: python.library.decimal#decimal.Context.is_zero\nSnippet: is_zero(x) Returns True if x is a zero; otherwise returns False.", "score": "0.6866145"}, {"id": "42717", "text": "Function: numpy.reference.generated.numpy.count_nonzero\nSnippet: numpy.count_nonzero numpy.count_nonzero(a, axis=None, *, keepdims=False)[source] Counts the number of non-zero values in the array a. The word “non-zero” is in reference to the Python 2.x built-in method __nonzero__() (renamed __bool__() in Python 3.x) of Python objects that tests an object’s “truthfulness”. For example, any number is considered truthful if it is nonzero, whereas any string is considered truthful if it is not the empty string. Thus, this function (recursively) counts how many elements in a (and in sub-arrays thereof) have their __nonzero__() or __bool__() method evaluated to True. Parameters aarray_like The array for which to count non-zeros. axisint or tuple, optional Axis or tuple of axes along which to count non-zeros. Default is None, meaning that non-zeros will be counted along a flattened version of a. New in version 1.12.0. keepdimsbool, optional If this is set to True, the axes that are counted are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. New in version 1.19.0. Returns countint or array of int Number of non-zero values in the array along a given axis. Otherwise, the total number of non-zero values in the array is returned. See also nonzero Return the coordinates of all the non-zero values. Examples >>> np.count_nonzero(np.eye(4)) 4 >>> a = np.array([[0, 1, 7, 0], ... [3, 0, 2, 19]]) >>> np.count_nonzero(a) 5 >>> np.count_nonzero(a, axis=0) array([1, 1, 2, 1]) >>> np.count_nonzero(a, axis=1) array([2, 3]) >>> np.count_nonzero(a, axis=1, keepdims=True) array([[2], [3]])", "score": "0.6846968"}, {"id": "20192", "text": "Function: python.library.stdtypes#float.is_integer\nSnippet: float.is_integer() Return True if the float instance is finite with integral value, and False otherwise: >>> (-2.0).is_integer() True >>> (3.2).is_integer() False", "score": "0.6828431"}]}
{"task_id": "humaneval_41", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n", "entry_point": "car_race_collision", "gold_generation": "    return n**2\n", "context": "Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.", "function_name": "def car_race_collision(n: int):", "ctxs": [{"id": "13670", "text": "Function: pygame.ref.sprite\nSnippet: each Sprite. The dokill argument is a bool. If set to True, all Sprites that collide will be removed from the Group. The collided argument is a callback function used to calculate if two sprites are colliding. it should take two sprites as values, and return a bool value indicating if they are colliding. If collided is not passed, all sprites must have a \"rect\" value, which is a rectangle of the sprite area, which will be used to calculate the collision. collided callables: collide_rect, collide_rect_ratio, collide_circle, collide_circle_ratio, collide_mask Example: # See if the Sprite block has collided with anything in the Group block_list # The True flag will remove the sprite in block_list blocks_hit_list = pygame.sprite.spritecollide(player, block_list, True) # Check the list of colliding sprites, and add one to the score for each one for block in blocks_hit_list: score +=1 pygame.sprite.collide_rect() Collision detection between two sprites, using rects. collide_rect(left, right) -> bool Tests for collision between two sprites. Uses the pygame rect colliderect function to calculate the collision. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a \"rect\" attributes. New in pygame 1.8. pygame.sprite.collide_rect_ratio() Collision detection between two sprites, using rects scaled to a ratio. collide_rect_ratio(ratio) -> collided_callable A callable class that checks for collisions between two sprites, using a scaled version of the sprites rects. Is created with a ratio, the instance is then intended to be passed as a collided callback function to the *collide functions. A ratio is a floating point number - 1.0 is the same size, 2.0 is twice as big, and 0.5 is half the size. New in pygame 1.8.1. pygame.sprite.collide_circle() Collision detection between two sprites, using circles. collide_circle(left, right) -> bool Tests for collision between two sprites, by testing to see if two circles centered on the sprites overlap. If the sprites have a \"radius\" attribute, that is used to create the circle, otherwise a circle is created that is big enough to completely enclose the sprites rect as given by the \"rect\" attribute. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a \"rect\" and an optional \"radius\" attribute. New in pygame 1.8.1. pygame.sprite.collide_circle_ratio() Collision detection between two sprites, using circles scaled to a ratio. collide_circle_ratio(ratio) -> collided_callable A callable class that checks for collisions between two sprites, using a scaled version of the sprites radius. Is created with a floating point ratio, the instance is then intended to be passed as a collided callback function to the *collide functions. A ratio is a floating point number - 1.0 is the same size, 2.0 is twice as big, and 0.5 is half the size. The created callable tests for collision between two sprites, by testing to see if two circles centered on the sprites overlap, after scaling the circles radius by the stored ratio. If the sprites have a \"radius\" attribute, that is used to create the circle, otherwise a circle is created that is big", "score": "0.69031155"}, {"id": "13672", "text": "Function: pygame.ref.sprite\nSnippet: callback function used to calculate if two sprites are colliding. It should take two sprites as values and return a bool value indicating if they are colliding. If collided is not passed, then all sprites must have a \"rect\" value, which is a rectangle of the sprite area, which will be used to calculate the collision.", "score": "0.6529018"}, {"id": "13777", "text": "Function: pygame.ref.sprite#pygame.sprite.groupcollide\nSnippet: pygame.sprite.groupcollide() Find all sprites that collide between two groups. groupcollide(group1, group2, dokill1, dokill2, collided = None) -> Sprite_dict This will find collisions between all the Sprites in two groups. Collision is determined by comparing the Sprite.rect attribute of each Sprite or by using the collided function if it is not None. Every Sprite inside group1 is added to the return dictionary. The value for each item is the list of Sprites in group2 that intersect. If either dokill argument is True, the colliding Sprites will be removed from their respective Group. The collided argument is a callback function used to calculate if two sprites are colliding. It should take two sprites as values and return a bool value indicating if they are colliding. If collided is not passed, then all sprites must have a \"rect\" value, which is a rectangle of the sprite area, which will be used to calculate the collision.", "score": "0.6519389"}, {"id": "41603", "text": "Function: numpy.reference.random.parallel\nSnippet: a collision in that pool, pessimistically-estimated (1), will be about \\(n^2*2^{-128}\\) where n is the number of streams spawned. If a program uses an aggressive million streams, about \\(2^{20}\\), then the probability that at least one pair of them are identical is about \\(2^{-88}\\), which is in solidly-ignorable territory (2). 1 The algorithm is carefully designed to eliminate a number of possible ways to collide. For example, if one only does one level of spawning, it is guaranteed that all states will be unique. But it’s easier to estimate the naive upper bound on a napkin and take comfort knowing that the probability is actually lower. 2 In this calculation, we can mostly ignore the amount of numbers drawn from each stream. See Upgrading PCG64 with PCG64DXSM for the technical details about PCG64. The other PRNGs we provide have some extra protection built in that avoids overlaps if the SeedSequence pools differ in the slightest bit. PCG64DXSM has \\(2^{127}\\) separate cycles determined by the seed in addition to the position in the \\(2^{128}\\) long period for each cycle, so one has to both get on or near the same cycle and seed a nearby position in the cycle. Philox has completely independent cycles determined by the seed. SFC64 incorporates a 64-bit counter so every unique seed is at least \\(2^{64}\\) iterations away from any other seed. And finally, MT19937 has just an unimaginably huge period. Getting a collision internal to SeedSequence is the way a failure would be observed. Independent Streams Philox is a counter-based RNG based which generates values by encrypting an incrementing counter using weak cryptographic primitives. The seed determines the key that is used for the encryption. Unique keys create unique, independent streams. Philox lets you bypass the seeding algorithm to directly set the 128-bit key. Similar, but different, keys will still create independent streams. import secrets from numpy.random import Philox # 128-bit number as a seed root_seed = secrets.getrandbits(128) streams = [Philox(key=root_seed + stream_id) for stream_id in range(10)] This scheme does require that you avoid reusing stream IDs. This may require coordination between the parallel processes. Jumping the BitGenerator state jumped advances the state of the BitGenerator as-if a large number of random numbers have been drawn, and returns a new instance with this state. The specific number of draws varies by BitGenerator, and ranges from \\(2^{64}\\) to \\(2^{128}\\). Additionally, the as-if draws also depend on the size of the default random number produced by the specific BitGenerator. The BitGenerators that support jumped, along with the period of the BitGenerator, the size of the jump and the bits in the default unsigned random are listed below. BitGenerator Period Jump Size Bits per Draw MT19937 \\(2^{19937}-1\\) \\(2^{128}\\) 32 PCG64 \\(2^{128}\\) \\(~2^{127}\\) (3) 64 PCG64DXSM \\(2^{128}\\) \\(~2^{127}\\) (3) 64 Philox \\(2^{256}\\) \\(2^{128}\\) 64 3(1,2) The jump size is \\((\\phi-1)*2^{128}\\) where \\(\\phi\\) is the golden ratio. As the jumps wrap around the period, the actual distances between neighboring streams will slowly grow smaller than the jump size, but using", "score": "0.64852524"}, {"id": "13727", "text": "Function: pygame.ref.rect#pygame.Rect.collidelist\nSnippet: collidelist() test if one rectangle in a list intersects collidelist(list) -> index Test whether the rectangle collides with any in a sequence of rectangles. The index of the first collision found is returned. If no collisions are found an index of -1 is returned.", "score": "0.6451992"}]}
{"task_id": "humaneval_42", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n", "entry_point": "incr_list", "gold_generation": "    return [(e + 1) for e in l]\n", "context": "Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]", "function_name": "def incr_list(l: list):", "ctxs": [{"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.67384297"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.67001116"}, {"id": "42756", "text": "Function: numpy.reference.distutils.misc_util#numpy.distutils.misc_util.as_list\nSnippet: numpy.distutils.misc_util.as_list(seq)[source]", "score": "0.66718256"}, {"id": "26754", "text": "Function: python.library.xml.dom#xml.dom.NodeList.item\nSnippet: NodeList.item(i) Return the i’th item from the sequence, if there is one, or None. The index i is not allowed to be less than zero or greater than or equal to the length of the sequence.", "score": "0.66228163"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.64705837"}]}
{"task_id": "humaneval_43", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "entry_point": "pairs_sum_to_zero", "gold_generation": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "context": "pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False", "function_name": "def pairs_sum_to_zero(l):", "ctxs": [{"id": "20215", "text": "Function: python.library.stdtypes#frozenset\nSnippet: and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem.", "score": "0.70014954"}, {"id": "23564", "text": "Function: python.library.stdtypes#set\nSnippet: and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem.", "score": "0.6976173"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.68982464"}, {"id": "20189", "text": "Function: python.library.stdtypes#float.as_integer_ratio\nSnippet: float.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original float and with a positive denominator. Raises OverflowError on infinities and a ValueError on NaNs.", "score": "0.6831592"}, {"id": "6629", "text": "Function: torch.generated.torch.is_nonzero#torch.is_nonzero\nSnippet: torch.is_nonzero(input) -> (bool) Returns True if the input is a single element tensor which is not equal to zero after type conversions. i.e. not equal to torch.tensor([0.]) or torch.tensor([0]) or torch.tensor([False]). Throws a RuntimeError if torch.numel() != 1 (even in case of sparse tensors). Parameters input (Tensor) – the input tensor. Examples: >>> torch.is_nonzero(torch.tensor([0.])) False >>> torch.is_nonzero(torch.tensor([1.5])) True >>> torch.is_nonzero(torch.tensor([False])) False >>> torch.is_nonzero(torch.tensor([3])) True >>> torch.is_nonzero(torch.tensor([1, 3, 5])) Traceback (most recent call last): ... RuntimeError: bool value of Tensor with more than one value is ambiguous >>> torch.is_nonzero(torch.tensor([])) Traceback (most recent call last): ... RuntimeError: bool value of Tensor with no values is ambiguous", "score": "0.6823428"}]}
{"task_id": "humaneval_44", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n", "entry_point": "change_base", "gold_generation": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n", "context": "Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'", "function_name": "def change_base(x: int, base: int):", "ctxs": [{"id": "42660", "text": "Function: numpy.reference.generated.numpy.base_repr\nSnippet: numpy.base_repr numpy.base_repr(number, base=2, padding=0)[source] Return a string representation of a number in the given base system. Parameters numberint The value to convert. Positive and negative values are handled. baseint, optional Convert number to the base number system. The valid range is 2-36, the default value is 2. paddingint, optional Number of zeros padded on the left. Default is 0 (no padding). Returns outstr String representation of number in base system. See also binary_repr Faster version of base_repr for base 2. Examples >>> np.base_repr(5) '101' >>> np.base_repr(6, 5) '11' >>> np.base_repr(7, base=5, padding=3) '00012' >>> np.base_repr(10, base=16) 'A' >>> np.base_repr(32, base=16) '20'", "score": "0.7661026"}, {"id": "41307", "text": "Function: django.ref.utils#django.utils.http.int_to_base36\nSnippet: int_to_base36(i) [source] Converts a positive integer to a base 36 string.", "score": "0.7346247"}, {"id": "41305", "text": "Function: django.ref.utils#django.utils.http.base36_to_int\nSnippet: base36_to_int(s) [source] Converts a base 36 string to an integer.", "score": "0.72429717"}, {"id": "20491", "text": "Function: python.library.functions#hex\nSnippet: hex(x) Convert an integer number to a lowercase hexadecimal string prefixed with “0x”. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> hex(255) '0xff' >>> hex(-42) '-0x2a' If you want to convert an integer number to an uppercase or lower hexadecimal string with prefix or not, you can use either of the following ways: >>> '%#x' % 255, '%x' % 255, '%X' % 255 ('0xff', 'ff', 'FF') >>> format(255, '#x'), format(255, 'x'), format(255, 'X') ('0xff', 'ff', 'FF') >>> f'{255:#x}', f'{255:x}', f'{255:X}' ('0xff', 'ff', 'FF') See also format() for more information. See also int() for converting a hexadecimal string to an integer using a base of 16. Note To obtain a hexadecimal string representation for a float, use the float.hex() method.", "score": "0.71029866"}, {"id": "21069", "text": "Function: python.library.functions#int\nSnippet: class int([x]) class int(x, base=10) Return an integer object constructed from a number or string x, or return 0 if no arguments are given. If x defines __int__(), int(x) returns x.__int__(). If x defines __index__(), it returns x.__index__(). If x defines __trunc__(), it returns x.__trunc__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in radix base. Optionally, the literal can be preceded by + or - (with no space in between) and surrounded by whitespace. A base-n literal consists of the digits 0 to n-1, with a to z (or A to Z) having values 10 to 35. The default base is 10. The allowed values are 0 and 2–36. Base-2, -8, and -16 literals can be optionally prefixed with 0b/0B, 0o/0O, or 0x/0X, as with integer literals in code. Base 0 means to interpret exactly as a code literal, so that the actual base is 2, 8, 10, or 16, and so that int('010', 0) is not legal, while int('010') is, as well as int('010', 8). The integer type is described in Numeric Types — int, float, complex. Changed in version 3.4: If base is not an instance of int and the base object has a base.__index__ method, that method is called to obtain an integer for the base. Previous versions used base.__int__ instead of base.__index__. Changed in version 3.6: Grouping digits with underscores as in code literals is allowed. Changed in version 3.7: x is now a positional-only parameter. Changed in version 3.8: Falls back to __index__() if __int__() is not defined.", "score": "0.7098541"}]}
{"task_id": "humaneval_45", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n", "entry_point": "triangle_area", "gold_generation": "    return a * h / 2.0\n", "context": "Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5", "function_name": "def triangle_area(a, h):", "ctxs": [{"id": "36610", "text": "Function: django.ref.contrib.gis.geos#django.contrib.gis.geos.GEOSGeometry.area\nSnippet: GEOSGeometry.area This property returns the area of the Geometry.", "score": "0.6701704"}, {"id": "14476", "text": "Function: pandas.reference.api.pandas.dataframe.rpow\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.65082026"}, {"id": "14450", "text": "Function: pandas.reference.api.pandas.dataframe.rdiv\nSnippet: triangle 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6459782"}, {"id": "36509", "text": "Function: django.ref.contrib.gis.gdal#django.contrib.gis.gdal.OGRGeometry.area\nSnippet: area", "score": "0.6454376"}, {"id": "13529", "text": "Function: pygame.ref.math#pygame.math.Vector3.length\nSnippet: length() returns the Euclidean length of the vector. length() -> float calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2)", "score": "0.6450974"}]}
{"task_id": "humaneval_46", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "entry_point": "fib4", "gold_generation": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "context": "The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14", "function_name": "def fib4(n: int):", "ctxs": [{"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.66809976"}, {"id": "20299", "text": "Function: python.library.functools\nSnippet: in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991: ... pep = get_pep(n) ... print(n, len(pep)) >>> get_pep.cache_info() CacheInfo(hits=3, misses=8, maxsize=32, currsize=8) Example of efficiently computing Fibonacci numbers using a cache to implement a dynamic programming technique: @lru_cache(maxsize=None) def fib(n): if n < 2: return n return fib(n-1) + fib(n-2) >>> [fib(n) for n in range(16)] [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610] >>> fib.cache_info() CacheInfo(hits=28, misses=16, maxsize=None, currsize=16) New in version 3.2. Changed in version 3.3: Added the typed option. Changed in version 3.8: Added the user_function option. New in version 3.9: Added the function cache_parameters() @functools.total_ordering Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest. This simplifies the effort involved in specifying all of the possible rich comparison operations: The class must define one of __lt__(), __le__(), __gt__(), or __ge__(). In addition, the class should supply an __eq__() method. For example: @total_ordering class Student: def _is_valid_operand(self, other): return (hasattr(other, \"lastname\") and hasattr(other, \"firstname\")) def __eq__(self, other): if not self._is_valid_operand(other): return NotImplemented return ((self.lastname.lower(), self.firstname.lower()) == (other.lastname.lower(), other.firstname.lower())) def __lt__(self, other): if not self._is_valid_operand(other): return NotImplemented return ((self.lastname.lower(), self.firstname.lower()) < (other.lastname.lower(), other.firstname.lower())) Note While this decorator makes it easy to create well behaved totally ordered types, it does come at the cost of slower execution and more complex stack traces for the derived comparison methods. If performance benchmarking indicates this is a bottleneck for a given application, implementing all six rich comparison methods instead is likely to provide an easy speed boost. New in version 3.2. Changed in version 3.4: Returning NotImplemented from the underlying comparison function for unrecognised types is now supported. functools.partial(func, /, *args, **keywords) Return a new partial object which when called will behave like func called with the positional arguments args and keyword arguments keywords. If more arguments are supplied to the call, they are appended to args. If additional keyword arguments are supplied, they extend and override keywords. Roughly equivalent to: def partial(func, /, *args, **keywords): def newfunc(*fargs, **fkeywords): newkeywords = {**keywords, **fkeywords} return func(*args, *fargs, **newkeywords) newfunc.func = func newfunc.args = args newfunc.keywords = keywords return newfunc The partial() is used for partial function application which “freezes” some portion of a function’s arguments and/or keywords resulting in a new object with a simplified signature. For example, partial() can be used to create a callable that behaves like the int() function where the base argument defaults to two: >>> from functools import partial >>> basetwo = partial(int, base=2) >>> basetwo.__doc__ = 'Convert base 2 string to an int.' >>> basetwo('10010') 18 class functools.partialmethod(func, /, *args, **keywords) Return a new partialmethod descriptor which behaves like partial except that it is designed to be used as a method definition rather than being directly callable. func must be a descriptor or a callable (objects which are both, like normal functions, are handled as descriptors). When func is a descriptor (such as a normal Python function, classmethod(), staticmethod(),", "score": "0.66501105"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.65476817"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.653277"}, {"id": "21290", "text": "Function: python.library.itertools\nSnippet: iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to: def chain(*iterables): # chain('ABC', 'DEF') --> A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable) Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to: def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F for it in iterables: for element in it: yield element itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n", "score": "0.6527339"}]}
{"task_id": "humaneval_47", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "entry_point": "median", "gold_generation": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "context": "Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0", "function_name": "def median(l: list):", "ctxs": [{"id": "24308", "text": "Function: python.library.statistics#statistics.median\nSnippet: statistics.median(data) Return the median (middle value) of numeric data, using the common “mean of middle two” method. If data is empty, StatisticsError is raised. data can be a sequence or iterable. The median is a robust measure of central location and is less affected by the presence of outliers. When the number of data points is odd, the middle data point is returned: >>> median([1, 3, 5]) 3 When the number of data points is even, the median is interpolated by taking the average of the two middle values: >>> median([1, 3, 5, 7]) 4.0 This is suited for when your data is discrete, and you don’t mind that the median may not be an actual data point. If the data is ordinal (supports order operations) but not numeric (doesn’t support addition), consider using median_low() or median_high() instead.", "score": "0.73540103"}, {"id": "24311", "text": "Function: python.library.statistics#statistics.median_low\nSnippet: statistics.median_low(data) Return the low median of numeric data. If data is empty, StatisticsError is raised. data can be a sequence or iterable. The low median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the smaller of the two middle values is returned. >>> median_low([1, 3, 5]) 3 >>> median_low([1, 3, 5, 7]) 3 Use the low median when your data are discrete and you prefer the median to be an actual data point rather than interpolated.", "score": "0.72453535"}, {"id": "24298", "text": "Function: python.library.statistics\nSnippet: statistics.median_low(data) Return the low median of numeric data. If data is empty, StatisticsError is raised. data can be a sequence or iterable. The low median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the smaller of the two middle values is returned. >>> median_low([1, 3, 5]) 3 >>> median_low([1, 3, 5, 7]) 3 Use the low median when your data are discrete and you prefer the median to be an actual data point rather than interpolated. statistics.median_high(data) Return the high median of data. If data is empty, StatisticsError is raised. data can be a sequence or iterable. The high median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the larger of the two middle values is returned. >>> median_high([1, 3, 5]) 3 >>> median_high([1, 3, 5, 7]) 5 Use the high median when your data are discrete and you prefer the median to be an actual data point rather than interpolated. statistics.median_grouped(data, interval=1) Return the median of grouped continuous data, calculated as the 50th percentile, using interpolation. If data is empty, StatisticsError is raised. data can be a sequence or iterable. >>> median_grouped([52, 52, 53, 54]) 52.5 In the following example, the data are rounded, so that each value represents the midpoint of data classes, e.g. 1 is the midpoint of the class 0.5–1.5, 2 is the midpoint of 1.5–2.5, 3 is the midpoint of 2.5–3.5, etc. With the data given, the middle value falls somewhere in the class 3.5–4.5, and interpolation is used to estimate it: >>> median_grouped([1, 2, 2, 3, 4, 4, 4, 4, 4, 5]) 3.7 Optional argument interval represents the class interval, and defaults to 1. Changing the class interval naturally will change the interpolation: >>> median_grouped([1, 3, 3, 5, 7], interval=1) 3.25 >>> median_grouped([1, 3, 3, 5, 7], interval=2) 3.5 This function does not check whether the data points are at least interval apart. CPython implementation detail: Under some circumstances, median_grouped() may coerce data points to floats. This behaviour is likely to change in the future. See also “Statistics for the Behavioral Sciences”, Frederick J Gravetter and Larry B Wallnau (8th Edition). The SSMEDIAN function in the Gnome Gnumeric spreadsheet, including this discussion. statistics.mode(data) Return the single most common data point from discrete or nominal data. The mode (when it exists) is the most typical value and serves as a measure of central location. If there are multiple modes with the same frequency, returns the first one encountered in the data. If the smallest or largest of those is desired instead, use min(multimode(data)) or max(multimode(data)). If the input data is empty, StatisticsError is raised. mode assumes discrete data and returns a single value. This is the standard treatment of the mode as commonly taught in schools: >>> mode([1, 1, 2, 3, 3, 3, 3, 4]) 3 The mode is unique in", "score": "0.72319615"}, {"id": "42316", "text": "Function: numpy.reference.generated.numpy.ma.median\nSnippet: numpy.ma.median ma.median(a, axis=None, out=None, overwrite_input=False, keepdims=False)[source] Compute the median along the specified axis. Returns the median of the array elements. Parameters aarray_like Input array or object that can be converted to an array. axisint, optional Axis along which the medians are computed. The default (None) is to compute the median along a flattened version of the array. outndarray, optional Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. overwrite_inputbool, optional If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if overwrite_input is True, and the input is not already an ndarray, an error will be raised. keepdimsbool, optional If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. New in version 1.10.0. Returns medianndarray A new array holding the result is returned unless out is specified, in which case a reference to out is returned. Return data-type is float64 for integers and floats smaller than float64, or the input data-type, otherwise. See also mean Notes Given a vector V with N non masked values, the median of V is the middle value of a sorted copy of V (Vs) - i.e. Vs[(N-1)/2], when N is odd, or {Vs[N/2 - 1] + Vs[N/2]}/2 when N is even. Examples >>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4) >>> np.ma.median(x) 1.5 >>> x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4) >>> np.ma.median(x) 2.5 >>> np.ma.median(x, axis=-1, overwrite_input=True) masked_array(data=[2.0, 5.0], mask=[False, False], fill_value=1e+20)", "score": "0.7038538"}, {"id": "43016", "text": "Function: numpy.reference.generated.numpy.median\nSnippet: numpy.median numpy.median(a, axis=None, out=None, overwrite_input=False, keepdims=False)[source] Compute the median along the specified axis. Returns the median of the array elements. Parameters aarray_like Input array or object that can be converted to an array. axis{int, sequence of int, None}, optional Axis or axes along which the medians are computed. The default is to compute the median along a flattened version of the array. A sequence of axes is supported since version 1.9.0. outndarray, optional Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary. overwrite_inputbool, optional If True, then allow use of memory of input array a for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If overwrite_input is True and a is not already an ndarray, an error will be raised. keepdimsbool, optional If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original arr. New in version 1.9.0. Returns medianndarray A new array holding the result. If the input contains integers or floats smaller than float64, then the output data-type is np.float64. Otherwise, the data-type of the output is the same as that of the input. If out is specified, that array is returned instead. See also mean, percentile Notes Given a vector V of length N, the median of V is the middle value of a sorted copy of V, V_sorted - i e., V_sorted[(N-1)/2], when N is odd, and the average of the two middle values of V_sorted when N is even. Examples >>> a = np.array([[10, 7, 4], [3, 2, 1]]) >>> a array([[10, 7, 4], [ 3, 2, 1]]) >>> np.median(a) 3.5 >>> np.median(a, axis=0) array([6.5, 4.5, 2.5]) >>> np.median(a, axis=1) array([7., 2.]) >>> m = np.median(a, axis=0) >>> out = np.zeros_like(m) >>> np.median(a, axis=0, out=m) array([6.5, 4.5, 2.5]) >>> m array([6.5, 4.5, 2.5]) >>> b = a.copy() >>> np.median(b, axis=1, overwrite_input=True) array([7., 2.]) >>> assert not np.all(a==b) >>> b = a.copy() >>> np.median(b, axis=None, overwrite_input=True) 3.5 >>> assert not np.all(a==b)", "score": "0.7026063"}]}
{"task_id": "humaneval_48", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "entry_point": "is_palindrome", "gold_generation": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "context": "Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False", "function_name": "def is_palindrome(text: str):", "ctxs": [{"id": "41731", "text": "Function: numpy.reference.generated.numpy.char.isdigit\nSnippet: numpy.char.isdigit char.isdigit(a)[source] Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. Calls str.isdigit element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like of str or unicode Returns outndarray Output array of bools See also str.isdigit", "score": "0.6641029"}, {"id": "41729", "text": "Function: numpy.reference.generated.numpy.char.isalpha\nSnippet: numpy.char.isalpha char.isalpha(a)[source] Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. Calls str.isalpha element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like of str or unicode Returns outndarray Output array of bools See also str.isalpha", "score": "0.66365916"}, {"id": "15338", "text": "Function: pandas.reference.api.pandas.series.str.isdigit\nSnippet: pandas.Series.str.isdigit Series.str.isdigit()[source] Check whether all characters in each string are digits. This is equivalent to running the Python string method str.isdigit() for each element of the Series/Index. If a string has zero characters, False is returned for that check. Returns Series or Index of bool Series or Index of boolean values with the same length as the original Series/Index. See also Series.str.isalpha Check whether all characters are alphabetic. Series.str.isnumeric Check whether all characters are numeric. Series.str.isalnum Check whether all characters are alphanumeric. Series.str.isdigit Check whether all characters are digits. Series.str.isdecimal Check whether all characters are decimal. Series.str.isspace Check whether all characters are whitespace. Series.str.islower Check whether all characters are lowercase. Series.str.isupper Check whether all characters are uppercase. Series.str.istitle Check whether all characters are titlecase. Examples Checks for Alphabetic and Numeric Characters >>> s1 = pd.Series(['one', 'one1', '1', '']) >>> s1.str.isalpha() 0 True 1 False 2 False 3 False dtype: bool >>> s1.str.isnumeric() 0 False 1 False 2 True 3 False dtype: bool >>> s1.str.isalnum() 0 True 1 True 2 True 3 False dtype: bool Note that checks against characters mixed with any additional punctuation or whitespace will evaluate to false for an alphanumeric check. >>> s2 = pd.Series(['A B', '1.5', '3,000']) >>> s2.str.isalnum() 0 False 1 False 2 False dtype: bool More Detailed Checks for Numeric Characters There are several different but overlapping sets of numeric characters that can be checked for. >>> s3 = pd.Series(['23', '³', '⅕', '']) The s3.str.isdecimal method checks for characters used to form numbers in base 10. >>> s3.str.isdecimal() 0 True 1 False 2 False 3 False dtype: bool The s.str.isdigit method is the same as s3.str.isdecimal but also includes special digits, like superscripted and subscripted digits in unicode. >>> s3.str.isdigit() 0 True 1 True 2 False 3 False dtype: bool The s.str.isnumeric method is the same as s3.str.isdigit but also includes other characters that can represent quantities such as unicode fractions. >>> s3.str.isnumeric() 0 True 1 True 2 True 3 False dtype: bool Checks for Whitespace >>> s4 = pd.Series([' ', '\\t\\r\\n ', '']) >>> s4.str.isspace() 0 True 1 True 2 False dtype: bool Checks for Character Case >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) >>> s5.str.islower() 0 True 1 False 2 False 3 False dtype: bool >>> s5.str.isupper() 0 False 1 False 2 True 3 False dtype: bool The s5.str.istitle method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters. >>> s5.str.istitle() 0 False 1 True 2 False 3 False dtype: bool", "score": "0.6622906"}, {"id": "19062", "text": "Function: python.library.curses.ascii#curses.ascii.isblank\nSnippet: curses.ascii.isblank(c) Checks for an ASCII whitespace character; space or horizontal tab.", "score": "0.6610287"}, {"id": "24361", "text": "Function: python.library.stdtypes#str.isupper\nSnippet: str.isupper() Return True if all cased characters 4 in the string are uppercase and there is at least one cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False", "score": "0.66099393"}]}
{"task_id": "humaneval_49", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n", "entry_point": "modp", "gold_generation": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n", "context": "Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1", "function_name": "def modp(n: int, p: int):", "ctxs": [{"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.65840685"}, {"id": "23150", "text": "Function: python.library.functions#pow\nSnippet: pow(base, exp[, mod]) Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp. The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10**2 returns 100, but 10**-2 returns 0.01. For int operands base and exp, if mod is present, mod must also be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod. In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod. Here’s an example of computing an inverse for 38 modulo 97: >>> pow(38, -1, mod=97) 23 >>> 23 * 38 % 97 == 1 True Changed in version 3.8: For int operands, the three-argument form of pow now allows the second argument to be negative, permitting computation of modular inverses. Changed in version 3.8: Allow keyword arguments. Formerly, only positional arguments were supported.", "score": "0.6484675"}, {"id": "20290", "text": "Function: python.library.functions\nSnippet: integer representing the Unicode code point of that character. For example, ord('a') returns the integer 97 and ord('€') (Euro sign) returns 8364. This is the inverse of chr(). pow(base, exp[, mod]) Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp. The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10**2 returns 100, but 10**-2 returns 0.01. For int operands base and exp, if mod is present, mod must also be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod. In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod. Here’s an example of computing an inverse for 38 modulo 97: >>> pow(38, -1, mod=97) 23 >>> 23 * 38 % 97 == 1 True Changed in version 3.8: For int operands, the three-argument form of pow now allows the second argument to be negative, permitting computation of modular inverses. Changed in version 3.8: Allow keyword arguments. Formerly, only positional arguments were supported. print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False) Print objects to the text stream file, separated by sep and followed by end. sep, end, file and flush, if present, must be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end. The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Since printed arguments are converted to text strings, print() cannot be used with binary mode file objects. For these, use file.write(...) instead. Whether output is buffered is usually determined by file, but if the flush keyword argument is true, the stream is forcibly flushed. Changed in version 3.3: Added the flush keyword argument. class property(fget=None, fset=None, fdel=None, doc=None) Return a property attribute. fget is a function for getting an attribute value. fset is a function for setting an attribute value. fdel is a function for deleting an attribute value. And doc creates a docstring for the attribute. A typical use is to define a managed attribute x: class C: def __init__(self): self._x = None def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") If c is an instance of C, c.x", "score": "0.64772904"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6457631"}, {"id": "42482", "text": "Function: numpy.reference.generated.numpy.ndarray.__mod__\nSnippet: numpy.ndarray.__mod__ method ndarray.__mod__(value, /) Return self%value.", "score": "0.6372043"}]}
{"task_id": "humaneval_50", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n", "entry_point": "decode_shift", "gold_generation": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n", "context": "returns encoded string by shifting every character by 5 in the alphabet.", "function_name": "def encode_shift(s: str):\n    \n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):", "ctxs": [{"id": "18539", "text": "Function: python.library.codecs\nSnippet: and decoding base64.encodebytes() / base64.decodebytes() bz2_codec bz2 Compress the operand using bz2. bz2.compress() / bz2.decompress() hex_codec hex Convert the operand to hexadecimal representation, with two digits per byte. binascii.b2a_hex() / binascii.a2b_hex() quopri_codec quopri, quotedprintable, quoted_printable Convert the operand to MIME quoted printable. quopri.encode() with quotetabs=True / quopri.decode() uu_codec uu Convert the operand using uuencode. uu.encode() / uu.decode() zlib_codec zip, zlib Compress the operand using gzip. zlib.compress() / zlib.decompress() 1 In addition to bytes-like objects, 'base64_codec' also accepts ASCII-only instances of str for decoding New in version 3.2: Restoration of the binary transforms. Changed in version 3.4: Restoration of the aliases for the binary transforms. Text Transforms The following codec provides a text transform: a str to str mapping. It is not supported by str.encode() (which only produces bytes output). Codec Aliases Meaning rot_13 rot13 Return the Caesar-cypher encryption of the operand. New in version 3.2: Restoration of the rot_13 text transform. Changed in version 3.4: Restoration of the rot13 alias. encodings.idna — Internationalized Domain Names in Applications This module implements RFC 3490 (Internationalized Domain Names in Applications) and RFC 3492 (Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)). It builds upon the punycode encoding and stringprep. If you need the IDNA 2008 standard from RFC 5891 and RFC 5895, use the third-party idna module <https://pypi.org/project/idna/>_. These RFCs together define a protocol to support non-ASCII characters in domain names. A domain name containing non-ASCII characters (such as www.Alliancefrançaise.nu) is converted into an ASCII-compatible encoding (ACE, such as www.xn--alliancefranaise-npb.nu). The ACE form of the domain name is then used in all places where arbitrary characters are not allowed by the protocol, such as DNS queries, HTTP Host fields, and so on. This conversion is carried out in the application; if possible invisible to the user: The application should transparently convert Unicode domain labels to IDNA on the wire, and convert back ACE labels to Unicode before presenting them to the user. Python supports this conversion in several ways: the idna codec performs conversion between Unicode and ACE, separating an input string into labels based on the separator characters defined in section 3.1 of RFC 3490 and converting each label to ACE as required, and conversely separating an input byte string into labels based on the . separator and converting any ACE labels found into unicode. Furthermore, the socket module transparently converts Unicode host names to ACE, so that applications need not be concerned about converting host names themselves when they pass them to the socket module. On top of that, modules that have host names as function parameters, such as http.client and ftplib, accept Unicode host names (http.client then also transparently sends an IDNA hostname in the Host field if it sends that field at all). When receiving host names from the wire (such as in reverse name lookup), no automatic conversion to Unicode is performed: applications wishing to present such host names to the user should decode them to Unicode. The module encodings.idna also implements the nameprep procedure, which performs", "score": "0.65169024"}, {"id": "18236", "text": "Function: python.library.binascii#binascii.unhexlify\nSnippet: binascii.a2b_hex(hexstr) binascii.unhexlify(hexstr) Return the binary data represented by the hexadecimal string hexstr. This function is the inverse of b2a_hex(). hexstr must contain an even number of hexadecimal digits (which can be upper or lower case), otherwise an Error exception is raised. Similar functionality (accepting only text string arguments, but more liberal towards whitespace) is also accessible using the bytes.fromhex() class method.", "score": "0.6490464"}, {"id": "41650", "text": "Function: numpy.reference.generated.numpy.char.chararray.encode\nSnippet: numpy.char.chararray.encode method char.chararray.encode(encoding=None, errors=None)[source] Calls str.encode element-wise. See also char.encode", "score": "0.6473201"}, {"id": "18220", "text": "Function: python.library.binascii#binascii.a2b_hex\nSnippet: binascii.a2b_hex(hexstr) binascii.unhexlify(hexstr) Return the binary data represented by the hexadecimal string hexstr. This function is the inverse of b2a_hex(). hexstr must contain an even number of hexadecimal digits (which can be upper or lower case), otherwise an Error exception is raised. Similar functionality (accepting only text string arguments, but more liberal towards whitespace) is also accessible using the bytes.fromhex() class method.", "score": "0.6446369"}, {"id": "41774", "text": "Function: numpy.reference.generated.numpy.chararray.encode\nSnippet: numpy.chararray.encode method chararray.encode(encoding=None, errors=None)[source] Calls str.encode element-wise. See also char.encode", "score": "0.64286584"}]}
{"task_id": "humaneval_51", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "entry_point": "remove_vowels", "gold_generation": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "context": "remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'", "function_name": "def remove_vowels(text):", "ctxs": [{"id": "24376", "text": "Function: python.library.stdtypes#str.rstrip\nSnippet: str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty'", "score": "0.69983816"}, {"id": "24369", "text": "Function: python.library.stdtypes#str.removesuffix\nSnippet: str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9.", "score": "0.6965463"}, {"id": "41761", "text": "Function: numpy.reference.generated.numpy.char.translate\nSnippet: numpy.char.translate char.translate(a, table, deletechars=None)[source] For each element in a, return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table. Calls str.translate element-wise. Parameters aarray-like of str or unicode tablestr of length 256 deletecharsstr Returns outndarray Output array of str or unicode, depending on input type See also str.translate", "score": "0.695737"}, {"id": "41712", "text": "Function: numpy.reference.generated.numpy.char.chararray.translate\nSnippet: numpy.char.chararray.translate method char.chararray.translate(table, deletechars=None)[source] For each element in self, return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table. See also char.translate", "score": "0.69371015"}, {"id": "24380", "text": "Function: python.library.stdtypes#str.strip\nSnippet: str.strip([chars]) Return a copy of the string with the leading and trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> ' spacious '.strip() 'spacious' >>> 'www.example.com'.strip('cmowz.') 'example' The outermost leading and trailing chars argument values are stripped from the string. Characters are removed from the leading end until reaching a string character that is not contained in the set of characters in chars. A similar action takes place on the trailing end. For example: >>> comment_string = '#....... Section 3.2.1 Issue #32 .......' >>> comment_string.strip('.#! ') 'Section 3.2.1 Issue #32'", "score": "0.6934338"}]}
{"task_id": "humaneval_52", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "entry_point": "below_threshold", "gold_generation": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "context": "Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False", "function_name": "def below_threshold(l: list, t: int):", "ctxs": [{"id": "20343", "text": "Function: python.library.gc#gc.get_threshold\nSnippet: gc.get_threshold() Return the current collection thresholds as a tuple of (threshold0, threshold1, threshold2).", "score": "0.6545707"}, {"id": "43820", "text": "Function: numpy.reference.random.generated.numpy.random.standard_t\nSnippet: which is lower than the 5% pre-determined significance threshold. Therefore, the probability of observing values as extreme as our intake conditionally on the null hypothesis being true is too low, and we reject the null hypothesis of no deviation.", "score": "0.64536554"}, {"id": "19477", "text": "Function: python.library.decimal#decimal.Context.is_normal\nSnippet: is_normal(x) Returns True if x is a normal number; otherwise returns False.", "score": "0.6440869"}, {"id": "19481", "text": "Function: python.library.decimal#decimal.Context.is_subnormal\nSnippet: is_subnormal(x) Returns True if x is subnormal; otherwise returns False.", "score": "0.64153826"}, {"id": "42613", "text": "Function: numpy.reference.generated.numpy.allclose\nSnippet: numpy.allclose numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)[source] Returns True if two arrays are element-wise equal within a tolerance. The tolerance values are positive, typically very small numbers. The relative difference (rtol * abs(b)) and the absolute difference atol are added together to compare against the absolute difference between a and b. NaNs are treated as equal if they are in the same place and if equal_nan=True. Infs are treated as equal if they are in the same place and of the same sign in both arrays. Parameters a, barray_like Input arrays to compare. rtolfloat The relative tolerance parameter (see Notes). atolfloat The absolute tolerance parameter (see Notes). equal_nanbool Whether to compare NaN’s as equal. If True, NaN’s in a will be considered equal to NaN’s in b in the output array. New in version 1.10.0. Returns allclosebool Returns True if the two arrays are equal within the given tolerance; False otherwise. See also isclose, all, any, equal Notes If the following equation is element-wise True, then allclose returns True. absolute(a - b) <= (atol + rtol * absolute(b)) The above equation is not symmetric in a and b, so that allclose(a, b) might be different from allclose(b, a) in some rare cases. The comparison of a and b uses standard broadcasting, which means that a and b need not have the same shape in order for allclose(a, b) to evaluate to True. The same is true for equal but not array_equal. allclose is not defined for non-numeric data types. bool is considered a numeric data-type for this purpose. Examples >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8]) False >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9]) True >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9]) False >>> np.allclose([1.0, np.nan], [1.0, np.nan]) False >>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True) True", "score": "0.6358578"}]}
{"task_id": "humaneval_53", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "entry_point": "add", "gold_generation": "    return x + y\n", "context": "Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12", "function_name": "def add(x: int, y: int):", "ctxs": [{"id": "19451", "text": "Function: python.library.decimal#decimal.Context.add\nSnippet: add(x, y) Return the sum of x and y.", "score": "0.7198272"}, {"id": "19495", "text": "Function: python.library.decimal#decimal.Context.multiply\nSnippet: multiply(x, y) Return the product of x and y.", "score": "0.65753394"}, {"id": "22301", "text": "Function: python.library.operator#operator.add\nSnippet: operator.add(a, b) operator.__add__(a, b) Return a + b, for a and b numbers.", "score": "0.64365447"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6380354"}, {"id": "19486", "text": "Function: python.library.decimal#decimal.Context.logical_and\nSnippet: logical_and(x, y) Applies the logical operation and between each operand’s digits.", "score": "0.6370435"}]}
{"task_id": "humaneval_54", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "entry_point": "same_chars", "gold_generation": "    return set(s0) == set(s1)\n", "context": "Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False", "function_name": "def same_chars(s0: str, s1: str):", "ctxs": [{"id": "41731", "text": "Function: numpy.reference.generated.numpy.char.isdigit\nSnippet: numpy.char.isdigit char.isdigit(a)[source] Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. Calls str.isdigit element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like of str or unicode Returns outndarray Output array of bools See also str.isdigit", "score": "0.70225894"}, {"id": "41664", "text": "Function: numpy.reference.generated.numpy.char.chararray.isdigit\nSnippet: numpy.char.chararray.isdigit method char.chararray.isdigit()[source] Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. See also char.isdigit", "score": "0.6997945"}, {"id": "41787", "text": "Function: numpy.reference.generated.numpy.chararray.isdigit\nSnippet: numpy.chararray.isdigit method chararray.isdigit()[source] Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. See also char.isdigit", "score": "0.69306195"}, {"id": "41729", "text": "Function: numpy.reference.generated.numpy.char.isalpha\nSnippet: numpy.char.isalpha char.isalpha(a)[source] Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. Calls str.isalpha element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like of str or unicode Returns outndarray Output array of bools See also str.isalpha", "score": "0.68535554"}, {"id": "41730", "text": "Function: numpy.reference.generated.numpy.char.isdecimal\nSnippet: numpy.char.isdecimal char.isdecimal(a)[source] For each element, return True if there are only decimal characters in the element. Calls unicode.isdecimal element-wise. Decimal characters include digit characters, and all characters that can be used to form decimal-radix numbers, e.g. U+0660, ARABIC-INDIC DIGIT ZERO. Parameters aarray_like, unicode Input array. Returns outndarray, bool Array of booleans identical in shape to a. See also unicode.isdecimal", "score": "0.6835141"}]}
{"task_id": "humaneval_55", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "entry_point": "fib", "gold_generation": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "context": "Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21", "function_name": "def fib(n: int):", "ctxs": [{"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6360615"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.620041"}, {"id": "20299", "text": "Function: python.library.functools\nSnippet: in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991: ... pep = get_pep(n) ... print(n, len(pep)) >>> get_pep.cache_info() CacheInfo(hits=3, misses=8, maxsize=32, currsize=8) Example of efficiently computing Fibonacci numbers using a cache to implement a dynamic programming technique: @lru_cache(maxsize=None) def fib(n): if n < 2: return n return fib(n-1) + fib(n-2) >>> [fib(n) for n in range(16)] [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610] >>> fib.cache_info() CacheInfo(hits=28, misses=16, maxsize=None, currsize=16) New in version 3.2. Changed in version 3.3: Added the typed option. Changed in version 3.8: Added the user_function option. New in version 3.9: Added the function cache_parameters() @functools.total_ordering Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest. This simplifies the effort involved in specifying all of the possible rich comparison operations: The class must define one of __lt__(), __le__(), __gt__(), or __ge__(). In addition, the class should supply an __eq__() method. For example: @total_ordering class Student: def _is_valid_operand(self, other): return (hasattr(other, \"lastname\") and hasattr(other, \"firstname\")) def __eq__(self, other): if not self._is_valid_operand(other): return NotImplemented return ((self.lastname.lower(), self.firstname.lower()) == (other.lastname.lower(), other.firstname.lower())) def __lt__(self, other): if not self._is_valid_operand(other): return NotImplemented return ((self.lastname.lower(), self.firstname.lower()) < (other.lastname.lower(), other.firstname.lower())) Note While this decorator makes it easy to create well behaved totally ordered types, it does come at the cost of slower execution and more complex stack traces for the derived comparison methods. If performance benchmarking indicates this is a bottleneck for a given application, implementing all six rich comparison methods instead is likely to provide an easy speed boost. New in version 3.2. Changed in version 3.4: Returning NotImplemented from the underlying comparison function for unrecognised types is now supported. functools.partial(func, /, *args, **keywords) Return a new partial object which when called will behave like func called with the positional arguments args and keyword arguments keywords. If more arguments are supplied to the call, they are appended to args. If additional keyword arguments are supplied, they extend and override keywords. Roughly equivalent to: def partial(func, /, *args, **keywords): def newfunc(*fargs, **fkeywords): newkeywords = {**keywords, **fkeywords} return func(*args, *fargs, **newkeywords) newfunc.func = func newfunc.args = args newfunc.keywords = keywords return newfunc The partial() is used for partial function application which “freezes” some portion of a function’s arguments and/or keywords resulting in a new object with a simplified signature. For example, partial() can be used to create a callable that behaves like the int() function where the base argument defaults to two: >>> from functools import partial >>> basetwo = partial(int, base=2) >>> basetwo.__doc__ = 'Convert base 2 string to an int.' >>> basetwo('10010') 18 class functools.partialmethod(func, /, *args, **keywords) Return a new partialmethod descriptor which behaves like partial except that it is designed to be used as a method definition rather than being directly callable. func must be a descriptor or a callable (objects which are both, like normal functions, are handled as descriptors). When func is a descriptor (such as a normal Python function, classmethod(), staticmethod(),", "score": "0.61921155"}, {"id": "43079", "text": "Function: numpy.reference.generated.numpy.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.6190518"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6096834"}]}
{"task_id": "humaneval_56", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n", "entry_point": "correct_bracketing", "gold_generation": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n", "context": "brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False", "function_name": "def correct_bracketing(brackets: str):", "ctxs": [{"id": "41790", "text": "Function: numpy.reference.generated.numpy.chararray.isspace\nSnippet: numpy.chararray.isspace method chararray.isspace()[source] Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. See also char.isspace", "score": "0.70243055"}, {"id": "41667", "text": "Function: numpy.reference.generated.numpy.char.chararray.isspace\nSnippet: numpy.char.chararray.isspace method char.chararray.isspace()[source] Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. See also char.isspace", "score": "0.7002409"}, {"id": "24344", "text": "Function: python.library.stdtypes#str.endswith\nSnippet: str.endswith(suffix[, start[, end]]) Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position.", "score": "0.6987613"}, {"id": "24379", "text": "Function: python.library.stdtypes#str.startswith\nSnippet: str.startswith(prefix[, start[, end]]) Return True if string starts with the prefix, otherwise return False. prefix can also be a tuple of prefixes to look for. With optional start, test string beginning at that position. With optional end, stop comparing string at that position.", "score": "0.6854091"}, {"id": "41734", "text": "Function: numpy.reference.generated.numpy.char.isspace\nSnippet: numpy.char.isspace char.isspace(a)[source] Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. Calls str.isspace element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like of str or unicode Returns outndarray Output array of bools See also str.isspace", "score": "0.68097514"}]}
{"task_id": "humaneval_57", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n", "entry_point": "monotonic", "gold_generation": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n", "context": "Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True", "function_name": "def monotonic(l: list):", "ctxs": [{"id": "14718", "text": "Function: pandas.reference.api.pandas.index.is_monotonic_decreasing\nSnippet: pandas.Index.is_monotonic_decreasing propertyIndex.is_monotonic_decreasing Return if the index is monotonic decreasing (only equal or decreasing) values. Examples >>> Index([3, 2, 1]).is_monotonic_decreasing True >>> Index([3, 2, 2]).is_monotonic_decreasing True >>> Index([3, 1, 2]).is_monotonic_decreasing False", "score": "0.8077279"}, {"id": "15205", "text": "Function: pandas.reference.api.pandas.series.is_monotonic\nSnippet: pandas.Series.is_monotonic propertySeries.is_monotonic Return boolean if values in the object are monotonic_increasing. Returns bool", "score": "0.80632776"}, {"id": "14719", "text": "Function: pandas.reference.api.pandas.index.is_monotonic_increasing\nSnippet: pandas.Index.is_monotonic_increasing propertyIndex.is_monotonic_increasing Return if the index is monotonic increasing (only equal or increasing) values. Examples >>> Index([1, 2, 3]).is_monotonic_increasing True >>> Index([1, 2, 2]).is_monotonic_increasing True >>> Index([1, 3, 2]).is_monotonic_increasing False", "score": "0.804534"}, {"id": "15206", "text": "Function: pandas.reference.api.pandas.series.is_monotonic_decreasing\nSnippet: pandas.Series.is_monotonic_decreasing propertySeries.is_monotonic_decreasing Return boolean if values in the object are monotonic_decreasing. Returns bool", "score": "0.79844105"}, {"id": "14178", "text": "Function: pandas.reference.api.pandas.core.groupby.seriesgroupby.is_monotonic_decreasing\nSnippet: pandas.core.groupby.SeriesGroupBy.is_monotonic_decreasing propertySeriesGroupBy.is_monotonic_decreasing Return boolean if values in the object are monotonic_decreasing. Returns bool", "score": "0.7973061"}]}
{"task_id": "humaneval_58", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "entry_point": "common", "gold_generation": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "context": "Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]", "function_name": "def common(l1: list, l2: list):", "ctxs": [{"id": "18655", "text": "Function: python.library.collections#collections.Counter.most_common\nSnippet: most_common([n]) Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered in the order first encountered: >>> Counter('abracadabra').most_common(3) [('a', 5), ('b', 2), ('r', 2)]", "score": "0.731207"}, {"id": "21302", "text": "Function: python.library.itertools#itertools.combinations_with_replacement\nSnippet: itertools.combinations_with_replacement(iterable, r) Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique. Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) The code for combinations_with_replacement() can be also expressed as a subsequence of product() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations_with_replacement(iterable, r): pool = tuple(iterable) n = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is (n+r-1)! / r! / (n-1)! when n > 0. New in version 3.1.", "score": "0.6842247"}, {"id": "42824", "text": "Function: numpy.reference.generated.numpy.find_common_type\nSnippet: numpy.find_common_type numpy.find_common_type(array_types, scalar_types)[source] Determine common type following standard coercion rules. Parameters array_typessequence A list of dtypes or dtype convertible objects representing arrays. scalar_typessequence A list of dtypes or dtype convertible objects representing scalars. Returns datatypedtype The common data type, which is the maximum of array_types ignoring scalar_types, unless the maximum of scalar_types is of a different kind (dtype.kind). If the kind is not understood, then None is returned. See also dtype, common_type, can_cast, mintypecode Examples >>> np.find_common_type([], [np.int64, np.float32, complex]) dtype('complex128') >>> np.find_common_type([np.int64, np.float32], []) dtype('float64') The standard casting rules ensure that a scalar cannot up-cast an array unless the scalar is of a fundamentally different kind of data (i.e. under a different hierarchy in the data type hierarchy) then the array: >>> np.find_common_type([np.float32], [np.int64, np.float64]) dtype('float32') Complex is of a different type, so it up-casts the float in the array_types argument: >>> np.find_common_type([np.float32], [complex]) dtype('complex128') Type specifier strings are convertible to dtypes and can therefore be used instead of dtypes: >>> np.find_common_type(['f4', 'f4', 'i4'], ['c8']) dtype('complex128')", "score": "0.67837894"}, {"id": "21301", "text": "Function: python.library.itertools#itertools.combinations\nSnippet: itertools.combinations(iterable, r) Return r length subsequences of elements from the input iterable. The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination. Roughly equivalent to: def combinations(iterable, r): # combinations('ABCD', 2) --> AB AC AD BC BD CD # combinations(range(4), 3) --> 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool): def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) The number of items returned is n! / r! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6759543"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.67400753"}]}
{"task_id": "humaneval_59", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "entry_point": "largest_prime_factor", "gold_generation": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "context": "Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2", "function_name": "def largest_prime_factor(n: int):", "ctxs": [{"id": "19366", "text": "Function: python.library.datetime#datetime.MAXYEAR\nSnippet: datetime.MAXYEAR The largest year number allowed in a date or datetime object. MAXYEAR is 9999.", "score": "0.6181776"}, {"id": "19558", "text": "Function: python.library.decimal#decimal.Decimal.next_minus\nSnippet: next_minus(context=None) Return the largest number representable in the given context (or in the current thread’s context if no context is given) that is smaller than the given operand.", "score": "0.60801566"}, {"id": "21805", "text": "Function: python.library.math#math.gcd\nSnippet: math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported.", "score": "0.60295683"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.5962552"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.5955127"}]}
{"task_id": "humaneval_60", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "entry_point": "sum_to_n", "gold_generation": "    return sum(range(n + 1))\n", "context": "sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1", "function_name": "def sum_to_n(n: int):", "ctxs": [{"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.7146566"}, {"id": "21298", "text": "Function: python.library.itertools#itertools.accumulate\nSnippet: itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter.", "score": "0.69557434"}, {"id": "21289", "text": "Function: python.library.itertools\nSnippet: AD BB BC BD CC CD DD Itertool functions The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream. itertools.accumulate(iterable[, func, *, initial=None]) Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument). If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.) Usually, the number of elements output matches the input iterable. However, if the keyword argument initial is provided, the accumulation leads off with the initial value so that the output has one more element than the input iterable. Roughly equivalent to: def accumulate(iterable, func=operator.add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) --> 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120 it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total There are a number of uses for the func argument. It can be set to min() for a running minimum, max() for a running maximum, or operator.mul() for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument: >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8] >>> list(accumulate(data, operator.mul)) # running product [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0] >>> list(accumulate(data, max)) # running maximum [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] # Amortize a 5% loan of 1000 with 4 annual payments of 90 >>> cashflows = [1000, -90, -90, -90, -90] >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)) [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001] # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map >>> logistic_map = lambda x, _: r * x * (1 - x) >>> r = 3.8 >>> x0 = 0.4 >>> inputs = repeat(x0, 36) # only the initial value is used >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)] ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] See functools.reduce() for a similar function that returns only the final accumulated value. New in version 3.2. Changed in version 3.3: Added the optional func parameter. Changed in version 3.8: Added the optional initial parameter. itertools.chain(*iterables) Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the", "score": "0.6924644"}, {"id": "43211", "text": "Function: numpy.reference.generated.numpy.sum\nSnippet: the summation is along the fast axis in memory. Note that the exact precision may vary depending on other parameters. In contrast to NumPy, Python’s math.fsum function uses a slower but more precise approach to summation. Especially when summing a large number of lower precision floating point numbers, such as float32, numerical errors can become significant. In such cases it can be advisable to use dtype=”float64” to use a higher precision for the output. Examples >>> np.sum([0.5, 1.5]) 2.0 >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32) 1 >>> np.sum([[0, 1], [0, 5]]) 6 >>> np.sum([[0, 1], [0, 5]], axis=0) array([0, 6]) >>> np.sum([[0, 1], [0, 5]], axis=1) array([1, 5]) >>> np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1) array([1., 5.]) If the accumulator is too small, overflow occurs: >>> np.ones(128, dtype=np.int8).sum(dtype=np.int8) -128 You can also start the sum with a value other than zero: >>> np.sum([10], initial=5) 15", "score": "0.6913103"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6749457"}]}
{"task_id": "humaneval_61", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n", "entry_point": "correct_bracketing", "gold_generation": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n", "context": "brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False", "function_name": "def correct_bracketing(brackets: str):", "ctxs": [{"id": "41790", "text": "Function: numpy.reference.generated.numpy.chararray.isspace\nSnippet: numpy.chararray.isspace method chararray.isspace()[source] Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. See also char.isspace", "score": "0.68244576"}, {"id": "24344", "text": "Function: python.library.stdtypes#str.endswith\nSnippet: str.endswith(suffix[, start[, end]]) Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position.", "score": "0.68187106"}, {"id": "41667", "text": "Function: numpy.reference.generated.numpy.char.chararray.isspace\nSnippet: numpy.char.chararray.isspace method char.chararray.isspace()[source] Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. See also char.isspace", "score": "0.6812215"}, {"id": "36676", "text": "Function: django.ref.contrib.gis.geos#django.contrib.gis.geos.MultiLineString.closed\nSnippet: closed Returns True if and only if all elements are closed.", "score": "0.6744781"}, {"id": "24379", "text": "Function: python.library.stdtypes#str.startswith\nSnippet: str.startswith(prefix[, start[, end]]) Return True if string starts with the prefix, otherwise return False. prefix can also be a tuple of prefixes to look for. With optional start, test string beginning at that position. With optional end, stop comparing string at that position.", "score": "0.6721466"}]}
{"task_id": "humaneval_62", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "entry_point": "derivative", "gold_generation": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "context": "xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]", "function_name": "def derivative(xs: list):", "ctxs": [{"id": "43582", "text": "Function: numpy.reference.generated.numpy.polynomial.polynomial.polyder\nSnippet: numpy.polynomial.polynomial.polyder polynomial.polynomial.polyder(c, m=1, scl=1, axis=0)[source] Differentiate a polynomial. Returns the polynomial coefficients c differentiated m times along axis. At each iteration the result is multiplied by scl (the scaling factor is for use in a linear change of variable). The argument c is an array of coefficients from low to high degree along each axis, e.g., [1,2,3] represents the polynomial 1 + 2*x + 3*x**2 while [[1,2],[1,2]] represents 1 + 1*x + 2*y + 2*x*y if axis=0 is x and axis=1 is y. Parameters carray_like Array of polynomial coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. mint, optional Number of derivatives taken, must be non-negative. (Default: 1) sclscalar, optional Each differentiation is multiplied by scl. The end result is multiplication by scl**m. This is for use in a linear change of variable. (Default: 1) axisint, optional Axis over which the derivative is taken. (Default: 0). New in version 1.7.0. Returns derndarray Polynomial coefficients of the derivative. See also polyint Examples >>> from numpy.polynomial import polynomial as P >>> c = (1,2,3,4) # 1 + 2x + 3x**2 + 4x**3 >>> P.polyder(c) # (d/dx)(c) = 2 + 6x + 12x**2 array([ 2., 6., 12.]) >>> P.polyder(c,3) # (d**3/dx**3)(c) = 24 array([24.]) >>> P.polyder(c,scl=-1) # (d/d(-x))(c) = -2 - 6x - 12x**2 array([ -2., -6., -12.]) >>> P.polyder(c,2,-1) # (d**2/d(-x)**2)(c) = 6 + 24x array([ 6., 24.])", "score": "0.70893735"}, {"id": "43287", "text": "Function: numpy.reference.routines.polynomials.poly1d\nSnippet: Poly1d Basics poly1d(c_or_r[, r, variable]) A one-dimensional polynomial class. polyval(p, x) Evaluate a polynomial at specific values. poly(seq_of_zeros) Find the coefficients of a polynomial with the given sequence of roots. roots(p) Return the roots of a polynomial with coefficients given in p. Fitting polyfit(x, y, deg[, rcond, full, w, cov]) Least squares polynomial fit. Calculus polyder(p[, m]) Return the derivative of the specified order of a polynomial. polyint(p[, m, k]) Return an antiderivative (indefinite integral) of a polynomial. Arithmetic polyadd(a1, a2) Find the sum of two polynomials. polydiv(u, v) Returns the quotient and remainder of polynomial division. polymul(a1, a2) Find the product of two polynomials. polysub(a1, a2) Difference (subtraction) of two polynomials. Warnings RankWarning Issued by polyfit when the Vandermonde matrix is rank deficient.", "score": "0.70167065"}, {"id": "43091", "text": "Function: numpy.reference.generated.numpy.polyder\nSnippet: numpy.polyder numpy.polyder(p, m=1)[source] Return the derivative of the specified order of a polynomial. Note This forms part of the old polynomial API. Since version 1.4, the new polynomial API defined in numpy.polynomial is preferred. A summary of the differences can be found in the transition guide. Parameters ppoly1d or sequence Polynomial to differentiate. A sequence is interpreted as polynomial coefficients, see poly1d. mint, optional Order of differentiation (default: 1) Returns derpoly1d A new polynomial representing the derivative. See also polyint Anti-derivative of a polynomial. poly1d Class for one-dimensional polynomials. Examples The derivative of the polynomial \\(x^3 + x^2 + x^1 + 1\\) is: >>> p = np.poly1d([1,1,1,1]) >>> p2 = np.polyder(p) >>> p2 poly1d([3, 2, 1]) which evaluates to: >>> p2(2.) 17.0 We can verify this, approximating the derivative with (f(x + h) - f(x))/h: >>> (p(2. + 0.001) - p(2.)) / 0.001 17.007000999997857 The fourth-order derivative of a 3rd-order polynomial is zero: >>> np.polyder(p, 2) poly1d([6, 2]) >>> np.polyder(p, 3) poly1d([6]) >>> np.polyder(p, 4) poly1d([0])", "score": "0.694893"}, {"id": "43602", "text": "Function: numpy.reference.generated.numpy.polynomial.polynomial.polynomial.deriv\nSnippet: numpy.polynomial.polynomial.Polynomial.deriv method polynomial.polynomial.Polynomial.deriv(m=1)[source] Differentiate. Return a series instance of that is the derivative of the current series. Parameters mnon-negative int Find the derivative of order m. Returns new_seriesseries A new series representing the derivative. The domain is the same as the domain of the differentiated series.", "score": "0.6934103"}, {"id": "43526", "text": "Function: numpy.reference.generated.numpy.polynomial.legendre.legder\nSnippet: numpy.polynomial.legendre.legder polynomial.legendre.legder(c, m=1, scl=1, axis=0)[source] Differentiate a Legendre series. Returns the Legendre series coefficients c differentiated m times along axis. At each iteration the result is multiplied by scl (the scaling factor is for use in a linear change of variable). The argument c is an array of coefficients from low to high degree along each axis, e.g., [1,2,3] represents the series 1*L_0 + 2*L_1 + 3*L_2 while [[1,2],[1,2]] represents 1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y) if axis=0 is x and axis=1 is y. Parameters carray_like Array of Legendre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. mint, optional Number of derivatives taken, must be non-negative. (Default: 1) sclscalar, optional Each differentiation is multiplied by scl. The end result is multiplication by scl**m. This is for use in a linear change of variable. (Default: 1) axisint, optional Axis over which the derivative is taken. (Default: 0). New in version 1.7.0. Returns derndarray Legendre series of the derivative. See also legint Notes In general, the result of differentiating a Legendre series does not resemble the same operation on a power series. Thus the result of this function may be “unintuitive,” albeit correct; see Examples section below. Examples >>> from numpy.polynomial import legendre as L >>> c = (1,2,3,4) >>> L.legder(c) array([ 6., 9., 20.]) >>> L.legder(c, 3) array([60.]) >>> L.legder(c, scl=-1) array([ -6., -9., -20.]) >>> L.legder(c, 2,-1) array([ 9., 60.])", "score": "0.6848347"}]}
{"task_id": "humaneval_63", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "entry_point": "fibfib", "gold_generation": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "context": "The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24", "function_name": "def fibfib(n: int):", "ctxs": [{"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6859879"}, {"id": "20299", "text": "Function: python.library.functools\nSnippet: in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991: ... pep = get_pep(n) ... print(n, len(pep)) >>> get_pep.cache_info() CacheInfo(hits=3, misses=8, maxsize=32, currsize=8) Example of efficiently computing Fibonacci numbers using a cache to implement a dynamic programming technique: @lru_cache(maxsize=None) def fib(n): if n < 2: return n return fib(n-1) + fib(n-2) >>> [fib(n) for n in range(16)] [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610] >>> fib.cache_info() CacheInfo(hits=28, misses=16, maxsize=None, currsize=16) New in version 3.2. Changed in version 3.3: Added the typed option. Changed in version 3.8: Added the user_function option. New in version 3.9: Added the function cache_parameters() @functools.total_ordering Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest. This simplifies the effort involved in specifying all of the possible rich comparison operations: The class must define one of __lt__(), __le__(), __gt__(), or __ge__(). In addition, the class should supply an __eq__() method. For example: @total_ordering class Student: def _is_valid_operand(self, other): return (hasattr(other, \"lastname\") and hasattr(other, \"firstname\")) def __eq__(self, other): if not self._is_valid_operand(other): return NotImplemented return ((self.lastname.lower(), self.firstname.lower()) == (other.lastname.lower(), other.firstname.lower())) def __lt__(self, other): if not self._is_valid_operand(other): return NotImplemented return ((self.lastname.lower(), self.firstname.lower()) < (other.lastname.lower(), other.firstname.lower())) Note While this decorator makes it easy to create well behaved totally ordered types, it does come at the cost of slower execution and more complex stack traces for the derived comparison methods. If performance benchmarking indicates this is a bottleneck for a given application, implementing all six rich comparison methods instead is likely to provide an easy speed boost. New in version 3.2. Changed in version 3.4: Returning NotImplemented from the underlying comparison function for unrecognised types is now supported. functools.partial(func, /, *args, **keywords) Return a new partial object which when called will behave like func called with the positional arguments args and keyword arguments keywords. If more arguments are supplied to the call, they are appended to args. If additional keyword arguments are supplied, they extend and override keywords. Roughly equivalent to: def partial(func, /, *args, **keywords): def newfunc(*fargs, **fkeywords): newkeywords = {**keywords, **fkeywords} return func(*args, *fargs, **newkeywords) newfunc.func = func newfunc.args = args newfunc.keywords = keywords return newfunc The partial() is used for partial function application which “freezes” some portion of a function’s arguments and/or keywords resulting in a new object with a simplified signature. For example, partial() can be used to create a callable that behaves like the int() function where the base argument defaults to two: >>> from functools import partial >>> basetwo = partial(int, base=2) >>> basetwo.__doc__ = 'Convert base 2 string to an int.' >>> basetwo('10010') 18 class functools.partialmethod(func, /, *args, **keywords) Return a new partialmethod descriptor which behaves like partial except that it is designed to be used as a method definition rather than being directly callable. func must be a descriptor or a callable (objects which are both, like normal functions, are handled as descriptors). When func is a descriptor (such as a normal Python function, classmethod(), staticmethod(),", "score": "0.67974126"}, {"id": "19644", "text": "Function: python.library.difflib#difflib.SequenceMatcher\nSnippet: abcd' at the tail end of the second sequence directly. Instead only the 'abcd' can match, and matches the leftmost 'abcd' in the second sequence: >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\") >>> s.find_longest_match(0, 5, 0, 9) Match(a=1, b=0, size=4) If no blocks match, this returns (alo, blo, 0). This method returns a named tuple Match(a, b, size). Changed in version 3.9: Added default arguments. get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution:", "score": "0.6632092"}, {"id": "19648", "text": "Function: python.library.difflib#difflib.SequenceMatcher.get_matching_blocks\nSnippet: get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]", "score": "0.6561979"}, {"id": "19649", "text": "Function: python.library.difflib#difflib.SequenceMatcher.get_opcodes\nSnippet: get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f'", "score": "0.6543728"}]}
{"task_id": "humaneval_64", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "vowels_count", "gold_generation": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "context": "Add more test cases.", "function_name": "FIX = \n\ndef vowels_count(s):", "ctxs": [{"id": "26167", "text": "Function: python.library.unittest#unittest.TestSuite.addTests\nSnippet: addTests(tests) Add all the tests from an iterable of TestCase and TestSuite instances to this test suite. This is equivalent to iterating over tests, calling addTest() for each element.", "score": "0.71498185"}, {"id": "26166", "text": "Function: python.library.unittest#unittest.TestSuite.addTest\nSnippet: addTest(test) Add a TestCase or TestSuite to the suite.", "score": "0.6970041"}, {"id": "41200", "text": "Function: django.topics.testing.tools#django.test.TestCase.databases\nSnippet: TestCase.databases", "score": "0.6563087"}, {"id": "26145", "text": "Function: python.library.unittest#unittest.TestResult.addSkip\nSnippet: addSkip(test, reason) Called when the test case test is skipped. reason is the reason the test gave for skipping. The default implementation appends a tuple (test, reason) to the instance’s skipped attribute.", "score": "0.6535877"}, {"id": "26165", "text": "Function: python.library.unittest#unittest.TestSuite\nSnippet: class unittest.TestSuite(tests=()) This class represents an aggregation of individual test cases and test suites. The class presents the interface needed by the test runner to allow it to be run as any other test case. Running a TestSuite instance is the same as iterating over the suite, running each test individually. If tests is given, it must be an iterable of individual test cases or other test suites that will be used to build the suite initially. Additional methods are provided to add test cases and suites to the collection later on. TestSuite objects behave much like TestCase objects, except they do not actually implement a test. Instead, they are used to aggregate tests into groups of tests that should be run together. Some additional methods are available to add tests to TestSuite instances: addTest(test) Add a TestCase or TestSuite to the suite. addTests(tests) Add all the tests from an iterable of TestCase and TestSuite instances to this test suite. This is equivalent to iterating over tests, calling addTest() for each element. TestSuite shares the following methods with TestCase: run(result) Run the tests associated with this suite, collecting the result into the test result object passed as result. Note that unlike TestCase.run(), TestSuite.run() requires the result object to be passed in. debug() Run the tests associated with this suite without collecting the result. This allows exceptions raised by the test to be propagated to the caller and can be used to support running tests under a debugger. countTestCases() Return the number of tests represented by this test object, including all individual tests and sub-suites. __iter__() Tests grouped by a TestSuite are always accessed by iteration. Subclasses can lazily provide tests by overriding __iter__(). Note that this method may be called several times on a single suite (for example when counting tests or comparing for equality) so the tests returned by repeated iterations before TestSuite.run() must be the same for each call iteration. After TestSuite.run(), callers should not rely on the tests returned by this method unless the caller uses a subclass that overrides TestSuite._removeTestAtIndex() to preserve test references. Changed in version 3.2: In earlier versions the TestSuite accessed tests directly rather than through iteration, so overriding __iter__() wasn’t sufficient for providing tests. Changed in version 3.4: In earlier versions the TestSuite held references to each TestCase after TestSuite.run(). Subclasses can restore that behavior by overriding TestSuite._removeTestAtIndex(). In the typical usage of a TestSuite object, the run() method is invoked by a TestRunner rather than by the end-user test harness.", "score": "0.64510846"}]}
{"task_id": "humaneval_65", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "circular_shift", "gold_generation": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n", "context": "Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"", "function_name": "def circular_shift(x, shift):", "ctxs": [{"id": "19510", "text": "Function: python.library.decimal#decimal.Context.shift\nSnippet: shift(x, y) Returns a shifted copy of x, y times.", "score": "0.71467966"}, {"id": "19569", "text": "Function: python.library.decimal#decimal.Decimal.shift\nSnippet: shift(other, context=None) Return the result of shifting the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to shift. If the second operand is positive then the shift is to the left; otherwise the shift is to the right. Digits shifted into the coefficient are zeros. The sign and exponent of the first operand are unchanged.", "score": "0.7129678"}, {"id": "43158", "text": "Function: numpy.reference.generated.numpy.right_shift\nSnippet: numpy.right_shift numpy.right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'right_shift'> Shift the bits of an integer to the right. Bits are shifted to the right x2. Because the internal representation of numbers is in binary format, this operation is equivalent to dividing x1 by 2**x2. Parameters x1array_like, int Input values. x2array_like, int Number of bits to remove at the right of x1. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray, int Return x1 with bits shifted x2 times to the right. This is a scalar if both x1 and x2 are scalars. See also left_shift Shift the bits of an integer to the left. binary_repr Return the binary representation of the input number as a string. Examples >>> np.binary_repr(10) '1010' >>> np.right_shift(10, 1) 5 >>> np.binary_repr(5) '101' >>> np.right_shift(10, [1,2,3]) array([5, 2, 1]) The >> operator can be used as a shorthand for np.right_shift on ndarrays. >>> x1 = 10 >>> x2 = np.array([1,2,3]) >>> x1 >> x2 array([5, 2, 1])", "score": "0.7062839"}, {"id": "42935", "text": "Function: numpy.reference.generated.numpy.left_shift\nSnippet: numpy.left_shift numpy.left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'left_shift'> Shift the bits of an integer to the left. Bits are shifted to the left by appending x2 0s at the right of x1. Since the internal representation of numbers is in binary format, this operation is equivalent to multiplying x1 by 2**x2. Parameters x1array_like of integer type Input values. x2array_like of integer type Number of zeros to append to x1. Has to be non-negative. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outarray of integer type Return x1 with bits shifted x2 times to the left. This is a scalar if both x1 and x2 are scalars. See also right_shift Shift the bits of an integer to the right. binary_repr Return the binary representation of the input number as a string. Examples >>> np.binary_repr(5) '101' >>> np.left_shift(5, 2) 20 >>> np.binary_repr(20) '10100' >>> np.left_shift(5, [1,2,3]) array([10, 20, 40]) Note that the dtype of the second argument may change the dtype of the result and can lead to unexpected results in some cases (see Casting Rules): >>> a = np.left_shift(np.uint8(255), 1) # Expect 254 >>> print(a, type(a)) # Unexpected result due to upcasting 510 <class 'numpy.int64'> >>> b = np.left_shift(np.uint8(255), np.uint8(1)) >>> print(b, type(b)) 254 <class 'numpy.uint8'> The << operator can be used as a shorthand for np.left_shift on ndarrays. >>> x1 = 5 >>> x2 = np.array([1, 2, 3]) >>> x1 << x2 array([10, 20, 40])", "score": "0.6993851"}, {"id": "19487", "text": "Function: python.library.decimal#decimal.Context.logical_invert\nSnippet: logical_invert(x) Invert all the digits in x.", "score": "0.68486917"}]}
{"task_id": "humaneval_66", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n", "entry_point": "digitSum", "gold_generation": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n", "context": "Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153", "function_name": "def digitSum(s):", "ctxs": [{"id": "24401", "text": "Function: python.library.string#string.ascii_uppercase\nSnippet: string.ascii_uppercase The uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. This value is not locale-dependent and will not change.", "score": "0.7291878"}, {"id": "18236", "text": "Function: python.library.binascii#binascii.unhexlify\nSnippet: binascii.a2b_hex(hexstr) binascii.unhexlify(hexstr) Return the binary data represented by the hexadecimal string hexstr. This function is the inverse of b2a_hex(). hexstr must contain an even number of hexadecimal digits (which can be upper or lower case), otherwise an Error exception is raised. Similar functionality (accepting only text string arguments, but more liberal towards whitespace) is also accessible using the bytes.fromhex() class method.", "score": "0.71335196"}, {"id": "41762", "text": "Function: numpy.reference.generated.numpy.char.upper\nSnippet: numpy.char.upper char.upper(a)[source] Return an array with the elements converted to uppercase. Calls str.upper element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like, {str, unicode} Input array. Returns outndarray, {str, unicode} Output array of str or unicode, depending on input type See also str.upper Examples >>> c = np.array(['a1b c', '1bca', 'bca1']); c array(['a1b c', '1bca', 'bca1'], dtype='<U5') >>> np.char.upper(c) array(['A1B C', '1BCA', 'BCA1'], dtype='<U5')", "score": "0.7124047"}, {"id": "18342", "text": "Function: python.library.stdtypes#bytes.upper\nSnippet: bytes.upper() bytearray.upper() Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart. For example: >>> b'Hello World'.upper() b'HELLO WORLD' Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made.", "score": "0.71137124"}, {"id": "19054", "text": "Function: python.library.curses.ascii\nSnippet: 8-bit character corresponding to the given ASCII character (the character bit value is bitwise-ored with 0x80). The following function takes either a single-character string or integer value; it returns a string. curses.ascii.unctrl(c) Return a string representation of the ASCII character c. If c is printable, this string is the character itself. If the character is a control character (0x00–0x1f) the string consists of a caret ('^') followed by the corresponding uppercase letter. If the character is an ASCII delete (0x7f) the string is '^?'. If the character has its meta bit (0x80) set, the meta bit is stripped, the preceding rules applied, and '!' prepended to the result. curses.ascii.controlnames A 33-element string array that contains the ASCII mnemonics for the thirty-two ASCII control characters from 0 (NUL) to 0x1f (US), in order, plus the mnemonic SP for the space character.", "score": "0.7100382"}]}
{"task_id": "humaneval_67", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n", "entry_point": "fruit_distribution", "gold_generation": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n", "context": "In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. Given the string that represents the total number of \n    the oranges and apples and an integer that represent the total number of the fruits \n    in the basket return the number of the mango fruits in the basket.\n    for examble:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n    fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19", "function_name": "def fruit_distribution(s,n):", "ctxs": [{"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6653372"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6620516"}, {"id": "23271", "text": "Function: python.library.random#random.choices\nSnippet: random.choices(population, weights=None, *, cum_weights=None, k=1) Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises IndexError. If a weights sequence is specified, selections are made according to the relative weights. Alternatively, if a cum_weights sequence is given, the selections are made according to the cumulative weights (perhaps computed using itertools.accumulate()). For example, the relative weights [10, 5, 30, 5] are equivalent to the cumulative weights [10, 15, 45, 50]. Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. It is a TypeError to specify both weights and cum_weights. The weights or cum_weights can use any numeric type that interoperates with the float values returned by random() (that includes integers, floats, and fractions but excludes decimals). Behavior is undefined if any weight is negative. A ValueError is raised if all weights are zero. For a given seed, the choices() function with equal weighting typically produces a different sequence than repeated calls to choice(). The algorithm used by choices() uses floating point arithmetic for internal consistency and speed. The algorithm used by choice() defaults to integer arithmetic with repeated selections to avoid small biases from round-off error. New in version 3.6. Changed in version 3.9: Raises a ValueError if all weights are zero.", "score": "0.64505124"}, {"id": "43676", "text": "Function: numpy.reference.random.generated.numpy.random.generator.multinomial\nSnippet: a 6-sided die >>> rng.multinomial([10, 20],[[1/4]*4 + [0]*2, [1/6]*6]) array([[2, 1, 4, 3, 0, 0], [3, 3, 3, 6, 1, 4]], dtype=int64) # random Generate categorical random variates from two categories where the first has 3 outcomes and the second has 2. >>> rng.multinomial(1, [[.1, .5, .4 ], [.3, .7, .0]]) array([[0, 0, 1], [0, 1, 0]], dtype=int64) # random argmax(axis=-1) is then used to return the categories. >>> pvals = [[.1, .5, .4 ], [.3, .7, .0]] >>> rvs = rng.multinomial(1, pvals, size=(4,2)) >>> rvs.argmax(axis=-1) array([[0, 1], [2, 0], [2, 1], [2, 0]], dtype=int64) # random The same output dimension can be produced using broadcasting. >>> rvs = rng.multinomial([[1]] * 4, pvals) >>> rvs.argmax(axis=-1) array([[0, 1], [2, 0], [2, 1], [2, 0]], dtype=int64) # random The probability inputs should be normalized. As an implementation detail, the value of the last entry is ignored and assumed to take up any leftover probability mass, but this should not be relied on. A biased coin which has twice as much weight on one side as on the other should be sampled like so: >>> rng.multinomial(100, [1.0 / 3, 2.0 / 3]) # RIGHT array([38, 62]) # random not like: >>> rng.multinomial(100, [1.0, 2.0]) # WRONG Traceback (most recent call last): ValueError: pvals < 0, pvals > 1 or pvals contains NaNs", "score": "0.6415615"}, {"id": "43770", "text": "Function: numpy.reference.random.generated.numpy.random.randomstate.multinomial\nSnippet: numpy.random.RandomState.multinomial method random.RandomState.multinomial(n, pvals, size=None) Draw samples from a multinomial distribution. The multinomial distribution is a multivariate generalization of the binomial distribution. Take an experiment with one of p possible outcomes. An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. Each sample drawn from the distribution represents n such experiments. Its values, X_i = [X_0, X_1, ..., X_p], represent the number of times the outcome was i. Note New code should use the multinomial method of a default_rng() instance instead; please see the Quick Start. Parameters nint Number of experiments. pvalssequence of floats, length p Probabilities of each of the p different outcomes. These must sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) <= 1). sizeint or tuple of ints, optional Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned. Returns outndarray The drawn samples, of shape size, if that was provided. If not, the shape is (N,). In other words, each entry out[i,j,...,:] is an N-dimensional value drawn from the distribution. See also Generator.multinomial which should be used for new code. Examples Throw a dice 20 times: >>> np.random.multinomial(20, [1/6.]*6, size=1) array([[4, 1, 7, 5, 2, 1]]) # random It landed 4 times on 1, once on 2, etc. Now, throw the dice 20 times, and 20 times again: >>> np.random.multinomial(20, [1/6.]*6, size=2) array([[3, 4, 3, 3, 4, 3], # random [2, 4, 3, 4, 0, 7]]) For the first run, we threw 3 times 1, 4 times 2, etc. For the second, we threw 2 times 1, 4 times 2, etc. A loaded die is more likely to land on number 6: >>> np.random.multinomial(100, [1/7.]*5 + [2/7.]) array([11, 16, 14, 17, 16, 26]) # random The probability inputs should be normalized. As an implementation detail, the value of the last entry is ignored and assumed to take up any leftover probability mass, but this should not be relied on. A biased coin which has twice as much weight on one side as on the other should be sampled like so: >>> np.random.multinomial(100, [1.0 / 3, 2.0 / 3]) # RIGHT array([38, 62]) # random not like: >>> np.random.multinomial(100, [1.0, 2.0]) # WRONG Traceback (most recent call last): ValueError: pvals < 0, pvals > 1 or pvals contains NaNs", "score": "0.6402946"}]}
{"task_id": "humaneval_68", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n", "entry_point": "pluck", "gold_generation": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n", "context": "\"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value", "function_name": "def pluck(arr):", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.7092718"}, {"id": "12996", "text": "Function: sklearn.modules.generated.sklearn.tree.extratreeregressor\nSnippet: See Glossary for details. min_impurity_decreasefloat, default=0.0 A node will be split if this split induces a decrease of the impurity greater than or equal to this value. The weighted impurity decrease equation is the following: N_t / N * (impurity - N_t_R / N_t * right_impurity - N_t_L / N_t * left_impurity) where N is the total number of samples, N_t is the number of samples at the current node, N_t_L is the number of samples in the left child, and N_t_R is the number of samples in the right child. N, N_t, N_t_R and N_t_L all refer to the weighted sum, if sample_weight is passed. New in version 0.19. min_impurity_splitfloat, default=None Threshold for early stopping in tree growth. A node will split if its impurity is above the threshold, otherwise it is a leaf. Deprecated since version 0.19: min_impurity_split has been deprecated in favor of min_impurity_decrease in 0.19. The default value of min_impurity_split has changed from 1e-7 to 0 in 0.23 and it will be removed in 1.0 (renaming of 0.25). Use min_impurity_decrease instead. max_leaf_nodesint, default=None Grow a tree with max_leaf_nodes in best-first fashion. Best nodes are defined as relative reduction in impurity. If None then unlimited number of leaf nodes. ccp_alphanon-negative float, default=0.0 Complexity parameter used for Minimal Cost-Complexity Pruning. The subtree with the largest cost complexity that is smaller than ccp_alpha will be chosen. By default, no pruning is performed. See Minimal Cost-Complexity Pruning for details. New in version 0.22. Attributes max_features_int The inferred value of max_features. n_features_int The number of features when fit is performed. feature_importances_ndarray of shape (n_features,) Return the feature importances. n_outputs_int The number of outputs when fit is performed. tree_Tree instance The underlying Tree object. Please refer to help(sklearn.tree._tree.Tree) for attributes of Tree object and Understanding the decision tree structure for basic usage of these attributes. See also ExtraTreeClassifier An extremely randomized tree classifier. sklearn.ensemble.ExtraTreesClassifier An extra-trees classifier. sklearn.ensemble.ExtraTreesRegressor An extra-trees regressor. Notes The default values for the parameters controlling the size of the trees (e.g. max_depth, min_samples_leaf, etc.) lead to fully grown and unpruned trees which can potentially be very large on some data sets. To reduce memory consumption, the complexity and size of the trees should be controlled by setting those parameter values. References 1 P. Geurts, D. Ernst., and L. Wehenkel, “Extremely randomized trees”, Machine Learning, 63(1), 3-42, 2006. Examples >>> from sklearn.datasets import load_diabetes >>> from sklearn.model_selection import train_test_split >>> from sklearn.ensemble import BaggingRegressor >>> from sklearn.tree import ExtraTreeRegressor >>> X, y = load_diabetes(return_X_y=True) >>> X_train, X_test, y_train, y_test = train_test_split( ... X, y, random_state=0) >>> extra_tree = ExtraTreeRegressor(random_state=0) >>> reg = BaggingRegressor(extra_tree, random_state=0).fit( ... X_train, y_train) >>> reg.score(X_test, y_test) 0.33... Methods apply(X[, check_input]) Return the index of the leaf that each sample is predicted as. cost_complexity_pruning_path(X, y[, …]) Compute the pruning path during Minimal Cost-Complexity Pruning. decision_path(X[, check_input]) Return the decision path in the tree. fit(X, y[, sample_weight, check_input, …]) Build a decision tree regressor from the training set (X, y). get_depth() Return the depth of the decision", "score": "0.7072704"}, {"id": "12950", "text": "Function: sklearn.modules.generated.sklearn.tree.decisiontreeregressor\nSnippet: split before finding the best split among them. But the best found split may vary across different runs, even if max_features=n_features. That is the case, if the improvement of the criterion is identical for several splits and one split has to be selected at random. To obtain a deterministic behaviour during fitting, random_state has to be fixed to an integer. See Glossary for details. max_leaf_nodesint, default=None Grow a tree with max_leaf_nodes in best-first fashion. Best nodes are defined as relative reduction in impurity. If None then unlimited number of leaf nodes. min_impurity_decreasefloat, default=0.0 A node will be split if this split induces a decrease of the impurity greater than or equal to this value. The weighted impurity decrease equation is the following: N_t / N * (impurity - N_t_R / N_t * right_impurity - N_t_L / N_t * left_impurity) where N is the total number of samples, N_t is the number of samples at the current node, N_t_L is the number of samples in the left child, and N_t_R is the number of samples in the right child. N, N_t, N_t_R and N_t_L all refer to the weighted sum, if sample_weight is passed. New in version 0.19. min_impurity_splitfloat, default=0 Threshold for early stopping in tree growth. A node will split if its impurity is above the threshold, otherwise it is a leaf. Deprecated since version 0.19: min_impurity_split has been deprecated in favor of min_impurity_decrease in 0.19. The default value of min_impurity_split has changed from 1e-7 to 0 in 0.23 and it will be removed in 1.0 (renaming of 0.25). Use min_impurity_decrease instead. ccp_alphanon-negative float, default=0.0 Complexity parameter used for Minimal Cost-Complexity Pruning. The subtree with the largest cost complexity that is smaller than ccp_alpha will be chosen. By default, no pruning is performed. See Minimal Cost-Complexity Pruning for details. New in version 0.22. Attributes feature_importances_ndarray of shape (n_features,) Return the feature importances. max_features_int The inferred value of max_features. n_features_int The number of features when fit is performed. n_outputs_int The number of outputs when fit is performed. tree_Tree instance The underlying Tree object. Please refer to help(sklearn.tree._tree.Tree) for attributes of Tree object and Understanding the decision tree structure for basic usage of these attributes. See also DecisionTreeClassifier A decision tree classifier. Notes The default values for the parameters controlling the size of the trees (e.g. max_depth, min_samples_leaf, etc.) lead to fully grown and unpruned trees which can potentially be very large on some data sets. To reduce memory consumption, the complexity and size of the trees should be controlled by setting those parameter values. References 1 https://en.wikipedia.org/wiki/Decision_tree_learning 2 L. Breiman, J. Friedman, R. Olshen, and C. Stone, “Classification and Regression Trees”, Wadsworth, Belmont, CA, 1984. 3 T. Hastie, R. Tibshirani and J. Friedman. “Elements of Statistical Learning”, Springer, 2009. 4 L. Breiman, and A. Cutler, “Random Forests”, https://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm Examples >>> from sklearn.datasets import load_diabetes >>> from sklearn.model_selection import cross_val_score >>> from sklearn.tree import DecisionTreeRegressor >>> X, y = load_diabetes(return_X_y=True) >>> regressor = DecisionTreeRegressor(random_state=0) >>> cross_val_score(regressor, X, y, cv=10) ... ... array([-0.39...,", "score": "0.70596915"}, {"id": "12973", "text": "Function: sklearn.modules.generated.sklearn.tree.extratreeclassifier\nSnippet: of leaf nodes. min_impurity_decreasefloat, default=0.0 A node will be split if this split induces a decrease of the impurity greater than or equal to this value. The weighted impurity decrease equation is the following: N_t / N * (impurity - N_t_R / N_t * right_impurity - N_t_L / N_t * left_impurity) where N is the total number of samples, N_t is the number of samples at the current node, N_t_L is the number of samples in the left child, and N_t_R is the number of samples in the right child. N, N_t, N_t_R and N_t_L all refer to the weighted sum, if sample_weight is passed. New in version 0.19. min_impurity_splitfloat, default=None Threshold for early stopping in tree growth. A node will split if its impurity is above the threshold, otherwise it is a leaf. Deprecated since version 0.19: min_impurity_split has been deprecated in favor of min_impurity_decrease in 0.19. The default value of min_impurity_split has changed from 1e-7 to 0 in 0.23 and it will be removed in 1.0 (renaming of 0.25). Use min_impurity_decrease instead. class_weightdict, list of dict or “balanced”, default=None Weights associated with classes in the form {class_label: weight}. If None, all classes are supposed to have weight one. For multi-output problems, a list of dicts can be provided in the same order as the columns of y. Note that for multioutput (including multilabel) weights should be defined for each class of every column in its own dict. For example, for four-class multilabel classification weights should be [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of [{1:1}, {2:5}, {3:1}, {4:1}]. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)) For multi-output, the weights of each column of y will be multiplied. Note that these weights will be multiplied with sample_weight (passed through the fit method) if sample_weight is specified. ccp_alphanon-negative float, default=0.0 Complexity parameter used for Minimal Cost-Complexity Pruning. The subtree with the largest cost complexity that is smaller than ccp_alpha will be chosen. By default, no pruning is performed. See Minimal Cost-Complexity Pruning for details. New in version 0.22. Attributes classes_ndarray of shape (n_classes,) or list of ndarray The classes labels (single output problem), or a list of arrays of class labels (multi-output problem). max_features_int The inferred value of max_features. n_classes_int or list of int The number of classes (for single output problems), or a list containing the number of classes for each output (for multi-output problems). feature_importances_ndarray of shape (n_features,) Return the feature importances. n_features_int The number of features when fit is performed. n_outputs_int The number of outputs when fit is performed. tree_Tree instance The underlying Tree object. Please refer to help(sklearn.tree._tree.Tree) for attributes of Tree object and Understanding the decision tree structure for basic usage of these attributes. See also ExtraTreeRegressor An extremely randomized tree regressor. sklearn.ensemble.ExtraTreesClassifier An extra-trees classifier. sklearn.ensemble.ExtraTreesRegressor An extra-trees regressor. Notes The default values for", "score": "0.70431775"}, {"id": "12968", "text": "Function: sklearn.modules.generated.sklearn.tree.extratreeclassifier#sklearn.tree.ExtraTreeClassifier\nSnippet: leaf nodes. min_impurity_decreasefloat, default=0.0 A node will be split if this split induces a decrease of the impurity greater than or equal to this value. The weighted impurity decrease equation is the following: N_t / N * (impurity - N_t_R / N_t * right_impurity - N_t_L / N_t * left_impurity) where N is the total number of samples, N_t is the number of samples at the current node, N_t_L is the number of samples in the left child, and N_t_R is the number of samples in the right child. N, N_t, N_t_R and N_t_L all refer to the weighted sum, if sample_weight is passed. New in version 0.19. min_impurity_splitfloat, default=None Threshold for early stopping in tree growth. A node will split if its impurity is above the threshold, otherwise it is a leaf. Deprecated since version 0.19: min_impurity_split has been deprecated in favor of min_impurity_decrease in 0.19. The default value of min_impurity_split has changed from 1e-7 to 0 in 0.23 and it will be removed in 1.0 (renaming of 0.25). Use min_impurity_decrease instead. class_weightdict, list of dict or “balanced”, default=None Weights associated with classes in the form {class_label: weight}. If None, all classes are supposed to have weight one. For multi-output problems, a list of dicts can be provided in the same order as the columns of y. Note that for multioutput (including multilabel) weights should be defined for each class of every column in its own dict. For example, for four-class multilabel classification weights should be [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of [{1:1}, {2:5}, {3:1}, {4:1}]. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)) For multi-output, the weights of each column of y will be multiplied. Note that these weights will be multiplied with sample_weight (passed through the fit method) if sample_weight is specified. ccp_alphanon-negative float, default=0.0 Complexity parameter used for Minimal Cost-Complexity Pruning. The subtree with the largest cost complexity that is smaller than ccp_alpha will be chosen. By default, no pruning is performed. See Minimal Cost-Complexity Pruning for details. New in version 0.22. Attributes classes_ndarray of shape (n_classes,) or list of ndarray The classes labels (single output problem), or a list of arrays of class labels (multi-output problem). max_features_int The inferred value of max_features. n_classes_int or list of int The number of classes (for single output problems), or a list containing the number of classes for each output (for multi-output problems). feature_importances_ndarray of shape (n_features,) Return the feature importances. n_features_int The number of features when fit is performed. n_outputs_int The number of outputs when fit is performed. tree_Tree instance The underlying Tree object. Please refer to help(sklearn.tree._tree.Tree) for attributes of Tree object and Understanding the decision tree structure for basic usage of these attributes. See also ExtraTreeRegressor An extremely randomized tree regressor. sklearn.ensemble.ExtraTreesClassifier An extra-trees classifier. sklearn.ensemble.ExtraTreesRegressor An extra-trees regressor. Notes The default values for the", "score": "0.7042882"}]}
{"task_id": "humaneval_69", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "entry_point": "search", "gold_generation": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "context": "", "function_name": "def search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015749"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49312225"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.49104327"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48984405"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.48983365"}]}
{"task_id": "humaneval_70", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "strange_sort_list", "gold_generation": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n", "context": "", "function_name": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015749"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49312225"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.49104327"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48984405"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.48983365"}]}
{"task_id": "humaneval_71", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "entry_point": "triangle_area", "gold_generation": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "context": "", "function_name": "def triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015749"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49312225"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.49104327"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48984405"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.48983365"}]}
{"task_id": "humaneval_72", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "entry_point": "will_it_fly", "gold_generation": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "context": "", "function_name": "def will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) ➞ True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015749"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49312225"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.49104327"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48984405"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.48983365"}]}
{"task_id": "humaneval_73", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n", "entry_point": "smallest_change", "gold_generation": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n", "context": "Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0", "function_name": "def smallest_change(arr):", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.71854746"}, {"id": "17643", "text": "Function: python.library.array#array.array.reverse\nSnippet: array.reverse() Reverse the order of the items in the array.", "score": "0.71706307"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.7130213"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.71042377"}, {"id": "42831", "text": "Function: numpy.reference.generated.numpy.fliplr\nSnippet: numpy.fliplr numpy.fliplr(m)[source] Reverse the order of elements along axis 1 (left/right). For a 2-D array, this flips the entries in each row in the left/right direction. Columns are preserved, but appear in a different order than before. Parameters marray_like Input array, must be at least 2-D. Returns fndarray A view of m with the columns reversed. Since a view is returned, this operation is \\(\\mathcal O(1)\\). See also flipud Flip array in the up/down direction. flip Flip array in one or more dimensions. rot90 Rotate array counterclockwise. Notes Equivalent to m[:,::-1] or np.flip(m, axis=1). Requires the array to be at least 2-D. Examples >>> A = np.diag([1.,2.,3.]) >>> A array([[1., 0., 0.], [0., 2., 0.], [0., 0., 3.]]) >>> np.fliplr(A) array([[0., 0., 1.], [0., 2., 0.], [3., 0., 0.]]) >>> A = np.random.randn(2,3,5) >>> np.all(np.fliplr(A) == A[:,::-1,...]) True", "score": "0.70288455"}]}
{"task_id": "humaneval_74", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n", "entry_point": "total_match", "gold_generation": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n", "context": "", "function_name": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) ➞ []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015749"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49312225"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.49104327"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48984405"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.48983365"}]}
{"task_id": "humaneval_75", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "entry_point": "is_multiply_prime", "gold_generation": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "context": "Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5", "function_name": "def is_multiply_prime(a):", "ctxs": [{"id": "19495", "text": "Function: python.library.decimal#decimal.Context.multiply\nSnippet: multiply(x, y) Return the product of x and y.", "score": "0.67285013"}, {"id": "14410", "text": "Function: pandas.reference.api.pandas.dataframe.multiply\nSnippet: 1.0 1.0 rectangle 1.0 1.0 B square 0.0 0.0 pentagon 0.0 0.0 hexagon 0.0 0.0", "score": "0.6683323"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6656405"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.64981997"}, {"id": "19474", "text": "Function: python.library.decimal#decimal.Context.is_finite\nSnippet: is_finite(x) Returns True if x is finite; otherwise returns False.", "score": "0.6491237"}]}
{"task_id": "humaneval_76", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "is_simple_power", "gold_generation": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n", "context": "Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false", "function_name": "def is_simple_power(x, n):", "ctxs": [{"id": "42052", "text": "Function: numpy.reference.generated.numpy.lib.scimath.power\nSnippet: numpy.lib.scimath.power lib.scimath.power(x, p)[source] Return x to the power p, (x**p). If x contains negative values, the output is converted to the complex domain. Parameters xarray_like The input value(s). parray_like of ints The power(s) to which x is raised. If x contains multiple values, p has to either be a scalar, or contain the same number of values as x. In the latter case, the result is x[0]**p[0], x[1]**p[1], .... Returns outndarray or scalar The result of x**p. If x and p are scalars, so is out, otherwise an array is returned. See also numpy.power Examples >>> np.set_printoptions(precision=4) >>> np.emath.power([2, 4], 2) array([ 4, 16]) >>> np.emath.power([2, 4], -2) array([0.25 , 0.0625]) >>> np.emath.power([-2, 4], 2) array([ 4.-0.j, 16.+0.j])", "score": "0.71227777"}, {"id": "21825", "text": "Function: python.library.math#math.pow\nSnippet: math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError. Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers.", "score": "0.70562524"}, {"id": "21810", "text": "Function: python.library.math#math.isinf\nSnippet: math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise.", "score": "0.70541555"}, {"id": "21776", "text": "Function: python.library.math\nSnippet: (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9. Note that frexp() and modf() have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 2**52 necessarily has no fractional bits. Power and logarithmic functions math.exp(x) Return e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). math.expm1(x) Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision: >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.0000050000069649e-05 >>> expm1(1e-5) # result accurate to full precision 1.0000050000166668e-05 New in version 3.2. math.log(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). math.log1p(x) Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. math.log2(x) Return the base-2 logarithm of x. This is usually more accurate than log(x, 2). New in version 3.3. See also int.bit_length() returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. math.log10(x) Return the base-10 logarithm of x. This is usually more accurate than log(x, 10). math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", "score": "0.7004436"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.6992619"}]}
{"task_id": "humaneval_77", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n", "entry_point": "iscube", "gold_generation": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n", "context": "", "function_name": "def iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015749"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49312225"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.49104327"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48984405"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.48983365"}]}
{"task_id": "humaneval_78", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n", "entry_point": "hex_key", "gold_generation": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n", "context": "You have been tasked to write a function that receives \n    a hexadecimal number as a string and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n    For num = \"AB\" the output should be 1.\n    For num = \"1077E\" the output should be 2.\n    For num = \"ABED1A33\" the output should be 4.\n    For num = \"123456789ABCDEF0\" the output should be 6.\n    For num = \"2020\" the output should be 2.", "function_name": "def hex_key(num):", "ctxs": [{"id": "25733", "text": "Function: python.library.stdtypes\nSnippet: ratio is exactly equal to the original float and with a positive denominator. Raises OverflowError on infinities and a ValueError on NaNs. float.is_integer() Return True if the float instance is finite with integral value, and False otherwise: >>> (-2.0).is_integer() True >>> (3.2).is_integer() False Two methods support conversion to and from hexadecimal strings. Since Python’s floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. float.hex() Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading 0x and a trailing p and exponent. classmethod float.fromhex(s) Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that float.hex() is an instance method, while float.fromhex() is a class method. A hexadecimal string takes the form: [sign] ['0x'] integer ['.' fraction] ['p' exponent] where the optional sign may by either + or -, integer and fraction are strings of hexadecimal digits, and exponent is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of float.hex() is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C’s %a format character or Java’s Double.toHexString are accepted by float.fromhex(). Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string 0x3.a7p10 represents the floating-point number (3 + 10./16 + 7./16**2) * 2.0**10, or 3740.0: >>> float.fromhex('0x3.a7p10') 3740.0 Applying the reverse conversion to 3740.0 gives a different hexadecimal string representing the same number: >>> float.hex(3740.0) '0x1.d380000000000p+11' Hashing of numeric types For numbers x and y, possibly of different types, it’s a requirement that hash(x) == hash(y) whenever x == y (see the __hash__() method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including int, float, decimal.Decimal and fractions.Fraction) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of int and fractions.Fraction, and all finite instances of float and decimal.Decimal. Essentially, this function is given by reduction modulo P for a fixed prime P. The value of P is made available to Python as the modulus attribute of sys.hash_info. CPython implementation detail: Currently, the prime used is P = 2**31 - 1 on machines with 32-bit C longs and P = 2**61 - 1 on machines with 64-bit C longs. Here are the rules", "score": "0.73408973"}, {"id": "20284", "text": "Function: python.library.functions\nSnippet: hexadecimal string prefixed with “0x”. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> hex(255) '0xff' >>> hex(-42) '-0x2a' If you want to convert an integer number to an uppercase or lower hexadecimal string with prefix or not, you can use either of the following ways: >>> '%#x' % 255, '%x' % 255, '%X' % 255 ('0xff', 'ff', 'FF') >>> format(255, '#x'), format(255, 'x'), format(255, 'X') ('0xff', 'ff', 'FF') >>> f'{255:#x}', f'{255:x}', f'{255:X}' ('0xff', 'ff', 'FF') See also format() for more information. See also int() for converting a hexadecimal string to an integer using a base of 16. Note To obtain a hexadecimal string representation for a float, use the float.hex() method. id(object) Return the “identity” of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value. CPython implementation detail: This is the address of the object in memory. Raises an auditing event builtins.id with argument id. input([prompt]) If the prompt argument is present, it is written to standard output without a trailing newline. The function then reads a line from input, converts it to a string (stripping a trailing newline), and returns that. When EOF is read, EOFError is raised. Example: >>> s = input('--> ') --> Monty Python's Flying Circus >>> s \"Monty Python's Flying Circus\" If the readline module was loaded, then input() will use it to provide elaborate line editing and history features. Raises an auditing event builtins.input with argument prompt before reading input Raises an auditing event builtins.input/result with the result after successfully reading input. class int([x]) class int(x, base=10) Return an integer object constructed from a number or string x, or return 0 if no arguments are given. If x defines __int__(), int(x) returns x.__int__(). If x defines __index__(), it returns x.__index__(). If x defines __trunc__(), it returns x.__trunc__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in radix base. Optionally, the literal can be preceded by + or - (with no space in between) and surrounded by whitespace. A base-n literal consists of the digits 0 to n-1, with a to z (or A to Z) having values 10 to 35. The default base is 10. The allowed values are 0 and 2–36. Base-2, -8, and -16 literals can be optionally prefixed with 0b/0B, 0o/0O, or 0x/0X, as with integer literals in code. Base 0 means to interpret exactly as a code literal, so that the actual base is 2, 8, 10, or 16, and so that int('010', 0) is not legal, while int('010') is, as well as int('010', 8). The integer type is described in Numeric Types — int, float, complex. Changed in version 3.4: If base is not an instance of int", "score": "0.7250512"}, {"id": "24414", "text": "Function: python.library.string#string.hexdigits\nSnippet: string.hexdigits The string '0123456789abcdefABCDEF'.", "score": "0.71486473"}, {"id": "20491", "text": "Function: python.library.functions#hex\nSnippet: hex(x) Convert an integer number to a lowercase hexadecimal string prefixed with “0x”. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> hex(255) '0xff' >>> hex(-42) '-0x2a' If you want to convert an integer number to an uppercase or lower hexadecimal string with prefix or not, you can use either of the following ways: >>> '%#x' % 255, '%x' % 255, '%X' % 255 ('0xff', 'ff', 'FF') >>> format(255, '#x'), format(255, 'x'), format(255, 'X') ('0xff', 'ff', 'FF') >>> f'{255:#x}', f'{255:x}', f'{255:X}' ('0xff', 'ff', 'FF') See also format() for more information. See also int() for converting a hexadecimal string to an integer using a base of 16. Note To obtain a hexadecimal string representation for a float, use the float.hex() method.", "score": "0.7135807"}, {"id": "15337", "text": "Function: pandas.reference.api.pandas.series.str.isdecimal\nSnippet: pandas.Series.str.isdecimal Series.str.isdecimal()[source] Check whether all characters in each string are decimal. This is equivalent to running the Python string method str.isdecimal() for each element of the Series/Index. If a string has zero characters, False is returned for that check. Returns Series or Index of bool Series or Index of boolean values with the same length as the original Series/Index. See also Series.str.isalpha Check whether all characters are alphabetic. Series.str.isnumeric Check whether all characters are numeric. Series.str.isalnum Check whether all characters are alphanumeric. Series.str.isdigit Check whether all characters are digits. Series.str.isdecimal Check whether all characters are decimal. Series.str.isspace Check whether all characters are whitespace. Series.str.islower Check whether all characters are lowercase. Series.str.isupper Check whether all characters are uppercase. Series.str.istitle Check whether all characters are titlecase. Examples Checks for Alphabetic and Numeric Characters >>> s1 = pd.Series(['one', 'one1', '1', '']) >>> s1.str.isalpha() 0 True 1 False 2 False 3 False dtype: bool >>> s1.str.isnumeric() 0 False 1 False 2 True 3 False dtype: bool >>> s1.str.isalnum() 0 True 1 True 2 True 3 False dtype: bool Note that checks against characters mixed with any additional punctuation or whitespace will evaluate to false for an alphanumeric check. >>> s2 = pd.Series(['A B', '1.5', '3,000']) >>> s2.str.isalnum() 0 False 1 False 2 False dtype: bool More Detailed Checks for Numeric Characters There are several different but overlapping sets of numeric characters that can be checked for. >>> s3 = pd.Series(['23', '³', '⅕', '']) The s3.str.isdecimal method checks for characters used to form numbers in base 10. >>> s3.str.isdecimal() 0 True 1 False 2 False 3 False dtype: bool The s.str.isdigit method is the same as s3.str.isdecimal but also includes special digits, like superscripted and subscripted digits in unicode. >>> s3.str.isdigit() 0 True 1 True 2 False 3 False dtype: bool The s.str.isnumeric method is the same as s3.str.isdigit but also includes other characters that can represent quantities such as unicode fractions. >>> s3.str.isnumeric() 0 True 1 True 2 True 3 False dtype: bool Checks for Whitespace >>> s4 = pd.Series([' ', '\\t\\r\\n ', '']) >>> s4.str.isspace() 0 True 1 True 2 False dtype: bool Checks for Character Case >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) >>> s5.str.islower() 0 True 1 False 2 False 3 False dtype: bool >>> s5.str.isupper() 0 False 1 False 2 True 3 False dtype: bool The s5.str.istitle method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters. >>> s5.str.istitle() 0 False 1 True 2 False 3 False dtype: bool", "score": "0.71091163"}]}
{"task_id": "humaneval_79", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "decimal_to_binary", "gold_generation": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "context": "You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"", "function_name": "def decimal_to_binary(decimal):", "ctxs": [{"id": "18215", "text": "Function: python.library.functions#bin\nSnippet: bin(x) Convert an integer number to a binary string prefixed with “0b”. The result is a valid Python expression. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> bin(3) '0b11' >>> bin(-10) '-0b1010' If prefix “0b” is desired or not, you can use either of the following ways. >>> format(14, '#b'), format(14, 'b') ('0b1110', '1110') >>> f'{14:#b}', f'{14:b}' ('0b1110', '1110') See also format() for more information.", "score": "0.7956003"}, {"id": "19516", "text": "Function: python.library.decimal#decimal.Decimal\nSnippet: class decimal.Decimal(value=\"0\", context=None) Construct a new Decimal object based from value. value can be an integer, string, tuple, float, or another Decimal object. If no value is given, returns Decimal('0'). If value is a string, it should conform to the decimal numeric string syntax after leading and trailing whitespace characters, as well as underscores throughout, are removed: sign ::= '+' | '-' digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' indicator ::= 'e' | 'E' digits ::= digit [digit]... decimal-part ::= digits '.' [digits] | ['.'] digits exponent-part ::= indicator [sign] digits infinity ::= 'Infinity' | 'Inf' nan ::= 'NaN' [digits] | 'sNaN' [digits] numeric-value ::= decimal-part [exponent-part] | infinity numeric-string ::= [sign] numeric-value | [sign] nan Other Unicode decimal digits are also permitted where digit appears above. These include decimal digits from various other alphabets (for example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits '\\uff10' through '\\uff19'. If value is a tuple, it should have three components, a sign (0 for positive or 1 for negative), a tuple of digits, and an integer exponent. For example, Decimal((0, (1, 4, 1, 4), -3)) returns Decimal('1.414'). If value is a float, the binary floating point value is losslessly converted to its exact decimal equivalent. This conversion can often require 53 or more digits of precision. For example, Decimal(float('1.1')) converts to Decimal('1.100000000000000088817841970012523233890533447265625'). The context precision does not affect how many digits are stored. That is determined exclusively by the number of digits in value. For example, Decimal('3.00000') records all five zeros even if the context precision is only three. The purpose of the context argument is determining what to do if value is a malformed string. If the context traps InvalidOperation, an exception is raised; otherwise, the constructor returns a new Decimal with the value of NaN. Once constructed, Decimal objects are immutable. Changed in version 3.2: The argument to the constructor is now permitted to be a float instance. Changed in version 3.3: float arguments raise an exception if the FloatOperation trap is set. By default the trap is off. Changed in version 3.6: Underscores are allowed for grouping, as with integral and floating-point literals in code. Decimal floating point objects share many properties with the other built-in numeric types such as float and int. All of the usual math operations and special methods apply. Likewise, decimal objects can be copied, pickled, printed, used as dictionary keys, used as set elements, compared, sorted, and coerced to another type (such as float or int). There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator % is applied to Decimal objects, the sign of the result is the sign of the dividend rather than the sign of the divisor: >>> (-7) % 4 1 >>> Decimal(-7) % Decimal(4) Decimal('-3') The integer division operator // behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather", "score": "0.78678304"}, {"id": "19536", "text": "Function: python.library.decimal#decimal.Decimal.from_float\nSnippet: from_float(f) Classmethod that converts a float to a decimal number, exactly. Note Decimal.from_float(0.1) is not the same as Decimal(‘0.1’). Since 0.1 is not exactly representable in binary floating point, the value is stored as the nearest representable value which is 0x1.999999999999ap-4. That equivalent value in decimal is 0.1000000000000000055511151231257827021181583404541015625. Note From Python 3.2 onwards, a Decimal instance can also be constructed directly from a float. >>> Decimal.from_float(0.1) Decimal('0.1000000000000000055511151231257827021181583404541015625') >>> Decimal.from_float(float('nan')) Decimal('NaN') >>> Decimal.from_float(float('inf')) Decimal('Infinity') >>> Decimal.from_float(float('-inf')) Decimal('-Infinity') New in version 3.1.", "score": "0.76450276"}, {"id": "19428", "text": "Function: python.library.decimal\nSnippet: where digit appears above. These include decimal digits from various other alphabets (for example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits '\\uff10' through '\\uff19'. If value is a tuple, it should have three components, a sign (0 for positive or 1 for negative), a tuple of digits, and an integer exponent. For example, Decimal((0, (1, 4, 1, 4), -3)) returns Decimal('1.414'). If value is a float, the binary floating point value is losslessly converted to its exact decimal equivalent. This conversion can often require 53 or more digits of precision. For example, Decimal(float('1.1')) converts to Decimal('1.100000000000000088817841970012523233890533447265625'). The context precision does not affect how many digits are stored. That is determined exclusively by the number of digits in value. For example, Decimal('3.00000') records all five zeros even if the context precision is only three. The purpose of the context argument is determining what to do if value is a malformed string. If the context traps InvalidOperation, an exception is raised; otherwise, the constructor returns a new Decimal with the value of NaN. Once constructed, Decimal objects are immutable. Changed in version 3.2: The argument to the constructor is now permitted to be a float instance. Changed in version 3.3: float arguments raise an exception if the FloatOperation trap is set. By default the trap is off. Changed in version 3.6: Underscores are allowed for grouping, as with integral and floating-point literals in code. Decimal floating point objects share many properties with the other built-in numeric types such as float and int. All of the usual math operations and special methods apply. Likewise, decimal objects can be copied, pickled, printed, used as dictionary keys, used as set elements, compared, sorted, and coerced to another type (such as float or int). There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator % is applied to Decimal objects, the sign of the result is the sign of the dividend rather than the sign of the divisor: >>> (-7) % 4 1 >>> Decimal(-7) % Decimal(4) Decimal('-3') The integer division operator // behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather than its floor, so as to preserve the usual identity x == (x // y) * y + x % y: >>> -7 // 4 -2 >>> Decimal(-7) // Decimal(4) Decimal('-1') The % and // operators implement the remainder and divide-integer operations (respectively) as described in the specification. Decimal objects cannot generally be combined with floats or instances of fractions.Fraction in arithmetic operations: an attempt to add a Decimal to a float, for example, will raise a TypeError. However, it is possible to use Python’s comparison operators to compare a Decimal instance x with another number y. This avoids confusing results when doing equality comparisons between numbers of different types. Changed in version 3.2: Mixed-type comparisons between Decimal instances and other numeric types are now fully supported. In addition to the standard numeric properties, decimal floating point", "score": "0.7602007"}, {"id": "24353", "text": "Function: python.library.stdtypes#str.isdecimal\nSnippet: str.isdecimal() Return True if all characters in the string are decimal characters and there is at least one character, False otherwise. Decimal characters are those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT ZERO. Formally a decimal character is a character in the Unicode General Category “Nd”.", "score": "0.75385803"}]}
{"task_id": "humaneval_80", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "entry_point": "is_happy", "gold_generation": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "context": "You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False", "function_name": "def is_happy(s):", "ctxs": [{"id": "41662", "text": "Function: numpy.reference.generated.numpy.char.chararray.isalpha\nSnippet: numpy.char.chararray.isalpha method char.chararray.isalpha()[source] Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. See also char.isalpha", "score": "0.6841737"}, {"id": "41785", "text": "Function: numpy.reference.generated.numpy.chararray.isalpha\nSnippet: numpy.chararray.isalpha method chararray.isalpha()[source] Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. See also char.isalpha", "score": "0.68371737"}, {"id": "15343", "text": "Function: pandas.reference.api.pandas.series.str.isupper\nSnippet: pandas.Series.str.isupper Series.str.isupper()[source] Check whether all characters in each string are uppercase. This is equivalent to running the Python string method str.isupper() for each element of the Series/Index. If a string has zero characters, False is returned for that check. Returns Series or Index of bool Series or Index of boolean values with the same length as the original Series/Index. See also Series.str.isalpha Check whether all characters are alphabetic. Series.str.isnumeric Check whether all characters are numeric. Series.str.isalnum Check whether all characters are alphanumeric. Series.str.isdigit Check whether all characters are digits. Series.str.isdecimal Check whether all characters are decimal. Series.str.isspace Check whether all characters are whitespace. Series.str.islower Check whether all characters are lowercase. Series.str.isupper Check whether all characters are uppercase. Series.str.istitle Check whether all characters are titlecase. Examples Checks for Alphabetic and Numeric Characters >>> s1 = pd.Series(['one', 'one1', '1', '']) >>> s1.str.isalpha() 0 True 1 False 2 False 3 False dtype: bool >>> s1.str.isnumeric() 0 False 1 False 2 True 3 False dtype: bool >>> s1.str.isalnum() 0 True 1 True 2 True 3 False dtype: bool Note that checks against characters mixed with any additional punctuation or whitespace will evaluate to false for an alphanumeric check. >>> s2 = pd.Series(['A B', '1.5', '3,000']) >>> s2.str.isalnum() 0 False 1 False 2 False dtype: bool More Detailed Checks for Numeric Characters There are several different but overlapping sets of numeric characters that can be checked for. >>> s3 = pd.Series(['23', '³', '⅕', '']) The s3.str.isdecimal method checks for characters used to form numbers in base 10. >>> s3.str.isdecimal() 0 True 1 False 2 False 3 False dtype: bool The s.str.isdigit method is the same as s3.str.isdecimal but also includes special digits, like superscripted and subscripted digits in unicode. >>> s3.str.isdigit() 0 True 1 True 2 False 3 False dtype: bool The s.str.isnumeric method is the same as s3.str.isdigit but also includes other characters that can represent quantities such as unicode fractions. >>> s3.str.isnumeric() 0 True 1 True 2 True 3 False dtype: bool Checks for Whitespace >>> s4 = pd.Series([' ', '\\t\\r\\n ', '']) >>> s4.str.isspace() 0 True 1 True 2 False dtype: bool Checks for Character Case >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) >>> s5.str.islower() 0 True 1 False 2 False 3 False dtype: bool >>> s5.str.isupper() 0 False 1 False 2 True 3 False dtype: bool The s5.str.istitle method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters. >>> s5.str.istitle() 0 False 1 True 2 False 3 False dtype: bool", "score": "0.6827799"}, {"id": "41729", "text": "Function: numpy.reference.generated.numpy.char.isalpha\nSnippet: numpy.char.isalpha char.isalpha(a)[source] Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. Calls str.isalpha element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like of str or unicode Returns outndarray Output array of bools See also str.isalpha", "score": "0.6822122"}, {"id": "15338", "text": "Function: pandas.reference.api.pandas.series.str.isdigit\nSnippet: pandas.Series.str.isdigit Series.str.isdigit()[source] Check whether all characters in each string are digits. This is equivalent to running the Python string method str.isdigit() for each element of the Series/Index. If a string has zero characters, False is returned for that check. Returns Series or Index of bool Series or Index of boolean values with the same length as the original Series/Index. See also Series.str.isalpha Check whether all characters are alphabetic. Series.str.isnumeric Check whether all characters are numeric. Series.str.isalnum Check whether all characters are alphanumeric. Series.str.isdigit Check whether all characters are digits. Series.str.isdecimal Check whether all characters are decimal. Series.str.isspace Check whether all characters are whitespace. Series.str.islower Check whether all characters are lowercase. Series.str.isupper Check whether all characters are uppercase. Series.str.istitle Check whether all characters are titlecase. Examples Checks for Alphabetic and Numeric Characters >>> s1 = pd.Series(['one', 'one1', '1', '']) >>> s1.str.isalpha() 0 True 1 False 2 False 3 False dtype: bool >>> s1.str.isnumeric() 0 False 1 False 2 True 3 False dtype: bool >>> s1.str.isalnum() 0 True 1 True 2 True 3 False dtype: bool Note that checks against characters mixed with any additional punctuation or whitespace will evaluate to false for an alphanumeric check. >>> s2 = pd.Series(['A B', '1.5', '3,000']) >>> s2.str.isalnum() 0 False 1 False 2 False dtype: bool More Detailed Checks for Numeric Characters There are several different but overlapping sets of numeric characters that can be checked for. >>> s3 = pd.Series(['23', '³', '⅕', '']) The s3.str.isdecimal method checks for characters used to form numbers in base 10. >>> s3.str.isdecimal() 0 True 1 False 2 False 3 False dtype: bool The s.str.isdigit method is the same as s3.str.isdecimal but also includes special digits, like superscripted and subscripted digits in unicode. >>> s3.str.isdigit() 0 True 1 True 2 False 3 False dtype: bool The s.str.isnumeric method is the same as s3.str.isdigit but also includes other characters that can represent quantities such as unicode fractions. >>> s3.str.isnumeric() 0 True 1 True 2 True 3 False dtype: bool Checks for Whitespace >>> s4 = pd.Series([' ', '\\t\\r\\n ', '']) >>> s4.str.isspace() 0 True 1 True 2 False dtype: bool Checks for Character Case >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) >>> s5.str.islower() 0 True 1 False 2 False 3 False dtype: bool >>> s5.str.isupper() 0 False 1 False 2 True 3 False dtype: bool The s5.str.istitle method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters. >>> s5.str.istitle() 0 False 1 True 2 False 3 False dtype: bool", "score": "0.6799279"}]}
{"task_id": "humaneval_81", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "numerical_letter_grade", "gold_generation": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "context": "It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']", "function_name": "def numerical_letter_grade(grades):", "ctxs": [{"id": "18242", "text": "Function: python.library.bisect\nSnippet: a[i] raise ValueError def find_ge(a, x): 'Find leftmost item greater than or equal to x' i = bisect_left(a, x) if i != len(a): return a[i] raise ValueError Other Examples The bisect() function can be useful for numeric table lookups. This example uses bisect() to look up a letter grade for an exam score (say) based on a set of ordered numeric breakpoints: 90 and up is an ‘A’, 80 to 89 is a ‘B’, and so on: >>> def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'): ... i = bisect(breakpoints, score) ... return grades[i] ... >>> [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]] ['F', 'A', 'C', 'C', 'B', 'A', 'A'] Unlike the sorted() function, it does not make sense for the bisect() functions to have key or reversed arguments because that would lead to an inefficient design (successive calls to bisect functions would not “remember” all of the previous key lookups). Instead, it is better to search a list of precomputed keys to find the index of the record in question: >>> data = [('red', 5), ('blue', 1), ('yellow', 8), ('black', 0)] >>> data.sort(key=lambda r: r[1]) >>> keys = [r[1] for r in data] # precomputed list of keys >>> data[bisect_left(keys, 0)] ('black', 0) >>> data[bisect_left(keys, 1)] ('blue', 1) >>> data[bisect_left(keys, 5)] ('red', 5) >>> data[bisect_left(keys, 8)] ('yellow', 8)", "score": "0.73022866"}, {"id": "13926", "text": "Function: pandas.user_guide.cookbook\nSnippet: \"II\"])) In [88]: indx = pd.MultiIndex.from_tuples(index, names=[\"Student\", \"Course\"]) In [89]: cols = pd.MultiIndex.from_tuples(headr) # Notice these are un-named In [90]: data = [[70 + x + y + (x * y) % 3 for x in range(4)] for y in range(9)] In [91]: df = pd.DataFrame(data, indx, cols) In [92]: df Out[92]: Exams Labs I II I II Student Course Ada Comp 70 71 72 73 Math 71 73 75 74 Sci 72 75 75 75 Quinn Comp 73 74 75 76 Math 74 76 78 77 Sci 75 78 78 78 Violet Comp 76 77 78 79 Math 77 79 81 80 Sci 78 81 81 81 In [93]: All = slice(None) In [94]: df.loc[\"Violet\"] Out[94]: Exams Labs I II I II Course Comp 76 77 78 79 Math 77 79 81 80 Sci 78 81 81 81 In [95]: df.loc[(All, \"Math\"), All] Out[95]: Exams Labs I II I II Student Course Ada Math 71 73 75 74 Quinn Math 74 76 78 77 Violet Math 77 79 81 80 In [96]: df.loc[(slice(\"Ada\", \"Quinn\"), \"Math\"), All] Out[96]: Exams Labs I II I II Student Course Ada Math 71 73 75 74 Quinn Math 74 76 78 77 In [97]: df.loc[(All, \"Math\"), (\"Exams\")] Out[97]: I II Student Course Ada Math 71 73 Quinn Math 74 76 Violet Math 77 79 In [98]: df.loc[(All, \"Math\"), (All, \"II\")] Out[98]: Exams Labs II II Student Course Ada Math 73 74 Quinn Math 76 77 Violet Math 79 80 Setting portions of a MultiIndex with xs Sorting Sort by specific column or an ordered list of columns, with a MultiIndex In [99]: df.sort_values(by=(\"Labs\", \"II\"), ascending=False) Out[99]: Exams Labs I II I II Student Course Violet Sci 78 81 81 81 Math 77 79 81 80 Comp 76 77 78 79 Quinn Sci 75 78 78 78 Math 74 76 78 77 Comp 73 74 75 76 Ada Sci 72 75 75 75 Math 71 73 75 74 Comp 70 71 72 73 Partial selection, the need for sortedness GH2995 Levels Prepending a level to a multiindex Flatten Hierarchical columns Missing data The missing data docs. Fill forward a reversed timeseries In [100]: df = pd.DataFrame( .....: np.random.randn(6, 1), .....: index=pd.date_range(\"2013-08-01\", periods=6, freq=\"B\"), .....: columns=list(\"A\"), .....: ) .....: In [101]: df.loc[df.index[3], \"A\"] = np.nan In [102]: df Out[102]: A 2013-08-01 0.721555 2013-08-02 -0.706771 2013-08-05 -1.039575 2013-08-06 NaN 2013-08-07 -0.424972 2013-08-08 0.567020 In [103]: df.reindex(df.index[::-1]).ffill() Out[103]: A 2013-08-08 0.567020 2013-08-07 -0.424972 2013-08-06 -0.424972 2013-08-05 -1.039575 2013-08-02 -0.706771 2013-08-01 0.721555 cumsum reset at NaN values Replace Using replace with backrefs Grouping The grouping docs. Basic grouping with apply Unlike agg, apply’s callable is passed a sub-DataFrame which gives you access to all the columns In [104]: df = pd.DataFrame( .....: { .....: \"animal\": \"cat dog cat fish dog cat cat\".split(), .....: \"size\": list(\"SSMMMLL\"), .....: \"weight\": [8, 10, 11, 1, 20, 12, 12], .....: \"adult\": [False] * 5 + [True] * 2, .....: } .....: ) .....: In [105]: df Out[105]: animal size weight adult 0 cat S", "score": "0.70791715"}, {"id": "13929", "text": "Function: pandas.user_guide.cookbook\nSnippet: 8, 4, 3, 1], .....: } .....: ) .....: In [152]: table = pd.pivot_table( .....: df, .....: values=[\"Sales\"], .....: index=[\"Province\"], .....: columns=[\"City\"], .....: aggfunc=np.sum, .....: margins=True, .....: ) .....: In [153]: table.stack(\"City\") Out[153]: Sales Province City AL All 12.0 Calgary 8.0 Edmonton 4.0 BC All 16.0 Vancouver 16.0 ... ... All Montreal 6.0 Toronto 13.0 Vancouver 16.0 Windsor 1.0 Winnipeg 3.0 [20 rows x 1 columns] Frequency table like plyr in R In [154]: grades = [48, 99, 75, 80, 42, 80, 72, 68, 36, 78] In [155]: df = pd.DataFrame( .....: { .....: \"ID\": [\"x%d\" % r for r in range(10)], .....: \"Gender\": [\"F\", \"M\", \"F\", \"M\", \"F\", \"M\", \"F\", \"M\", \"M\", \"M\"], .....: \"ExamYear\": [ .....: \"2007\", .....: \"2007\", .....: \"2007\", .....: \"2008\", .....: \"2008\", .....: \"2008\", .....: \"2008\", .....: \"2009\", .....: \"2009\", .....: \"2009\", .....: ], .....: \"Class\": [ .....: \"algebra\", .....: \"stats\", .....: \"bio\", .....: \"algebra\", .....: \"algebra\", .....: \"stats\", .....: \"stats\", .....: \"algebra\", .....: \"bio\", .....: \"bio\", .....: ], .....: \"Participated\": [ .....: \"yes\", .....: \"yes\", .....: \"yes\", .....: \"yes\", .....: \"no\", .....: \"yes\", .....: \"yes\", .....: \"yes\", .....: \"yes\", .....: \"yes\", .....: ], .....: \"Passed\": [\"yes\" if x > 50 else \"no\" for x in grades], .....: \"Employed\": [ .....: True, .....: True, .....: True, .....: False, .....: False, .....: False, .....: False, .....: True, .....: True, .....: False, .....: ], .....: \"Grade\": grades, .....: } .....: ) .....: In [156]: df.groupby(\"ExamYear\").agg( .....: { .....: \"Participated\": lambda x: x.value_counts()[\"yes\"], .....: \"Passed\": lambda x: sum(x == \"yes\"), .....: \"Employed\": lambda x: sum(x), .....: \"Grade\": lambda x: sum(x) / len(x), .....: } .....: ) .....: Out[156]: Participated Passed Employed Grade ExamYear 2007 3 2 3 74.000000 2008 3 3 0 68.500000 2009 3 2 2 60.666667 Plot pandas DataFrame with year over year data To create year and month cross tabulation: In [157]: df = pd.DataFrame( .....: {\"value\": np.random.randn(36)}, .....: index=pd.date_range(\"2011-01-01\", freq=\"M\", periods=36), .....: ) .....: In [158]: pd.pivot_table( .....: df, index=df.index.month, columns=df.index.year, values=\"value\", aggfunc=\"sum\" .....: ) .....: Out[158]: 2011 2012 2013 1 -1.039268 -0.968914 2.565646 2 -0.370647 -1.294524 1.431256 3 -1.157892 0.413738 1.340309 4 -1.344312 0.276662 -1.170299 5 0.844885 -0.472035 -0.226169 6 1.075770 -0.013960 0.410835 7 -0.109050 -0.362543 0.813850 8 1.643563 -0.006154 0.132003 9 -1.469388 -0.923061 -0.827317 10 0.357021 0.895717 -0.076467 11 -0.674600 0.805244 -1.187678 12 -1.776904 -1.206412 1.130127 Apply Rolling apply to organize - Turning embedded lists into a MultiIndex frame In [159]: df = pd.DataFrame( .....: data={ .....: \"A\": [[2, 4, 8, 16], [100, 200], [10, 20, 30]], .....: \"B\": [[\"a\", \"b\", \"c\"], [\"jj\", \"kk\"], [\"ccc\"]], .....: }, .....: index=[\"I\", \"II\", \"III\"], .....: ) .....: In [160]: def SeriesFromSubList(aList): .....: return pd.Series(aList) .....: In [161]: df_orgz = pd.concat( .....: {ind: row.apply(SeriesFromSubList) for ind, row in df.iterrows()} .....: ) .....: In [162]: df_orgz Out[162]: 0 1 2 3 I A 2 4 8 16.0 B a b c NaN II A 100 200 NaN NaN B jj kk NaN NaN III A 10 20.0 30.0 NaN B ccc NaN NaN NaN Rolling apply with", "score": "0.6914775"}, {"id": "13923", "text": "Function: pandas.user_guide.cookbook\nSnippet: 2 6 30 -30 3 7 40 -50 Building criteria Select with multi-column criteria In [19]: df = pd.DataFrame( ....: {\"AAA\": [4, 5, 6, 7], \"BBB\": [10, 20, 30, 40], \"CCC\": [100, 50, -30, -50]} ....: ) ....: In [20]: df Out[20]: AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 …and (without assignment returns a Series) In [21]: df.loc[(df[\"BBB\"] < 25) & (df[\"CCC\"] >= -40), \"AAA\"] Out[21]: 0 4 1 5 Name: AAA, dtype: int64 …or (without assignment returns a Series) In [22]: df.loc[(df[\"BBB\"] > 25) | (df[\"CCC\"] >= -40), \"AAA\"] Out[22]: 0 4 1 5 2 6 3 7 Name: AAA, dtype: int64 …or (with assignment modifies the DataFrame.) In [23]: df.loc[(df[\"BBB\"] > 25) | (df[\"CCC\"] >= 75), \"AAA\"] = 0.1 In [24]: df Out[24]: AAA BBB CCC 0 0.1 10 100 1 5.0 20 50 2 0.1 30 -30 3 0.1 40 -50 Select rows with data closest to certain value using argsort In [25]: df = pd.DataFrame( ....: {\"AAA\": [4, 5, 6, 7], \"BBB\": [10, 20, 30, 40], \"CCC\": [100, 50, -30, -50]} ....: ) ....: In [26]: df Out[26]: AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 In [27]: aValue = 43.0 In [28]: df.loc[(df.CCC - aValue).abs().argsort()] Out[28]: AAA BBB CCC 1 5 20 50 0 4 10 100 2 6 30 -30 3 7 40 -50 Dynamically reduce a list of criteria using a binary operators In [29]: df = pd.DataFrame( ....: {\"AAA\": [4, 5, 6, 7], \"BBB\": [10, 20, 30, 40], \"CCC\": [100, 50, -30, -50]} ....: ) ....: In [30]: df Out[30]: AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 In [31]: Crit1 = df.AAA <= 5.5 In [32]: Crit2 = df.BBB == 10.0 In [33]: Crit3 = df.CCC > -40.0 One could hard code: In [34]: AllCrit = Crit1 & Crit2 & Crit3 …Or it can be done with a list of dynamically built criteria In [35]: import functools In [36]: CritList = [Crit1, Crit2, Crit3] In [37]: AllCrit = functools.reduce(lambda x, y: x & y, CritList) In [38]: df[AllCrit] Out[38]: AAA BBB CCC 0 4 10 100 Selection Dataframes The indexing docs. Using both row labels and value conditionals In [39]: df = pd.DataFrame( ....: {\"AAA\": [4, 5, 6, 7], \"BBB\": [10, 20, 30, 40], \"CCC\": [100, 50, -30, -50]} ....: ) ....: In [40]: df Out[40]: AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 In [41]: df[(df.AAA <= 6) & (df.index.isin([0, 2, 4]))] Out[41]: AAA BBB CCC 0 4 10 100 2 6 30 -30 Use loc for label-oriented slicing and iloc positional slicing GH2904 In [42]: df = pd.DataFrame( ....: {\"AAA\": [4, 5, 6, 7], \"BBB\": [10, 20, 30, 40], \"CCC\": [100, 50, -30, -50]}, ....: index=[\"foo\", \"bar\", \"boo\", \"kar\"], ....: ) ....: There are", "score": "0.6719059"}, {"id": "43082", "text": "Function: numpy.reference.generated.numpy.percentile\nSnippet: as the maximum if q=100. This optional method parameter specifies the method to use when the desired quantile lies between two data points i < j. If g is the fractional part of the index surrounded by i and alpha and beta are correction constants modifying i and j. Below, ‘q’ is the quantile value, ‘n’ is the sample size and alpha and beta are constants. The following formula gives an interpolation “i + g” of where the quantile would be in the sorted sample. With ‘i’ being the floor and ‘g’ the fractional part of the result. \\[i + g = (q - alpha) / ( n - alpha - beta + 1 )\\] The different methods then work as follows inverted_cdf: method 1 of H&F [1]. This method gives discontinuous results: * if g > 0 ; then take j * if g = 0 ; then take i averaged_inverted_cdf: method 2 of H&F [1]. This method give discontinuous results: * if g > 0 ; then take j * if g = 0 ; then average between bounds closest_observation: method 3 of H&F [1]. This method give discontinuous results: * if g > 0 ; then take j * if g = 0 and index is odd ; then take j * if g = 0 and index is even ; then take i interpolated_inverted_cdf: method 4 of H&F [1]. This method give continuous results using: * alpha = 0 * beta = 1 hazen: method 5 of H&F [1]. This method give continuous results using: * alpha = 1/2 * beta = 1/2 weibull: method 6 of H&F [1]. This method give continuous results using: * alpha = 0 * beta = 0 linear: method 7 of H&F [1]. This method give continuous results using: * alpha = 1 * beta = 1 median_unbiased: method 8 of H&F [1]. This method is probably the best method if the sample distribution function is unknown (see reference). This method give continuous results using: * alpha = 1/3 * beta = 1/3 normal_unbiased: method 9 of H&F [1]. This method is probably the best method if the sample distribution function is known to be normal. This method give continuous results using: * alpha = 3/8 * beta = 3/8 lower: NumPy method kept for backwards compatibility. Takes i as the interpolation point. higher: NumPy method kept for backwards compatibility. Takes j as the interpolation point. nearest: NumPy method kept for backwards compatibility. Takes i or j, whichever is nearest. midpoint: NumPy method kept for backwards compatibility. Uses (i + j) / 2. References 1(1,2,3,4,5,6,7,8,9,10) R. J. Hyndman and Y. Fan, “Sample quantiles in statistical packages,” The American Statistician, 50(4), pp. 361-365, 1996 Examples >>> a = np.array([[10, 7, 4], [3, 2, 1]]) >>> a array([[10, 7, 4], [ 3, 2, 1]]) >>> np.percentile(a, 50) 3.5 >>> np.percentile(a, 50, axis=0) array([6.5, 4.5, 2.5]) >>> np.percentile(a, 50, axis=1) array([7., 2.]) >>> np.percentile(a, 50, axis=1, keepdims=True) array([[7.], [2.]]) >>> m = np.percentile(a,", "score": "0.67141753"}]}
{"task_id": "humaneval_82", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "entry_point": "prime_length", "gold_generation": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "context": "Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise\n    Examples\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False", "function_name": "def prime_length(string):", "ctxs": [{"id": "15338", "text": "Function: pandas.reference.api.pandas.series.str.isdigit\nSnippet: pandas.Series.str.isdigit Series.str.isdigit()[source] Check whether all characters in each string are digits. This is equivalent to running the Python string method str.isdigit() for each element of the Series/Index. If a string has zero characters, False is returned for that check. Returns Series or Index of bool Series or Index of boolean values with the same length as the original Series/Index. See also Series.str.isalpha Check whether all characters are alphabetic. Series.str.isnumeric Check whether all characters are numeric. Series.str.isalnum Check whether all characters are alphanumeric. Series.str.isdigit Check whether all characters are digits. Series.str.isdecimal Check whether all characters are decimal. Series.str.isspace Check whether all characters are whitespace. Series.str.islower Check whether all characters are lowercase. Series.str.isupper Check whether all characters are uppercase. Series.str.istitle Check whether all characters are titlecase. Examples Checks for Alphabetic and Numeric Characters >>> s1 = pd.Series(['one', 'one1', '1', '']) >>> s1.str.isalpha() 0 True 1 False 2 False 3 False dtype: bool >>> s1.str.isnumeric() 0 False 1 False 2 True 3 False dtype: bool >>> s1.str.isalnum() 0 True 1 True 2 True 3 False dtype: bool Note that checks against characters mixed with any additional punctuation or whitespace will evaluate to false for an alphanumeric check. >>> s2 = pd.Series(['A B', '1.5', '3,000']) >>> s2.str.isalnum() 0 False 1 False 2 False dtype: bool More Detailed Checks for Numeric Characters There are several different but overlapping sets of numeric characters that can be checked for. >>> s3 = pd.Series(['23', '³', '⅕', '']) The s3.str.isdecimal method checks for characters used to form numbers in base 10. >>> s3.str.isdecimal() 0 True 1 False 2 False 3 False dtype: bool The s.str.isdigit method is the same as s3.str.isdecimal but also includes special digits, like superscripted and subscripted digits in unicode. >>> s3.str.isdigit() 0 True 1 True 2 False 3 False dtype: bool The s.str.isnumeric method is the same as s3.str.isdigit but also includes other characters that can represent quantities such as unicode fractions. >>> s3.str.isnumeric() 0 True 1 True 2 True 3 False dtype: bool Checks for Whitespace >>> s4 = pd.Series([' ', '\\t\\r\\n ', '']) >>> s4.str.isspace() 0 True 1 True 2 False dtype: bool Checks for Character Case >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) >>> s5.str.islower() 0 True 1 False 2 False 3 False dtype: bool >>> s5.str.isupper() 0 False 1 False 2 True 3 False dtype: bool The s5.str.istitle method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters. >>> s5.str.istitle() 0 False 1 True 2 False 3 False dtype: bool", "score": "0.7218656"}, {"id": "15340", "text": "Function: pandas.reference.api.pandas.series.str.isnumeric\nSnippet: pandas.Series.str.isnumeric Series.str.isnumeric()[source] Check whether all characters in each string are numeric. This is equivalent to running the Python string method str.isnumeric() for each element of the Series/Index. If a string has zero characters, False is returned for that check. Returns Series or Index of bool Series or Index of boolean values with the same length as the original Series/Index. See also Series.str.isalpha Check whether all characters are alphabetic. Series.str.isnumeric Check whether all characters are numeric. Series.str.isalnum Check whether all characters are alphanumeric. Series.str.isdigit Check whether all characters are digits. Series.str.isdecimal Check whether all characters are decimal. Series.str.isspace Check whether all characters are whitespace. Series.str.islower Check whether all characters are lowercase. Series.str.isupper Check whether all characters are uppercase. Series.str.istitle Check whether all characters are titlecase. Examples Checks for Alphabetic and Numeric Characters >>> s1 = pd.Series(['one', 'one1', '1', '']) >>> s1.str.isalpha() 0 True 1 False 2 False 3 False dtype: bool >>> s1.str.isnumeric() 0 False 1 False 2 True 3 False dtype: bool >>> s1.str.isalnum() 0 True 1 True 2 True 3 False dtype: bool Note that checks against characters mixed with any additional punctuation or whitespace will evaluate to false for an alphanumeric check. >>> s2 = pd.Series(['A B', '1.5', '3,000']) >>> s2.str.isalnum() 0 False 1 False 2 False dtype: bool More Detailed Checks for Numeric Characters There are several different but overlapping sets of numeric characters that can be checked for. >>> s3 = pd.Series(['23', '³', '⅕', '']) The s3.str.isdecimal method checks for characters used to form numbers in base 10. >>> s3.str.isdecimal() 0 True 1 False 2 False 3 False dtype: bool The s.str.isdigit method is the same as s3.str.isdecimal but also includes special digits, like superscripted and subscripted digits in unicode. >>> s3.str.isdigit() 0 True 1 True 2 False 3 False dtype: bool The s.str.isnumeric method is the same as s3.str.isdigit but also includes other characters that can represent quantities such as unicode fractions. >>> s3.str.isnumeric() 0 True 1 True 2 True 3 False dtype: bool Checks for Whitespace >>> s4 = pd.Series([' ', '\\t\\r\\n ', '']) >>> s4.str.isspace() 0 True 1 True 2 False dtype: bool Checks for Character Case >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) >>> s5.str.islower() 0 True 1 False 2 False 3 False dtype: bool >>> s5.str.isupper() 0 False 1 False 2 True 3 False dtype: bool The s5.str.istitle method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters. >>> s5.str.istitle() 0 False 1 True 2 False 3 False dtype: bool", "score": "0.71613467"}, {"id": "15337", "text": "Function: pandas.reference.api.pandas.series.str.isdecimal\nSnippet: pandas.Series.str.isdecimal Series.str.isdecimal()[source] Check whether all characters in each string are decimal. This is equivalent to running the Python string method str.isdecimal() for each element of the Series/Index. If a string has zero characters, False is returned for that check. Returns Series or Index of bool Series or Index of boolean values with the same length as the original Series/Index. See also Series.str.isalpha Check whether all characters are alphabetic. Series.str.isnumeric Check whether all characters are numeric. Series.str.isalnum Check whether all characters are alphanumeric. Series.str.isdigit Check whether all characters are digits. Series.str.isdecimal Check whether all characters are decimal. Series.str.isspace Check whether all characters are whitespace. Series.str.islower Check whether all characters are lowercase. Series.str.isupper Check whether all characters are uppercase. Series.str.istitle Check whether all characters are titlecase. Examples Checks for Alphabetic and Numeric Characters >>> s1 = pd.Series(['one', 'one1', '1', '']) >>> s1.str.isalpha() 0 True 1 False 2 False 3 False dtype: bool >>> s1.str.isnumeric() 0 False 1 False 2 True 3 False dtype: bool >>> s1.str.isalnum() 0 True 1 True 2 True 3 False dtype: bool Note that checks against characters mixed with any additional punctuation or whitespace will evaluate to false for an alphanumeric check. >>> s2 = pd.Series(['A B', '1.5', '3,000']) >>> s2.str.isalnum() 0 False 1 False 2 False dtype: bool More Detailed Checks for Numeric Characters There are several different but overlapping sets of numeric characters that can be checked for. >>> s3 = pd.Series(['23', '³', '⅕', '']) The s3.str.isdecimal method checks for characters used to form numbers in base 10. >>> s3.str.isdecimal() 0 True 1 False 2 False 3 False dtype: bool The s.str.isdigit method is the same as s3.str.isdecimal but also includes special digits, like superscripted and subscripted digits in unicode. >>> s3.str.isdigit() 0 True 1 True 2 False 3 False dtype: bool The s.str.isnumeric method is the same as s3.str.isdigit but also includes other characters that can represent quantities such as unicode fractions. >>> s3.str.isnumeric() 0 True 1 True 2 True 3 False dtype: bool Checks for Whitespace >>> s4 = pd.Series([' ', '\\t\\r\\n ', '']) >>> s4.str.isspace() 0 True 1 True 2 False dtype: bool Checks for Character Case >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) >>> s5.str.islower() 0 True 1 False 2 False 3 False dtype: bool >>> s5.str.isupper() 0 False 1 False 2 True 3 False dtype: bool The s5.str.istitle method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters. >>> s5.str.istitle() 0 False 1 True 2 False 3 False dtype: bool", "score": "0.71502894"}, {"id": "15339", "text": "Function: pandas.reference.api.pandas.series.str.islower\nSnippet: pandas.Series.str.islower Series.str.islower()[source] Check whether all characters in each string are lowercase. This is equivalent to running the Python string method str.islower() for each element of the Series/Index. If a string has zero characters, False is returned for that check. Returns Series or Index of bool Series or Index of boolean values with the same length as the original Series/Index. See also Series.str.isalpha Check whether all characters are alphabetic. Series.str.isnumeric Check whether all characters are numeric. Series.str.isalnum Check whether all characters are alphanumeric. Series.str.isdigit Check whether all characters are digits. Series.str.isdecimal Check whether all characters are decimal. Series.str.isspace Check whether all characters are whitespace. Series.str.islower Check whether all characters are lowercase. Series.str.isupper Check whether all characters are uppercase. Series.str.istitle Check whether all characters are titlecase. Examples Checks for Alphabetic and Numeric Characters >>> s1 = pd.Series(['one', 'one1', '1', '']) >>> s1.str.isalpha() 0 True 1 False 2 False 3 False dtype: bool >>> s1.str.isnumeric() 0 False 1 False 2 True 3 False dtype: bool >>> s1.str.isalnum() 0 True 1 True 2 True 3 False dtype: bool Note that checks against characters mixed with any additional punctuation or whitespace will evaluate to false for an alphanumeric check. >>> s2 = pd.Series(['A B', '1.5', '3,000']) >>> s2.str.isalnum() 0 False 1 False 2 False dtype: bool More Detailed Checks for Numeric Characters There are several different but overlapping sets of numeric characters that can be checked for. >>> s3 = pd.Series(['23', '³', '⅕', '']) The s3.str.isdecimal method checks for characters used to form numbers in base 10. >>> s3.str.isdecimal() 0 True 1 False 2 False 3 False dtype: bool The s.str.isdigit method is the same as s3.str.isdecimal but also includes special digits, like superscripted and subscripted digits in unicode. >>> s3.str.isdigit() 0 True 1 True 2 False 3 False dtype: bool The s.str.isnumeric method is the same as s3.str.isdigit but also includes other characters that can represent quantities such as unicode fractions. >>> s3.str.isnumeric() 0 True 1 True 2 True 3 False dtype: bool Checks for Whitespace >>> s4 = pd.Series([' ', '\\t\\r\\n ', '']) >>> s4.str.isspace() 0 True 1 True 2 False dtype: bool Checks for Character Case >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) >>> s5.str.islower() 0 True 1 False 2 False 3 False dtype: bool >>> s5.str.isupper() 0 False 1 False 2 True 3 False dtype: bool The s5.str.istitle method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters. >>> s5.str.istitle() 0 False 1 True 2 False 3 False dtype: bool", "score": "0.7089715"}, {"id": "15343", "text": "Function: pandas.reference.api.pandas.series.str.isupper\nSnippet: pandas.Series.str.isupper Series.str.isupper()[source] Check whether all characters in each string are uppercase. This is equivalent to running the Python string method str.isupper() for each element of the Series/Index. If a string has zero characters, False is returned for that check. Returns Series or Index of bool Series or Index of boolean values with the same length as the original Series/Index. See also Series.str.isalpha Check whether all characters are alphabetic. Series.str.isnumeric Check whether all characters are numeric. Series.str.isalnum Check whether all characters are alphanumeric. Series.str.isdigit Check whether all characters are digits. Series.str.isdecimal Check whether all characters are decimal. Series.str.isspace Check whether all characters are whitespace. Series.str.islower Check whether all characters are lowercase. Series.str.isupper Check whether all characters are uppercase. Series.str.istitle Check whether all characters are titlecase. Examples Checks for Alphabetic and Numeric Characters >>> s1 = pd.Series(['one', 'one1', '1', '']) >>> s1.str.isalpha() 0 True 1 False 2 False 3 False dtype: bool >>> s1.str.isnumeric() 0 False 1 False 2 True 3 False dtype: bool >>> s1.str.isalnum() 0 True 1 True 2 True 3 False dtype: bool Note that checks against characters mixed with any additional punctuation or whitespace will evaluate to false for an alphanumeric check. >>> s2 = pd.Series(['A B', '1.5', '3,000']) >>> s2.str.isalnum() 0 False 1 False 2 False dtype: bool More Detailed Checks for Numeric Characters There are several different but overlapping sets of numeric characters that can be checked for. >>> s3 = pd.Series(['23', '³', '⅕', '']) The s3.str.isdecimal method checks for characters used to form numbers in base 10. >>> s3.str.isdecimal() 0 True 1 False 2 False 3 False dtype: bool The s.str.isdigit method is the same as s3.str.isdecimal but also includes special digits, like superscripted and subscripted digits in unicode. >>> s3.str.isdigit() 0 True 1 True 2 False 3 False dtype: bool The s.str.isnumeric method is the same as s3.str.isdigit but also includes other characters that can represent quantities such as unicode fractions. >>> s3.str.isnumeric() 0 True 1 True 2 True 3 False dtype: bool Checks for Whitespace >>> s4 = pd.Series([' ', '\\t\\r\\n ', '']) >>> s4.str.isspace() 0 True 1 True 2 False dtype: bool Checks for Character Case >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) >>> s5.str.islower() 0 True 1 False 2 False 3 False dtype: bool >>> s5.str.isupper() 0 False 1 False 2 True 3 False dtype: bool The s5.str.istitle method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters. >>> s5.str.istitle() 0 False 1 True 2 False 3 False dtype: bool", "score": "0.7052564"}]}
{"task_id": "humaneval_83", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "starts_one_ends", "gold_generation": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n", "context": "Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.", "function_name": "def starts_one_ends(n):", "ctxs": [{"id": "21304", "text": "Function: python.library.itertools#itertools.count\nSnippet: itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments.", "score": "0.68467665"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.6523679"}, {"id": "41718", "text": "Function: numpy.reference.generated.numpy.char.count\nSnippet: numpy.char.count char.count(a, sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. Calls str.count element-wise. Parameters aarray_like of str or unicode substr or unicode The substring to search for. start, endint, optional Optional arguments start and end are interpreted as slice notation to specify the range in which to count. Returns outndarray Output array of ints. See also str.count Examples >>> c = np.array(['aAaAaA', ' aA ', 'abBABba']) >>> c array(['aAaAaA', ' aA ', 'abBABba'], dtype='<U7') >>> np.char.count(c, 'A') array([3, 1, 1]) >>> np.char.count(c, 'aA') array([3, 1, 0]) >>> np.char.count(c, 'A', start=1, end=4) array([2, 1, 1]) >>> np.char.count(c, 'A', start=1, end=3) array([1, 0, 0])", "score": "0.64998305"}, {"id": "18260", "text": "Function: python.library.stdtypes#bytearray.count\nSnippet: bytes.count(sub[, start[, end]]) bytearray.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.6424339"}, {"id": "18304", "text": "Function: python.library.stdtypes#bytes.count\nSnippet: bytes.count(sub[, start[, end]]) bytearray.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.", "score": "0.6384113"}]}
{"task_id": "humaneval_84", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "entry_point": "solve", "gold_generation": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "context": "Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 ≤ N ≤ 10000.\n    Output:\n         a string of binary number", "function_name": "def solve(N):", "ctxs": [{"id": "21071", "text": "Function: python.library.stdtypes#int.bit_length\nSnippet: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1.", "score": "0.7147743"}, {"id": "42661", "text": "Function: numpy.reference.generated.numpy.binary_repr\nSnippet: numpy.binary_repr numpy.binary_repr(num, width=None)[source] Return the binary representation of the input number as a string. For negative numbers, if width is not given, a minus sign is added to the front. If width is given, the two’s complement of the number is returned, with respect to that width. In a two’s-complement system negative numbers are represented by the two’s complement of the absolute value. This is the most common method of representing signed integers on computers [1]. A N-bit two’s-complement system can represent every integer in the range \\(-2^{N-1}\\) to \\(+2^{N-1}-1\\). Parameters numint Only an integer decimal number can be used. widthint, optional The length of the returned string if num is positive, or the length of the two’s complement if num is negative, provided that width is at least a sufficient number of bits for num to be represented in the designated form. If the width value is insufficient, it will be ignored, and num will be returned in binary (num > 0) or two’s complement (num < 0) form with its width equal to the minimum number of bits needed to represent the number in the designated form. This behavior is deprecated and will later raise an error. Deprecated since version 1.12.0. Returns binstr Binary representation of num or two’s complement of num. See also base_repr Return a string representation of a number in the given base system. bin Python’s built-in binary representation generator of an integer. Notes binary_repr is equivalent to using base_repr with base 2, but about 25x faster. References 1 Wikipedia, “Two’s complement”, https://en.wikipedia.org/wiki/Two’s_complement Examples >>> np.binary_repr(3) '11' >>> np.binary_repr(-3) '-11' >>> np.binary_repr(3, width=4) '0011' The two’s complement is returned when the input number is negative and width is specified: >>> np.binary_repr(-3, width=3) '101' >>> np.binary_repr(-3, width=5) '11101'", "score": "0.69383425"}, {"id": "25732", "text": "Function: python.library.stdtypes\nSnippet: there were an infinite number of sign bits. Additional Methods on Integer Types The int type implements the numbers.Integral abstract base class. In addition, it provides a few more methods: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1. int.to_bytes(length, byteorder, *, signed=False) Return an array of bytes representing an integer. >>> (1024).to_bytes(2, byteorder='big') b'\\x04\\x00' >>> (1024).to_bytes(10, byteorder='big') b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00' >>> (-1024).to_bytes(10, byteorder='big', signed=True) b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00' >>> x = 1000 >>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little') b'\\xe8\\x03' The integer is represented using length bytes. An OverflowError is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument determines whether two’s complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. The default value for signed is False. New in version 3.2. classmethod int.from_bytes(bytes, byteorder, *, signed=False) Return the integer represented by the given array of bytes. >>> int.from_bytes(b'\\x00\\x10', byteorder='big') 16 >>> int.from_bytes(b'\\x00\\x10', byteorder='little') 4096 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True) -1024 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False) 64512 >>> int.from_bytes([255, 0, 0], byteorder='big') 16711680 The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. New in version 3.2. int.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original integer and with a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. New in version 3.8. Additional Methods on Float The float type implements the numbers.Real abstract base class. float also has the following additional methods. float.as_integer_ratio() Return a pair of integers whose", "score": "0.6778857"}, {"id": "42660", "text": "Function: numpy.reference.generated.numpy.base_repr\nSnippet: numpy.base_repr numpy.base_repr(number, base=2, padding=0)[source] Return a string representation of a number in the given base system. Parameters numberint The value to convert. Positive and negative values are handled. baseint, optional Convert number to the base number system. The valid range is 2-36, the default value is 2. paddingint, optional Number of zeros padded on the left. Default is 0 (no padding). Returns outstr String representation of number in base system. See also binary_repr Faster version of base_repr for base 2. Examples >>> np.base_repr(5) '101' >>> np.base_repr(6, 5) '11' >>> np.base_repr(7, base=5, padding=3) '00012' >>> np.base_repr(10, base=16) 'A' >>> np.base_repr(32, base=16) '20'", "score": "0.66309905"}, {"id": "19516", "text": "Function: python.library.decimal#decimal.Decimal\nSnippet: class decimal.Decimal(value=\"0\", context=None) Construct a new Decimal object based from value. value can be an integer, string, tuple, float, or another Decimal object. If no value is given, returns Decimal('0'). If value is a string, it should conform to the decimal numeric string syntax after leading and trailing whitespace characters, as well as underscores throughout, are removed: sign ::= '+' | '-' digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' indicator ::= 'e' | 'E' digits ::= digit [digit]... decimal-part ::= digits '.' [digits] | ['.'] digits exponent-part ::= indicator [sign] digits infinity ::= 'Infinity' | 'Inf' nan ::= 'NaN' [digits] | 'sNaN' [digits] numeric-value ::= decimal-part [exponent-part] | infinity numeric-string ::= [sign] numeric-value | [sign] nan Other Unicode decimal digits are also permitted where digit appears above. These include decimal digits from various other alphabets (for example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits '\\uff10' through '\\uff19'. If value is a tuple, it should have three components, a sign (0 for positive or 1 for negative), a tuple of digits, and an integer exponent. For example, Decimal((0, (1, 4, 1, 4), -3)) returns Decimal('1.414'). If value is a float, the binary floating point value is losslessly converted to its exact decimal equivalent. This conversion can often require 53 or more digits of precision. For example, Decimal(float('1.1')) converts to Decimal('1.100000000000000088817841970012523233890533447265625'). The context precision does not affect how many digits are stored. That is determined exclusively by the number of digits in value. For example, Decimal('3.00000') records all five zeros even if the context precision is only three. The purpose of the context argument is determining what to do if value is a malformed string. If the context traps InvalidOperation, an exception is raised; otherwise, the constructor returns a new Decimal with the value of NaN. Once constructed, Decimal objects are immutable. Changed in version 3.2: The argument to the constructor is now permitted to be a float instance. Changed in version 3.3: float arguments raise an exception if the FloatOperation trap is set. By default the trap is off. Changed in version 3.6: Underscores are allowed for grouping, as with integral and floating-point literals in code. Decimal floating point objects share many properties with the other built-in numeric types such as float and int. All of the usual math operations and special methods apply. Likewise, decimal objects can be copied, pickled, printed, used as dictionary keys, used as set elements, compared, sorted, and coerced to another type (such as float or int). There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator % is applied to Decimal objects, the sign of the result is the sign of the dividend rather than the sign of the divisor: >>> (-7) % 4 1 >>> Decimal(-7) % Decimal(4) Decimal('-3') The integer division operator // behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather", "score": "0.6630066"}]}
{"task_id": "humaneval_85", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n", "entry_point": "add", "gold_generation": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n", "context": "Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2", "function_name": "def add(lst):", "ctxs": [{"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.6781326"}, {"id": "43987", "text": "Function: numpy.reference.generated.numpy.ufunc.at\nSnippet: numpy.ufunc.at method ufunc.at(a, indices, b=None, /) Performs unbuffered in place operation on operand ‘a’ for elements specified by ‘indices’. For addition ufunc, this method is equivalent to a[indices] += b, except that results are accumulated for elements that are indexed more than once. For example, a[[0,0]] += 1 will only increment the first element once because of buffering, whereas add.at(a, [0,0], 1) will increment the first element twice. New in version 1.8.0. Parameters aarray_like The array to perform in place operation on. indicesarray_like or tuple Array like index object or slice object for indexing into first operand. If first operand has multiple dimensions, indices can be a tuple of array like index objects or slice objects. barray_like Second operand for ufuncs requiring two operands. Operand must be broadcastable over first operand after indexing or slicing. Examples Set items 0 and 1 to their negative values: >>> a = np.array([1, 2, 3, 4]) >>> np.negative.at(a, [0, 1]) >>> a array([-1, -2, 3, 4]) Increment items 0 and 1, and increment item 2 twice: >>> a = np.array([1, 2, 3, 4]) >>> np.add.at(a, [0, 1, 2, 2], 1) >>> a array([2, 3, 5, 4]) Add items 0 and 1 in first array to second array, and store results in first array: >>> a = np.array([1, 2, 3, 4]) >>> b = np.array([1, 2]) >>> np.add.at(a, [0, 1], b) >>> a array([2, 4, 3, 4])", "score": "0.6679892"}, {"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.6628781"}, {"id": "20216", "text": "Function: python.library.stdtypes#frozenset.add\nSnippet: add(elem) Add element elem to the set.", "score": "0.6553414"}, {"id": "17639", "text": "Function: python.library.array#array.array.insert\nSnippet: array.insert(i, x) Insert a new item with value x in the array before position i. Negative values are treated as being relative to the end of the array.", "score": "0.6516683"}]}
{"task_id": "humaneval_86", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "anti_shuffle", "gold_generation": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n", "context": "Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'", "function_name": "def anti_shuffle(s):", "ctxs": [{"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.75078726"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.74753857"}, {"id": "41691", "text": "Function: numpy.reference.generated.numpy.char.chararray.searchsorted\nSnippet: numpy.char.chararray.searchsorted method char.chararray.searchsorted(v, side='left', sorter=None) Find indices where elements of v should be inserted in a to maintain order. For full documentation, see numpy.searchsorted See also numpy.searchsorted equivalent function", "score": "0.7295538"}, {"id": "41951", "text": "Function: numpy.reference.generated.numpy.dtype.newbyteorder\nSnippet: numpy.dtype.newbyteorder method dtype.newbyteorder(new_order='S', /) Return a new dtype with a different byte order. Changes are also made in all fields and sub-arrays of the data type. Parameters new_orderstring, optional Byte order to force; a value from the byte order specifications below. The default value (‘S’) results in swapping the current byte order. new_order codes can be any of: ‘S’ - swap dtype from current to opposite endian {‘<’, ‘little’} - little endian {‘>’, ‘big’} - big endian {‘=’, ‘native’} - native order {‘|’, ‘I’} - ignore (no change to byte order) Returns new_dtypedtype New dtype object with the given change to the byte order. Notes Changes are also made in all fields and sub-arrays of the data type. Examples >>> import sys >>> sys_is_le = sys.byteorder == 'little' >>> native_code = sys_is_le and '<' or '>' >>> swapped_code = sys_is_le and '>' or '<' >>> native_dt = np.dtype(native_code+'i2') >>> swapped_dt = np.dtype(swapped_code+'i2') >>> native_dt.newbyteorder('S') == swapped_dt True >>> native_dt.newbyteorder() == swapped_dt True >>> native_dt == swapped_dt.newbyteorder('S') True >>> native_dt == swapped_dt.newbyteorder('=') True >>> native_dt == swapped_dt.newbyteorder('N') True >>> native_dt == native_dt.newbyteorder('|') True >>> np.dtype('<i2') == native_dt.newbyteorder('<') True >>> np.dtype('<i2') == native_dt.newbyteorder('L') True >>> np.dtype('>i2') == native_dt.newbyteorder('>') True >>> np.dtype('>i2') == native_dt.newbyteorder('B') True", "score": "0.7280301"}, {"id": "41813", "text": "Function: numpy.reference.generated.numpy.chararray.searchsorted\nSnippet: numpy.chararray.searchsorted method chararray.searchsorted(v, side='left', sorter=None) Find indices where elements of v should be inserted in a to maintain order. For full documentation, see numpy.searchsorted See also numpy.searchsorted equivalent function", "score": "0.7258132"}]}
{"task_id": "humaneval_87", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "get_row", "gold_generation": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "context": "You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]", "function_name": "def get_row(lst, x):", "ctxs": [{"id": "42938", "text": "Function: numpy.reference.generated.numpy.lexsort\nSnippet: numpy.lexsort numpy.lexsort(keys, axis=- 1) Perform an indirect stable sort using a sequence of keys. Given multiple sorting keys, which can be interpreted as columns in a spreadsheet, lexsort returns an array of integer indices that describes the sort order by multiple columns. The last key in the sequence is used for the primary sort order, the second-to-last key for the secondary sort order, and so on. The keys argument must be a sequence of objects that can be converted to arrays of the same shape. If a 2D array is provided for the keys argument, its rows are interpreted as the sorting keys and sorting is according to the last row, second last row etc. Parameters keys(k, N) array or tuple containing k (N,)-shaped sequences The k different “columns” to be sorted. The last column (or row if keys is a 2D array) is the primary sort key. axisint, optional Axis to be indirectly sorted. By default, sort over the last axis. Returns indices(N,) ndarray of ints Array of indices that sort the keys along the specified axis. See also argsort Indirect sort. ndarray.sort In-place sort. sort Return a sorted copy of an array. Examples Sort names: first by surname, then by name. >>> surnames = ('Hertz', 'Galilei', 'Hertz') >>> first_names = ('Heinrich', 'Galileo', 'Gustav') >>> ind = np.lexsort((first_names, surnames)) >>> ind array([1, 2, 0]) >>> [surnames[i] + \", \" + first_names[i] for i in ind] ['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich'] Sort two columns of numbers: >>> a = [1,5,1,4,3,4,4] # First column >>> b = [9,4,0,4,0,2,1] # Second column >>> ind = np.lexsort((b,a)) # Sort by a, then by b >>> ind array([2, 0, 4, 6, 5, 3, 1]) >>> [(a[i],b[i]) for i in ind] [(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)] Note that sorting is first according to the elements of a. Secondary sorting is according to the elements of b. A normal argsort would have yielded: >>> [(a[i],b[i]) for i in np.argsort(a)] [(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)] Structured arrays are sorted lexically by argsort: >>> x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)], ... dtype=np.dtype([('x', int), ('y', int)])) >>> np.argsort(x) # or np.argsort(x, order=('x', 'y')) array([2, 0, 4, 6, 5, 3, 1])", "score": "0.7297911"}, {"id": "42538", "text": "Function: numpy.user.quickstart\nSnippet: 1.25, 1.5 , 1.75, 2. ]) >>> x = np.linspace(0, 2 * pi, 100) # useful to evaluate function at lots of points >>> f = np.sin(x) See also array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange, linspace, numpy.random.Generator.rand, numpy.random.Generator.randn, fromfunction, fromfile Printing Arrays When you print an array, NumPy displays it in a similar way to nested lists, but with the following layout: the last axis is printed from left to right, the second-to-last is printed from top to bottom, the rest are also printed from top to bottom, with each slice separated from the next by an empty line. One-dimensional arrays are then printed as rows, bidimensionals as matrices and tridimensionals as lists of matrices. >>> a = np.arange(6) # 1d array >>> print(a) [0 1 2 3 4 5] >>> >>> b = np.arange(12).reshape(4, 3) # 2d array >>> print(b) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] >>> >>> c = np.arange(24).reshape(2, 3, 4) # 3d array >>> print(c) [[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]] See below to get more details on reshape. If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners: >>> print(np.arange(10000)) [ 0 1 2 ... 9997 9998 9999] >>> >>> print(np.arange(10000).reshape(100, 100)) [[ 0 1 2 ... 97 98 99] [ 100 101 102 ... 197 198 199] [ 200 201 202 ... 297 298 299] ... [9700 9701 9702 ... 9797 9798 9799] [9800 9801 9802 ... 9897 9898 9899] [9900 9901 9902 ... 9997 9998 9999]] To disable this behaviour and force NumPy to print the entire array, you can change the printing options using set_printoptions. >>> np.set_printoptions(threshold=sys.maxsize) # sys module should be imported Basic Operations Arithmetic operators on arrays apply elementwise. A new array is created and filled with the result. >>> a = np.array([20, 30, 40, 50]) >>> b = np.arange(4) >>> b array([0, 1, 2, 3]) >>> c = a - b >>> c array([20, 29, 38, 47]) >>> b**2 array([0, 1, 4, 9]) >>> 10 * np.sin(a) array([ 9.12945251, -9.88031624, 7.4511316 , -2.62374854]) >>> a < 35 array([ True, True, False, False]) Unlike in many matrix languages, the product operator * operates elementwise in NumPy arrays. The matrix product can be performed using the @ operator (in python >=3.5) or the dot function or method: >>> A = np.array([[1, 1], ... [0, 1]]) >>> B = np.array([[2, 0], ... [3, 4]]) >>> A * B # elementwise product array([[2, 0], [0, 4]]) >>> A @ B # matrix product array([[5, 4], [3, 4]]) >>> A.dot(B) # another matrix product array([[5, 4], [3, 4]]) Some operations, such as += and *=, act in place to modify an existing array rather than create a new one. >>> rg = np.random.default_rng(1) # create instance of default", "score": "0.713359"}, {"id": "42540", "text": "Function: numpy.user.quickstart\nSnippet: 216, 125, 1000, 27, 1000, 1, 1000]) >>> for i in a: ... print(i**(1 / 3.)) ... 9.999999999999998 1.0 9.999999999999998 3.0 9.999999999999998 4.999999999999999 5.999999999999999 6.999999999999999 7.999999999999999 8.999999999999998 Multidimensional arrays can have one index per axis. These indices are given in a tuple separated by commas: >>> def f(x, y): ... return 10 * x + y ... >>> b = np.fromfunction(f, (5, 4), dtype=int) >>> b array([[ 0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, 32, 33], [40, 41, 42, 43]]) >>> b[2, 3] 23 >>> b[0:5, 1] # each row in the second column of b array([ 1, 11, 21, 31, 41]) >>> b[:, 1] # equivalent to the previous example array([ 1, 11, 21, 31, 41]) >>> b[1:3, :] # each column in the second and third row of b array([[10, 11, 12, 13], [20, 21, 22, 23]]) When fewer indices are provided than the number of axes, the missing indices are considered complete slices: >>> b[-1] # the last row. Equivalent to b[-1, :] array([40, 41, 42, 43]) The expression within brackets in b[i] is treated as an i followed by as many instances of : as needed to represent the remaining axes. NumPy also allows you to write this using dots as b[i, ...]. The dots (...) represent as many colons as needed to produce a complete indexing tuple. For example, if x is an array with 5 axes, then x[1, 2, ...] is equivalent to x[1, 2, :, :, :], x[..., 3] to x[:, :, :, :, 3] and x[4, ..., 5, :] to x[4, :, :, 5, :]. >>> c = np.array([[[ 0, 1, 2], # a 3D array (two stacked 2D arrays) ... [ 10, 12, 13]], ... [[100, 101, 102], ... [110, 112, 113]]]) >>> c.shape (2, 2, 3) >>> c[1, ...] # same as c[1, :, :] or c[1] array([[100, 101, 102], [110, 112, 113]]) >>> c[..., 2] # same as c[:, :, 2] array([[ 2, 13], [102, 113]]) Iterating over multidimensional arrays is done with respect to the first axis: >>> for row in b: ... print(row) ... [0 1 2 3] [10 11 12 13] [20 21 22 23] [30 31 32 33] [40 41 42 43] However, if one wants to perform an operation on each element in the array, one can use the flat attribute which is an iterator over all the elements of the array: >>> for element in b.flat: ... print(element) ... 0 1 2 3 10 11 12 13 20 21 22 23 30 31 32 33 40 41 42 43 See also Indexing on ndarrays, Indexing routines (reference), newaxis, ndenumerate, indices Shape Manipulation Changing the shape of an array An array has a shape given by the number of elements along each axis: >>> a = np.floor(10 * rg.random((3, 4))) >>> a array([[3., 7., 3., 4.], [1., 4., 2., 2.], [7., 2., 4., 9.]]) >>> a.shape (3, 4) The shape of an array can be changed with", "score": "0.71109205"}, {"id": "42436", "text": "Function: numpy.reference.generated.numpy.matrix.tolist\nSnippet: numpy.matrix.tolist method matrix.tolist()[source] Return the matrix as a (possibly nested) list. See ndarray.tolist for full documentation. See also ndarray.tolist Examples >>> x = np.matrix(np.arange(12).reshape((3,4))); x matrix([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) >>> x.tolist() [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]", "score": "0.7105472"}, {"id": "15313", "text": "Function: pandas.reference.api.pandas.series.sparse.to_coo\nSnippet: pandas.Series.sparse.to_coo Series.sparse.to_coo(row_levels=(0,), column_levels=(1,), sort_labels=False)[source] Create a scipy.sparse.coo_matrix from a Series with MultiIndex. Use row_levels and column_levels to determine the row and column coordinates respectively. row_levels and column_levels are the names (labels) or numbers of the levels. {row_levels, column_levels} must be a partition of the MultiIndex level names (or numbers). Parameters row_levels:tuple/list column_levels:tuple/list sort_labels:bool, default False Sort the row and column labels before forming the sparse matrix. When row_levels and/or column_levels refer to a single level, set to True for a faster execution. Returns y:scipy.sparse.coo_matrix rows:list (row labels) columns:list (column labels) Examples >>> s = pd.Series([3.0, np.nan, 1.0, 3.0, np.nan, np.nan]) >>> s.index = pd.MultiIndex.from_tuples( ... [ ... (1, 2, \"a\", 0), ... (1, 2, \"a\", 1), ... (1, 1, \"b\", 0), ... (1, 1, \"b\", 1), ... (2, 1, \"b\", 0), ... (2, 1, \"b\", 1) ... ], ... names=[\"A\", \"B\", \"C\", \"D\"], ... ) >>> s A B C D 1 2 a 0 3.0 1 NaN 1 b 0 1.0 1 3.0 2 1 b 0 NaN 1 NaN dtype: float64 >>> ss = s.astype(\"Sparse\") >>> ss A B C D 1 2 a 0 3.0 1 NaN 1 b 0 1.0 1 3.0 2 1 b 0 NaN 1 NaN dtype: Sparse[float64, nan] >>> A, rows, columns = ss.sparse.to_coo( ... row_levels=[\"A\", \"B\"], column_levels=[\"C\", \"D\"], sort_labels=True ... ) >>> A <3x4 sparse matrix of type '<class 'numpy.float64'>' with 3 stored elements in COOrdinate format> >>> A.todense() matrix([[0., 0., 1., 3.], [3., 0., 0., 0.], [0., 0., 0., 0.]]) >>> rows [(1, 1), (1, 2), (2, 1)] >>> columns [('a', 0), ('a', 1), ('b', 0), ('b', 1)]", "score": "0.7077691"}]}
{"task_id": "humaneval_88", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n", "entry_point": "sort_array", "gold_generation": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n", "context": "Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]", "function_name": "def sort_array(array):", "ctxs": [{"id": "43877", "text": "Function: numpy.reference.generated.numpy.recarray.sort\nSnippet: numpy.recarray.sort method recarray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.7531047"}, {"id": "43195", "text": "Function: numpy.reference.generated.numpy.sort\nSnippet: numpy.sort numpy.sort(a, axis=- 1, kind=None, order=None)[source] Return a sorted copy of an array. Parameters aarray_like Array to be sorted. axisint or None, optional Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort or radix sort under the covers and, in general, the actual implementation will vary with data type. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0.: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. Returns sorted_arrayndarray Array of the same type and shape as a. See also ndarray.sort Method to sort an array in-place. argsort Indirect sort. lexsort Indirect stable sort on multiple keys. searchsorted Find elements in a sorted array. partition Partial sort. Notes The various sorting algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The four algorithms implemented in NumPy have the following properties: kind speed worst case work space stable ‘quicksort’ 1 O(n^2) 0 no ‘heapsort’ 3 O(n*log(n)) 0 no ‘mergesort’ 2 O(n*log(n)) ~n/2 yes ‘timsort’ 2 O(n*log(n)) ~n/2 yes Note The datatype determines which of ‘mergesort’ or ‘timsort’ is actually used, even if ‘mergesort’ is specified. User selection at a finer scale is not currently available. All the sort algorithms make temporary copies of the data when sorting along any but the last axis. Consequently, sorting along the last axis is faster and uses less space than sorting along any other axis. The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts. Previous to numpy 1.4.0 sorting real and complex arrays containing nan values led to undefined behaviour. In numpy versions >= 1.4.0 nan values are sorted to the end. The extended sort order is: Real: [R, nan] Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj] where R is a non-nan real value. Complex values with the same nan placements are sorted according to the non-nan part if it exists. Non-nan values are sorted as before. New in version 1.12.0. quicksort has been changed to introsort. When sorting does not make enough progress it switches to heapsort. This implementation makes quicksort O(n*log(n)) in the worst case. ‘stable’ automatically chooses the best stable sorting algorithm for the data type being", "score": "0.7526817"}, {"id": "42565", "text": "Function: numpy.reference.generated.numpy.ndarray.sort\nSnippet: numpy.ndarray.sort method ndarray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.74989325"}, {"id": "42427", "text": "Function: numpy.reference.generated.numpy.matrix.sort\nSnippet: numpy.matrix.sort method matrix.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.7478038"}, {"id": "42939", "text": "Function: numpy.reference.generated.numpy.lib.arraysetops\nSnippet: numpy.lib.arraysetops Set operations for arrays based on sorting. Notes For floating point arrays, inaccurate results may appear due to usual round-off and floating point comparison issues. Speed could be gained in some operations by an implementation of numpy.sort, that can provide directly the permutation vectors, thus avoiding calls to numpy.argsort. Original author: Robert Cimrman", "score": "0.74481833"}]}
{"task_id": "humaneval_89", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "encrypt", "gold_generation": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n", "context": "Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'", "function_name": "def encrypt(s):", "ctxs": [{"id": "23484", "text": "Function: python.library.secrets\nSnippet: They should be salted and hashed using a cryptographically-strong one-way (irreversible) hash function. Generate a ten-character alphanumeric password with at least one lowercase character, at least one uppercase character, and at least three digits: import string import secrets alphabet = string.ascii_letters + string.digits while True: password = ''.join(secrets.choice(alphabet) for i in range(10)) if (any(c.islower() for c in password) and any(c.isupper() for c in password) and sum(c.isdigit() for c in password) >= 3): break Generate an XKCD-style passphrase: import secrets # On standard Linux systems, use a convenient dictionary file. # Other platforms may need to provide their own word-list. with open('/usr/share/dict/words') as f: words = [word.strip() for word in f] password = ' '.join(secrets.choice(words) for i in range(4)) Generate a hard-to-guess temporary URL containing a security token suitable for password recovery applications: import secrets url = 'https://mydomain.com/reset=' + secrets.token_urlsafe()", "score": "0.7208978"}, {"id": "18865", "text": "Function: python.library.crypt#crypt.crypt\nSnippet: crypt.crypt(word, salt=None) word will usually be a user’s password as typed at a prompt or in a graphical interface. The optional salt is either a string as returned from mksalt(), one of the crypt.METHOD_* values (though not all may be available on all platforms), or a full encrypted password including salt, as returned by this function. If salt is not provided, the strongest method will be used (as returned by methods()). Checking a password is usually done by passing the plain-text password as word and the full results of a previous crypt() call, which should be the same as the results of this call. salt (either a random 2 or 16 character string, possibly prefixed with $digit$ to indicate the method) which will be used to perturb the encryption algorithm. The characters in salt must be in the set [./a-zA-Z0-9], with the exception of Modular Crypt Format which prefixes a $digit$. Returns the hashed password as a string, which will be composed of characters from the same alphabet as the salt. Since a few crypt(3) extensions allow different values, with different sizes in the salt, it is recommended to use the full crypted password as salt when checking for a password. Changed in version 3.3: Accept crypt.METHOD_* values in addition to strings for salt.", "score": "0.68657285"}, {"id": "18236", "text": "Function: python.library.binascii#binascii.unhexlify\nSnippet: binascii.a2b_hex(hexstr) binascii.unhexlify(hexstr) Return the binary data represented by the hexadecimal string hexstr. This function is the inverse of b2a_hex(). hexstr must contain an even number of hexadecimal digits (which can be upper or lower case), otherwise an Error exception is raised. Similar functionality (accepting only text string arguments, but more liberal towards whitespace) is also accessible using the bytes.fromhex() class method.", "score": "0.6857306"}, {"id": "18137", "text": "Function: python.library.base64\nSnippet: and filesystem-safe alphabet, which substitutes - instead of + and _ instead of / in the standard Base64 alphabet, and return the decoded bytes. base64.b32encode(s) Encode the bytes-like object s using Base32 and return the encoded bytes. base64.b32decode(s, casefold=False, map01=None) Decode the Base32 encoded bytes-like object or ASCII string s and return the decoded bytes. Optional casefold is a flag specifying whether a lowercase alphabet is acceptable as input. For security purposes, the default is False. RFC 3548 allows for optional mapping of the digit 0 (zero) to the letter O (oh), and for optional mapping of the digit 1 (one) to either the letter I (eye) or letter L (el). The optional argument map01 when not None, specifies which letter the digit 1 should be mapped to (when map01 is not None, the digit 0 is always mapped to the letter O). For security purposes the default is None, so that 0 and 1 are not allowed in the input. A binascii.Error is raised if s is incorrectly padded or if there are non-alphabet characters present in the input. base64.b16encode(s) Encode the bytes-like object s using Base16 and return the encoded bytes. base64.b16decode(s, casefold=False) Decode the Base16 encoded bytes-like object or ASCII string s and return the decoded bytes. Optional casefold is a flag specifying whether a lowercase alphabet is acceptable as input. For security purposes, the default is False. A binascii.Error is raised if s is incorrectly padded or if there are non-alphabet characters present in the input. base64.a85encode(b, *, foldspaces=False, wrapcol=0, pad=False, adobe=False) Encode the bytes-like object b using Ascii85 and return the encoded bytes. foldspaces is an optional flag that uses the special short sequence ‘y’ instead of 4 consecutive spaces (ASCII 0x20) as supported by ‘btoa’. This feature is not supported by the “standard” Ascii85 encoding. wrapcol controls whether the output should have newline (b'\\n') characters added to it. If this is non-zero, each output line will be at most this many characters long. pad controls whether the input is padded to a multiple of 4 before encoding. Note that the btoa implementation always pads. adobe controls whether the encoded byte sequence is framed with <~ and ~>, which is used by the Adobe implementation. New in version 3.4. base64.a85decode(b, *, foldspaces=False, adobe=False, ignorechars=b' \\t\\n\\r\\v') Decode the Ascii85 encoded bytes-like object or ASCII string b and return the decoded bytes. foldspaces is a flag that specifies whether the ‘y’ short sequence should be accepted as shorthand for 4 consecutive spaces (ASCII 0x20). This feature is not supported by the “standard” Ascii85 encoding. adobe controls whether the input sequence is in Adobe Ascii85 format (i.e. is framed with <~ and ~>). ignorechars should be a bytes-like object or ASCII string containing characters to ignore from the input. This should only contain whitespace characters, and by default contains all whitespace characters in ASCII. New in version 3.4. base64.b85encode(b, pad=False) Encode the bytes-like object b using base85 (as used in e.g. git-style binary diffs) and return the encoded", "score": "0.6795916"}, {"id": "18220", "text": "Function: python.library.binascii#binascii.a2b_hex\nSnippet: binascii.a2b_hex(hexstr) binascii.unhexlify(hexstr) Return the binary data represented by the hexadecimal string hexstr. This function is the inverse of b2a_hex(). hexstr must contain an even number of hexadecimal digits (which can be upper or lower case), otherwise an Error exception is raised. Similar functionality (accepting only text string arguments, but more liberal towards whitespace) is also accessible using the bytes.fromhex() class method.", "score": "0.67608184"}]}
{"task_id": "humaneval_90", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "next_smallest", "gold_generation": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "context": "You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None", "function_name": "def next_smallest(lst):", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.7460047"}, {"id": "21889", "text": "Function: python.library.functions#min\nSnippet: min(iterable, *[, key, default]) min(arg1, arg2, *args[, key]) Return the smallest item in an iterable or the smallest of two or more arguments. If one positional argument is provided, it should be an iterable. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.74043024"}, {"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.73976964"}, {"id": "19497", "text": "Function: python.library.decimal#decimal.Context.next_plus\nSnippet: next_plus(x) Returns the smallest representable number larger than x.", "score": "0.73594064"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.73591876"}]}
{"task_id": "humaneval_91", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "is_bored", "gold_generation": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "context": "You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1", "function_name": "def is_bored(S):", "ctxs": [{"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.66247463"}, {"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.66135806"}, {"id": "21304", "text": "Function: python.library.itertools#itertools.count\nSnippet: itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments.", "score": "0.64810276"}, {"id": "20736", "text": "Function: python.library.idle\nSnippet: Find Selection Search for the currently selected string, if there is one. Find in Files… Open a file search dialog. Put results in a new output window. Replace… Open a search-and-replace dialog. Go to Line Move the cursor to the beginning of the line requested and make that line visible. A request past the end of the file goes to the end. Clear any selection and update the line and column status. Show Completions Open a scrollable list allowing selection of existing names. See Completions in the Editing and navigation section below. Expand Word Expand a prefix you have typed to match a full word in the same window; repeat to get a different expansion. Show call tip After an unclosed parenthesis for a function, open a small window with function parameter hints. See Calltips in the Editing and navigation section below. Show surrounding parens Highlight the surrounding parenthesis. Format menu (Editor window only) Indent Region Shift selected lines right by the indent width (default 4 spaces). Dedent Region Shift selected lines left by the indent width (default 4 spaces). Comment Out Region Insert ## in front of selected lines. Uncomment Region Remove leading # or ## from selected lines. Tabify Region Turn leading stretches of spaces into tabs. (Note: We recommend using 4 space blocks to indent Python code.) Untabify Region Turn all tabs into the correct number of spaces. Toggle Tabs Open a dialog to switch between indenting with spaces and tabs. New Indent Width Open a dialog to change indent width. The accepted default by the Python community is 4 spaces. Format Paragraph Reformat the current blank-line-delimited paragraph in comment block or multiline string or selected line in a string. All lines in the paragraph will be formatted to less than N columns, where N defaults to 72. Strip trailing whitespace Remove trailing space and other whitespace characters after the last non-whitespace character of a line by applying str.rstrip to each line, including lines within multiline strings. Except for Shell windows, remove extra newlines at the end of the file. Run menu (Editor window only) Run Module Do Check Module. If no error, restart the shell to clean the environment, then execute the module. Output is displayed in the Shell window. Note that output requires use of print or write. When execution is complete, the Shell retains focus and displays a prompt. At this point, one may interactively explore the result of execution. This is similar to executing a file with python -i file at a command line. Run… Customized Same as Run Module, but run the module with customized settings. Command Line Arguments extend sys.argv as if passed on a command line. The module can be run in the Shell without restarting. Check Module Check the syntax of the module currently open in the Editor window. If the module has not been saved IDLE will either prompt the user to save or autosave, as selected in the General tab of the Idle Settings dialog. If there", "score": "0.6478115"}, {"id": "15323", "text": "Function: pandas.reference.api.pandas.series.str.count\nSnippet: pandas.Series.str.count Series.str.count(pat, flags=0)[source] Count occurrences of pattern in each string of the Series/Index. This function is used to count the number of times a particular regex pattern is repeated in each of the string elements of the Series. Parameters pat:str Valid regular expression. flags:int, default 0, meaning no flags Flags for the re module. For a complete list, see here. **kwargs For compatibility with other string methods. Not used. Returns Series or Index Same type as the calling object containing the integer counts. See also re Standard library module for regular expressions. str.count Standard library version, without regular expression support. Notes Some characters need to be escaped when passing in pat. eg. '$' has a special meaning in regex and must be escaped when finding this literal character. Examples >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat']) >>> s.str.count('a') 0 0.0 1 0.0 2 2.0 3 2.0 4 NaN 5 0.0 6 1.0 dtype: float64 Escape '$' to find the literal dollar sign. >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat']) >>> s.str.count('\\\\$') 0 1 1 0 2 1 3 2 4 2 5 0 dtype: int64 This is also available on Index >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a') Int64Index([0, 0, 2, 1], dtype='int64')", "score": "0.6462335"}]}
{"task_id": "humaneval_92", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n", "entry_point": "any_int", "gold_generation": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n", "context": "", "function_name": "def any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) ➞ True\n    \n    any_int(3, 2, 2) ➞ False\n\n    any_int(3, -2, 1) ➞ True\n    \n    any_int(3.6, -2.2, 2) ➞ False\n  \n\n    \n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015749"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49312225"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.49104327"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48984405"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.48983365"}]}
{"task_id": "humaneval_93", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "encode", "gold_generation": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n", "context": "Write a function that takes a message, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'", "function_name": "def encode(message):", "ctxs": [{"id": "41704", "text": "Function: numpy.reference.generated.numpy.char.chararray.swapcase\nSnippet: numpy.char.chararray.swapcase method char.chararray.swapcase()[source] For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. See also char.swapcase", "score": "0.7179551"}, {"id": "18339", "text": "Function: python.library.stdtypes#bytes.swapcase\nSnippet: bytes.swapcase() bytearray.swapcase() Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart and vice-versa. For example: >>> b'Hello World'.swapcase() b'hELLO wORLD' Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. Unlike str.swapcase(), it is always the case that bin.swapcase().swapcase() == bin for the binary versions. Case conversions are symmetrical in ASCII, even though that is not generally true for arbitrary Unicode code points. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made.", "score": "0.71636164"}, {"id": "41825", "text": "Function: numpy.reference.generated.numpy.chararray.swapcase\nSnippet: numpy.chararray.swapcase method chararray.swapcase()[source] For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. See also char.swapcase", "score": "0.71455634"}, {"id": "18295", "text": "Function: python.library.stdtypes#bytearray.swapcase\nSnippet: bytes.swapcase() bytearray.swapcase() Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart and vice-versa. For example: >>> b'Hello World'.swapcase() b'hELLO wORLD' Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. Unlike str.swapcase(), it is always the case that bin.swapcase().swapcase() == bin for the binary versions. Case conversions are symmetrical in ASCII, even though that is not generally true for arbitrary Unicode code points. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made.", "score": "0.7143356"}, {"id": "41759", "text": "Function: numpy.reference.generated.numpy.char.swapcase\nSnippet: numpy.char.swapcase char.swapcase(a)[source] Return element-wise a copy of the string with uppercase characters converted to lowercase and vice versa. Calls str.swapcase element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like, {str, unicode} Input array. Returns outndarray, {str, unicode} Output array of str or unicode, depending on input type See also str.swapcase Examples >>> c=np.array(['a1B c','1b Ca','b Ca1','cA1b'],'S5'); c array(['a1B c', '1b Ca', 'b Ca1', 'cA1b'], dtype='|S5') >>> np.char.swapcase(c) array(['A1b C', '1B cA', 'B cA1', 'Ca1B'], dtype='|S5')", "score": "0.7124577"}]}
{"task_id": "humaneval_94", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "entry_point": "skjkasdkd", "gold_generation": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "context": "You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7", "function_name": "def skjkasdkd(lst):", "ctxs": [{"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.6952797"}, {"id": "14180", "text": "Function: pandas.reference.api.pandas.core.groupby.seriesgroupby.nlargest\nSnippet: pandas.core.groupby.SeriesGroupBy.nlargest SeriesGroupBy.nlargest(n=5, keep='first')[source] Return the largest n elements. Parameters n:int, default 5 Return this many descending sorted values. keep:{‘first’, ‘last’, ‘all’}, default ‘first’ When there are duplicate values that cannot all fit in a Series of n elements: first : return the first n occurrences in order of appearance. last : return the last n occurrences in reverse order of appearance. all : keep all occurrences. This can result in a Series of size larger than n. Returns Series The n largest values in the Series, sorted in decreasing order. See also Series.nsmallest Get the n smallest elements. Series.sort_values Sort Series by values. Series.head Return the first n rows. Notes Faster than .sort_values(ascending=False).head(n) for small n relative to the size of the Series object. Examples >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000, ... \"Malta\": 434000, \"Maldives\": 434000, ... \"Brunei\": 434000, \"Iceland\": 337000, ... \"Nauru\": 11300, \"Tuvalu\": 11300, ... \"Anguilla\": 11300, \"Montserrat\": 5200} >>> s = pd.Series(countries_population) >>> s Italy 59000000 France 65000000 Malta 434000 Maldives 434000 Brunei 434000 Iceland 337000 Nauru 11300 Tuvalu 11300 Anguilla 11300 Montserrat 5200 dtype: int64 The n largest elements where n=5 by default. >>> s.nlargest() France 65000000 Italy 59000000 Malta 434000 Maldives 434000 Brunei 434000 dtype: int64 The n largest elements where n=3. Default keep value is ‘first’ so Malta will be kept. >>> s.nlargest(3) France 65000000 Italy 59000000 Malta 434000 dtype: int64 The n largest elements where n=3 and keeping the last duplicates. Brunei will be kept since it is the last with value 434000 based on the index order. >>> s.nlargest(3, keep='last') France 65000000 Italy 59000000 Brunei 434000 dtype: int64 The n largest elements where n=3 with all duplicates kept. Note that the returned Series has five elements due to the three duplicates. >>> s.nlargest(3, keep='all') France 65000000 Italy 59000000 Malta 434000 Maldives 434000 Brunei 434000 dtype: int64", "score": "0.6794548"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.67383623"}, {"id": "15240", "text": "Function: pandas.reference.api.pandas.series.nlargest\nSnippet: pandas.Series.nlargest Series.nlargest(n=5, keep='first')[source] Return the largest n elements. Parameters n:int, default 5 Return this many descending sorted values. keep:{‘first’, ‘last’, ‘all’}, default ‘first’ When there are duplicate values that cannot all fit in a Series of n elements: first : return the first n occurrences in order of appearance. last : return the last n occurrences in reverse order of appearance. all : keep all occurrences. This can result in a Series of size larger than n. Returns Series The n largest values in the Series, sorted in decreasing order. See also Series.nsmallest Get the n smallest elements. Series.sort_values Sort Series by values. Series.head Return the first n rows. Notes Faster than .sort_values(ascending=False).head(n) for small n relative to the size of the Series object. Examples >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000, ... \"Malta\": 434000, \"Maldives\": 434000, ... \"Brunei\": 434000, \"Iceland\": 337000, ... \"Nauru\": 11300, \"Tuvalu\": 11300, ... \"Anguilla\": 11300, \"Montserrat\": 5200} >>> s = pd.Series(countries_population) >>> s Italy 59000000 France 65000000 Malta 434000 Maldives 434000 Brunei 434000 Iceland 337000 Nauru 11300 Tuvalu 11300 Anguilla 11300 Montserrat 5200 dtype: int64 The n largest elements where n=5 by default. >>> s.nlargest() France 65000000 Italy 59000000 Malta 434000 Maldives 434000 Brunei 434000 dtype: int64 The n largest elements where n=3. Default keep value is ‘first’ so Malta will be kept. >>> s.nlargest(3) France 65000000 Italy 59000000 Malta 434000 dtype: int64 The n largest elements where n=3 and keeping the last duplicates. Brunei will be kept since it is the last with value 434000 based on the index order. >>> s.nlargest(3, keep='last') France 65000000 Italy 59000000 Brunei 434000 dtype: int64 The n largest elements where n=3 with all duplicates kept. Note that the returned Series has five elements due to the three duplicates. >>> s.nlargest(3, keep='all') France 65000000 Italy 59000000 Malta 434000 Maldives 434000 Brunei 434000 dtype: int64", "score": "0.67181313"}, {"id": "21776", "text": "Function: python.library.math\nSnippet: (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9. Note that frexp() and modf() have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 2**52 necessarily has no fractional bits. Power and logarithmic functions math.exp(x) Return e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). math.expm1(x) Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision: >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.0000050000069649e-05 >>> expm1(1e-5) # result accurate to full precision 1.0000050000166668e-05 New in version 3.2. math.log(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). math.log1p(x) Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. math.log2(x) Return the base-2 logarithm of x. This is usually more accurate than log(x, 2). New in version 3.3. See also int.bit_length() returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. math.log10(x) Return the base-10 logarithm of x. This is usually more accurate than log(x, 10). math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", "score": "0.65715927"}]}
{"task_id": "humaneval_95", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "entry_point": "check_dict_case", "gold_generation": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "context": "Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.", "function_name": "def check_dict_case(dict):", "ctxs": [{"id": "24361", "text": "Function: python.library.stdtypes#str.isupper\nSnippet: str.isupper() Return True if all cased characters 4 in the string are uppercase and there is at least one cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False", "score": "0.80028415"}, {"id": "24356", "text": "Function: python.library.stdtypes#str.islower\nSnippet: str.islower() Return True if all cased characters 4 in the string are lowercase and there is at least one cased character, False otherwise.", "score": "0.7638341"}, {"id": "41736", "text": "Function: numpy.reference.generated.numpy.char.isupper\nSnippet: numpy.char.isupper char.isupper(a)[source] Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. Call str.isupper element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like of str or unicode Returns outndarray Output array of bools See also str.isupper", "score": "0.7613007"}, {"id": "24384", "text": "Function: python.library.stdtypes#str.upper\nSnippet: str.upper() Return a copy of the string with all the cased characters 4 converted to uppercase. Note that s.upper().isupper() might be False if s contains uncased characters or if the Unicode category of the resulting character(s) is not “Lu” (Letter, uppercase), but e.g. “Lt” (Letter, titlecase). The uppercasing algorithm used is described in section 3.13 of the Unicode Standard.", "score": "0.7597541"}, {"id": "41669", "text": "Function: numpy.reference.generated.numpy.char.chararray.isupper\nSnippet: numpy.char.chararray.isupper method char.chararray.isupper()[source] Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. See also char.isupper", "score": "0.75680125"}]}
{"task_id": "humaneval_96", "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n", "entry_point": "count_up_to", "gold_generation": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n", "context": "Implement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    for example:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]", "function_name": "def count_up_to(n):", "ctxs": [{"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.71236366"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.7072456"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6974163"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.68235385"}, {"id": "21304", "text": "Function: python.library.itertools#itertools.count\nSnippet: itertools.count(start=0, step=1) Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to: def count(start=0, step=1): # count(10) --> 10 11 12 13 14 ... # count(2.5, 0.5) -> 2.5 3.0 3.5 ... n = start while True: yield n n += step When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). Changed in version 3.1: Added step argument and allowed non-integer arguments.", "score": "0.679873"}]}
{"task_id": "humaneval_97", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n", "entry_point": "multiply", "gold_generation": "    return abs(a % 10) * abs(b % 10)\n", "context": "Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.", "function_name": "def multiply(a, b):", "ctxs": [{"id": "19495", "text": "Function: python.library.decimal#decimal.Context.multiply\nSnippet: multiply(x, y) Return the product of x and y.", "score": "0.76167"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.71065557"}, {"id": "21826", "text": "Function: python.library.math#math.prod\nSnippet: math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8.", "score": "0.6823817"}, {"id": "19448", "text": "Function: python.library.decimal#decimal.Context\nSnippet: operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x - y * n, where n is the integer nearest the exact value of x / y (if the result is 0 then its sign will be the sign of x). rotate(x, y) Returns a rotated copy of x, y times. same_quantum(x, y) Returns True if the two operands have the same exponent. scaleb(x, y) Returns the first operand after adding the second value its exp. shift(x, y) Returns a shifted copy of x, y times. sqrt(x) Square root of a non-negative number to context precision. subtract(x, y) Return the difference between x and y. to_eng_string(x) Convert to a string, using engineering", "score": "0.676867"}, {"id": "21776", "text": "Function: python.library.math\nSnippet: (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9. Note that frexp() and modf() have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 2**52 necessarily has no fractional bits. Power and logarithmic functions math.exp(x) Return e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). math.expm1(x) Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision: >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.0000050000069649e-05 >>> expm1(1e-5) # result accurate to full precision 1.0000050000166668e-05 New in version 3.2. math.log(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). math.log1p(x) Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. math.log2(x) Return the base-2 logarithm of x. This is usually more accurate than log(x, 2). New in version 3.3. See also int.bit_length() returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. math.log10(x) Return the base-10 logarithm of x. This is usually more accurate than log(x, 10). math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", "score": "0.6730206"}]}
{"task_id": "humaneval_98", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "count_upper", "gold_generation": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n", "context": "Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0", "function_name": "def count_upper(s):", "ctxs": [{"id": "24361", "text": "Function: python.library.stdtypes#str.isupper\nSnippet: str.isupper() Return True if all cased characters 4 in the string are uppercase and there is at least one cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False", "score": "0.73026687"}, {"id": "24384", "text": "Function: python.library.stdtypes#str.upper\nSnippet: str.upper() Return a copy of the string with all the cased characters 4 converted to uppercase. Note that s.upper().isupper() might be False if s contains uncased characters or if the Unicode category of the resulting character(s) is not “Lu” (Letter, uppercase), but e.g. “Lt” (Letter, titlecase). The uppercasing algorithm used is described in section 3.13 of the Unicode Standard.", "score": "0.7284127"}, {"id": "41736", "text": "Function: numpy.reference.generated.numpy.char.isupper\nSnippet: numpy.char.isupper char.isupper(a)[source] Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. Call str.isupper element-wise. For 8-bit strings, this method is locale-dependent. Parameters aarray_like of str or unicode Returns outndarray Output array of bools See also str.isupper", "score": "0.7258335"}, {"id": "41669", "text": "Function: numpy.reference.generated.numpy.char.chararray.isupper\nSnippet: numpy.char.chararray.isupper method char.chararray.isupper()[source] Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. See also char.isupper", "score": "0.7218732"}, {"id": "24401", "text": "Function: python.library.string#string.ascii_uppercase\nSnippet: string.ascii_uppercase The uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. This value is not locale-dependent and will not change.", "score": "0.72103333"}]}
{"task_id": "humaneval_99", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "entry_point": "closest_integer", "gold_generation": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "context": "", "function_name": "def closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015749"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49312225"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.49104327"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48984405"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.48983365"}]}
{"task_id": "humaneval_100", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "make_a_pile", "gold_generation": "    return [n + 2*i for i in range(n)]\n", "context": "Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]", "function_name": "def make_a_pile(n):", "ctxs": [{"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.67946565"}, {"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.6724448"}, {"id": "43141", "text": "Function: numpy.reference.generated.numpy.ravel\nSnippet: 3, 4, 5, 6, 7, 8, 9, 10, 11])", "score": "0.6689456"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6685606"}, {"id": "23267", "text": "Function: python.library.random\nSnippet: the same sequence when the compatible seeder is given the same seed. Examples Basic examples: >>> random() # Random float: 0.0 <= x < 1.0 0.37444887175646646 >>> uniform(2.5, 10.0) # Random float: 2.5 <= x < 10.0 3.1800146073117523 >>> expovariate(1 / 5) # Interval between arrivals averaging 5 seconds 5.148957571865031 >>> randrange(10) # Integer from 0 to 9 inclusive 7 >>> randrange(0, 101, 2) # Even integer from 0 to 100 inclusive 26 >>> choice(['win', 'lose', 'draw']) # Single random element from a sequence 'draw' >>> deck = 'ace two three four'.split() >>> shuffle(deck) # Shuffle a list >>> deck ['four', 'two', 'ace', 'three'] >>> sample([10, 20, 30, 40, 50], k=4) # Four samples without replacement [40, 10, 50, 30] Simulations: >>> # Six roulette wheel spins (weighted sampling with replacement) >>> choices(['red', 'black', 'green'], [18, 18, 2], k=6) ['red', 'green', 'black', 'black', 'red', 'black'] >>> # Deal 20 cards without replacement from a deck >>> # of 52 playing cards, and determine the proportion of cards >>> # with a ten-value: ten, jack, queen, or king. >>> dealt = sample(['tens', 'low cards'], counts=[16, 36], k=20) >>> dealt.count('tens') / 20 0.15 >>> # Estimate the probability of getting 5 or more heads from 7 spins >>> # of a biased coin that settles on heads 60% of the time. >>> def trial(): ... return choices('HT', cum_weights=(0.60, 1.00), k=7).count('H') >= 5 ... >>> sum(trial() for i in range(10_000)) / 10_000 0.4169 >>> # Probability of the median of 5 samples being in middle two quartiles >>> def trial(): ... return 2_500 <= sorted(choices(range(10_000), k=5))[2] < 7_500 ... >>> sum(trial() for i in range(10_000)) / 10_000 0.7958 Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: # http://statistics.about.com/od/Applications/a/Example-Of-Bootstrapping.htm from statistics import fmean as mean from random import choices data = [41, 50, 29, 37, 81, 30, 73, 63, 20, 35, 68, 22, 60, 31, 95] means = sorted(mean(choices(data, k=len(data))) for i in range(100)) print(f'The sample mean of {mean(data):.1f} has a 90% confidence ' f'interval from {means[5]:.1f} to {means[94]:.1f}') Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson from statistics import fmean as mean from random import shuffle drug = [54, 73, 53, 70, 73, 68, 52, 65, 65] placebo = [54, 51, 58, 44, 55, 52, 42, 47, 58, 46] observed_diff = mean(drug) - mean(placebo) n = 10_000 count = 0 combined = drug + placebo for i in range(n): shuffle(combined) new_diff = mean(combined[:len(drug)]) - mean(combined[len(drug):]) count += (new_diff >= observed_diff) print(f'{n} label reshufflings produced only {count} instances with a difference') print(f'at least as extreme as the observed difference of {observed_diff:.1f}.') print(f'The one-sided p-value of {count / n:.4f} leads us to reject the null') print(f'hypothesis that there is no difference between the drug and the placebo.') Simulation of arrival times and service deliveries", "score": "0.66139567"}]}
{"task_id": "humaneval_101", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "entry_point": "words_string", "gold_generation": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "context": "You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]", "function_name": "def words_string(s):", "ctxs": [{"id": "41818", "text": "Function: numpy.reference.generated.numpy.chararray.split\nSnippet: numpy.chararray.split method chararray.split(sep=None, maxsplit=None)[source] For each element in self, return a list of the words in the string, using sep as the delimiter string. See also char.split", "score": "0.7800098"}, {"id": "41697", "text": "Function: numpy.reference.generated.numpy.char.chararray.split\nSnippet: numpy.char.chararray.split method char.chararray.split(sep=None, maxsplit=None)[source] For each element in self, return a list of the words in the string, using sep as the delimiter string. See also char.split", "score": "0.77781075"}, {"id": "41754", "text": "Function: numpy.reference.generated.numpy.char.split\nSnippet: numpy.char.split char.split(a, sep=None, maxsplit=None)[source] For each element in a, return a list of the words in the string, using sep as the delimiter string. Calls str.split element-wise. Parameters aarray_like of str or unicode sepstr or unicode, optional If sep is not specified or None, any whitespace string is a separator. maxsplitint, optional If maxsplit is given, at most maxsplit splits are done. Returns outndarray Array of list objects See also str.split, rsplit", "score": "0.7605126"}, {"id": "41811", "text": "Function: numpy.reference.generated.numpy.chararray.rsplit\nSnippet: numpy.chararray.rsplit method chararray.rsplit(sep=None, maxsplit=None)[source] For each element in self, return a list of the words in the string, using sep as the delimiter string. See also char.rsplit", "score": "0.75097287"}, {"id": "41689", "text": "Function: numpy.reference.generated.numpy.char.chararray.rsplit\nSnippet: numpy.char.chararray.rsplit method char.chararray.rsplit(sep=None, maxsplit=None)[source] For each element in self, return a list of the words in the string, using sep as the delimiter string. See also char.rsplit", "score": "0.75074756"}]}
{"task_id": "humaneval_102", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "entry_point": "choose_num", "gold_generation": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "context": "This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1", "function_name": "def choose_num(x, y):", "ctxs": [{"id": "21776", "text": "Function: python.library.math\nSnippet: (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9. Note that frexp() and modf() have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 2**52 necessarily has no fractional bits. Power and logarithmic functions math.exp(x) Return e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). math.expm1(x) Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision: >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.0000050000069649e-05 >>> expm1(1e-5) # result accurate to full precision 1.0000050000166668e-05 New in version 3.2. math.log(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). math.log1p(x) Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. math.log2(x) Return the base-2 logarithm of x. This is usually more accurate than log(x, 2). New in version 3.3. See also int.bit_length() returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. math.log10(x) Return the base-10 logarithm of x. This is usually more accurate than log(x, 10). math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", "score": "0.7435534"}, {"id": "19496", "text": "Function: python.library.decimal#decimal.Context.next_minus\nSnippet: next_minus(x) Returns the largest representable number smaller than x.", "score": "0.72843564"}, {"id": "19490", "text": "Function: python.library.decimal#decimal.Context.max\nSnippet: max(x, y) Compares two values numerically and returns the maximum.", "score": "0.72312516"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.72118086"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.7183616"}]}
{"task_id": "humaneval_103", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "entry_point": "rounded_avg", "gold_generation": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "context": "You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"", "function_name": "def rounded_avg(n, m):", "ctxs": [{"id": "19597", "text": "Function: python.library.decimal#decimal.ROUND_HALF_EVEN\nSnippet: decimal.ROUND_HALF_EVEN Round to nearest with ties going to nearest even integer.", "score": "0.7330171"}, {"id": "23466", "text": "Function: python.library.functions#round\nSnippet: round(number[, ndigits]) Return number rounded to ndigits precision after the decimal point. If ndigits is omitted or is None, it returns the nearest integer to its input. For the built-in types supporting round(), values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice (so, for example, both round(0.5) and round(-0.5) are 0, and round(1.5) is 2). Any integer value is valid for ndigits (positive, zero, or negative). The return value is an integer if ndigits is omitted or None. Otherwise the return value has the same type as number. For a general Python object number, round delegates to number.__round__. Note The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a bug: it’s a result of the fact that most decimal fractions can’t be represented exactly as a float. See Floating Point Arithmetic: Issues and Limitations for more information.", "score": "0.72892445"}, {"id": "19432", "text": "Function: python.library.decimal\nSnippet: be necessary. In this case, the rounding mode is determined by the rounding argument if given, else by the given context argument; if neither argument is given the rounding mode of the current thread’s context is used. An error is returned whenever the resulting exponent is greater than Emax or less than Etiny. radix() Return Decimal(10), the radix (base) in which the Decimal class does all its arithmetic. Included for compatibility with the specification. remainder_near(other, context=None) Return the remainder from dividing self by other. This differs from self % other in that the sign of the remainder is chosen so as to minimize its absolute value. More precisely, the return value is self - n * other where n is the integer nearest to the exact value of self / other, and if two integers are equally near then the even one is chosen. If the result is zero then its sign will be the sign of self. >>> Decimal(18).remainder_near(Decimal(10)) Decimal('-2') >>> Decimal(25).remainder_near(Decimal(10)) Decimal('5') >>> Decimal(35).remainder_near(Decimal(10)) Decimal('-5') rotate(other, context=None) Return the result of rotating the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to rotate. If the second operand is positive then rotation is to the left; otherwise rotation is to the right. The coefficient of the first operand is padded on the left with zeros to length precision if necessary. The sign and exponent of the first operand are unchanged. same_quantum(other, context=None) Test whether self and other have the same exponent or whether both are NaN. This operation is unaffected by context and is quiet: no flags are changed and no rounding is performed. As an exception, the C version may raise InvalidOperation if the second operand cannot be converted exactly. scaleb(other, context=None) Return the first operand with exponent adjusted by the second. Equivalently, return the first operand multiplied by 10**other. The second operand must be an integer. shift(other, context=None) Return the result of shifting the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to shift. If the second operand is positive then the shift is to the left; otherwise the shift is to the right. Digits shifted into the coefficient are zeros. The sign and exponent of the first operand are unchanged. sqrt(context=None) Return the square root of the argument to full precision. to_eng_string(context=None) Convert to a string, using engineering notation if an exponent is needed. Engineering notation has an exponent which is a multiple of 3. This can leave up to 3 digits to the left of the decimal place and may require the addition of either one or two trailing zeros. For example, this converts Decimal('123E+1') to Decimal('1.23E+3'). to_integral(rounding=None, context=None) Identical to the to_integral_value() method. The", "score": "0.72354853"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.7213096"}, {"id": "19519", "text": "Function: python.library.decimal#decimal.Decimal\nSnippet: logarithm of the operand. The result is correctly rounded using the ROUND_HALF_EVEN rounding mode. log10(context=None) Return the base ten logarithm of the operand. The result is correctly rounded using the ROUND_HALF_EVEN rounding mode. logb(context=None) For a nonzero number, return the adjusted exponent of its operand as a Decimal instance. If the operand is a zero then Decimal('-Infinity') is returned and the DivisionByZero flag is raised. If the operand is an infinity then Decimal('Infinity') is returned. logical_and(other, context=None) logical_and() is a logical operation which takes two logical operands (see Logical operands). The result is the digit-wise and of the two operands. logical_invert(context=None) logical_invert() is a logical operation. The result is the digit-wise inversion of the operand. logical_or(other, context=None) logical_or() is a logical operation which takes two logical operands (see Logical operands). The result is the digit-wise or of the two operands. logical_xor(other, context=None) logical_xor() is a logical operation which takes two logical operands (see Logical operands). The result is the digit-wise exclusive or of the two operands. max(other, context=None) Like max(self, other) except that the context rounding rule is applied before returning and that NaN values are either signaled or ignored (depending on the context and whether they are signaling or quiet). max_mag(other, context=None) Similar to the max() method, but the comparison is done using the absolute values of the operands. min(other, context=None) Like min(self, other) except that the context rounding rule is applied before returning and that NaN values are either signaled or ignored (depending on the context and whether they are signaling or quiet). min_mag(other, context=None) Similar to the min() method, but the comparison is done using the absolute values of the operands. next_minus(context=None) Return the largest number representable in the given context (or in the current thread’s context if no context is given) that is smaller than the given operand. next_plus(context=None) Return the smallest number representable in the given context (or in the current thread’s context if no context is given) that is larger than the given operand. next_toward(other, context=None) If the two operands are unequal, return the number closest to the first operand in the direction of the second operand. If both operands are numerically equal, return a copy of the first operand with the sign set to be the same as the sign of the second operand. normalize(context=None) Normalize the number by stripping the rightmost trailing zeros and converting any result equal to Decimal('0') to Decimal('0e0'). Used for producing canonical values for attributes of an equivalence class. For example, Decimal('32.100') and Decimal('0.321000e+2') both normalize to the equivalent value Decimal('32.1'). number_class(context=None) Return a string describing the class of the operand. The returned value is one of the following ten strings. \"-Infinity\", indicating that the operand is negative infinity. \"-Normal\", indicating that the operand is a negative normal number. \"-Subnormal\", indicating that the operand is negative and subnormal. \"-Zero\", indicating that the operand is a negative zero. \"+Zero\", indicating that the operand is a positive zero. \"+Subnormal\", indicating that the operand is positive and subnormal. \"+Normal\", indicating that", "score": "0.71911716"}]}
{"task_id": "humaneval_104", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "unique_digits", "gold_generation": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n", "context": "Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []", "function_name": "def unique_digits(x):", "ctxs": [{"id": "14770", "text": "Function: pandas.reference.api.pandas.index.unique\nSnippet: pandas.Index.unique Index.unique(level=None)[source] Return unique values in the index. Unique values are returned in order of appearance, this does NOT sort. Parameters level:int or hashable, optional Only return values from specified level (for MultiIndex). If int, gets the level by integer position, else by level name. Returns Index See also unique Numpy array of unique values in that column. Series.unique Return unique values of Series object.", "score": "0.7049675"}, {"id": "43259", "text": "Function: numpy.reference.generated.numpy.unique\nSnippet: numpy.unique numpy.unique(ar, return_index=False, return_inverse=False, return_counts=False, axis=None)[source] Find the unique elements of an array. Returns the sorted unique elements of an array. There are three optional outputs in addition to the unique elements: the indices of the input array that give the unique values the indices of the unique array that reconstruct the input array the number of times each unique value comes up in the input array Parameters ararray_like Input array. Unless axis is specified, this will be flattened if it is not already 1-D. return_indexbool, optional If True, also return the indices of ar (along the specified axis, if provided, or in the flattened array) that result in the unique array. return_inversebool, optional If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct ar. return_countsbool, optional If True, also return the number of times each unique item appears in ar. New in version 1.9.0. axisint or None, optional The axis to operate on. If None, ar will be flattened. If an integer, the subarrays indexed by the given axis will be flattened and treated as the elements of a 1-D array with the dimension of the given axis, see the notes for more details. Object arrays or structured arrays that contain objects are not supported if the axis kwarg is used. The default is None. New in version 1.13.0. Returns uniquendarray The sorted unique values. unique_indicesndarray, optional The indices of the first occurrences of the unique values in the original array. Only provided if return_index is True. unique_inversendarray, optional The indices to reconstruct the original array from the unique array. Only provided if return_inverse is True. unique_countsndarray, optional The number of times each of the unique values comes up in the original array. Only provided if return_counts is True. New in version 1.9.0. See also numpy.lib.arraysetops Module with a number of other functions for performing set operations on arrays. repeat Repeat elements of an array. Notes When an axis is specified the subarrays indexed by the axis are sorted. This is done by making the specified axis the first dimension of the array (move the axis to the first dimension to keep the order of the other axes) and then flattening the subarrays in C order. The flattened subarrays are then viewed as a structured type with each element given a label, with the effect that we end up with a 1-D array of structured types that can be treated in the same way as any other 1-D array. The result is that the flattened subarrays are sorted in lexicographic order starting with the first element. Examples >>> np.unique([1, 1, 2, 2, 3, 3]) array([1, 2, 3]) >>> a = np.array([[1, 1], [2, 3]]) >>> np.unique(a) array([1, 2, 3]) Return the unique rows of a 2D array >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]]) >>> np.unique(a, axis=0) array([[1, 0, 0], [2, 3, 4]]) Return the indices of the original array that give", "score": "0.6910799"}, {"id": "43260", "text": "Function: numpy.reference.generated.numpy.unique\nSnippet: the unique values: >>> a = np.array(['a', 'b', 'b', 'c', 'a']) >>> u, indices = np.unique(a, return_index=True) >>> u array(['a', 'b', 'c'], dtype='<U1') >>> indices array([0, 1, 3]) >>> a[indices] array(['a', 'b', 'c'], dtype='<U1') Reconstruct the input array from the unique values and inverse: >>> a = np.array([1, 2, 6, 4, 2, 3, 2]) >>> u, indices = np.unique(a, return_inverse=True) >>> u array([1, 2, 3, 4, 6]) >>> indices array([0, 1, 4, 3, 1, 2, 1]) >>> u[indices] array([1, 2, 6, 4, 2, 3, 2]) Reconstruct the input values from the unique values and counts: >>> a = np.array([1, 2, 6, 4, 2, 3, 2]) >>> values, counts = np.unique(a, return_counts=True) >>> values array([1, 2, 3, 4, 6]) >>> counts array([1, 3, 1, 1, 1]) >>> np.repeat(values, counts) array([1, 2, 2, 2, 3, 4, 6]) # original order not preserved", "score": "0.6880647"}, {"id": "15416", "text": "Function: pandas.reference.api.pandas.series.unique\nSnippet: pandas.Series.unique Series.unique()[source] Return unique values of Series object. Uniques are returned in order of appearance. Hash table-based unique, therefore does NOT sort. Returns ndarray or ExtensionArray The unique values returned as a NumPy array. See Notes. See also unique Top-level unique method for any 1-d array-like object. Index.unique Return Index with unique values from an Index object. Notes Returns the unique values as a NumPy array. In case of an extension-array backed Series, a new ExtensionArray of that type with just the unique values is returned. This includes Categorical Period Datetime with Timezone Interval Sparse IntegerNA See Examples section. Examples >>> pd.Series([2, 1, 3, 3], name='A').unique() array([2, 1, 3]) >>> pd.Series([pd.Timestamp('2016-01-01') for _ in range(3)]).unique() array(['2016-01-01T00:00:00.000000000'], dtype='datetime64[ns]') >>> pd.Series([pd.Timestamp('2016-01-01', tz='US/Eastern') ... for _ in range(3)]).unique() <DatetimeArray> ['2016-01-01 00:00:00-05:00'] Length: 1, dtype: datetime64[ns, US/Eastern] An Categorical will return categories in the order of appearance and with the same dtype. >>> pd.Series(pd.Categorical(list('baabc'))).unique() ['b', 'a', 'c'] Categories (3, object): ['a', 'b', 'c'] >>> pd.Series(pd.Categorical(list('baabc'), categories=list('abc'), ... ordered=True)).unique() ['b', 'a', 'c'] Categories (3, object): ['a' < 'b' < 'c']", "score": "0.68188846"}, {"id": "8201", "text": "Function: torch.generated.torch.unique#torch.unique\nSnippet: torch.unique(*args, **kwargs) Returns the unique elements of the input tensor. Note This function is different from torch.unique_consecutive() in the sense that this function also eliminates non-consecutive duplicate values. Note Currently in the CUDA implementation and the CPU implementation when dim is specified, torch.unique always sort the tensor at the beginning regardless of the sort argument. Sorting could be slow, so if your input tensor is already sorted, it is recommended to use torch.unique_consecutive() which avoids the sorting. Parameters input (Tensor) – the input tensor sorted (bool) – Whether to sort the unique elements in ascending order before returning as output. return_inverse (bool) – Whether to also return the indices for where elements in the original input ended up in the returned unique list. return_counts (bool) – Whether to also return the counts for each unique element. dim (int) – the dimension to apply unique. If None, the unique of the flattened input is returned. default: None Returns A tensor or a tuple of tensors containing output (Tensor): the output list of unique scalar elements. inverse_indices (Tensor): (optional) if return_inverse is True, there will be an additional returned tensor (same shape as input) representing the indices for where elements in the original input map to in the output; otherwise, this function will only return a single tensor. counts (Tensor): (optional) if return_counts is True, there will be an additional returned tensor (same shape as output or output.size(dim), if dim was specified) representing the number of occurrences for each unique value or tensor. Return type (Tensor, Tensor (optional), Tensor (optional)) Example: >>> output = torch.unique(torch.tensor([1, 3, 2, 3], dtype=torch.long)) >>> output tensor([ 2, 3, 1]) >>> output, inverse_indices = torch.unique( ... torch.tensor([1, 3, 2, 3], dtype=torch.long), sorted=True, return_inverse=True) >>> output tensor([ 1, 2, 3]) >>> inverse_indices tensor([ 0, 2, 1, 2]) >>> output, inverse_indices = torch.unique( ... torch.tensor([[1, 3], [2, 3]], dtype=torch.long), sorted=True, return_inverse=True) >>> output tensor([ 1, 2, 3]) >>> inverse_indices tensor([[ 0, 2], [ 1, 2]])", "score": "0.6783922"}]}
{"task_id": "humaneval_105", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n", "entry_point": "by_length", "gold_generation": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n", "context": "Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n      If the array is empty, return an empty array:\n      arr = []\n      return []\n    \n      If the array has any strange number ignore it:\n      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n      return = ['One']", "function_name": "def by_length(arr):", "ctxs": [{"id": "17643", "text": "Function: python.library.array#array.array.reverse\nSnippet: array.reverse() Reverse the order of the items in the array.", "score": "0.7352115"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.7211821"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.7137727"}, {"id": "41696", "text": "Function: numpy.reference.generated.numpy.char.chararray.sort\nSnippet: numpy.char.chararray.sort method char.chararray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.70339465"}, {"id": "43877", "text": "Function: numpy.reference.generated.numpy.recarray.sort\nSnippet: numpy.recarray.sort method recarray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.70196164"}]}
{"task_id": "humaneval_106", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "entry_point": "f", "gold_generation": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "context": "Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]", "function_name": "def f(n):", "ctxs": [{"id": "21799", "text": "Function: python.library.math#math.factorial\nSnippet: math.factorial(x) Return x factorial as an integer. Raises ValueError if x is not integral or is negative. Deprecated since version 3.9: Accepting floats with integral values (like 5.0) is deprecated.", "score": "0.74337566"}, {"id": "21773", "text": "Function: python.library.math\nSnippet: math — Mathematical functions This module provides access to the mathematical functions defined by the C standard. These functions cannot be used with complex numbers; use the functions of the same name from the cmath module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don’t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place. The following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats. Number-theoretic and representation functions math.ceil(x) Return the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to x.__ceil__(), which should return an Integral value. math.comb(n, k) Return the number of ways to choose k items from n items without repetition and without order. Evaluates to n! / (k! * (n - k)!) when k <= n and evaluates to zero when k > n. Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of the expression (1 + x) ** n. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.copysign(x, y) Return a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, copysign(1.0, -0.0) returns -1.0. math.fabs(x) Return the absolute value of x. math.factorial(x) Return x factorial as an integer. Raises ValueError if x is not integral or is negative. Deprecated since version 3.9: Accepting floats with integral values (like 5.0) is deprecated. math.floor(x) Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to x.__floor__(), which should return an Integral value. math.fmod(x, y) Return fmod(x, y), as defined by the platform C library. Note that the Python expression x % y may not return the same result. The intent of the C standard is that fmod(x, y) be exactly (mathematically; to infinite precision) equal to x - n*y for some integer n such that the result has the same sign as x and magnitude less than abs(y). Python’s x % y returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, fmod(-1e-100, 1e100) is -1e-100, but the result of Python’s -1e-100 % 1e100 is 1e100-1e-100, which cannot be represented exactly as a float, and rounds to the surprising 1e100. For this reason, function fmod() is generally preferred when working with floats, while Python’s x % y is preferred when working with integers. math.frexp(x) Return the mantissa and exponent of x as the pair (m, e).", "score": "0.70596826"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.70223725"}, {"id": "1194", "text": "Function: tensorflow.compat.v1.scan\nSnippet: packs the results of applying fn to tensors unpacked from elems along the first dimension, and the previous accumulator value(s), from first to last (or last to first, if reverse=True). Raises TypeError if fn is not callable or the structure of the output of fn and initializer do not match. ValueError if the lengths of the output of fn and initializer do not match. Examples: elems = np.array([1, 2, 3, 4, 5, 6]) sum = scan(lambda a, x: a + x, elems) # sum == [1, 3, 6, 10, 15, 21] sum = scan(lambda a, x: a + x, elems, reverse=True) # sum == [21, 20, 18, 15, 11, 6] elems = np.array([1, 2, 3, 4, 5, 6]) initializer = np.array(0) sum_one = scan( lambda a, x: x[0] - x[1] + a, (elems + 1, elems), initializer) # sum_one == [1, 2, 3, 4, 5, 6] elems = np.array([1, 0, 0, 0, 0, 0]) initializer = (np.array(0), np.array(1)) fibonaccis = scan(lambda a, _: (a[1], a[0] + a[1]), elems, initializer) # fibonaccis == ([1, 1, 2, 3, 5, 8], [1, 2, 3, 5, 8, 13])", "score": "0.6840696"}, {"id": "21787", "text": "Function: python.library.math#math.comb\nSnippet: math.comb(n, k) Return the number of ways to choose k items from n items without repetition and without order. Evaluates to n! / (k! * (n - k)!) when k <= n and evaluates to zero when k > n. Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of the expression (1 + x) ** n. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.68203485"}]}
{"task_id": "humaneval_107", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "even_odd_palindrome", "gold_generation": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "context": "Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.", "function_name": "def even_odd_palindrome(n):", "ctxs": [{"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6782791"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6547987"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.65327203"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.6523652"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6513648"}]}
{"task_id": "humaneval_108", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "count_nums", "gold_generation": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n", "context": "Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3", "function_name": "def count_nums(arr):", "ctxs": [{"id": "42119", "text": "Function: numpy.reference.generated.numpy.ma.count\nSnippet: numpy.ma.count ma.count(self, axis=None, keepdims=<no value>) = <numpy.ma.core._frommethod object> Count the non-masked elements of the array along the given axis. Parameters axisNone or int or tuple of ints, optional Axis or axes along which the count is performed. The default, None, performs the count over all the dimensions of the input array. axis may be negative, in which case it counts from the last to the first axis. New in version 1.10.0. If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before. keepdimsbool, optional If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array. Returns resultndarray or scalar An array with the same shape as the input array, with the specified axis removed. If the array is a 0-d array, or if axis is None, a scalar is returned. See also ma.count_masked Count masked elements in array or along a given axis. Examples >>> import numpy.ma as ma >>> a = ma.arange(6).reshape((2, 3)) >>> a[1, :] = ma.masked >>> a masked_array( data=[[0, 1, 2], [--, --, --]], mask=[[False, False, False], [ True, True, True]], fill_value=999999) >>> a.count() 3 When the axis keyword is specified an array of appropriate size is returned. >>> a.count(axis=0) array([1, 1, 1]) >>> a.count(axis=1) array([3, 0])", "score": "0.7318583"}, {"id": "25732", "text": "Function: python.library.stdtypes\nSnippet: there were an infinite number of sign bits. Additional Methods on Integer Types The int type implements the numbers.Integral abstract base class. In addition, it provides a few more methods: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1. int.to_bytes(length, byteorder, *, signed=False) Return an array of bytes representing an integer. >>> (1024).to_bytes(2, byteorder='big') b'\\x04\\x00' >>> (1024).to_bytes(10, byteorder='big') b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00' >>> (-1024).to_bytes(10, byteorder='big', signed=True) b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00' >>> x = 1000 >>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little') b'\\xe8\\x03' The integer is represented using length bytes. An OverflowError is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument determines whether two’s complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. The default value for signed is False. New in version 3.2. classmethod int.from_bytes(bytes, byteorder, *, signed=False) Return the integer represented by the given array of bytes. >>> int.from_bytes(b'\\x00\\x10', byteorder='big') 16 >>> int.from_bytes(b'\\x00\\x10', byteorder='little') 4096 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True) -1024 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False) 64512 >>> int.from_bytes([255, 0, 0], byteorder='big') 16711680 The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. New in version 3.2. int.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original integer and with a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. New in version 3.8. Additional Methods on Float The float type implements the numbers.Real abstract base class. float also has the following additional methods. float.as_integer_ratio() Return a pair of integers whose", "score": "0.7258123"}, {"id": "42662", "text": "Function: numpy.reference.generated.numpy.bincount\nSnippet: numpy.bincount numpy.bincount(x, /, weights=None, minlength=0) Count number of occurrences of each value in array of non-negative ints. The number of bins (of size 1) is one larger than the largest value in x. If minlength is specified, there will be at least this number of bins in the output array (though it will be longer if necessary, depending on the contents of x). Each bin gives the number of occurrences of its index value in x. If weights is specified the input array is weighted by it, i.e. if a value n is found at position i, out[n] += weight[i] instead of out[n] += 1. Parameters xarray_like, 1 dimension, nonnegative ints Input array. weightsarray_like, optional Weights, array of the same shape as x. minlengthint, optional A minimum number of bins for the output array. New in version 1.6.0. Returns outndarray of ints The result of binning the input array. The length of out is equal to np.amax(x)+1. Raises ValueError If the input is not 1-dimensional, or contains elements with negative values, or if minlength is negative. TypeError If the type of the input is float or complex. See also histogram, digitize, unique Examples >>> np.bincount(np.arange(5)) array([1, 1, 1, 1, 1]) >>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7])) array([1, 3, 1, 1, 0, 0, 0, 1]) >>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23]) >>> np.bincount(x).size == np.amax(x)+1 True The input array needs to be of integer dtype, otherwise a TypeError is raised: >>> np.bincount(np.arange(5, dtype=float)) Traceback (most recent call last): ... TypeError: Cannot cast array data from dtype('float64') to dtype('int64') according to the rule 'safe' A possible use of bincount is to perform sums over variable-size chunks of an array, using the weights keyword. >>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights >>> x = np.array([0, 1, 1, 2, 2, 2]) >>> np.bincount(x, weights=w) array([ 0.3, 0.7, 1.1])", "score": "0.7182692"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.71799695"}, {"id": "41718", "text": "Function: numpy.reference.generated.numpy.char.count\nSnippet: numpy.char.count char.count(a, sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. Calls str.count element-wise. Parameters aarray_like of str or unicode substr or unicode The substring to search for. start, endint, optional Optional arguments start and end are interpreted as slice notation to specify the range in which to count. Returns outndarray Output array of ints. See also str.count Examples >>> c = np.array(['aAaAaA', ' aA ', 'abBABba']) >>> c array(['aAaAaA', ' aA ', 'abBABba'], dtype='<U7') >>> np.char.count(c, 'A') array([3, 1, 1]) >>> np.char.count(c, 'aA') array([3, 1, 0]) >>> np.char.count(c, 'A', start=1, end=4) array([2, 1, 1]) >>> np.char.count(c, 'A', start=1, end=3) array([1, 0, 0])", "score": "0.71687484"}]}
{"task_id": "humaneval_109", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "entry_point": "move_one_ball", "gold_generation": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "context": "We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.", "function_name": "def move_one_ball(arr):", "ctxs": [{"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.7270436"}, {"id": "43877", "text": "Function: numpy.reference.generated.numpy.recarray.sort\nSnippet: numpy.recarray.sort method recarray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.7269118"}, {"id": "43195", "text": "Function: numpy.reference.generated.numpy.sort\nSnippet: numpy.sort numpy.sort(a, axis=- 1, kind=None, order=None)[source] Return a sorted copy of an array. Parameters aarray_like Array to be sorted. axisint or None, optional Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort or radix sort under the covers and, in general, the actual implementation will vary with data type. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0.: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. Returns sorted_arrayndarray Array of the same type and shape as a. See also ndarray.sort Method to sort an array in-place. argsort Indirect sort. lexsort Indirect stable sort on multiple keys. searchsorted Find elements in a sorted array. partition Partial sort. Notes The various sorting algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The four algorithms implemented in NumPy have the following properties: kind speed worst case work space stable ‘quicksort’ 1 O(n^2) 0 no ‘heapsort’ 3 O(n*log(n)) 0 no ‘mergesort’ 2 O(n*log(n)) ~n/2 yes ‘timsort’ 2 O(n*log(n)) ~n/2 yes Note The datatype determines which of ‘mergesort’ or ‘timsort’ is actually used, even if ‘mergesort’ is specified. User selection at a finer scale is not currently available. All the sort algorithms make temporary copies of the data when sorting along any but the last axis. Consequently, sorting along the last axis is faster and uses less space than sorting along any other axis. The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts. Previous to numpy 1.4.0 sorting real and complex arrays containing nan values led to undefined behaviour. In numpy versions >= 1.4.0 nan values are sorted to the end. The extended sort order is: Real: [R, nan] Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj] where R is a non-nan real value. Complex values with the same nan placements are sorted according to the non-nan part if it exists. Non-nan values are sorted as before. New in version 1.12.0. quicksort has been changed to introsort. When sorting does not make enough progress it switches to heapsort. This implementation makes quicksort O(n*log(n)) in the worst case. ‘stable’ automatically chooses the best stable sorting algorithm for the data type being", "score": "0.72601205"}, {"id": "42565", "text": "Function: numpy.reference.generated.numpy.ndarray.sort\nSnippet: numpy.ndarray.sort method ndarray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.7241324"}, {"id": "43158", "text": "Function: numpy.reference.generated.numpy.right_shift\nSnippet: numpy.right_shift numpy.right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'right_shift'> Shift the bits of an integer to the right. Bits are shifted to the right x2. Because the internal representation of numbers is in binary format, this operation is equivalent to dividing x1 by 2**x2. Parameters x1array_like, int Input values. x2array_like, int Number of bits to remove at the right of x1. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outndarray, int Return x1 with bits shifted x2 times to the right. This is a scalar if both x1 and x2 are scalars. See also left_shift Shift the bits of an integer to the left. binary_repr Return the binary representation of the input number as a string. Examples >>> np.binary_repr(10) '1010' >>> np.right_shift(10, 1) 5 >>> np.binary_repr(5) '101' >>> np.right_shift(10, [1,2,3]) array([5, 2, 1]) The >> operator can be used as a shorthand for np.right_shift on ndarrays. >>> x1 = 10 >>> x2 = np.array([1,2,3]) >>> x1 >> x2 array([5, 2, 1])", "score": "0.7231581"}]}
{"task_id": "humaneval_110", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "entry_point": "exchange", "gold_generation": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "context": "In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.", "function_name": "def exchange(lst1, lst2):", "ctxs": [{"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.69329417"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.6889012"}, {"id": "23564", "text": "Function: python.library.stdtypes#set\nSnippet: and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem.", "score": "0.68575966"}, {"id": "20215", "text": "Function: python.library.stdtypes#frozenset\nSnippet: and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem.", "score": "0.68244404"}, {"id": "21862", "text": "Function: python.library.stdtypes#memoryview.__eq__\nSnippet: __eq__(exporter) A memoryview and a PEP 3118 exporter are equal if their shapes are equivalent and if all corresponding values are equal when the operands’ respective format codes are interpreted using struct syntax. For the subset of struct format strings currently supported by tolist(), v and w are equal if v.tolist() == w.tolist(): >>> import array >>> a = array.array('I', [1, 2, 3, 4, 5]) >>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0]) >>> c = array.array('b', [5, 3, 1]) >>> x = memoryview(a) >>> y = memoryview(b) >>> x == a == y == b True >>> x.tolist() == a.tolist() == y.tolist() == b.tolist() True >>> z = y[::-2] >>> z == c True >>> z.tolist() == c.tolist() True If either format string is not supported by the struct module, then the objects will always compare as unequal (even if the format strings and buffer contents are identical): >>> from ctypes import BigEndianStructure, c_long >>> class BEPoint(BigEndianStructure): ... _fields_ = [(\"x\", c_long), (\"y\", c_long)] ... >>> point = BEPoint(100, 200) >>> a = memoryview(point) >>> b = memoryview(point) >>> a == point False >>> a == b False Note that, as with floating point numbers, v is w does not imply v == w for memoryview objects. Changed in version 3.3: Previous versions compared the raw memory disregarding the item format and the logical array structure.", "score": "0.67611134"}]}
{"task_id": "humaneval_111", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n", "entry_point": "histogram", "gold_generation": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n", "context": "Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}", "function_name": "def histogram(test):", "ctxs": [{"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.6976075"}, {"id": "41768", "text": "Function: numpy.reference.generated.numpy.chararray.count\nSnippet: numpy.chararray.count method chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.6975802"}, {"id": "41718", "text": "Function: numpy.reference.generated.numpy.char.count\nSnippet: numpy.char.count char.count(a, sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. Calls str.count element-wise. Parameters aarray_like of str or unicode substr or unicode The substring to search for. start, endint, optional Optional arguments start and end are interpreted as slice notation to specify the range in which to count. Returns outndarray Output array of ints. See also str.count Examples >>> c = np.array(['aAaAaA', ' aA ', 'abBABba']) >>> c array(['aAaAaA', ' aA ', 'abBABba'], dtype='<U7') >>> np.char.count(c, 'A') array([3, 1, 1]) >>> np.char.count(c, 'aA') array([3, 1, 0]) >>> np.char.count(c, 'A', start=1, end=4) array([2, 1, 1]) >>> np.char.count(c, 'A', start=1, end=3) array([1, 0, 0])", "score": "0.6975718"}, {"id": "41643", "text": "Function: numpy.reference.generated.numpy.char.chararray.count\nSnippet: numpy.char.chararray.count method char.chararray.count(sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. See also char.count", "score": "0.69741845"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.6895419"}]}
{"task_id": "humaneval_112", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "entry_point": "reverse_delete", "gold_generation": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "context": "Task\n    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True/False for the check.\n    Example\n    For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n    For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n    For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)", "function_name": "def reverse_delete(s,c):", "ctxs": [{"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.7043261"}, {"id": "25746", "text": "Function: python.library.stdtypes\nSnippet: Return -1 on failure. str.rindex(sub[, start[, end]]) Like rfind() but raises ValueError when the substring sub is not found. str.rjust(width[, fillchar]) Return the string right justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.rpartition(sep) Split the string at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself. str.rsplit(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any whitespace string is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below. str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty' str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3'] str.splitlines([keepends]) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. This", "score": "0.701433"}, {"id": "23315", "text": "Function: python.library.re\nSnippet: ['carefully', 'quickly'] Finding all Adverbs and their Positions If one wants more information about all matches of a pattern than the matched text, finditer() is useful as it provides match objects instead of strings. Continuing with the previous example, if a writer wanted to find all of the adverbs and their positions in some text, they would use finditer() in the following manner: >>> text = \"He was carefully disguised but captured quickly by police.\" >>> for m in re.finditer(r\"\\w+ly\", text): ... print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0))) 07-16: carefully 40-47: quickly Raw String Notation Raw string notation (r\"text\") keeps regular expressions sane. Without it, every backslash ('\\') in a regular expression would have to be prefixed with another one to escape it. For example, the two following lines of code are functionally identical: >>> re.match(r\"\\W(.)\\1\\W\", \" ff \") <re.Match object; span=(0, 4), match=' ff '> >>> re.match(\"\\\\W(.)\\\\1\\\\W\", \" ff \") <re.Match object; span=(0, 4), match=' ff '> When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, this means r\"\\\\\". Without raw string notation, one must use \"\\\\\\\\\", making the following lines of code functionally identical: >>> re.match(r\"\\\\\", r\"\\\\\") <re.Match object; span=(0, 1), match='\\\\'> >>> re.match(\"\\\\\\\\\", r\"\\\\\") <re.Match object; span=(0, 1), match='\\\\'> Writing a Tokenizer A tokenizer or scanner analyzes a string to categorize groups of characters. This is a useful first step in writing a compiler or interpreter. The text categories are specified with regular expressions. The technique is to combine those into a single master regular expression and to loop over successive matches: from typing import NamedTuple import re class Token(NamedTuple): type: str value: str line: int column: int def tokenize(code): keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'} token_specification = [ ('NUMBER', r'\\d+(\\.\\d*)?'), # Integer or decimal number ('ASSIGN', r':='), # Assignment operator ('END', r';'), # Statement terminator ('ID', r'[A-Za-z]+'), # Identifiers ('OP', r'[+\\-*/]'), # Arithmetic operators ('NEWLINE', r'\\n'), # Line endings ('SKIP', r'[ \\t]+'), # Skip over spaces and tabs ('MISMATCH', r'.'), # Any other character ] tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specification) line_num = 1 line_start = 0 for mo in re.finditer(tok_regex, code): kind = mo.lastgroup value = mo.group() column = mo.start() - line_start if kind == 'NUMBER': value = float(value) if '.' in value else int(value) elif kind == 'ID' and value in keywords: kind = value elif kind == 'NEWLINE': line_start = mo.end() line_num += 1 continue elif kind == 'SKIP': continue elif kind == 'MISMATCH': raise RuntimeError(f'{value!r} unexpected on line {line_num}') yield Token(kind, value, line_num, column) statements = ''' IF quantity THEN total := total + price * quantity; tax := price * 0.05; ENDIF; ''' for token in tokenize(statements): print(token) The tokenizer produces the following output: Token(type='IF', value='IF', line=2, column=4) Token(type='ID', value='quantity', line=2, column=7) Token(type='THEN', value='THEN', line=2, column=16) Token(type='ID', value='total', line=3, column=8) Token(type='ASSIGN', value=':=', line=3, column=14) Token(type='ID', value='total', line=3, column=17) Token(type='OP', value='+', line=3, column=23) Token(type='ID', value='price', line=3, column=25) Token(type='OP', value='*', line=3, column=31) Token(type='ID', value='quantity', line=3, column=33)", "score": "0.6998771"}, {"id": "23299", "text": "Function: python.library.re\nSnippet: re — Regular expression operations Source code: Lib/re.py This module provides regular expression matching operations similar to those found in Perl. Both patterns and strings to be searched can be Unicode strings (str) as well as 8-bit strings (bytes). However, Unicode strings and 8-bit strings cannot be mixed: that is, you cannot match a Unicode string with a byte pattern or vice-versa; similarly, when asking for a substitution, the replacement string must be of the same type as both the pattern and the search string. Regular expressions use the backslash character ('\\') to indicate special forms or to allow special characters to be used without invoking their special meaning. This collides with Python’s usage of the same character for the same purpose in string literals; for example, to match a literal backslash, one might have to write '\\\\\\\\' as the pattern string, because the regular expression must be \\\\, and each backslash must be expressed as \\\\ inside a regular Python string literal. Also, please note that any invalid escape sequences in Python’s usage of the backslash in string literals now generate a DeprecationWarning and in the future this will become a SyntaxError. This behaviour will happen even if it is a valid escape sequence for a regular expression. The solution is to use Python’s raw string notation for regular expression patterns; backslashes are not handled in any special way in a string literal prefixed with 'r'. So r\"\\n\" is a two-character string containing '\\' and 'n', while \"\\n\" is a one-character string containing a newline. Usually patterns will be expressed in Python code using this raw string notation. It is important to note that most regular expression operations are available as module-level functions and methods on compiled regular expressions. The functions are shortcuts that don’t require you to compile a regex object first, but miss some fine-tuning parameters. See also The third-party regex module, which has an API compatible with the standard library re module, but offers additional functionality and a more thorough Unicode support. Regular Expression Syntax A regular expression (or RE) specifies a set of strings that matches it; the functions in this module let you check if a particular string matches a given regular expression (or if a given regular expression matches a particular string, which comes down to the same thing). Regular expressions can be concatenated to form new regular expressions; if A and B are both regular expressions, then AB is also a regular expression. In general, if a string p matches A and another string q matches B, the string pq will match AB. This holds unless A or B contain low precedence operations; boundary conditions between A and B; or have numbered group references. Thus, complex expressions can easily be constructed from simpler primitive expressions like the ones described here. For details of the theory and implementation of regular expressions, consult the Friedl book [Frie09], or almost any textbook about compiler construction. A brief explanation of the format of regular expressions follows.", "score": "0.692188"}, {"id": "41745", "text": "Function: numpy.reference.generated.numpy.char.not_equal\nSnippet: numpy.char.not_equal char.not_equal(x1, x2)[source] Return (x1 != x2) element-wise. Unlike numpy.not_equal, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray. Parameters x1, x2array_like of str or unicode Input arrays of the same shape. Returns outndarray Output array of bools. See also equal, greater_equal, less_equal, greater, less", "score": "0.6918428"}]}
{"task_id": "humaneval_113", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "odd_count", "gold_generation": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n", "context": "Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]", "function_name": "def odd_count(lst):", "ctxs": [{"id": "41747", "text": "Function: numpy.reference.generated.numpy.char.replace\nSnippet: numpy.char.replace char.replace(a, old, new, count=None)[source] For each element in a, return a copy of the string with all occurrences of substring old replaced by new. Calls str.replace element-wise. Parameters aarray-like of str or unicode old, newstr or unicode countint, optional If the optional argument count is given, only the first count occurrences are replaced. Returns outndarray Output array of str or unicode, depending on input type See also str.replace", "score": "0.7477891"}, {"id": "24370", "text": "Function: python.library.stdtypes#str.replace\nSnippet: str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced.", "score": "0.73431355"}, {"id": "41718", "text": "Function: numpy.reference.generated.numpy.char.count\nSnippet: numpy.char.count char.count(a, sub, start=0, end=None)[source] Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. Calls str.count element-wise. Parameters aarray_like of str or unicode substr or unicode The substring to search for. start, endint, optional Optional arguments start and end are interpreted as slice notation to specify the range in which to count. Returns outndarray Output array of ints. See also str.count Examples >>> c = np.array(['aAaAaA', ' aA ', 'abBABba']) >>> c array(['aAaAaA', ' aA ', 'abBABba'], dtype='<U7') >>> np.char.count(c, 'A') array([3, 1, 1]) >>> np.char.count(c, 'aA') array([3, 1, 0]) >>> np.char.count(c, 'A', start=1, end=4) array([2, 1, 1]) >>> np.char.count(c, 'A', start=1, end=3) array([1, 0, 0])", "score": "0.73080695"}, {"id": "24342", "text": "Function: python.library.stdtypes#str.count\nSnippet: str.count(sub[, start[, end]]) Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.717053"}, {"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.70926666"}]}
{"task_id": "humaneval_114", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n", "entry_point": "minSubArraySum", "gold_generation": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n", "context": "Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6", "function_name": "def minSubArraySum(nums):", "ctxs": [{"id": "43859", "text": "Function: numpy.reference.generated.numpy.recarray.min\nSnippet: numpy.recarray.min method recarray.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the minimum along a given axis. Refer to numpy.amin for full documentation. See also numpy.amin equivalent function", "score": "0.7342372"}, {"id": "13013", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos#sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.71826917"}, {"id": "12778", "text": "Function: sklearn.modules.generated.sklearn.utils.arrayfuncs.min_pos\nSnippet: sklearn.utils.arrayfuncs.min_pos sklearn.utils.arrayfuncs.min_pos() Find the minimum value of an array over positive values Returns a huge value if none of the values are positive", "score": "0.7139565"}, {"id": "43023", "text": "Function: numpy.reference.generated.numpy.minimum\nSnippet: numpy.minimum numpy.minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'minimum'> Element-wise minimum of array elements. Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The minimum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also maximum Element-wise maximum of two arrays, propagates NaNs. fmin Element-wise minimum of two arrays, ignores NaNs. amin The minimum value of an array along a given axis, propagates NaNs. nanmin The minimum value of an array along a given axis, ignores NaNs. fmax, amax, nanmax Notes The minimum is equivalent to np.where(x1 <= x2, x1, x2) when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting. Examples >>> np.minimum([2, 3, 4], [1, 5, 2]) array([1, 3, 2]) >>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting array([[ 0.5, 0. ], [ 0. , 1. ]]) >>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.minimum(-np.Inf, 1) -inf", "score": "0.71390575"}, {"id": "42533", "text": "Function: numpy.reference.generated.numpy.ndarray.min\nSnippet: numpy.ndarray.min method ndarray.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True) Return the minimum along a given axis. Refer to numpy.amin for full documentation. See also numpy.amin equivalent function", "score": "0.71219504"}]}
{"task_id": "humaneval_115", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "entry_point": "max_fill", "gold_generation": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "context": "You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10", "function_name": "def max_fill(grid, capacity):\n    import math", "ctxs": [{"id": "5647", "text": "Function: torch.generated.torch.bucketize#torch.bucketize\nSnippet: torch.bucketize(input, boundaries, *, out_int32=False, right=False, out=None) → Tensor Returns the indices of the buckets to which each value in the input belongs, where the boundaries of the buckets are set by boundaries. Return a new tensor with the same size as input. If right is False (default), then the left boundary is closed. More formally, the returned index satisfies the following rules: right returned index satisfies False boundaries[i-1] < input[m][n]...[l][x] <= boundaries[i] True boundaries[i-1] <= input[m][n]...[l][x] < boundaries[i] Parameters input (Tensor or Scalar) – N-D tensor or a Scalar containing the search value(s). boundaries (Tensor) – 1-D tensor, must contain a monotonically increasing sequence. Keyword Arguments out_int32 (bool, optional) – indicate the output data type. torch.int32 if True, torch.int64 otherwise. Default value is False, i.e. default output data type is torch.int64. right (bool, optional) – if False, return the first suitable location that is found. If True, return the last such index. If no suitable index found, return 0 for non-numerical value (eg. nan, inf) or the size of boundaries (one pass the last index). In other words, if False, gets the lower bound index for each value in input from boundaries. If True, gets the upper bound index instead. Default value is False. out (Tensor, optional) – the output tensor, must be the same size as input if provided. Example: >>> boundaries = torch.tensor([1, 3, 5, 7, 9]) >>> boundaries tensor([1, 3, 5, 7, 9]) >>> v = torch.tensor([[3, 6, 9], [3, 6, 9]]) >>> v tensor([[3, 6, 9], [3, 6, 9]]) >>> torch.bucketize(v, boundaries) tensor([[1, 3, 4], [1, 3, 4]]) >>> torch.bucketize(v, boundaries, right=True) tensor([[2, 3, 5], [2, 3, 5]])", "score": "0.7065425"}, {"id": "17065", "text": "Function: skimage.api.skimage.morphology\nSnippet: equal (or within tolerance of) the seed point replaced with new_value. Notes The conceptual analogy of this operation is the ‘paint bucket’ tool in many raster graphics programs. Examples >>> from skimage.morphology import flood_fill >>> image = np.zeros((4, 7), dtype=int) >>> image[1:3, 1:3] = 1 >>> image[3, 0] = 1 >>> image[1:3, 4:6] = 2 >>> image[3, 6] = 3 >>> image array([[0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0], [0, 1, 1, 0, 2, 2, 0], [1, 0, 0, 0, 0, 0, 3]]) Fill connected ones with 5, with full connectivity (diagonals included): >>> flood_fill(image, (1, 1), 5) array([[0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 0, 2, 2, 0], [0, 5, 5, 0, 2, 2, 0], [5, 0, 0, 0, 0, 0, 3]]) Fill connected ones with 5, excluding diagonal points (connectivity 1): >>> flood_fill(image, (1, 1), 5, connectivity=1) array([[0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 0, 2, 2, 0], [0, 5, 5, 0, 2, 2, 0], [1, 0, 0, 0, 0, 0, 3]]) Fill with a tolerance: >>> flood_fill(image, (0, 0), 5, tolerance=1) array([[5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 2, 2, 5], [5, 5, 5, 5, 2, 2, 5], [5, 5, 5, 5, 5, 5, 3]]) h_maxima skimage.morphology.h_maxima(image, h, selem=None) [source] Determine all maxima of the image with height >= h. The local maxima are defined as connected sets of pixels with equal grey level strictly greater than the grey level of all pixels in direct neighborhood of the set. A local maximum M of height h is a local maximum for which there is at least one path joining M with an equal or higher local maximum on which the minimal value is f(M) - h (i.e. the values along the path are not decreasing by more than h with respect to the maximum’s value) and no path to an equal or higher local maximum for which the minimal value is greater. The global maxima of the image are also found by this function. Parameters imagendarray The input image for which the maxima are to be calculated. hunsigned integer The minimal height of all extracted maxima. selemndarray, optional The neighborhood expressed as an n-D array of 1’s and 0’s. Default is the ball of radius 1 according to the maximum norm (i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.) Returns h_maxndarray The local maxima of height >= h and the global maxima. The resulting image is a binary image, where pixels belonging to the determined maxima take value 1, the others take value 0. See also skimage.morphology.extrema.h_minima skimage.morphology.extrema.local_maxima skimage.morphology.extrema.local_minima References 1 Soille, P., “Morphological Image Analysis: Principles and Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883. Examples >>> import numpy as np >>> from skimage.morphology import extrema We create an image (quadratic function with a maximum in the center and 4 additional constant maxima. The heights of the maxima are: 1, 21, 41, 61,", "score": "0.68511677"}, {"id": "3977", "text": "Function: tensorflow.raw_ops.bucketize\nSnippet: tf.raw_ops.Bucketize Bucketizes 'input' based on 'boundaries'. View aliases Compat aliases for migration See Migration guide for more details. tf.compat.v1.raw_ops.Bucketize tf.raw_ops.Bucketize( input, boundaries, name=None ) For example, if the inputs are boundaries = [0, 10, 100] input = [[-5, 10000] [150, 10] [5, 100]] then the output will be output = [[0, 3] [3, 2] [1, 3]] Args input A Tensor. Must be one of the following types: int32, int64, float32, float64. Any shape of Tensor contains with int or float type. boundaries A list of floats. A sorted list of floats gives the boundary of the buckets. name A name for the operation (optional). Returns A Tensor of type int32.", "score": "0.67640996"}, {"id": "7106", "text": "Function: torch.generated.torch.nn.maxunpool3d#torch.nn.MaxUnpool3d\nSnippet: class torch.nn.MaxUnpool3d(kernel_size, stride=None, padding=0) [source] Computes a partial inverse of MaxPool3d. MaxPool3d is not fully invertible, since the non-maximal values are lost. MaxUnpool3d takes in as input the output of MaxPool3d including the indices of the maximal values and computes a partial inverse in which all non-maximal values are set to zero. Note MaxPool3d can map several input sizes to the same output sizes. Hence, the inversion process can get ambiguous. To accommodate this, you can provide the needed output size as an additional argument output_size in the forward call. See the Inputs section below. Parameters kernel_size (int or tuple) – Size of the max pooling window. stride (int or tuple) – Stride of the max pooling window. It is set to kernel_size by default. padding (int or tuple) – Padding that was added to the input Inputs: input: the input Tensor to invert indices: the indices given out by MaxPool3d output_size (optional): the targeted output size Shape: Input: (N,C,Din,Hin,Win)(N, C, D_{in}, H_{in}, W_{in}) Output: (N,C,Dout,Hout,Wout)(N, C, D_{out}, H_{out}, W_{out}) , where Dout=(Din−1)×stride[0]−2×padding[0]+kernel_size[0]D_{out} = (D_{in} - 1) \\times \\text{stride[0]} - 2 \\times \\text{padding[0]} + \\text{kernel\\_size[0]} Hout=(Hin−1)×stride[1]−2×padding[1]+kernel_size[1]H_{out} = (H_{in} - 1) \\times \\text{stride[1]} - 2 \\times \\text{padding[1]} + \\text{kernel\\_size[1]} Wout=(Win−1)×stride[2]−2×padding[2]+kernel_size[2]W_{out} = (W_{in} - 1) \\times \\text{stride[2]} - 2 \\times \\text{padding[2]} + \\text{kernel\\_size[2]} or as given by output_size in the call operator Example: >>> # pool of square window of size=3, stride=2 >>> pool = nn.MaxPool3d(3, stride=2, return_indices=True) >>> unpool = nn.MaxUnpool3d(3, stride=2) >>> output, indices = pool(torch.randn(20, 16, 51, 33, 15)) >>> unpooled_output = unpool(output, indices) >>> unpooled_output.size() torch.Size([20, 16, 51, 33, 15])", "score": "0.6749738"}, {"id": "270", "text": "Function: tensorflow.compat.v1.depth_to_space\nSnippet: [ [3], [4], [7], [8]], [ [9], [10], [13], [14]], [ [11], [12], [15], [16]]]] Args input A Tensor. block_size An int that is >= 2. The size of the spatial block, same as in Space2Depth. data_format An optional string from: \"NHWC\", \"NCHW\", \"NCHW_VECT_C\". Defaults to \"NHWC\". name A name for the operation (optional). Returns A Tensor. Has the same type as input.", "score": "0.6738074"}]}
{"task_id": "humaneval_116", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "sort_array", "gold_generation": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n", "context": "In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]", "function_name": "def sort_array(arr):", "ctxs": [{"id": "41696", "text": "Function: numpy.reference.generated.numpy.char.chararray.sort\nSnippet: numpy.char.chararray.sort method char.chararray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.7584715"}, {"id": "42565", "text": "Function: numpy.reference.generated.numpy.ndarray.sort\nSnippet: numpy.ndarray.sort method ndarray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.7543888"}, {"id": "41817", "text": "Function: numpy.reference.generated.numpy.chararray.sort\nSnippet: numpy.chararray.sort method chararray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.7536737"}, {"id": "43877", "text": "Function: numpy.reference.generated.numpy.recarray.sort\nSnippet: numpy.recarray.sort method recarray.sort(axis=- 1, kind=None, order=None) Sort an array in-place. Refer to numpy.sort for full documentation. Parameters axisint, optional Axis along which to sort. Default is -1, which means sort along the last axis. kind{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’ use timsort under the covers and, in general, the actual implementation will vary with datatype. The ‘mergesort’ option is retained for backwards compatibility. Changed in version 1.15.0: The ‘stable’ option was added. orderstr or list of str, optional When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties. See also numpy.sort Return a sorted copy of an array. numpy.argsort Indirect sort. numpy.lexsort Indirect stable sort on multiple keys. numpy.searchsorted Find elements in sorted array. numpy.partition Partial sort. Notes See numpy.sort for notes on the different sorting algorithms. Examples >>> a = np.array([[1,4], [3,1]]) >>> a.sort(axis=1) >>> a array([[1, 4], [1, 3]]) >>> a.sort(axis=0) >>> a array([[1, 3], [1, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)]) >>> a.sort(order='y') >>> a array([(b'c', 1), (b'a', 2)], dtype=[('x', 'S1'), ('y', '<i8')])", "score": "0.7526189"}, {"id": "43196", "text": "Function: numpy.reference.generated.numpy.sort\nSnippet: sorted. It, along with ‘mergesort’ is currently mapped to timsort or radix sort depending on the data type. API forward compatibility currently limits the ability to select the implementation and it is hardwired for the different data types. New in version 1.17.0. Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For timsort details, refer to CPython listsort.txt. ‘mergesort’ and ‘stable’ are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n). Changed in version 1.18.0. NaT now sorts to the end of arrays for consistency with NaN. Examples >>> a = np.array([[1,4],[3,1]]) >>> np.sort(a) # sort along the last axis array([[1, 4], [1, 3]]) >>> np.sort(a, axis=None) # sort the flattened array array([1, 1, 3, 4]) >>> np.sort(a, axis=0) # sort along the first axis array([[1, 1], [3, 4]]) Use the order keyword to specify a field to use when sorting a structured array: >>> dtype = [('name', 'S10'), ('height', float), ('age', int)] >>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38), ... ('Galahad', 1.7, 38)] >>> a = np.array(values, dtype=dtype) # create a structured array >>> np.sort(a, order='height') array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41), ('Lancelot', 1.8999999999999999, 38)], dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')]) Sort by age, then height if ages are equal: >>> np.sort(a, order=['age', 'height']) array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38), ('Arthur', 1.8, 41)], dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])", "score": "0.75229484"}]}
{"task_id": "humaneval_117", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "entry_point": "select_words", "gold_generation": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "context": "Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]", "function_name": "def select_words(s, n):", "ctxs": [{"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.71653104"}, {"id": "24377", "text": "Function: python.library.stdtypes#str.split\nSnippet: str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3']", "score": "0.7110774"}, {"id": "25746", "text": "Function: python.library.stdtypes\nSnippet: Return -1 on failure. str.rindex(sub[, start[, end]]) Like rfind() but raises ValueError when the substring sub is not found. str.rjust(width[, fillchar]) Return the string right justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.rpartition(sep) Split the string at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself. str.rsplit(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any whitespace string is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below. str.rstrip([chars]) Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty' str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3'] str.splitlines([keepends]) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. This", "score": "0.6874731"}, {"id": "41752", "text": "Function: numpy.reference.generated.numpy.char.rsplit\nSnippet: numpy.char.rsplit char.rsplit(a, sep=None, maxsplit=None)[source] For each element in a, return a list of the words in the string, using sep as the delimiter string. Calls str.rsplit element-wise. Except for splitting from the right, rsplit behaves like split. Parameters aarray_like of str or unicode sepstr or unicode, optional If sep is not specified or None, any whitespace string is a separator. maxsplitint, optional If maxsplit is given, at most maxsplit splits are done, the rightmost ones. Returns outndarray Array of list objects See also str.rsplit, split", "score": "0.68669057"}, {"id": "19634", "text": "Function: python.library.difflib#difflib.get_close_matches\nSnippet: difflib.get_close_matches(word, possibilities, n=3, cutoff=0.6) Return a list of the best “good enough” matches. word is a sequence for which close matches are desired (typically a string), and possibilities is a list of sequences against which to match word (typically a list of strings). Optional argument n (default 3) is the maximum number of close matches to return; n must be greater than 0. Optional argument cutoff (default 0.6) is a float in the range [0, 1]. Possibilities that don’t score at least that similar to word are ignored. The best (no more than n) matches among the possibilities are returned in a list, sorted by similarity score, most similar first. >>> get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy']) ['apple', 'ape'] >>> import keyword >>> get_close_matches('wheel', keyword.kwlist) ['while'] >>> get_close_matches('pineapple', keyword.kwlist) [] >>> get_close_matches('accept', keyword.kwlist) ['except']", "score": "0.685102"}]}
{"task_id": "humaneval_118", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "get_closest_vowel", "gold_generation": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n", "context": "You are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"", "function_name": "def get_closest_vowel(word):", "ctxs": [{"id": "24346", "text": "Function: python.library.stdtypes#str.find\nSnippet: str.find(sub[, start[, end]]) Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True", "score": "0.6957858"}, {"id": "41724", "text": "Function: numpy.reference.generated.numpy.char.find\nSnippet: numpy.char.find char.find(a, sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. Calls str.find element-wise. For each element, return the lowest index in the string where substring sub is found, such that sub is contained in the range [start, end]. Parameters aarray_like of str or unicode substr or unicode start, endint, optional Optional arguments start and end are interpreted as in slice notation. Returns outndarray or int Output array of ints. Returns -1 if sub is not found. See also str.find", "score": "0.68833035"}, {"id": "25745", "text": "Function: python.library.stdtypes\nSnippet: cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable) Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width[, fillchar]) Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard. str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(x[, y[, z]]) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep) Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /) If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' New in version 3.9. str.removesuffix(suffix, /) If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' New in version 3.9. str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. str.rfind(sub[, start[, end]]) Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation.", "score": "0.68248606"}, {"id": "2413", "text": "Function: tensorflow.experimental.numpy.unicode_\nSnippet: to test for reserved identifiers such as \"def\" and \"class\". islower islower() Return True if the string is a lowercase string, False otherwise. A string is lowercase if all cased characters in the string are lowercase and there is at least one cased character in the string. isnumeric isnumeric() Return True if the string is a numeric string, False otherwise. A string is numeric if all characters in the string are numeric and there is at least one character in the string. isprintable isprintable() Return True if the string is printable, False otherwise. A string is printable if all of its characters are considered printable in repr() or if it is empty. isspace isspace() Return True if the string is a whitespace string, False otherwise. A string is whitespace if all characters in the string are whitespace and there is at least one character in the string. istitle istitle() Return True if the string is a title-cased string, False otherwise. In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones. isupper isupper() Return True if the string is an uppercase string, False otherwise. A string is uppercase if all cased characters in the string are uppercase and there is at least one cased character in the string. item item() Not implemented (virtual attribute) Class generic exists solely to derive numpy scalars from, and possesses, albeit unimplemented, all the attributes of the ndarray class so as to provide a uniform API. See also the corresponding attribute of the derived class of interest. itemset itemset() Not implemented (virtual attribute) Class generic exists solely to derive numpy scalars from, and possesses, albeit unimplemented, all the attributes of the ndarray class so as to provide a uniform API. See also the corresponding attribute of the derived class of interest. join join( iterable, / ) Concatenate any number of strings. The string whose method is called is inserted in between each given string. The result is returned as a new string. Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs' ljust ljust( width, fillchar, / ) Return a left-justified string of length width. Padding is done using the specified fill character (default is a space). lower lower() Return a copy of the string converted to lowercase. lstrip lstrip( chars, / ) Return a copy of the string with leading whitespace removed. If chars is given and not None, remove characters in chars instead. maketrans maketrans( x, y, z, / ) Return a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters to Unicode ordinals, strings or None. Character keys will be then converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None", "score": "0.67351776"}, {"id": "41727", "text": "Function: numpy.reference.generated.numpy.char.index\nSnippet: numpy.char.index char.index(a, sub, start=0, end=None)[source] Like find, but raises ValueError when the substring is not found. Calls str.index element-wise. Parameters aarray_like of str or unicode substr or unicode start, endint, optional Returns outndarray Output array of ints. Returns -1 if sub is not found. See also find, str.find", "score": "0.6684743"}]}
{"task_id": "humaneval_119", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n", "entry_point": "match_parens", "gold_generation": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n", "context": "", "function_name": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015749"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49312225"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.49104327"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48984405"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.48983365"}]}
{"task_id": "humaneval_120", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "entry_point": "maximum", "gold_generation": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "context": "Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)", "function_name": "def maximum(arr, k):", "ctxs": [{"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.70998335"}, {"id": "18944", "text": "Function: python.library.ctypes#ctypes.Array._length_\nSnippet: _length_ A positive integer specifying the number of elements in the array. Out-of-range subscripts result in an IndexError. Will be returned by len().", "score": "0.70341045"}, {"id": "17641", "text": "Function: python.library.array#array.array.pop\nSnippet: array.pop([i]) Removes the item with the index i from the array and returns it. The optional argument defaults to -1, so that by default the last item is removed and returned.", "score": "0.7009106"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6936897"}, {"id": "43012", "text": "Function: numpy.reference.generated.numpy.maximum\nSnippet: numpy.maximum numpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'maximum'> Element-wise maximum of array elements. Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated. Parameters x1, x2array_like The arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns yndarray or scalar The maximum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars. See also minimum Element-wise minimum of two arrays, propagates NaNs. fmax Element-wise maximum of two arrays, ignores NaNs. amax The maximum value of an array along a given axis, propagates NaNs. nanmax The maximum value of an array along a given axis, ignores NaNs. fmin, amin, nanmin Notes The maximum is equivalent to np.where(x1 >= x2, x1, x2) when neither x1 nor x2 are nans, but it is faster and does proper broadcasting. Examples >>> np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4]) >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting array([[ 1. , 2. ], [ 0.5, 2. ]]) >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) >>> np.maximum(np.Inf, 1) inf", "score": "0.69288987"}]}
{"task_id": "humaneval_121", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n", "entry_point": "solution", "gold_generation": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n", "context": "Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0", "function_name": "def solution(lst):", "ctxs": [{"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6720928"}, {"id": "18653", "text": "Function: python.library.collections#collections.Counter.elements\nSnippet: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> sorted(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']", "score": "0.6705007"}, {"id": "21310", "text": "Function: python.library.itertools#itertools.permutations\nSnippet: itertools.permutations(iterable, r=None) Return successive r length permutations of elements in the iterable. If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n.", "score": "0.6668536"}, {"id": "21293", "text": "Function: python.library.itertools\nSnippet: to the length of the iterable and all possible full-length permutations are generated. The permutation tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation. Roughly equivalent to: def permutations(iterable, r=None): # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --> 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool): def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) The number of items returned is n! / (n-r)! when 0 <= r <= n or zero when r > n. itertools.product(*iterables, repeat=1) Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order. To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory: def product(*args, repeat=1): # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) Before product() runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. itertools.repeat(object[, times]) Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for", "score": "0.66054267"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6594565"}]}
{"task_id": "humaneval_122", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "add_elements", "gold_generation": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "context": "Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)", "function_name": "def add_elements(arr, k):", "ctxs": [{"id": "43881", "text": "Function: numpy.reference.generated.numpy.recarray.sum\nSnippet: numpy.recarray.sum method recarray.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True) Return the sum of the array elements over the given axis. Refer to numpy.sum for full documentation. See also numpy.sum equivalent function", "score": "0.7029468"}, {"id": "42569", "text": "Function: numpy.reference.generated.numpy.ndarray.sum\nSnippet: numpy.ndarray.sum method ndarray.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True) Return the sum of the array elements over the given axis. Refer to numpy.sum for full documentation. See also numpy.sum equivalent function", "score": "0.6934961"}, {"id": "43210", "text": "Function: numpy.reference.generated.numpy.sum\nSnippet: numpy.sum numpy.sum(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)[source] Sum of array elements over a given axis. Parameters aarray_like Elements to sum. axisNone or int or tuple of ints, optional Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis. New in version 1.7.0. If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before. dtypedtype, optional The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. outndarray, optional Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary. keepdimsbool, optional If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the sum method of sub-classes of ndarray, however any non-default value will be. If the sub-class’ method does not implement keepdims any exceptions will be raised. initialscalar, optional Starting value for the sum. See reduce for details. New in version 1.15.0. wherearray_like of bool, optional Elements to include in the sum. See reduce for details. New in version 1.17.0. Returns sum_along_axisndarray An array with the same shape as a, with the specified axis removed. If a is a 0-d array, or if axis is None, a scalar is returned. If an output array is specified, a reference to out is returned. See also ndarray.sum Equivalent method. add.reduce Equivalent functionality of add. cumsum Cumulative sum of array elements. trapz Integration of array values using the composite trapezoidal rule. mean, average Notes Arithmetic is modular when using integer types, and no error is raised on overflow. The sum of an empty array is the neutral element 0: >>> np.sum([]) 0.0 For floating point numbers the numerical precision of sum (and np.add.reduce) is in general limited by directly adding each number individually to the result causing rounding errors in every step. However, often numpy will use a numerically better approach (partial pairwise summation) leading to improved precision in many use-cases. This improved precision is always provided when no axis is given. When axis is given, it will depend on which axis is summed. Technically, to provide the best speed possible, the improved precision is only used when", "score": "0.6874844"}, {"id": "24549", "text": "Function: python.library.functions#sum\nSnippet: sum(iterable, /, start=0) Sums start and the items of an iterable from left to right and returns the total. The iterable’s items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument.", "score": "0.68676233"}, {"id": "42345", "text": "Function: numpy.reference.generated.numpy.ma.sum\nSnippet: numpy.ma.sum ma.sum(self, axis=None, dtype=None, out=None, keepdims=<no value>) = <numpy.ma.core._frommethod object> Return the sum of the array elements over the given axis. Masked elements are set to 0 internally. Refer to numpy.sum for full documentation. See also numpy.ndarray.sum corresponding function for ndarrays numpy.sum equivalent function Examples >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4) >>> x masked_array( data=[[1, --, 3], [--, 5, --], [7, --, 9]], mask=[[False, True, False], [ True, False, True], [False, True, False]], fill_value=999999) >>> x.sum() 25 >>> x.sum(axis=1) masked_array(data=[4, 5, 16], mask=[False, False, False], fill_value=999999) >>> x.sum(axis=0) masked_array(data=[8, 5, 12], mask=[False, False, False], fill_value=999999) >>> print(type(x.sum(axis=0, dtype=np.int64)[0])) <class 'numpy.int64'>", "score": "0.6821642"}]}
{"task_id": "humaneval_123", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "get_odd_collatz", "gold_generation": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n", "context": "Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.", "function_name": "def get_odd_collatz(n):", "ctxs": [{"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.6312445"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.62650377"}, {"id": "21787", "text": "Function: python.library.math#math.comb\nSnippet: math.comb(n, k) Return the number of ways to choose k items from n items without repetition and without order. Evaluates to n! / (k! * (n - k)!) when k <= n and evaluates to zero when k > n. Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of the expression (1 + x) ** n. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6089287"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.60839385"}, {"id": "19648", "text": "Function: python.library.difflib#difflib.SequenceMatcher.get_matching_blocks\nSnippet: get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]", "score": "0.6060826"}]}
{"task_id": "humaneval_124", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n", "entry_point": "valid_date", "gold_generation": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n", "context": "You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False", "function_name": "def valid_date(date):", "ctxs": [{"id": "36098", "text": "Function: django.ref.forms.fields#django.forms.DateField\nSnippet: class DateField(**kwargs) Default widget: DateInput Empty value: None Normalizes to: A Python datetime.date object. Validates that the given value is either a datetime.date, datetime.datetime or string formatted in a particular date format. Error message keys: required, invalid Takes one optional argument: input_formats A list of formats used to attempt to convert a string to a valid datetime.date object. If no input_formats argument is provided, the default input formats are taken from DATE_INPUT_FORMATS if USE_L10N is False, or from the active locale format DATE_INPUT_FORMATS key if localization is enabled. See also format localization.", "score": "0.7243594"}, {"id": "42911", "text": "Function: numpy.reference.generated.numpy.is_busday\nSnippet: numpy.is_busday numpy.is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None) Calculates which of the given dates are valid days, and which are not. New in version 1.7.0. Parameters datesarray_like of datetime64[D] The array of dates to process. weekmaskstr or array_like of bool, optional A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun holidaysarray_like of datetime64[D], optional An array of dates to consider as invalid dates. They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days. busdaycalbusdaycalendar, optional A busdaycalendar object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided. outarray of bool, optional If provided, this array is filled with the result. Returns outarray of bool An array with the same shape as dates, containing True for each valid day, and False for each invalid day. See also busdaycalendar An object that specifies a custom set of valid days. busday_offset Applies an offset counted in valid days. busday_count Counts how many valid days are in a half-open date range. Examples >>> # The weekdays are Friday, Saturday, and Monday ... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'], ... holidays=['2011-07-01', '2011-07-04', '2011-07-17']) array([False, False, True])", "score": "0.71895593"}, {"id": "19300", "text": "Function: python.library.datetime#datetime.date\nSnippet: class datetime.date(year, month, day) All arguments are required. Arguments must be integers, in the following ranges: MINYEAR <= year <= MAXYEAR 1 <= month <= 12 1 <= day <= number of days in the given month and year If an argument outside those ranges is given, ValueError is raised.", "score": "0.7150637"}, {"id": "36102", "text": "Function: django.ref.forms.fields#django.forms.DateTimeField\nSnippet: class DateTimeField(**kwargs) Default widget: DateTimeInput Empty value: None Normalizes to: A Python datetime.datetime object. Validates that the given value is either a datetime.datetime, datetime.date or string formatted in a particular datetime format. Error message keys: required, invalid Takes one optional argument: input_formats A list of formats used to attempt to convert a string to a valid datetime.datetime object, in addition to ISO 8601 formats. The field always accepts strings in ISO 8601 formatted dates or similar recognized by parse_datetime(). Some examples are: * '2006-10-25 14:30:59' * '2006-10-25T14:30:59' * '2006-10-25 14:30' * '2006-10-25T14:30' * '2006-10-25T14:30Z' * '2006-10-25T14:30+02:00' * '2006-10-25' If no input_formats argument is provided, the default input formats are taken from DATETIME_INPUT_FORMATS and DATE_INPUT_FORMATS if USE_L10N is False, or from the active locale format DATETIME_INPUT_FORMATS and DATE_INPUT_FORMATS keys if localization is enabled. See also format localization.", "score": "0.70811296"}, {"id": "19312", "text": "Function: python.library.datetime#datetime.date.month\nSnippet: date.month Between 1 and 12 inclusive.", "score": "0.6954758"}]}
{"task_id": "humaneval_125", "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n", "entry_point": "split_words", "gold_generation": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n", "context": "", "function_name": "def split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015749"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49312225"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.49104327"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48984405"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.48983365"}]}
{"task_id": "humaneval_126", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n", "entry_point": "is_sorted", "gold_generation": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n", "context": "", "function_name": "def is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) ➞ True\n    is_sorted([1, 2, 3, 4, 5]) ➞ True\n    is_sorted([1, 3, 2, 4, 5]) ➞ False\n    is_sorted([1, 2, 3, 4, 5, 6]) ➞ True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False\n    is_sorted([1, 2, 2, 3, 3, 4]) ➞ True\n    is_sorted([1, 2, 2, 2, 3, 4]) ➞ False\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015749"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49312225"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.49104327"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48984405"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.48983365"}]}
{"task_id": "humaneval_127", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "entry_point": "intersection", "gold_generation": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "context": "You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"", "function_name": "def intersection(interval1, interval2):", "ctxs": [{"id": "14792", "text": "Function: pandas.reference.api.pandas.interval.overlaps\nSnippet: pandas.Interval.overlaps Interval.overlaps() Check whether two Interval objects overlap. Two intervals overlap if they share a common point, including closed endpoints. Intervals that only have an open endpoint in common do not overlap. Parameters other:Interval Interval to check against for an overlap. Returns bool True if the two intervals overlap. See also IntervalArray.overlaps The corresponding method for IntervalArray. IntervalIndex.overlaps The corresponding method for IntervalIndex. Examples >>> i1 = pd.Interval(0, 2) >>> i2 = pd.Interval(1, 3) >>> i1.overlaps(i2) True >>> i3 = pd.Interval(4, 5) >>> i1.overlaps(i3) False Intervals that share closed endpoints overlap: >>> i4 = pd.Interval(0, 1, closed='both') >>> i5 = pd.Interval(1, 2, closed='both') >>> i4.overlaps(i5) True Intervals that only have an open endpoint in common do not overlap: >>> i6 = pd.Interval(1, 2, closed='neither') >>> i4.overlaps(i6) False", "score": "0.72208476"}, {"id": "14807", "text": "Function: pandas.reference.api.pandas.intervalindex.is_overlapping\nSnippet: pandas.IntervalIndex.is_overlapping propertyIntervalIndex.is_overlapping Return True if the IntervalIndex has overlapping intervals, else False. Two intervals overlap if they share a common point, including closed endpoints. Intervals that only have an open endpoint in common do not overlap. Returns bool Boolean indicating if the IntervalIndex has overlapping intervals. See also Interval.overlaps Check whether two Interval objects overlap. IntervalIndex.overlaps Check an IntervalIndex elementwise for overlaps. Examples >>> index = pd.IntervalIndex.from_tuples([(0, 2), (1, 3), (4, 5)]) >>> index IntervalIndex([(0, 2], (1, 3], (4, 5]], dtype='interval[int64, right]') >>> index.is_overlapping True Intervals that share closed endpoints overlap: >>> index = pd.interval_range(0, 3, closed='both') >>> index IntervalIndex([[0, 1], [1, 2], [2, 3]], dtype='interval[int64, both]') >>> index.is_overlapping True Intervals that only have an open endpoint in common do not overlap: >>> index = pd.interval_range(0, 3, closed='left') >>> index IntervalIndex([[0, 1), [1, 2), [2, 3)], dtype='interval[int64, left]') >>> index.is_overlapping False", "score": "0.7147368"}, {"id": "14811", "text": "Function: pandas.reference.api.pandas.intervalindex.overlaps\nSnippet: pandas.IntervalIndex.overlaps IntervalIndex.overlaps(*args, **kwargs)[source] Check elementwise if an Interval overlaps the values in the IntervalArray. Two intervals overlap if they share a common point, including closed endpoints. Intervals that only have an open endpoint in common do not overlap. Parameters other:IntervalArray Interval to check against for an overlap. Returns ndarray Boolean array positionally indicating where an overlap occurs. See also Interval.overlaps Check whether two Interval objects overlap. Examples >>> data = [(0, 1), (1, 3), (2, 4)] >>> intervals = pd.arrays.IntervalArray.from_tuples(data) >>> intervals <IntervalArray> [(0, 1], (1, 3], (2, 4]] Length: 3, dtype: interval[int64, right] >>> intervals.overlaps(pd.Interval(0.5, 1.5)) array([ True, True, False]) Intervals that share closed endpoints overlap: >>> intervals.overlaps(pd.Interval(1, 3, closed='left')) array([ True, True, True]) Intervals that only have an open endpoint in common do not overlap: >>> intervals.overlaps(pd.Interval(1, 2, closed='right')) array([False, True, False])", "score": "0.7118858"}, {"id": "14058", "text": "Function: pandas.reference.api.pandas.arrays.intervalarray.overlaps\nSnippet: pandas.arrays.IntervalArray.overlaps IntervalArray.overlaps(other)[source] Check elementwise if an Interval overlaps the values in the IntervalArray. Two intervals overlap if they share a common point, including closed endpoints. Intervals that only have an open endpoint in common do not overlap. Parameters other:IntervalArray Interval to check against for an overlap. Returns ndarray Boolean array positionally indicating where an overlap occurs. See also Interval.overlaps Check whether two Interval objects overlap. Examples >>> data = [(0, 1), (1, 3), (2, 4)] >>> intervals = pd.arrays.IntervalArray.from_tuples(data) >>> intervals <IntervalArray> [(0, 1], (1, 3], (2, 4]] Length: 3, dtype: interval[int64, right] >>> intervals.overlaps(pd.Interval(0.5, 1.5)) array([ True, True, False]) Intervals that share closed endpoints overlap: >>> intervals.overlaps(pd.Interval(1, 3, closed='left')) array([ True, True, True]) Intervals that only have an open endpoint in common do not overlap: >>> intervals.overlaps(pd.Interval(1, 2, closed='right')) array([False, True, False])", "score": "0.70860744"}, {"id": "14782", "text": "Function: pandas.reference.api.pandas.interval\nSnippet: pandas.Interval classpandas.Interval Immutable object implementing an Interval, a bounded slice-like interval. Parameters left:orderable scalar Left bound for the interval. right:orderable scalar Right bound for the interval. closed:{‘right’, ‘left’, ‘both’, ‘neither’}, default ‘right’ Whether the interval is closed on the left-side, right-side, both or neither. See the Notes for more detailed explanation. See also IntervalIndex An Index of Interval objects that are all closed on the same side. cut Convert continuous data into discrete bins (Categorical of Interval objects). qcut Convert continuous data into bins (Categorical of Interval objects) based on quantiles. Period Represents a period of time. Notes The parameters left and right must be from the same type, you must be able to compare them and they must satisfy left <= right. A closed interval (in mathematics denoted by square brackets) contains its endpoints, i.e. the closed interval [0, 5] is characterized by the conditions 0 <= x <= 5. This is what closed='both' stands for. An open interval (in mathematics denoted by parentheses) does not contain its endpoints, i.e. the open interval (0, 5) is characterized by the conditions 0 < x < 5. This is what closed='neither' stands for. Intervals can also be half-open or half-closed, i.e. [0, 5) is described by 0 <= x < 5 (closed='left') and (0, 5] is described by 0 < x <= 5 (closed='right'). Examples It is possible to build Intervals of different types, like numeric ones: >>> iv = pd.Interval(left=0, right=5) >>> iv Interval(0, 5, closed='right') You can check if an element belongs to it >>> 2.5 in iv True You can test the bounds (closed='right', so 0 < x <= 5): >>> 0 in iv False >>> 5 in iv True >>> 0.0001 in iv True Calculate its length >>> iv.length 5 You can operate with + and * over an Interval and the operation is applied to each of its bounds, so the result depends on the type of the bound elements >>> shifted_iv = iv + 3 >>> shifted_iv Interval(3, 8, closed='right') >>> extended_iv = iv * 10.0 >>> extended_iv Interval(0.0, 50.0, closed='right') To create a time interval you can use Timestamps as the bounds >>> year_2017 = pd.Interval(pd.Timestamp('2017-01-01 00:00:00'), ... pd.Timestamp('2018-01-01 00:00:00'), ... closed='left') >>> pd.Timestamp('2017-01-01 00:00') in year_2017 True >>> year_2017.length Timedelta('365 days 00:00:00') Attributes closed Whether the interval is closed on the left-side, right-side, both or neither. closed_left Check if the interval is closed on the left side. closed_right Check if the interval is closed on the right side. is_empty Indicates if an interval is empty, meaning it contains no points. left Left bound for the interval. length Return the length of the Interval. mid Return the midpoint of the Interval. open_left Check if the interval is open on the left side. open_right Check if the interval is open on the right side. right Right bound for the interval. Methods overlaps Check whether two Interval objects overlap.", "score": "0.6802364"}]}
{"task_id": "humaneval_128", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "prod_signs", "gold_generation": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n", "context": "You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None", "function_name": "def prod_signs(arr):", "ctxs": [{"id": "21826", "text": "Function: python.library.math#math.prod\nSnippet: math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8.", "score": "0.7342738"}, {"id": "43865", "text": "Function: numpy.reference.generated.numpy.recarray.prod\nSnippet: numpy.recarray.prod method recarray.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True) Return the product of the array elements over the given axis Refer to numpy.prod for full documentation. See also numpy.prod equivalent function", "score": "0.7297002"}, {"id": "43109", "text": "Function: numpy.reference.generated.numpy.prod\nSnippet: >>> x = np.array([1, 2, 3], dtype=np.int8) >>> np.prod(x).dtype == int True You can also start the product with a value other than one: >>> np.prod([1, 2], initial=5) 10", "score": "0.7245159"}, {"id": "42330", "text": "Function: numpy.reference.generated.numpy.ma.prod\nSnippet: numpy.ma.prod ma.prod(self, axis=None, dtype=None, out=None, keepdims=<no value>) = <numpy.ma.core._frommethod object> Return the product of the array elements over the given axis. Masked elements are set to 1 internally for computation. Refer to numpy.prod for full documentation. See also numpy.ndarray.prod corresponding function for ndarrays numpy.prod equivalent function Notes Arithmetic is modular when using integer types, and no error is raised on overflow.", "score": "0.7225176"}, {"id": "42551", "text": "Function: numpy.reference.generated.numpy.ndarray.prod\nSnippet: numpy.ndarray.prod method ndarray.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True) Return the product of the array elements over the given axis Refer to numpy.prod for full documentation. See also numpy.prod equivalent function", "score": "0.7211851"}]}
{"task_id": "humaneval_129", "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n", "entry_point": "minPath", "gold_generation": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n", "context": "Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]", "function_name": "def minPath(grid, k):", "ctxs": [{"id": "16908", "text": "Function: skimage.api.skimage.graph\nSnippet: By default (reach = 1), the shortest path can only move one row up or down for every step it moves forward (i.e., the path gradient is limited to 1). reach defines the number of elements that can be skipped along each non-axis dimension at each step. axisint, optional The axis along which the path must always move forward (default -1) output_indexlistbool, optional See return value p for explanation. Returns piterable of int For each step along axis, the coordinate of the shortest path. If output_indexlist is True, then the path is returned as a list of n-d tuples that index into arr. If False, then the path is returned as an array listing the coordinates of the path along the non-axis dimensions for each step along the axis dimension. That is, p.shape == (arr.shape[axis], arr.ndim-1) except that p is squeezed before returning so if arr.ndim == 2, then p.shape == (arr.shape[axis],) costfloat Cost of path. This is the absolute sum of all the differences along the path. MCP class skimage.graph.MCP(costs, offsets=None, fully_connected=True, sampling=None) Bases: object A class for finding the minimum cost path through a given n-d costs array. Given an n-d costs array, this class can be used to find the minimum-cost path through that array from any set of points to any other set of points. Basic usage is to initialize the class and call find_costs() with a one or more starting indices (and an optional list of end indices). After that, call traceback() one or more times to find the path from any given end-position to the closest starting index. New paths through the same costs array can be found by calling find_costs() repeatedly. The cost of a path is calculated simply as the sum of the values of the costs array at each point on the path. The class MCP_Geometric, on the other hand, accounts for the fact that diagonal vs. axial moves are of different lengths, and weights the path cost accordingly. Array elements with infinite or negative costs will simply be ignored, as will paths whose cumulative cost overflows to infinite. Parameters costsndarray offsetsiterable, optional A list of offset tuples: each offset specifies a valid move from a given n-d position. If not provided, offsets corresponding to a singly- or fully-connected n-d neighborhood will be constructed with make_offsets(), using the fully_connected parameter value. fully_connectedbool, optional If no offsets are provided, this determines the connectivity of the generated neighborhood. If true, the path may go along diagonals between elements of the costs array; otherwise only axial moves are permitted. samplingtuple, optional For each dimension, specifies the distance between two cells/voxels. If not given or None, the distance is assumed unit. Attributes offsetsndarray Equivalent to the offsets provided to the constructor, or if none were so provided, the offsets created for the requested n-d neighborhood. These are useful for interpreting the traceback array returned by the find_costs() method. __init__(costs, offsets=None, fully_connected=True, sampling=None) See class documentation. find_costs() Find the minimum-cost path from the given starting points.", "score": "0.71599144"}, {"id": "16909", "text": "Function: skimage.api.skimage.graph\nSnippet: This method finds the minimum-cost path to the specified ending indices from any one of the specified starting indices. If no end positions are given, then the minimum-cost path to every position in the costs array will be found. Parameters startsiterable A list of n-d starting indices (where n is the dimension of the costs array). The minimum cost path to the closest/cheapest starting point will be found. endsiterable, optional A list of n-d ending indices. find_all_endsbool, optional If ‘True’ (default), the minimum-cost-path to every specified end-position will be found; otherwise the algorithm will stop when a a path is found to any end-position. (If no ends were specified, then this parameter has no effect.) Returns cumulative_costsndarray Same shape as the costs array; this array records the minimum cost path from the nearest/cheapest starting index to each index considered. (If ends were specified, not all elements in the array will necessarily be considered: positions not evaluated will have a cumulative cost of inf. If find_all_ends is ‘False’, only one of the specified end-positions will have a finite cumulative cost.) tracebackndarray Same shape as the costs array; this array contains the offset to any given index from its predecessor index. The offset indices index into the offsets attribute, which is a array of n-d offsets. In the 2-d case, if offsets[traceback[x, y]] is (-1, -1), that means that the predecessor of [x, y] in the minimum cost path to some start position is [x+1, y+1]. Note that if the offset_index is -1, then the given index was not considered. goal_reached() int goal_reached(int index, float cumcost) This method is called each iteration after popping an index from the heap, before examining the neighbours. This method can be overloaded to modify the behavior of the MCP algorithm. An example might be to stop the algorithm when a certain cumulative cost is reached, or when the front is a certain distance away from the seed point. This method should return 1 if the algorithm should not check the current point’s neighbours and 2 if the algorithm is now done. traceback(end) Trace a minimum cost path through the pre-calculated traceback array. This convenience function reconstructs the the minimum cost path to a given end position from one of the starting indices provided to find_costs(), which must have been called previously. This function can be called as many times as desired after find_costs() has been run. Parameters enditerable An n-d index into the costs array. Returns tracebacklist of n-d tuples A list of indices into the costs array, starting with one of the start positions passed to find_costs(), and ending with the given end index. These indices specify the minimum-cost path from any given start index to the end index. (The total cost of that path can be read out from the cumulative_costs array returned by find_costs().) MCP_Connect class skimage.graph.MCP_Connect(costs, offsets=None, fully_connected=True) Bases: skimage.graph._mcp.MCP Connect source points using the distance-weighted minimum cost function. A front is grown from each seed point simultaneously, while the origin of", "score": "0.71401095"}, {"id": "16914", "text": "Function: skimage.api.skimage.graph#skimage.graph.MCP.find_costs\nSnippet: find_costs() Find the minimum-cost path from the given starting points. This method finds the minimum-cost path to the specified ending indices from any one of the specified starting indices. If no end positions are given, then the minimum-cost path to every position in the costs array will be found. Parameters startsiterable A list of n-d starting indices (where n is the dimension of the costs array). The minimum cost path to the closest/cheapest starting point will be found. endsiterable, optional A list of n-d ending indices. find_all_endsbool, optional If ‘True’ (default), the minimum-cost-path to every specified end-position will be found; otherwise the algorithm will stop when a a path is found to any end-position. (If no ends were specified, then this parameter has no effect.) Returns cumulative_costsndarray Same shape as the costs array; this array records the minimum cost path from the nearest/cheapest starting index to each index considered. (If ends were specified, not all elements in the array will necessarily be considered: positions not evaluated will have a cumulative cost of inf. If find_all_ends is ‘False’, only one of the specified end-positions will have a finite cumulative cost.) tracebackndarray Same shape as the costs array; this array contains the offset to any given index from its predecessor index. The offset indices index into the offsets attribute, which is a array of n-d offsets. In the 2-d case, if offsets[traceback[x, y]] is (-1, -1), that means that the predecessor of [x, y] in the minimum cost path to some start position is [x+1, y+1]. Note that if the offset_index is -1, then the given index was not considered.", "score": "0.71161157"}, {"id": "16929", "text": "Function: skimage.api.skimage.graph#skimage.graph.shortest_path\nSnippet: skimage.graph.shortest_path(arr, reach=1, axis=-1, output_indexlist=False) [source] Find the shortest path through an n-d array from one side to another. Parameters arrndarray of float64 reachint, optional By default (reach = 1), the shortest path can only move one row up or down for every step it moves forward (i.e., the path gradient is limited to 1). reach defines the number of elements that can be skipped along each non-axis dimension at each step. axisint, optional The axis along which the path must always move forward (default -1) output_indexlistbool, optional See return value p for explanation. Returns piterable of int For each step along axis, the coordinate of the shortest path. If output_indexlist is True, then the path is returned as a list of n-d tuples that index into arr. If False, then the path is returned as an array listing the coordinates of the path along the non-axis dimensions for each step along the axis dimension. That is, p.shape == (arr.shape[axis], arr.ndim-1) except that p is squeezed before returning so if arr.ndim == 2, then p.shape == (arr.shape[axis],) costfloat Cost of path. This is the absolute sum of all the differences along the path.", "score": "0.7093962"}, {"id": "16912", "text": "Function: skimage.api.skimage.graph#skimage.graph.MCP\nSnippet: class skimage.graph.MCP(costs, offsets=None, fully_connected=True, sampling=None) Bases: object A class for finding the minimum cost path through a given n-d costs array. Given an n-d costs array, this class can be used to find the minimum-cost path through that array from any set of points to any other set of points. Basic usage is to initialize the class and call find_costs() with a one or more starting indices (and an optional list of end indices). After that, call traceback() one or more times to find the path from any given end-position to the closest starting index. New paths through the same costs array can be found by calling find_costs() repeatedly. The cost of a path is calculated simply as the sum of the values of the costs array at each point on the path. The class MCP_Geometric, on the other hand, accounts for the fact that diagonal vs. axial moves are of different lengths, and weights the path cost accordingly. Array elements with infinite or negative costs will simply be ignored, as will paths whose cumulative cost overflows to infinite. Parameters costsndarray offsetsiterable, optional A list of offset tuples: each offset specifies a valid move from a given n-d position. If not provided, offsets corresponding to a singly- or fully-connected n-d neighborhood will be constructed with make_offsets(), using the fully_connected parameter value. fully_connectedbool, optional If no offsets are provided, this determines the connectivity of the generated neighborhood. If true, the path may go along diagonals between elements of the costs array; otherwise only axial moves are permitted. samplingtuple, optional For each dimension, specifies the distance between two cells/voxels. If not given or None, the distance is assumed unit. Attributes offsetsndarray Equivalent to the offsets provided to the constructor, or if none were so provided, the offsets created for the requested n-d neighborhood. These are useful for interpreting the traceback array returned by the find_costs() method. __init__(costs, offsets=None, fully_connected=True, sampling=None) See class documentation. find_costs() Find the minimum-cost path from the given starting points. This method finds the minimum-cost path to the specified ending indices from any one of the specified starting indices. If no end positions are given, then the minimum-cost path to every position in the costs array will be found. Parameters startsiterable A list of n-d starting indices (where n is the dimension of the costs array). The minimum cost path to the closest/cheapest starting point will be found. endsiterable, optional A list of n-d ending indices. find_all_endsbool, optional If ‘True’ (default), the minimum-cost-path to every specified end-position will be found; otherwise the algorithm will stop when a a path is found to any end-position. (If no ends were specified, then this parameter has no effect.) Returns cumulative_costsndarray Same shape as the costs array; this array records the minimum cost path from the nearest/cheapest starting index to each index considered. (If ends were specified, not all elements in the array will necessarily be considered: positions not evaluated will have a cumulative cost of inf. If find_all_ends is ‘False’, only one", "score": "0.7078791"}]}
{"task_id": "humaneval_130", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "entry_point": "tri", "gold_generation": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "context": "Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]", "function_name": "def tri(n):", "ctxs": [{"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.6272171"}, {"id": "43231", "text": "Function: numpy.reference.generated.numpy.tri\nSnippet: numpy.tri numpy.tri(N, M=None, k=0, dtype=<class 'float'>, *, like=None)[source] An array with ones at and below the given diagonal and zeros elsewhere. Parameters Nint Number of rows in the array. Mint, optional Number of columns in the array. By default, M is taken equal to N. kint, optional The sub-diagonal at and below which the array is filled. k = 0 is the main diagonal, while k < 0 is below it, and k > 0 is above. The default is 0. dtypedtype, optional Data type of the returned array. The default is float. likearray_like Reference object to allow the creation of arrays which are not NumPy arrays. If an array-like passed in as like supports the __array_function__ protocol, the result will be defined by it. In this case, it ensures the creation of an array object compatible with that passed in via this argument. New in version 1.20.0. Returns trindarray of shape (N, M) Array with its lower triangle filled with ones and zero elsewhere; in other words T[i,j] == 1 for j <= i + k, 0 otherwise. Examples >>> np.tri(3, 5, 2, dtype=int) array([[1, 1, 1, 0, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 1]]) >>> np.tri(3, 5, -1) array([[0., 0., 0., 0., 0.], [1., 0., 0., 0., 0.], [1., 1., 0., 0., 0.]])", "score": "0.6241734"}, {"id": "23267", "text": "Function: python.library.random\nSnippet: the same sequence when the compatible seeder is given the same seed. Examples Basic examples: >>> random() # Random float: 0.0 <= x < 1.0 0.37444887175646646 >>> uniform(2.5, 10.0) # Random float: 2.5 <= x < 10.0 3.1800146073117523 >>> expovariate(1 / 5) # Interval between arrivals averaging 5 seconds 5.148957571865031 >>> randrange(10) # Integer from 0 to 9 inclusive 7 >>> randrange(0, 101, 2) # Even integer from 0 to 100 inclusive 26 >>> choice(['win', 'lose', 'draw']) # Single random element from a sequence 'draw' >>> deck = 'ace two three four'.split() >>> shuffle(deck) # Shuffle a list >>> deck ['four', 'two', 'ace', 'three'] >>> sample([10, 20, 30, 40, 50], k=4) # Four samples without replacement [40, 10, 50, 30] Simulations: >>> # Six roulette wheel spins (weighted sampling with replacement) >>> choices(['red', 'black', 'green'], [18, 18, 2], k=6) ['red', 'green', 'black', 'black', 'red', 'black'] >>> # Deal 20 cards without replacement from a deck >>> # of 52 playing cards, and determine the proportion of cards >>> # with a ten-value: ten, jack, queen, or king. >>> dealt = sample(['tens', 'low cards'], counts=[16, 36], k=20) >>> dealt.count('tens') / 20 0.15 >>> # Estimate the probability of getting 5 or more heads from 7 spins >>> # of a biased coin that settles on heads 60% of the time. >>> def trial(): ... return choices('HT', cum_weights=(0.60, 1.00), k=7).count('H') >= 5 ... >>> sum(trial() for i in range(10_000)) / 10_000 0.4169 >>> # Probability of the median of 5 samples being in middle two quartiles >>> def trial(): ... return 2_500 <= sorted(choices(range(10_000), k=5))[2] < 7_500 ... >>> sum(trial() for i in range(10_000)) / 10_000 0.7958 Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: # http://statistics.about.com/od/Applications/a/Example-Of-Bootstrapping.htm from statistics import fmean as mean from random import choices data = [41, 50, 29, 37, 81, 30, 73, 63, 20, 35, 68, 22, 60, 31, 95] means = sorted(mean(choices(data, k=len(data))) for i in range(100)) print(f'The sample mean of {mean(data):.1f} has a 90% confidence ' f'interval from {means[5]:.1f} to {means[94]:.1f}') Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson from statistics import fmean as mean from random import shuffle drug = [54, 73, 53, 70, 73, 68, 52, 65, 65] placebo = [54, 51, 58, 44, 55, 52, 42, 47, 58, 46] observed_diff = mean(drug) - mean(placebo) n = 10_000 count = 0 combined = drug + placebo for i in range(n): shuffle(combined) new_diff = mean(combined[:len(drug)]) - mean(combined[len(drug):]) count += (new_diff >= observed_diff) print(f'{n} label reshufflings produced only {count} instances with a difference') print(f'at least as extreme as the observed difference of {observed_diff:.1f}.') print(f'The one-sided p-value of {count / n:.4f} leads us to reject the null') print(f'hypothesis that there is no difference between the drug and the placebo.') Simulation of arrival times and service deliveries", "score": "0.61697596"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6104413"}, {"id": "20299", "text": "Function: python.library.functools\nSnippet: in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991: ... pep = get_pep(n) ... print(n, len(pep)) >>> get_pep.cache_info() CacheInfo(hits=3, misses=8, maxsize=32, currsize=8) Example of efficiently computing Fibonacci numbers using a cache to implement a dynamic programming technique: @lru_cache(maxsize=None) def fib(n): if n < 2: return n return fib(n-1) + fib(n-2) >>> [fib(n) for n in range(16)] [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610] >>> fib.cache_info() CacheInfo(hits=28, misses=16, maxsize=None, currsize=16) New in version 3.2. Changed in version 3.3: Added the typed option. Changed in version 3.8: Added the user_function option. New in version 3.9: Added the function cache_parameters() @functools.total_ordering Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest. This simplifies the effort involved in specifying all of the possible rich comparison operations: The class must define one of __lt__(), __le__(), __gt__(), or __ge__(). In addition, the class should supply an __eq__() method. For example: @total_ordering class Student: def _is_valid_operand(self, other): return (hasattr(other, \"lastname\") and hasattr(other, \"firstname\")) def __eq__(self, other): if not self._is_valid_operand(other): return NotImplemented return ((self.lastname.lower(), self.firstname.lower()) == (other.lastname.lower(), other.firstname.lower())) def __lt__(self, other): if not self._is_valid_operand(other): return NotImplemented return ((self.lastname.lower(), self.firstname.lower()) < (other.lastname.lower(), other.firstname.lower())) Note While this decorator makes it easy to create well behaved totally ordered types, it does come at the cost of slower execution and more complex stack traces for the derived comparison methods. If performance benchmarking indicates this is a bottleneck for a given application, implementing all six rich comparison methods instead is likely to provide an easy speed boost. New in version 3.2. Changed in version 3.4: Returning NotImplemented from the underlying comparison function for unrecognised types is now supported. functools.partial(func, /, *args, **keywords) Return a new partial object which when called will behave like func called with the positional arguments args and keyword arguments keywords. If more arguments are supplied to the call, they are appended to args. If additional keyword arguments are supplied, they extend and override keywords. Roughly equivalent to: def partial(func, /, *args, **keywords): def newfunc(*fargs, **fkeywords): newkeywords = {**keywords, **fkeywords} return func(*args, *fargs, **newkeywords) newfunc.func = func newfunc.args = args newfunc.keywords = keywords return newfunc The partial() is used for partial function application which “freezes” some portion of a function’s arguments and/or keywords resulting in a new object with a simplified signature. For example, partial() can be used to create a callable that behaves like the int() function where the base argument defaults to two: >>> from functools import partial >>> basetwo = partial(int, base=2) >>> basetwo.__doc__ = 'Convert base 2 string to an int.' >>> basetwo('10010') 18 class functools.partialmethod(func, /, *args, **keywords) Return a new partialmethod descriptor which behaves like partial except that it is designed to be used as a method definition rather than being directly callable. func must be a descriptor or a callable (objects which are both, like normal functions, are handled as descriptors). When func is a descriptor (such as a normal Python function, classmethod(), staticmethod(),", "score": "0.6086777"}]}
{"task_id": "humaneval_131", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "entry_point": "digits", "gold_generation": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "context": "Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15", "function_name": "def digits(n):", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6872592"}, {"id": "21826", "text": "Function: python.library.math#math.prod\nSnippet: math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8.", "score": "0.68275833"}, {"id": "21776", "text": "Function: python.library.math\nSnippet: (not a number), return x. If x is negative, return ulp(-x). If x is a positive infinity, return x. If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, sys.float_info.min). If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is x - ulp(x). Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x). ULP stands for “Unit in the Last Place”. See also math.nextafter() and sys.float_info.epsilon. New in version 3.9. Note that frexp() and modf() have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 2**52 necessarily has no fractional bits. Power and logarithmic functions math.exp(x) Return e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). math.expm1(x) Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision: >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.0000050000069649e-05 >>> expm1(1e-5) # result accurate to full precision 1.0000050000166668e-05 New in version 3.2. math.log(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). math.log1p(x) Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. math.log2(x) Return the base-2 logarithm of x. This is usually more accurate than log(x, 2). New in version 3.3. See also int.bit_length() returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. math.log10(x) Return the base-10 logarithm of x. This is usually more accurate than log(x, 10). math.pow(x, y) Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", "score": "0.6594362"}, {"id": "25734", "text": "Function: python.library.stdtypes\nSnippet: in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf, -sys.hash_info.inf and sys.hash_info.nan are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.) For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, it’s replaced with -2. To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Iterator Types Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example", "score": "0.6576277"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.6563201"}]}
{"task_id": "humaneval_132", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "entry_point": "is_nested", "gold_generation": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "context": "", "function_name": "def is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015645"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49314862"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.4911952"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48990315"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.4897412"}]}
{"task_id": "humaneval_133", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "sum_squares", "gold_generation": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "context": "You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6", "function_name": "def sum_squares(lst):", "ctxs": [{"id": "19593", "text": "Function: python.library.decimal#decimal.ROUND_CEILING\nSnippet: decimal.ROUND_CEILING Round towards Infinity.", "score": "0.7485882"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.7433314"}, {"id": "21812", "text": "Function: python.library.math#math.isqrt\nSnippet: math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8.", "score": "0.73113084"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.71709734"}, {"id": "43211", "text": "Function: numpy.reference.generated.numpy.sum\nSnippet: the summation is along the fast axis in memory. Note that the exact precision may vary depending on other parameters. In contrast to NumPy, Python’s math.fsum function uses a slower but more precise approach to summation. Especially when summing a large number of lower precision floating point numbers, such as float32, numerical errors can become significant. In such cases it can be advisable to use dtype=”float64” to use a higher precision for the output. Examples >>> np.sum([0.5, 1.5]) 2.0 >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32) 1 >>> np.sum([[0, 1], [0, 5]]) 6 >>> np.sum([[0, 1], [0, 5]], axis=0) array([0, 6]) >>> np.sum([[0, 1], [0, 5]], axis=1) array([1, 5]) >>> np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1) array([1., 5.]) If the accumulator is too small, overflow occurs: >>> np.ones(128, dtype=np.int8).sum(dtype=np.int8) -128 You can also start the sum with a value other than zero: >>> np.sum([10], initial=5) 15", "score": "0.71467507"}]}
{"task_id": "humaneval_134", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "check_if_last_char_is_a_letter", "gold_generation": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "context": "", "function_name": "def check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015645"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49314862"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.4911952"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48990315"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.4897412"}]}
{"task_id": "humaneval_135", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "entry_point": "can_arrange", "gold_generation": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "context": "Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1", "function_name": "def can_arrange(arr):", "ctxs": [{"id": "17638", "text": "Function: python.library.array#array.array.index\nSnippet: array.index(x) Return the smallest i such that i is the index of the first occurrence of x in the array.", "score": "0.7619379"}, {"id": "25766", "text": "Function: python.library.stdtypes\nSnippet: is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others) set |= other | ... Update the set, adding elements from all others. intersection_update(*others) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types — dict A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can", "score": "0.7305869"}, {"id": "19496", "text": "Function: python.library.decimal#decimal.Context.next_minus\nSnippet: next_minus(x) Returns the largest representable number smaller than x.", "score": "0.7276095"}, {"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.72637814"}, {"id": "42871", "text": "Function: numpy.reference.generated.numpy.greater_equal\nSnippet: numpy.greater_equal numpy.greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = <ufunc 'greater_equal'> Return the truth value of (x1 >= x2) element-wise. Parameters x1, x2array_like Input arrays. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output). outndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. wherearray_like, optional This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default out=None, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the ufunc docs. Returns outbool or ndarray of bool Output array, element-wise comparison of x1 and x2. Typically of type bool, unless dtype=object is passed. This is a scalar if both x1 and x2 are scalars. See also greater, less, less_equal, equal, not_equal Examples >>> np.greater_equal([4, 2, 1], [2, 2, 2]) array([ True, True, False]) The >= operator can be used as a shorthand for np.greater_equal on ndarrays. >>> a = np.array([4, 2, 1]) >>> b = np.array([2, 2, 2]) >>> a >= b array([ True, True, False])", "score": "0.7184774"}]}
{"task_id": "humaneval_136", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "entry_point": "largest_smallest_integers", "gold_generation": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "context": "", "function_name": "def largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015645"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49314862"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.4911952"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48990315"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.4897412"}]}
{"task_id": "humaneval_137", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "compare_one", "gold_generation": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n", "context": "Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) ➞ 2.5\n    compare_one(1, \"2,3\") ➞ \"2,3\"\n    compare_one(\"5,1\", \"6\") ➞ \"6\"\n    compare_one(\"1\", 1) ➞ None", "function_name": "def compare_one(a, b):", "ctxs": [{"id": "25730", "text": "Function: python.library.stdtypes\nSnippet: equivalent to is. The <, <=, > and >= operators are only defined where they make sense; for example, they raise a TypeError exception when one of the arguments is a complex number. Non-identical instances of a class normally compare as non-equal unless the class defines the __eq__() method. Instances of a class cannot be ordered with respect to other instances of the same class, or other types of object, unless the class defines enough of the methods __lt__(), __le__(), __gt__(), and __ge__() (in general, __lt__() and __eq__() are sufficient, if you want the conventional meanings of the comparison operators). The behavior of the is and is not operators cannot be customized; also they can be applied to any two objects and never raise an exception. Two more operations with the same syntactic priority, in and not in, are supported by types that are iterable or implement the __contains__() method. Numeric Types — int, float, complex There are three distinct numeric types: integers, floating point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating point numbers are usually implemented using double in C; information about the precision and internal representation of floating point numbers for the machine on which your program is running is available in sys.float_info. Complex numbers have a real and imaginary part, which are each a floating point number. To extract these parts from a complex number z, use z.real and z.imag. (The standard library includes the additional numeric types fractions.Fraction, for rationals, and decimal.Decimal, for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating point numbers. Appending 'j' or 'J' to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. 2 The constructors int(), float(), and complex() can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): Operation Result Notes Full documentation x + y sum of x and y x - y difference of x and y x * y product of x and y x / y quotient of x and y x // y floored quotient of x and y (1) x % y remainder of x / y (2) -x x negated +x x unchanged abs(x) absolute value", "score": "0.76229405"}, {"id": "41598", "text": "Function: numpy.reference.arrays.scalars\nSnippet: decimal value may compare unequal despite printing identically: >>> f16 = np.float16(\"0.1\") >>> f32 = np.float32(\"0.1\") >>> f64 = np.float64(\"0.1\") >>> f16 == f32 == f64 False >>> f16, f32, f64 (0.1, 0.1, 0.1) Floating-point types class numpy.floating[source] Abstract base class of all floating-point scalar types. class numpy.half[source] Half-precision floating-point number type. Character code 'e' Alias on this platform (Linux x86_64) numpy.float16: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa. class numpy.single[source] Single-precision floating-point number type, compatible with C float. Character code 'f' Alias on this platform (Linux x86_64) numpy.float32: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa. class numpy.double(x=0, /)[source] Double-precision floating-point number type, compatible with Python float and C double. Character code 'd' Alias numpy.float_ Alias on this platform (Linux x86_64) numpy.float64: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa. class numpy.longdouble[source] Extended-precision floating-point number type, compatible with C long double but not necessarily with IEEE 754 quadruple-precision. Character code 'g' Alias numpy.longfloat Alias on this platform (Linux x86_64) numpy.float128: 128-bit extended-precision floating-point number type. Complex floating-point types class numpy.complexfloating[source] Abstract base class of all complex number scalar types that are made up of floating-point numbers. class numpy.csingle[source] Complex number type composed of two single-precision floating-point numbers. Character code 'F' Alias numpy.singlecomplex Alias on this platform (Linux x86_64) numpy.complex64: Complex number type composed of 2 32-bit-precision floating-point numbers. class numpy.cdouble(real=0, imag=0)[source] Complex number type composed of two double-precision floating-point numbers, compatible with Python complex. Character code 'D' Alias numpy.cfloat Alias numpy.complex_ Alias on this platform (Linux x86_64) numpy.complex128: Complex number type composed of 2 64-bit-precision floating-point numbers. class numpy.clongdouble[source] Complex number type composed of two extended-precision floating-point numbers. Character code 'G' Alias numpy.clongfloat Alias numpy.longcomplex Alias on this platform (Linux x86_64) numpy.complex256: Complex number type composed of 2 128-bit extended-precision floating-point numbers. Other types class numpy.bool_[source] Boolean type (True or False), stored as a byte. Warning The bool_ type is not a subclass of the int_ type (the bool_ is not even a number type). This is different than Python’s default implementation of bool as a sub-class of int. Character code '?' Alias numpy.bool8 class numpy.datetime64[source] If created from a 64-bit integer, it represents an offset from 1970-01-01T00:00:00. If created from string, the string can be in ISO 8601 date or datetime format. >>> np.datetime64(10, 'Y') numpy.datetime64('1980') >>> np.datetime64('1980', 'Y') numpy.datetime64('1980') >>> np.datetime64(10, 'D') numpy.datetime64('1970-01-11') See Datetimes and Timedeltas for more information. Character code 'M' class numpy.timedelta64[source] A timedelta stored as a 64-bit integer. See Datetimes and Timedeltas for more information. Character code 'm' class numpy.object_[source] Any Python object. Character code 'O' Note The data actually stored in object arrays (i.e., arrays having dtype object_) are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python lists, in the sense that their contents need not be of the same Python type. The object type is also special because an array containing object_ items does not return an object_ object", "score": "0.73626757"}, {"id": "19429", "text": "Function: python.library.decimal\nSnippet: objects also have a number of specialized methods: adjusted() Return the adjusted exponent after shifting out the coefficient’s rightmost digits until only the lead digit remains: Decimal('321e+5').adjusted() returns seven. Used for determining the position of the most significant digit with respect to the decimal point. as_integer_ratio() Return a pair (n, d) of integers that represent the given Decimal instance as a fraction, in lowest terms and with a positive denominator: >>> Decimal('-3.14').as_integer_ratio() (-157, 50) The conversion is exact. Raise OverflowError on infinities and ValueError on NaNs. New in version 3.6. as_tuple() Return a named tuple representation of the number: DecimalTuple(sign, digits, exponent). canonical() Return the canonical encoding of the argument. Currently, the encoding of a Decimal instance is always canonical, so this operation returns its argument unchanged. compare(other, context=None) Compare the values of two Decimal instances. compare() returns a Decimal instance, and if either operand is a NaN then the result is a NaN: a or b is a NaN ==> Decimal('NaN') a < b ==> Decimal('-1') a == b ==> Decimal('0') a > b ==> Decimal('1') compare_signal(other, context=None) This operation is identical to the compare() method, except that all NaNs signal. That is, if neither operand is a signaling NaN then any quiet NaN operand is treated as though it were a signaling NaN. compare_total(other, context=None) Compare two operands using their abstract representation rather than their numerical value. Similar to the compare() method, but the result gives a total ordering on Decimal instances. Two Decimal instances with the same numeric value but different representations compare unequal in this ordering: >>> Decimal('12.0').compare_total(Decimal('12')) Decimal('-1') Quiet and signaling NaNs are also included in the total ordering. The result of this function is Decimal('0') if both operands have the same representation, Decimal('-1') if the first operand is lower in the total order than the second, and Decimal('1') if the first operand is higher in the total order than the second operand. See the specification for details of the total order. This operation is unaffected by context and is quiet: no flags are changed and no rounding is performed. As an exception, the C version may raise InvalidOperation if the second operand cannot be converted exactly. compare_total_mag(other, context=None) Compare two operands using their abstract representation rather than their value as in compare_total(), but ignoring the sign of each operand. x.compare_total_mag(y) is equivalent to x.copy_abs().compare_total(y.copy_abs()). This operation is unaffected by context and is quiet: no flags are changed and no rounding is performed. As an exception, the C version may raise InvalidOperation if the second operand cannot be converted exactly. conjugate() Just returns self, this method is only to comply with the Decimal Specification. copy_abs() Return the absolute value of the argument. This operation is unaffected by the context and is quiet: no flags are changed and no rounding is performed. copy_negate() Return the negation of the argument. This operation is unaffected by the context and is quiet: no flags are changed and no rounding is performed. copy_sign(other, context=None) Return a copy of the first", "score": "0.73463345"}, {"id": "19455", "text": "Function: python.library.decimal#decimal.Context.compare\nSnippet: compare(x, y) Compares x and y numerically.", "score": "0.73387456"}, {"id": "19457", "text": "Function: python.library.decimal#decimal.Context.compare_total\nSnippet: compare_total(x, y) Compares two operands using their abstract representation.", "score": "0.7285732"}]}
{"task_id": "humaneval_138", "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n", "entry_point": "is_equal_to_sum_even", "gold_generation": "    return n%2 == 0 and n >= 8\n", "context": "Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True", "function_name": "def is_equal_to_sum_even(n):", "ctxs": [{"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.6361223"}, {"id": "21810", "text": "Function: python.library.math#math.isinf\nSnippet: math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise.", "score": "0.635972"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.62809634"}, {"id": "19539", "text": "Function: python.library.decimal#decimal.Decimal.is_infinite\nSnippet: is_infinite() Return True if the argument is either positive or negative infinity and False otherwise.", "score": "0.6262554"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.624673"}]}
{"task_id": "humaneval_139", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "entry_point": "special_factorial", "gold_generation": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "context": "The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.", "function_name": "def special_factorial(n):", "ctxs": [{"id": "21799", "text": "Function: python.library.math#math.factorial\nSnippet: math.factorial(x) Return x factorial as an integer. Raises ValueError if x is not integral or is negative. Deprecated since version 3.9: Accepting floats with integral values (like 5.0) is deprecated.", "score": "0.734733"}, {"id": "21773", "text": "Function: python.library.math\nSnippet: math — Mathematical functions This module provides access to the mathematical functions defined by the C standard. These functions cannot be used with complex numbers; use the functions of the same name from the cmath module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don’t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place. The following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats. Number-theoretic and representation functions math.ceil(x) Return the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to x.__ceil__(), which should return an Integral value. math.comb(n, k) Return the number of ways to choose k items from n items without repetition and without order. Evaluates to n! / (k! * (n - k)!) when k <= n and evaluates to zero when k > n. Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of the expression (1 + x) ** n. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.copysign(x, y) Return a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, copysign(1.0, -0.0) returns -1.0. math.fabs(x) Return the absolute value of x. math.factorial(x) Return x factorial as an integer. Raises ValueError if x is not integral or is negative. Deprecated since version 3.9: Accepting floats with integral values (like 5.0) is deprecated. math.floor(x) Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to x.__floor__(), which should return an Integral value. math.fmod(x, y) Return fmod(x, y), as defined by the platform C library. Note that the Python expression x % y may not return the same result. The intent of the C standard is that fmod(x, y) be exactly (mathematically; to infinite precision) equal to x - n*y for some integer n such that the result has the same sign as x and magnitude less than abs(y). Python’s x % y returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, fmod(-1e-100, 1e100) is -1e-100, but the result of Python’s -1e-100 % 1e100 is 1e100-1e-100, which cannot be represented exactly as a float, and rounds to the surprising 1e100. For this reason, function fmod() is generally preferred when working with floats, while Python’s x % y is preferred when working with integers. math.frexp(x) Return the mantissa and exponent of x as the pair (m, e).", "score": "0.66736305"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.65029764"}, {"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.65002155"}, {"id": "21802", "text": "Function: python.library.math#math.frexp\nSnippet: math.frexp(x) Return the mantissa and exponent of x as the pair (m, e). m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way.", "score": "0.6451539"}]}
{"task_id": "humaneval_140", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n", "entry_point": "fix_spaces", "gold_generation": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n", "context": "Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"", "function_name": "def fix_spaces(text):", "ctxs": [{"id": "25036", "text": "Function: python.library.textwrap#textwrap.TextWrapper.replace_whitespace\nSnippet: replace_whitespace (default: True) If true, after tab expansion but before wrapping, the wrap() method will replace each whitespace character with a single space. The whitespace characters replaced are as follows: tab, newline, vertical tab, formfeed, and carriage return ('\\t\\n\\v\\f\\r'). Note If expand_tabs is false and replace_whitespace is true, each tab character will be replaced by a single space, which is not the same as tab expansion. Note If replace_whitespace is false, newlines may appear in the middle of a line and cause strange output. For this reason, text should be split into paragraphs (using str.splitlines() or similar) which are wrapped separately.", "score": "0.716245"}, {"id": "24422", "text": "Function: python.library.string#string.whitespace\nSnippet: string.whitespace A string containing all ASCII characters that are considered whitespace. This includes the characters space, tab, linefeed, return, formfeed, and vertical tab.", "score": "0.70050395"}, {"id": "24398", "text": "Function: python.library.string\nSnippet: characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", "score": "0.6967038"}, {"id": "25024", "text": "Function: python.library.textwrap#textwrap.shorten\nSnippet: textwrap.shorten(text, width, **kwargs) Collapse and truncate the given text to fit in the given width. First the whitespace in text is collapsed (all whitespace is replaced by single spaces). If the result fits in the width, it is returned. Otherwise, enough words are dropped from the end so that the remaining words plus the placeholder fit within width: >>> textwrap.shorten(\"Hello world!\", width=12) 'Hello world!' >>> textwrap.shorten(\"Hello world!\", width=11) 'Hello [...]' >>> textwrap.shorten(\"Hello world\", width=10, placeholder=\"...\") 'Hello...' Optional keyword arguments correspond to the instance attributes of TextWrapper, documented below. Note that the whitespace is collapsed before the text is passed to the TextWrapper fill() function, so changing the value of tabsize, expand_tabs, drop_whitespace, and replace_whitespace will have no effect. New in version 3.4.", "score": "0.6909501"}, {"id": "24370", "text": "Function: python.library.stdtypes#str.replace\nSnippet: str.replace(old, new[, count]) Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced.", "score": "0.6896063"}]}
{"task_id": "humaneval_141", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n", "entry_point": "file_name_check", "gold_generation": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n", "context": "Create a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)", "function_name": "def file_name_check(file_name):", "ctxs": [{"id": "20196", "text": "Function: python.library.fnmatch#fnmatch.fnmatch\nSnippet: fnmatch.fnmatch(filename, pattern) Test whether the filename string matches the pattern string, returning True or False. Both parameters are case-normalized using os.path.normcase(). fnmatchcase() can be used to perform a case-sensitive comparison, regardless of whether that’s standard for the operating system. This example will print all file names in the current directory with the extension .txt: import fnmatch import os for file in os.listdir('.'): if fnmatch.fnmatch(file, '*.txt'): print(file)", "score": "0.75750136"}, {"id": "35412", "text": "Function: django.howto.custom-file-storage#django.core.files.storage.get_valid_name\nSnippet: get_valid_name(name)", "score": "0.74848956"}, {"id": "35423", "text": "Function: django.ref.files.storage#django.core.files.storage.Storage.get_valid_name\nSnippet: get_valid_name(name) Returns a filename based on the name parameter that’s suitable for use on the target storage system.", "score": "0.7426517"}, {"id": "20197", "text": "Function: python.library.fnmatch#fnmatch.fnmatchcase\nSnippet: fnmatch.fnmatchcase(filename, pattern) Test whether filename matches pattern, returning True or False; the comparison is case-sensitive and does not apply os.path.normcase().", "score": "0.73658895"}, {"id": "27141", "text": "Function: python.library.zipfile#zipfile.is_zipfile\nSnippet: zipfile.is_zipfile(filename) Returns True if filename is a valid ZIP file based on its magic number, otherwise returns False. filename may be a file or file-like object too. Changed in version 3.1: Support for file and file-like objects.", "score": "0.7343945"}]}
{"task_id": "humaneval_142", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n", "entry_point": "sum_squares", "gold_generation": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n", "context": "\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126", "function_name": "def sum_squares(lst):", "ctxs": [{"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.7408548"}, {"id": "21774", "text": "Function: python.library.math\nSnippet: m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. math.fsum(iterable) Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. math.gcd(*integers) Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0. New in version 3.5. Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) Return True if the values a and b are close to each other and False otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass rel_tol=0.05. The default tolerance is 1e-09, which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol). The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, NaN is not considered close to any other value, including NaN. inf and -inf are only considered close to themselves. New in version 3.5. See also PEP 485 – A function for testing approximate equality math.isfinite(x) Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.) New in version 3.2. math.isinf(x) Return True if x is a positive or negative infinity, and False otherwise. math.isnan(x) Return True if x is a NaN (not a number), and False otherwise. math.isqrt(n) Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For", "score": "0.72025293"}, {"id": "25736", "text": "Function: python.library.stdtypes\nSnippet: s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up", "score": "0.72010857"}, {"id": "25740", "text": "Function: python.library.stdtypes\nSnippet: omitted, it defaults to 0. If step is zero, ValueError is raised. For a positive step, the contents of a range r are determined by the formula r[i] = start + step*i where i >= 0 and r[i] < stop. For a negative step, the contents of the range are still determined by the formula r[i] = start + step*i, but the constraints are i >= 0 and r[i] > stop. A range object will be empty if r[0] does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than sys.maxsize are permitted but some features (such as len()) may raise OverflowError. Range examples: >>> list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> list(range(0, 30, 5)) [0, 5, 10, 15, 20, 25] >>> list(range(0, 10, 3)) [0, 3, 6, 9] >>> list(range(0, -10, -1)) [0, -1, -2, -3, -4, -5, -6, -7, -8, -9] >>> list(range(0)) [] >>> list(range(1, 0)) [] Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). start The value of the start parameter (or 0 if the parameter was not supplied) stop The value of the stop parameter step The value of the step parameter (or 1 if the parameter was not supplied) The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and subranges as needed). Range objects implement the collections.abc.Sequence ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): >>> r = range(0, 20, 2) >>> r range(0, 20, 2) >>> 11 in r False >>> 10 in r True >>> r.index(10) 5 >>> r[5] 10 >>> r[:5] range(0, 10, 2) >>> r[-1] 18 Testing range objects for equality with == and != compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different start, stop and step attributes, for example range(0) == range(2, 1, 3) or range(0, 3, 2) == range(0, 4, 2).) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test int objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity). New in version 3.3: The", "score": "0.69598275"}, {"id": "21773", "text": "Function: python.library.math\nSnippet: math — Mathematical functions This module provides access to the mathematical functions defined by the C standard. These functions cannot be used with complex numbers; use the functions of the same name from the cmath module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don’t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place. The following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats. Number-theoretic and representation functions math.ceil(x) Return the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to x.__ceil__(), which should return an Integral value. math.comb(n, k) Return the number of ways to choose k items from n items without repetition and without order. Evaluates to n! / (k! * (n - k)!) when k <= n and evaluates to zero when k > n. Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of the expression (1 + x) ** n. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.copysign(x, y) Return a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, copysign(1.0, -0.0) returns -1.0. math.fabs(x) Return the absolute value of x. math.factorial(x) Return x factorial as an integer. Raises ValueError if x is not integral or is negative. Deprecated since version 3.9: Accepting floats with integral values (like 5.0) is deprecated. math.floor(x) Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to x.__floor__(), which should return an Integral value. math.fmod(x, y) Return fmod(x, y), as defined by the platform C library. Note that the Python expression x % y may not return the same result. The intent of the C standard is that fmod(x, y) be exactly (mathematically; to infinite precision) equal to x - n*y for some integer n such that the result has the same sign as x and magnitude less than abs(y). Python’s x % y returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, fmod(-1e-100, 1e100) is -1e-100, but the result of Python’s -1e-100 % 1e100 is 1e100-1e-100, which cannot be represented exactly as a float, and rounds to the surprising 1e100. For this reason, function fmod() is generally preferred when working with floats, while Python’s x % y is preferred when working with integers. math.frexp(x) Return the mantissa and exponent of x as the pair (m, e).", "score": "0.69534767"}]}
{"task_id": "humaneval_143", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "entry_point": "words_in_sentence", "gold_generation": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "context": "You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters", "function_name": "def words_in_sentence(sentence):", "ctxs": [{"id": "24398", "text": "Function: python.library.string\nSnippet: characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", "score": "0.7079065"}, {"id": "25020", "text": "Function: python.library.textwrap\nSnippet: \"'\", followed by a space. One problem with this is algorithm is that it is unable to detect the difference between “Dr.” in [...] Dr. Frankenstein's monster [...] and “Spot.” in [...] See Spot. See Spot run [...] fix_sentence_endings is false by default. Since the sentence detection algorithm relies on string.lowercase for the definition of “lowercase letter”, and a convention of using two spaces after a period to separate sentences on the same line, it is specific to English-language texts. break_long_words (default: True) If true, then words longer than width will be broken in order to ensure that no lines are longer than width. If it is false, long words will not be broken, and some lines may be longer than width. (Long words will be put on a line by themselves, in order to minimize the amount by which width is exceeded.) break_on_hyphens (default: True) If true, wrapping will occur preferably on whitespaces and right after hyphens in compound words, as it is customary in English. If false, only whitespaces will be considered as potentially good places for line breaks, but you need to set break_long_words to false if you want truly insecable words. Default behaviour in previous versions was to always allow breaking hyphenated words. max_lines (default: None) If not None, then the output will contain at most max_lines lines, with placeholder appearing at the end of the output. New in version 3.4. placeholder (default: ' [...]') String that will appear at the end of the output text if it has been truncated. New in version 3.4. TextWrapper also provides some public methods, analogous to the module-level convenience functions: wrap(text) Wraps the single paragraph in text (a string) so every line is at most width characters long. All wrapping options are taken from instance attributes of the TextWrapper instance. Returns a list of output lines, without final newlines. If the wrapped output has no content, the returned list is empty. fill(text) Wraps the single paragraph in text, and returns a single string containing the wrapped paragraph.", "score": "0.6963833"}, {"id": "24377", "text": "Function: python.library.stdtypes#str.split\nSnippet: str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3']", "score": "0.6932975"}, {"id": "15368", "text": "Function: pandas.reference.api.pandas.series.str.split\nSnippet: split. >>> s.str.split(expand=True) 0 1 2 3 4 0 this is a regular sentence 1 https://docs.python.org/3/tutorial/index.html None None None None 2 NaN NaN NaN NaN NaN For slightly more complex use cases like splitting the html document name from a url, a combination of parameter settings can be used. >>> s.str.rsplit(\"/\", n=1, expand=True) 0 1 0 this is a regular sentence None 1 https://docs.python.org/3/tutorial index.html 2 NaN NaN Remember to escape special characters when explicitly using regular expressions. >>> s = pd.Series([\"foo and bar plus baz\"]) >>> s.str.split(r\"and|plus\", expand=True) 0 1 2 0 foo bar baz Regular expressions can be used to handle urls or file names. When pat is a string and regex=None (the default), the given pat is compiled as a regex only if len(pat) != 1. >>> s = pd.Series(['foojpgbar.jpg']) >>> s.str.split(r\".\", expand=True) 0 1 0 foojpgbar jpg >>> s.str.split(r\"\\.jpg\", expand=True) 0 1 0 foojpgbar When regex=True, pat is interpreted as a regex >>> s.str.split(r\"\\.jpg\", regex=True, expand=True) 0 1 0 foojpgbar A compiled regex can be passed as pat >>> import re >>> s.str.split(re.compile(r\"\\.jpg\"), expand=True) 0 1 0 foojpgbar When regex=False, pat is interpreted as the string itself >>> s.str.split(r\"\\.jpg\", regex=False, expand=True) 0 0 foojpgbar.jpg", "score": "0.69111395"}, {"id": "23301", "text": "Function: python.library.re\nSnippet: repetitions as possible. For example, a{3,5} will match from 3 to 5 'a' characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, a{4,}b will match 'aaaab' or a thousand 'a' characters followed by a 'b', but not 'aaab'. The comma may not be omitted or the modifier would be confused with the previously described form. {m,n}? Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous qualifier. For example, on the 6-character string 'aaaaaa', a{3,5} will match 5 'a' characters, while a{3,5}? will only match 3 characters. \\ Either escapes special characters (permitting you to match characters like '*', '?', and so forth), or signals a special sequence; special sequences are discussed below. If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions. [] Used to indicate a set of characters. In a set: Characters can be listed individually, e.g. [amk] will match 'a', 'm', or 'k'. Ranges of characters can be indicated by giving two characters and separating them by a '-', for example [a-z] will match any lowercase ASCII letter, [0-5][0-9] will match all the two-digits numbers from 00 to 59, and [0-9A-Fa-f] will match any hexadecimal digit. If - is escaped (e.g. [a\\-z]) or if it’s placed as the first or last character (e.g. [-a] or [a-]), it will match a literal '-'. Special characters lose their special meaning inside sets. For example, [(+*)] will match any of the literal characters '(', '+', '*', or ')'. Character classes such as \\w or \\S (defined below) are also accepted inside a set, although the characters they match depends on whether ASCII or LOCALE mode is in force. Characters that are not within a range can be matched by complementing the set. If the first character of the set is '^', all the characters that are not in the set will be matched. For example, [^5] will match any character except '5', and [^^] will match any character except '^'. ^ has no special meaning if it’s not the first character in the set. To match a literal ']' inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both [()[\\]{}] and []()[{}] will both match a parenthesis. Support of nested sets and set operations as in Unicode Technical Standard #18 might be added in the future. This would change the syntax, so to facilitate this change", "score": "0.6899298"}]}
{"task_id": "humaneval_144", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "entry_point": "simplify", "gold_generation": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "context": "Your task is to implement a function that will simplify the expression\n    x * n. The function returns True if x * n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False", "function_name": "def simplify(x, n):", "ctxs": [{"id": "20202", "text": "Function: python.library.fractions#fractions.Fraction\nSnippet: class fractions.Fraction(numerator=0, denominator=1) class fractions.Fraction(other_fraction) class fractions.Fraction(float) class fractions.Fraction(decimal) class fractions.Fraction(string) The first version requires that numerator and denominator are instances of numbers.Rational and returns a new Fraction instance with value numerator/denominator. If denominator is 0, it raises a ZeroDivisionError. The second version requires that other_fraction is an instance of numbers.Rational and returns a Fraction instance with the same value. The next two versions accept either a float or a decimal.Decimal instance, and return a Fraction instance with exactly the same value. Note that due to the usual issues with binary floating-point (see Floating Point Arithmetic: Issues and Limitations), the argument to Fraction(1.1) is not exactly equal to 11/10, and so Fraction(1.1) does not return Fraction(11, 10) as one might expect. (But see the documentation for the limit_denominator() method below.) The last version of the constructor expects a string or unicode instance. The usual form for this instance is: [sign] numerator ['/' denominator] where the optional sign may be either ‘+’ or ‘-‘ and numerator and denominator (if present) are strings of decimal digits. In addition, any string that represents a finite value and is accepted by the float constructor is also accepted by the Fraction constructor. In either form the input string may also have leading and/or trailing whitespace. Here are some examples: >>> from fractions import Fraction >>> Fraction(16, -10) Fraction(-8, 5) >>> Fraction(123) Fraction(123, 1) >>> Fraction() Fraction(0, 1) >>> Fraction('3/7') Fraction(3, 7) >>> Fraction(' -3/7 ') Fraction(-3, 7) >>> Fraction('1.414213 \\t\\n') Fraction(1414213, 1000000) >>> Fraction('-.125') Fraction(-1, 8) >>> Fraction('7e-6') Fraction(7, 1000000) >>> Fraction(2.25) Fraction(9, 4) >>> Fraction(1.1) Fraction(2476979795053773, 2251799813685248) >>> from decimal import Decimal >>> Fraction(Decimal('1.1')) Fraction(11, 10) The Fraction class inherits from the abstract base class numbers.Rational, and implements all of the methods and operations from that class. Fraction instances are hashable, and should be treated as immutable. In addition, Fraction has the following properties and methods: Changed in version 3.2: The Fraction constructor now accepts float and decimal.Decimal instances. Changed in version 3.9: The math.gcd() function is now used to normalize the numerator and denominator. math.gcd() always return a int type. Previously, the GCD type depended on numerator and denominator. numerator Numerator of the Fraction in lowest term. denominator Denominator of the Fraction in lowest term. as_integer_ratio() Return a tuple of two integers, whose ratio is equal to the Fraction and with a positive denominator. New in version 3.8. from_float(flt) This class method constructs a Fraction representing the exact value of flt, which must be a float. Beware that Fraction.from_float(0.3) is not the same value as Fraction(3, 10). Note From Python 3.2 onwards, you can also construct a Fraction instance directly from a float. from_decimal(dec) This class method constructs a Fraction representing the exact value of dec, which must be a decimal.Decimal instance. Note From Python 3.2 onwards, you can also construct a Fraction instance directly from a decimal.Decimal instance. limit_denominator(max_denominator=1000000) Finds and returns the closest Fraction to self that has denominator at most max_denominator. This method is useful for finding rational approximations to", "score": "0.6976086"}, {"id": "19436", "text": "Function: python.library.decimal\nSnippet: if x is negative; otherwise returns False. is_snan(x) Returns True if x is a signaling NaN; otherwise returns False. is_subnormal(x) Returns True if x is subnormal; otherwise returns False. is_zero(x) Returns True if x is a zero; otherwise returns False. ln(x) Returns the natural (base e) logarithm of x. log10(x) Returns the base 10 logarithm of x. logb(x) Returns the exponent of the magnitude of the operand’s MSD. logical_and(x, y) Applies the logical operation and between each operand’s digits. logical_invert(x) Invert all the digits in x. logical_or(x, y) Applies the logical operation or between each operand’s digits. logical_xor(x, y) Applies the logical operation xor between each operand’s digits. max(x, y) Compares two values numerically and returns the maximum. max_mag(x, y) Compares the values numerically with their sign ignored. min(x, y) Compares two values numerically and returns the minimum. min_mag(x, y) Compares the values numerically with their sign ignored. minus(x) Minus corresponds to the unary prefix minus operator in Python. multiply(x, y) Return the product of x and y. next_minus(x) Returns the largest representable number smaller than x. next_plus(x) Returns the smallest representable number larger than x. next_toward(x, y) Returns the number closest to x, in direction towards y. normalize(x) Reduces x to its simplest form. number_class(x) Returns an indication of the class of x. plus(x) Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. power(x, y, modulo=None) Return x to the power of y, reduced modulo modulo if given. With two arguments, compute x**y. If x is negative then y must be integral. The result will be inexact unless y is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version. Decimal(0) ** Decimal(0) results in InvalidOperation, and if InvalidOperation is not trapped, then results in Decimal('NaN'). Changed in version 3.3: The C module computes power() in terms of the correctly-rounded exp() and ln() functions. The result is well-defined but only “almost always correctly-rounded”. With three arguments, compute (x**y) % modulo. For the three argument form, the following restrictions on the arguments hold: all three arguments must be integral y must be nonnegative at least one of x or y must be nonzero modulo must be nonzero and have at most ‘precision’ digits The value resulting from Context.power(x, y, modulo) is equal to the value that would be obtained by computing (x**y) % modulo with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of x, y and modulo. The result is always exact. quantize(x, y) Returns a value equal to x (rounded), having the exponent of y. radix() Just returns 10, as this is Decimal, :) remainder(x, y) Returns the remainder from integer division. The sign of the result, if non-zero, is the same as that of the original dividend. remainder_near(x, y) Returns x", "score": "0.6970117"}, {"id": "20200", "text": "Function: python.library.fractions\nSnippet: fractions — Rational numbers Source code: Lib/fractions.py The fractions module provides support for rational number arithmetic. A Fraction instance can be constructed from a pair of integers, from another rational number, or from a string. class fractions.Fraction(numerator=0, denominator=1) class fractions.Fraction(other_fraction) class fractions.Fraction(float) class fractions.Fraction(decimal) class fractions.Fraction(string) The first version requires that numerator and denominator are instances of numbers.Rational and returns a new Fraction instance with value numerator/denominator. If denominator is 0, it raises a ZeroDivisionError. The second version requires that other_fraction is an instance of numbers.Rational and returns a Fraction instance with the same value. The next two versions accept either a float or a decimal.Decimal instance, and return a Fraction instance with exactly the same value. Note that due to the usual issues with binary floating-point (see Floating Point Arithmetic: Issues and Limitations), the argument to Fraction(1.1) is not exactly equal to 11/10, and so Fraction(1.1) does not return Fraction(11, 10) as one might expect. (But see the documentation for the limit_denominator() method below.) The last version of the constructor expects a string or unicode instance. The usual form for this instance is: [sign] numerator ['/' denominator] where the optional sign may be either ‘+’ or ‘-‘ and numerator and denominator (if present) are strings of decimal digits. In addition, any string that represents a finite value and is accepted by the float constructor is also accepted by the Fraction constructor. In either form the input string may also have leading and/or trailing whitespace. Here are some examples: >>> from fractions import Fraction >>> Fraction(16, -10) Fraction(-8, 5) >>> Fraction(123) Fraction(123, 1) >>> Fraction() Fraction(0, 1) >>> Fraction('3/7') Fraction(3, 7) >>> Fraction(' -3/7 ') Fraction(-3, 7) >>> Fraction('1.414213 \\t\\n') Fraction(1414213, 1000000) >>> Fraction('-.125') Fraction(-1, 8) >>> Fraction('7e-6') Fraction(7, 1000000) >>> Fraction(2.25) Fraction(9, 4) >>> Fraction(1.1) Fraction(2476979795053773, 2251799813685248) >>> from decimal import Decimal >>> Fraction(Decimal('1.1')) Fraction(11, 10) The Fraction class inherits from the abstract base class numbers.Rational, and implements all of the methods and operations from that class. Fraction instances are hashable, and should be treated as immutable. In addition, Fraction has the following properties and methods: Changed in version 3.2: The Fraction constructor now accepts float and decimal.Decimal instances. Changed in version 3.9: The math.gcd() function is now used to normalize the numerator and denominator. math.gcd() always return a int type. Previously, the GCD type depended on numerator and denominator. numerator Numerator of the Fraction in lowest term. denominator Denominator of the Fraction in lowest term. as_integer_ratio() Return a tuple of two integers, whose ratio is equal to the Fraction and with a positive denominator. New in version 3.8. from_float(flt) This class method constructs a Fraction representing the exact value of flt, which must be a float. Beware that Fraction.from_float(0.3) is not the same value as Fraction(3, 10). Note From Python 3.2 onwards, you can also construct a Fraction instance directly from a float. from_decimal(dec) This class method constructs a Fraction representing the exact value of dec, which must be a decimal.Decimal instance. Note From Python 3.2 onwards, you", "score": "0.6856121"}, {"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.68534505"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.68419826"}]}
{"task_id": "humaneval_145", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "order_by_points", "gold_generation": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "context": "Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []", "function_name": "def order_by_points(nums):", "ctxs": [{"id": "15305", "text": "Function: pandas.reference.api.pandas.series.sort_index\nSnippet: s = pd.Series([1, 2, 3, 4], index=['A', 'b', 'C', 'd']) >>> s.sort_index(key=lambda x : x.str.lower()) A 1 b 2 C 3 d 4 dtype: int64", "score": "0.74982375"}, {"id": "15306", "text": "Function: pandas.reference.api.pandas.series.sort_values\nSnippet: pandas.Series.sort_values Series.sort_values(axis=0, ascending=True, inplace=False, kind='quicksort', na_position='last', ignore_index=False, key=None)[source] Sort by the values. Sort a Series in ascending or descending order by some criterion. Parameters axis:{0 or ‘index’}, default 0 Axis to direct sorting. The value ‘index’ is accepted for compatibility with DataFrame.sort_values. ascending:bool or list of bools, default True If True, sort values in ascending order, otherwise descending. inplace:bool, default False If True, perform operation in-place. kind:{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, default ‘quicksort’ Choice of sorting algorithm. See also numpy.sort() for more information. ‘mergesort’ and ‘stable’ are the only stable algorithms. na_position:{‘first’ or ‘last’}, default ‘last’ Argument ‘first’ puts NaNs at the beginning, ‘last’ puts NaNs at the end. ignore_index:bool, default False If True, the resulting axis will be labeled 0, 1, …, n - 1. New in version 1.0.0. key:callable, optional If not None, apply the key function to the series values before sorting. This is similar to the key argument in the builtin sorted() function, with the notable difference that this key function should be vectorized. It should expect a Series and return an array-like. New in version 1.1.0. Returns Series or None Series ordered by values or None if inplace=True. See also Series.sort_index Sort by the Series indices. DataFrame.sort_values Sort DataFrame by the values along either axis. DataFrame.sort_index Sort DataFrame by indices. Examples >>> s = pd.Series([np.nan, 1, 3, 10, 5]) >>> s 0 NaN 1 1.0 2 3.0 3 10.0 4 5.0 dtype: float64 Sort values ascending order (default behaviour) >>> s.sort_values(ascending=True) 1 1.0 2 3.0 4 5.0 3 10.0 0 NaN dtype: float64 Sort values descending order >>> s.sort_values(ascending=False) 3 10.0 4 5.0 2 3.0 1 1.0 0 NaN dtype: float64 Sort values inplace >>> s.sort_values(ascending=False, inplace=True) >>> s 3 10.0 4 5.0 2 3.0 1 1.0 0 NaN dtype: float64 Sort values putting NAs first >>> s.sort_values(na_position='first') 0 NaN 1 1.0 2 3.0 4 5.0 3 10.0 dtype: float64 Sort a series of strings >>> s = pd.Series(['z', 'b', 'd', 'a', 'c']) >>> s 0 z 1 b 2 d 3 a 4 c dtype: object >>> s.sort_values() 3 a 1 b 4 c 2 d 0 z dtype: object Sort using a key function. Your key function will be given the Series of values and should return an array-like. >>> s = pd.Series(['a', 'B', 'c', 'D', 'e']) >>> s.sort_values() 1 B 3 D 0 a 2 c 4 e dtype: object >>> s.sort_values(key=lambda x: x.str.lower()) 0 a 1 B 2 c 3 D 4 e dtype: object NumPy ufuncs work well here. For example, we can sort by the sin of the value >>> s = pd.Series([-4, -2, 0, 2, 4]) >>> s.sort_values(key=np.sin) 1 -2 4 4 2 0 0 -4 3 2 dtype: int64 More complicated user-defined functions can be used, as long as they expect a Series and return an array-like >>> s.sort_values(key=lambda x: (np.tan(x.cumsum()))) 0 -4 3 2 4 4 1 -2 2 0 dtype: int64", "score": "0.7306986"}, {"id": "14755", "text": "Function: pandas.reference.api.pandas.index.sort_values\nSnippet: pandas.Index.sort_values Index.sort_values(return_indexer=False, ascending=True, na_position='last', key=None)[source] Return a sorted copy of the index. Return a sorted copy of the index, and optionally return the indices that sorted the index itself. Parameters return_indexer:bool, default False Should the indices that would sort the index be returned. ascending:bool, default True Should the index values be sorted in an ascending order. na_position:{‘first’ or ‘last’}, default ‘last’ Argument ‘first’ puts NaNs at the beginning, ‘last’ puts NaNs at the end. New in version 1.2.0. key:callable, optional If not None, apply the key function to the index values before sorting. This is similar to the key argument in the builtin sorted() function, with the notable difference that this key function should be vectorized. It should expect an Index and return an Index of the same shape. New in version 1.1.0. Returns sorted_index:pandas.Index Sorted copy of the index. indexer:numpy.ndarray, optional The indices that the index itself was sorted by. See also Series.sort_values Sort values of a Series. DataFrame.sort_values Sort values in a DataFrame. Examples >>> idx = pd.Index([10, 100, 1, 1000]) >>> idx Int64Index([10, 100, 1, 1000], dtype='int64') Sort values in ascending order (default behavior). >>> idx.sort_values() Int64Index([1, 10, 100, 1000], dtype='int64') Sort values in descending order, and also get the indices idx was sorted by. >>> idx.sort_values(ascending=False, return_indexer=True) (Int64Index([1000, 100, 10, 1], dtype='int64'), array([3, 1, 0, 2]))", "score": "0.7235553"}, {"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.72291553"}, {"id": "14674", "text": "Function: pandas.reference.api.pandas.index.argsort\nSnippet: pandas.Index.argsort Index.argsort(*args, **kwargs)[source] Return the integer indices that would sort the index. Parameters *args Passed to numpy.ndarray.argsort. **kwargs Passed to numpy.ndarray.argsort. Returns np.ndarray[np.intp] Integer indices that would sort the index if used as an indexer. See also numpy.argsort Similar method for NumPy arrays. Index.sort_values Return sorted copy of Index. Examples >>> idx = pd.Index(['b', 'a', 'd', 'c']) >>> idx Index(['b', 'a', 'd', 'c'], dtype='object') >>> order = idx.argsort() >>> order array([1, 0, 3, 2]) >>> idx[order] Index(['a', 'b', 'c', 'd'], dtype='object')", "score": "0.7197166"}]}
{"task_id": "humaneval_146", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "entry_point": "specialFilter", "gold_generation": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "context": "Write a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2", "function_name": "def specialFilter(nums):", "ctxs": [{"id": "42443", "text": "Function: numpy.user.misc\nSnippet: Miscellaneous IEEE 754 Floating Point Special Values Special values defined in numpy: nan, inf, NaNs can be used as a poor-man’s mask (if you don’t care what the original value was) Note: cannot use equality to test NaNs. E.g.: >>> myarr = np.array([1., 0., np.nan, 3.]) >>> np.nonzero(myarr == np.nan) (array([], dtype=int64),) >>> np.nan == np.nan # is always False! Use special numpy functions instead. False >>> myarr[myarr == np.nan] = 0. # doesn't work >>> myarr array([ 1., 0., NaN, 3.]) >>> myarr[np.isnan(myarr)] = 0. # use this instead find >>> myarr array([ 1., 0., 0., 3.]) Other related special value functions: isinf(): True if value is inf isfinite(): True if not nan or inf nan_to_num(): Map nan to 0, inf to max float, -inf to min float The following corresponds to the usual functions except that nans are excluded from the results: nansum() nanmax() nanmin() nanargmax() nanargmin() >>> x = np.arange(10.) >>> x[3] = np.nan >>> x.sum() nan >>> np.nansum(x) 42.0 How numpy handles numerical exceptions The default is to 'warn' for invalid, divide, and overflow and 'ignore' for underflow. But this can be changed, and it can be set individually for different kinds of exceptions. The different behaviors are: ‘ignore’ : Take no action when the exception occurs. ‘warn’ : Print a RuntimeWarning (via the Python warnings module). ‘raise’ : Raise a FloatingPointError. ‘call’ : Call a function specified using the seterrcall function. ‘print’ : Print a warning directly to stdout. ‘log’ : Record error in a Log object specified by seterrcall. These behaviors can be set for all kinds of errors or specific ones: all : apply to all numeric exceptions invalid : when NaNs are generated divide : divide by zero (for integers as well!) overflow : floating point overflows underflow : floating point underflows Note that integer divide-by-zero is handled by the same machinery. These behaviors are set on a per-thread basis. Examples >>> oldsettings = np.seterr(all='warn') >>> np.zeros(5,dtype=np.float32)/0. invalid value encountered in divide >>> j = np.seterr(under='ignore') >>> np.array([1.e-100])**10 >>> j = np.seterr(invalid='raise') >>> np.sqrt(np.array([-1.])) FloatingPointError: invalid value encountered in sqrt >>> def errorhandler(errstr, errflag): ... print(\"saw stupid error!\") >>> np.seterrcall(errorhandler) <function err_handler at 0x...> >>> j = np.seterr(all='call') >>> np.zeros(5, dtype=np.int32)/0 FloatingPointError: invalid value encountered in divide saw stupid error! >>> j = np.seterr(**oldsettings) # restore previous ... # error-handling settings Interfacing to C Only a survey of the choices. Little detail on how each works. Bare metal, wrap your own C-code manually. Plusses: Efficient No dependencies on other tools Minuses: Lots of learning overhead: need to learn basics of Python C API need to learn basics of numpy C API need to learn how to handle reference counting and love it. Reference counting often difficult to get right. getting it wrong leads to memory leaks, and worse, segfaults API will change for Python 3.0! Cython Plusses: avoid learning C API’s no dealing with reference counting can code in pseudo python and generate C code can also interface to existing C code", "score": "0.7129125"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.70975757"}, {"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.70838857"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.70589805"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.70368534"}]}
{"task_id": "humaneval_147", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "entry_point": "get_max_triples", "gold_generation": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "context": "You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).", "function_name": "def get_max_triples(n):", "ctxs": [{"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.68898815"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.6792622"}, {"id": "19648", "text": "Function: python.library.difflib#difflib.SequenceMatcher.get_matching_blocks\nSnippet: get_matching_blocks() Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]", "score": "0.6748582"}, {"id": "43231", "text": "Function: numpy.reference.generated.numpy.tri\nSnippet: numpy.tri numpy.tri(N, M=None, k=0, dtype=<class 'float'>, *, like=None)[source] An array with ones at and below the given diagonal and zeros elsewhere. Parameters Nint Number of rows in the array. Mint, optional Number of columns in the array. By default, M is taken equal to N. kint, optional The sub-diagonal at and below which the array is filled. k = 0 is the main diagonal, while k < 0 is below it, and k > 0 is above. The default is 0. dtypedtype, optional Data type of the returned array. The default is float. likearray_like Reference object to allow the creation of arrays which are not NumPy arrays. If an array-like passed in as like supports the __array_function__ protocol, the result will be defined by it. In this case, it ensures the creation of an array object compatible with that passed in via this argument. New in version 1.20.0. Returns trindarray of shape (N, M) Array with its lower triangle filled with ones and zero elsewhere; in other words T[i,j] == 1 for j <= i + k, 0 otherwise. Examples >>> np.tri(3, 5, 2, dtype=int) array([[1, 1, 1, 0, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 1]]) >>> np.tri(3, 5, -1) array([[0., 0., 0., 0., 0.], [1., 0., 0., 0., 0.], [1., 1., 0., 0., 0.]])", "score": "0.6572512"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.65537745"}]}
{"task_id": "humaneval_148", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "entry_point": "bf", "gold_generation": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "context": "", "function_name": "def bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015645"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49314862"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.4911952"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48990315"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.4897412"}]}
{"task_id": "humaneval_149", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n", "entry_point": "sorted_list_sum", "gold_generation": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n", "context": "Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]", "function_name": "def sorted_list_sum(lst):", "ctxs": [{"id": "42690", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.7477343"}, {"id": "42687", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: sort this array. copy([order]) Return a copy of the array. count(sub[, start, end]) Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]. decode([encoding, errors]) Calls str.decode element-wise. dump(file) Dump a pickle of the array to the specified file. dumps() Returns the pickle of the array as a string. encode([encoding, errors]) Calls str.encode element-wise. endswith(suffix[, start, end]) Returns a boolean array which is True where the string element in self ends with suffix, otherwise False. expandtabs([tabsize]) Return a copy of each string element where all tab characters are replaced by one or more spaces. fill(value) Fill the array with a scalar value. find(sub[, start, end]) For each element, return the lowest index in the string where substring sub is found. flatten([order]) Return a copy of the array collapsed into one dimension. getfield(dtype[, offset]) Returns a field of the given array as a certain type. index(sub[, start, end]) Like find, but raises ValueError when the substring is not found. isalnum() Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise. isalpha() Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise. isdecimal() For each element in self, return True if there are only decimal characters in the element. isdigit() Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise. islower() Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. isnumeric() For each element in self, return True if there are only numeric characters in the element. isspace() Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise. istitle() Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise. isupper() Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise. item(*args) Copy an element of an array to a standard Python scalar and return it. join(seq) Return a string which is the concatenation of the strings in the sequence seq. ljust(width[, fillchar]) Return an array with the elements of self left-justified in a string of length width. lower() Return an array with the elements of self converted to lowercase. lstrip([chars]) For each element in self, return a copy with the leading characters removed. nonzero() Return the indices of the elements that are non-zero. put(indices, values[, mode]) Set a.flat[n] = values[n] for all n in indices. ravel([order]) Return a flattened array. repeat(repeats[, axis]) Repeat elements of an array. replace(old, new[, count]) For each element in self, return a copy of the string with all occurrences of substring old replaced by new. reshape(shape[, order]) Returns an array containing the", "score": "0.7443182"}, {"id": "21358", "text": "Function: python.library.stdtypes#list.sort\nSnippet: sort(*, key=None, reverse=False) This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.", "score": "0.7371799"}, {"id": "23949", "text": "Function: python.library.functions#sorted\nSnippet: sorted(iterable, *, key=None, reverse=False) Return a new sorted list from the items in iterable. Has two optional arguments which must be specified as keyword arguments. key specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. Use functools.cmp_to_key() to convert an old-style cmp function to a key function. The built-in sorted() function is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting HOW TO.", "score": "0.72098976"}, {"id": "42691", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: same data with a new shape. resize(new_shape[, refcheck]) Change shape and size of array in-place. rfind(sub[, start, end]) For each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. rindex(sub[, start, end]) Like rfind, but raises ValueError when the substring sub is not found. rjust(width[, fillchar]) Return an array with the elements of self right-justified in a string of length width. rsplit([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. rstrip([chars]) For each element in self, return a copy with the trailing characters removed. searchsorted(v[, side, sorter]) Find indices where elements of v should be inserted in a to maintain order. setfield(val, dtype[, offset]) Put a value into a specified place in a field defined by a data-type. setflags([write, align, uic]) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. sort([axis, kind, order]) Sort an array in-place. split([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. splitlines([keepends]) For each element in self, return a list of the lines in the element, breaking at line boundaries. squeeze([axis]) Remove axes of length one from a. startswith(prefix[, start, end]) Returns a boolean array which is True where the string element in self starts with prefix, otherwise False. strip([chars]) For each element in self, return a copy with the leading and trailing characters removed. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. swapcase() For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. title() For each element in self, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. translate(table[, deletechars]) For each element in self, return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table. transpose(*axes) Returns a view of the array with axes transposed. upper() Return an array with the elements of self converted to uppercase. view([dtype][, type]) New view of array with the same data. zfill(width) Return the numeric string left-filled with zeros in a string of length width.", "score": "0.72095263"}]}
{"task_id": "humaneval_150", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "entry_point": "x_or_y", "gold_generation": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "context": "A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5", "function_name": "def x_or_y(n, x, y):", "ctxs": [{"id": "21799", "text": "Function: python.library.math#math.factorial\nSnippet: math.factorial(x) Return x factorial as an integer. Raises ValueError if x is not integral or is negative. Deprecated since version 3.9: Accepting floats with integral values (like 5.0) is deprecated.", "score": "0.69341516"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6931186"}, {"id": "21775", "text": "Function: python.library.math\nSnippet: some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using a = 1 + isqrt(n - 1). New in version 3.8. math.lcm(*integers) Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1. New in version 3.9. math.ldexp(x, i) Return x * (2**i). This is essentially the inverse of function frexp(). math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats. math.nextafter(x, y) Return the next floating-point value after x towards y. If x is equal to y, return y. Examples: math.nextafter(x, math.inf) goes up: towards positive infinity. math.nextafter(x, -math.inf) goes down: towards minus infinity. math.nextafter(x, 0.0) goes towards zero. math.nextafter(x, math.copysign(math.inf, x)) goes away from zero. See also math.ulp(). New in version 3.9. math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8. math.prod(iterable, *, start=1) Calculate the product of all the elements in the input iterable. The default start value for the product is 1. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. New in version 3.8. math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7. math.trunc(x) Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__(). math.ulp(x) Return the value of the least significant bit of the float x: If x is a NaN", "score": "0.67994803"}, {"id": "21828", "text": "Function: python.library.math#math.remainder\nSnippet: math.remainder(x, y) Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced. New in version 3.7.", "score": "0.6788831"}, {"id": "19488", "text": "Function: python.library.decimal#decimal.Context.logical_or\nSnippet: logical_or(x, y) Applies the logical operation or between each operand’s digits.", "score": "0.6779204"}]}
{"task_id": "humaneval_151", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "entry_point": "double_the_difference", "gold_generation": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "context": "", "function_name": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015645"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49314862"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.4911952"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48990315"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.4897412"}]}
{"task_id": "humaneval_152", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "compare", "gold_generation": "    return [abs(x-y) for x,y in zip(game,guess)]\n", "context": "I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    \n    \n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]", "function_name": "def compare(game,guess):", "ctxs": [{"id": "19651", "text": "Function: python.library.difflib#difflib.SequenceMatcher.ratio\nSnippet: ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5", "score": "0.71331215"}, {"id": "19628", "text": "Function: python.library.difflib\nSnippet: as large as ratio(): >>> s = SequenceMatcher(None, \"abcd\", \"bcde\") >>> s.ratio() 0.75 >>> s.quick_ratio() 0.75 >>> s.real_quick_ratio() 1.0 SequenceMatcher Examples This example compares two strings, considering blanks to be “junk”: >>> s = SequenceMatcher(lambda x: x == \" \", ... \"private Thread currentThread;\", ... \"private volatile Thread currentThread;\") ratio() returns a float in [0, 1], measuring the similarity of the sequences. As a rule of thumb, a ratio() value over 0.6 means the sequences are close matches: >>> print(round(s.ratio(), 3)) 0.866 If you’re only interested in where the sequences match, get_matching_blocks() is handy: >>> for block in s.get_matching_blocks(): ... print(\"a[%d] and b[%d] match for %d elements\" % block) a[0] and b[0] match for 8 elements a[8] and b[17] match for 21 elements a[29] and b[38] match for 0 elements Note that the last tuple returned by get_matching_blocks() is always a dummy, (len(a), len(b), 0), and this is the only case in which the last tuple element (number of elements matched) is 0. If you want to know how to change the first sequence into the second, use get_opcodes(): >>> for opcode in s.get_opcodes(): ... print(\"%6s a[%d:%d] b[%d:%d]\" % opcode) equal a[0:8] b[0:8] insert a[8:8] b[8:17] equal a[8:29] b[17:38] See also The get_close_matches() function in this module which shows how simple code building on SequenceMatcher can be used to do useful work. Simple version control recipe for a small application built with SequenceMatcher. Differ Objects Note that Differ-generated deltas make no claim to be minimal diffs. To the contrary, minimal diffs are often counter-intuitive, because they synch up anywhere possible, sometimes accidental matches 100 pages apart. Restricting synch points to contiguous matches preserves some notion of locality, at the occasional cost of producing a longer diff. The Differ class has this constructor: class difflib.Differ(linejunk=None, charjunk=None) Optional keyword parameters linejunk and charjunk are for filter functions (or None): linejunk: A function that accepts a single string argument, and returns true if the string is junk. The default is None, meaning that no line is considered junk. charjunk: A function that accepts a single character argument (a string of length 1), and returns true if the character is junk. The default is None, meaning that no character is considered junk. These junk-filtering functions speed up matching to find differences and do not cause any differing lines or characters to be ignored. Read the description of the find_longest_match() method’s isjunk parameter for an explanation. Differ objects are used (deltas generated) via a single method: compare(a, b) Compare two sequences of lines, and generate the delta (a sequence of lines). Each sequence must contain individual single-line strings ending with newlines. Such sequences can be obtained from the readlines() method of file-like objects. The delta generated also consists of newline-terminated strings, ready to be printed as-is via the writelines() method of a file-like object. Differ Example This example compares two texts. First we set up the texts, sequences of individual single-line strings ending with newlines (such sequences can also be obtained from the readlines() method", "score": "0.70324135"}, {"id": "19634", "text": "Function: python.library.difflib#difflib.get_close_matches\nSnippet: difflib.get_close_matches(word, possibilities, n=3, cutoff=0.6) Return a list of the best “good enough” matches. word is a sequence for which close matches are desired (typically a string), and possibilities is a list of sequences against which to match word (typically a list of strings). Optional argument n (default 3) is the maximum number of close matches to return; n must be greater than 0. Optional argument cutoff (default 0.6) is a float in the range [0, 1]. Possibilities that don’t score at least that similar to word are ignored. The best (no more than n) matches among the possibilities are returned in a list, sorted by similarity score, most similar first. >>> get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy']) ['apple', 'ape'] >>> import keyword >>> get_close_matches('wheel', keyword.kwlist) ['while'] >>> get_close_matches('pineapple', keyword.kwlist) [] >>> get_close_matches('accept', keyword.kwlist) ['except']", "score": "0.69503444"}, {"id": "43963", "text": "Function: numpy.reference.generated.numpy.testing.assert_approx_equal\nSnippet: numpy.testing.assert_approx_equal testing.assert_approx_equal(actual, desired, significant=7, err_msg='', verbose=True)[source] Raises an AssertionError if two items are not equal up to significant digits. Note It is recommended to use one of assert_allclose, assert_array_almost_equal_nulp or assert_array_max_ulp instead of this function for more consistent floating point comparisons. Given two numbers, check that they are approximately equal. Approximately equal is defined as the number of significant digits that agree. Parameters actualscalar The object to check. desiredscalar The expected object. significantint, optional Desired precision, default is 7. err_msgstr, optional The error message to be printed in case of failure. verbosebool, optional If True, the conflicting values are appended to the error message. Raises AssertionError If actual and desired are not equal up to specified precision. See also assert_allclose Compare two array_like objects for equality with desired relative and/or absolute precision. assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal Examples >>> np.testing.assert_approx_equal(0.12345677777777e-20, 0.1234567e-20) >>> np.testing.assert_approx_equal(0.12345670e-20, 0.12345671e-20, ... significant=8) >>> np.testing.assert_approx_equal(0.12345670e-20, 0.12345672e-20, ... significant=8) Traceback (most recent call last): ... AssertionError: Items are not equal to 8 significant digits: ACTUAL: 1.234567e-21 DESIRED: 1.2345672e-21 the evaluated condition that raises the exception is >>> abs(0.12345670e-20/1e-21 - 0.12345672e-20/1e-21) >= 10**-(8-1) True", "score": "0.6921879"}, {"id": "19627", "text": "Function: python.library.difflib\nSnippet: describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j. The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks. >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\") >>> s.get_matching_blocks() [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)] get_opcodes() Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings: Value Meaning 'replace' a[i1:i2] should be replaced by b[j1:j2]. 'delete' a[i1:i2] should be deleted. Note that j1 == j2 in this case. 'insert' b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case. 'equal' a[i1:i2] == b[j1:j2] (the sub-sequences are equal). For example: >>> a = \"qabxcd\" >>> b = \"abycdf\" >>> s = SequenceMatcher(None, a, b) >>> for tag, i1, i2, j1, j2 in s.get_opcodes(): ... print('{:7} a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format( ... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2])) delete a[0:1] --> b[0:0] 'q' --> '' equal a[1:3] --> b[0:2] 'ab' --> 'ab' replace a[3:4] --> b[2:3] 'x' --> 'y' equal a[4:6] --> b[3:5] 'cd' --> 'cd' insert a[6:6] --> b[5:6] '' --> 'f' get_grouped_opcodes(n=3) Return a generator of groups with up to n lines of context. Starting with the groups returned by get_opcodes(), this method splits out smaller change clusters and eliminates intervening ranges which have no changes. The groups are returned in the same format as get_opcodes(). ratio() Return a measure of the sequences’ similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if get_matching_blocks() or get_opcodes() hasn’t already been called, in which case you may want to try quick_ratio() or real_quick_ratio() first to get an upper bound. Note Caution: The result of a ratio() call may depend on the order of the arguments. For instance: >>> SequenceMatcher(None, 'tide', 'diet').ratio() 0.25 >>> SequenceMatcher(None, 'diet', 'tide').ratio() 0.5 quick_ratio() Return an upper bound on ratio() relatively quickly. real_quick_ratio() Return an upper bound on ratio() very quickly. The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although quick_ratio() and real_quick_ratio() are always at least", "score": "0.68978596"}]}
{"task_id": "humaneval_153", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "entry_point": "Strongest_Extension", "gold_generation": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "context": "You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'", "function_name": "def Strongest_Extension(class_name, extensions):", "ctxs": [{"id": "13334", "text": "Function: pygame.ref.freetype#pygame.freetype.Font.strength\nSnippet: strength The strength associated with the strong or wide font styles strength -> float The amount by which a font glyph's size is enlarged for the strong or wide transformations, as a fraction of the untransformed size. For the wide style only the horizontal dimension is increased. For strong text both the horizontal and vertical dimensions are enlarged. A wide style of strength 0.08333 ( 1/12 ) is equivalent to the pygame.font.Font bold style. The default is 0.02778 ( 1/36 ). The strength style is only supported for scalable (outline) fonts. An attempt to set this property on a bitmap font will raise an AttributeError. If the font object is inactive, as returned by Font.__new__(), assignment to this property raises a RuntimeError.", "score": "0.69795"}, {"id": "13981", "text": "Function: pandas.reference.api.pandas.api.extensions.extensiondtype.construct_from_string\nSnippet: pandas.api.extensions.ExtensionDtype.construct_from_string classmethodExtensionDtype.construct_from_string(string)[source] Construct this type from a string. This is useful mainly for data types that accept parameters. For example, a period dtype accepts a frequency parameter that can be set as period[H] (where H means hourly frequency). By default, in the abstract class, just the name of the type is expected. But subclasses can overwrite this method to accept parameters. Parameters string:str The name of the type, for example category. Returns ExtensionDtype Instance of the dtype. Raises TypeError If a class cannot be constructed from this ‘string’. Examples For extension dtypes with arguments the following may be an adequate implementation. >>> @classmethod ... def construct_from_string(cls, string): ... pattern = re.compile(r\"^my_type\\[(?P<arg_name>.+)\\]$\") ... match = pattern.match(string) ... if match: ... return cls(**match.groupdict()) ... else: ... raise TypeError( ... f\"Cannot construct a '{cls.__name__}' from '{string}'\" ... )", "score": "0.69180226"}, {"id": "13987", "text": "Function: pandas.reference.api.pandas.api.extensions.extensiondtype.names\nSnippet: pandas.api.extensions.ExtensionDtype.names propertyExtensionDtype.names Ordered list of field names, or None if there are no fields. This is for compatibility with NumPy arrays, and may be removed in the future.", "score": "0.68931276"}, {"id": "2364", "text": "Function: tensorflow.experimental.numpy.string_\nSnippet: at that position. suffix can also be a tuple of bytes to try. expandtabs expandtabs() B.expandtabs(tabsize=8) -> copy of B Return a copy of B where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed. fill fill() Not implemented (virtual attribute) Class generic exists solely to derive numpy scalars from, and possesses, albeit unimplemented, all the attributes of the ndarray class so as to provide a uniform API. See also the corresponding attribute of the derived class of interest. find find() B.find(sub[, start[, end]]) -> int Return the lowest index in B where subsection sub is found, such that sub is contained within B[start,end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. flatten flatten() Not implemented (virtual attribute) Class generic exists solely to derive numpy scalars from, and possesses, albeit unimplemented, all the attributes of the ndarray class so as to provide a uniform API. See also the corresponding attribute of the derived class of interest. fromhex fromhex( string, / ) Create a bytes object from a string of hexadecimal numbers. Spaces between two numbers are accepted. Example: bytes.fromhex('B9 01EF') -> b'\\xb9\\x01\\xef'. getfield getfield() Not implemented (virtual attribute) Class generic exists solely to derive numpy scalars from, and possesses, albeit unimplemented, all the attributes of the ndarray class so as to provide a uniform API. See also the corresponding attribute of the derived class of interest. hex hex() B.hex() -> string Create a string of hexadecimal numbers from a bytes object. Example: b'\\xb9\\x01\\xef'.hex() -> 'b901ef'. index index() B.index(sub[, start[, end]]) -> int Return the lowest index in B where subsection sub is found, such that sub is contained within B[start,end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the subsection is not found. isalnum isalnum() B.isalnum() -> bool Return True if all characters in B are alphanumeric and there is at least one character in B, False otherwise. isalpha isalpha() B.isalpha() -> bool Return True if all characters in B are alphabetic and there is at least one character in B, False otherwise. isascii isascii() B.isascii() -> bool Return True if B is empty or all characters in B are ASCII, False otherwise. isdigit isdigit() B.isdigit() -> bool Return True if all characters in B are digits and there is at least one character in B, False otherwise. islower islower() B.islower() -> bool Return True if all cased characters in B are lowercase and there is at least one cased character in B, False otherwise. isspace isspace() B.isspace() -> bool Return True if all characters in B are whitespace and there is at least one character in B, False otherwise. istitle istitle() B.istitle() -> bool Return True if B is a titlecased string and there is at least one character in B, i.e. uppercase characters may only follow uncased characters and lowercase characters only cased ones. Return False otherwise. isupper isupper() B.isupper() -> bool Return True", "score": "0.68845606"}, {"id": "2412", "text": "Function: tensorflow.experimental.numpy.unicode_\nSnippet: end, stop comparing S at that position. suffix can also be a tuple of strings to try. expandtabs expandtabs( tabsize=8 ) Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed. fill fill() Not implemented (virtual attribute) Class generic exists solely to derive numpy scalars from, and possesses, albeit unimplemented, all the attributes of the ndarray class so as to provide a uniform API. See also the corresponding attribute of the derived class of interest. find find() S.find(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. flatten flatten() Not implemented (virtual attribute) Class generic exists solely to derive numpy scalars from, and possesses, albeit unimplemented, all the attributes of the ndarray class so as to provide a uniform API. See also the corresponding attribute of the derived class of interest. format format() S.format(*args, **kwargs) -> str Return a formatted version of S, using substitutions from args and kwargs. The substitutions are identified by braces ('{' and '}'). format_map format_map() S.format_map(mapping) -> str Return a formatted version of S, using substitutions from mapping. The substitutions are identified by braces ('{' and '}'). getfield getfield() Not implemented (virtual attribute) Class generic exists solely to derive numpy scalars from, and possesses, albeit unimplemented, all the attributes of the ndarray class so as to provide a uniform API. See also the corresponding attribute of the derived class of interest. index index() S.index(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found. isalnum isalnum() Return True if the string is an alpha-numeric string, False otherwise. A string is alpha-numeric if all characters in the string are alpha-numeric and there is at least one character in the string. isalpha isalpha() Return True if the string is an alphabetic string, False otherwise. A string is alphabetic if all characters in the string are alphabetic and there is at least one character in the string. isascii isascii() Return True if all characters in the string are ASCII, False otherwise. ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too. isdecimal isdecimal() Return True if the string is a decimal string, False otherwise. A string is a decimal string if all characters in the string are decimal and there is at least one character in the string. isdigit isdigit() Return True if the string is a digit string, False otherwise. A string is a digit string if all characters in the string are digits and there is at least one character in the string. isidentifier isidentifier() Return True if the string is a valid Python identifier, False otherwise. Use keyword.iskeyword()", "score": "0.68747413"}]}
{"task_id": "humaneval_154", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "entry_point": "cycpattern_check", "gold_generation": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "context": "You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True", "function_name": "def cycpattern_check(a , b):", "ctxs": [{"id": "23308", "text": "Function: python.library.re\nSnippet: the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. re.findall(pattern, string, flags=0) Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.finditer(pattern, string, flags=0) Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. Changed in version 3.7: Non-empty matches can now start just after a previous empty match. re.sub(pattern, repl, string, count=0, flags=0) Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as \\& are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example: >>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):', ... r'static PyObject*\\npy_\\1(void)\\n{', ... 'def myfunc():') 'static PyObject*\\npy_myfunc(void)\\n{' If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. For example: >>> def dashrepl(matchobj): ... if matchobj.group(0) == '-': return ' ' ... else: return '-' >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files') 'pro--gram files' >>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE) 'Baked Beans & Spam' The pattern may be a string or a pattern object. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern", "score": "0.68212265"}, {"id": "23368", "text": "Function: python.library.re#re.split\nSnippet: re.split(pattern, string, maxsplit=0, flags=0) Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. >>> re.split(r'\\W+', 'Words, words, words.') ['Words', 'words', 'words', ''] >>> re.split(r'(\\W+)', 'Words, words, words.') ['Words', ', ', 'words', ', ', 'words', '.', ''] >>> re.split(r'\\W+', 'Words, words, words.', 1) ['Words', 'words, words.'] >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE) ['0', '3', '9'] If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: >>> re.split(r'(\\W+)', '...words, words...') ['', '...', 'words', ', ', 'words', '...', ''] That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. >>> re.split(r'\\b', 'Words, words, words.') ['', 'Words', ', ', 'words', ', ', 'words', '.'] >>> re.split(r'\\W*', '...words...') ['', '', 'w', 'o', 'r', 'd', 's', '', ''] >>> re.split(r'(\\W*)', '...words...') ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', ''] Changed in version 3.1: Added the optional flags argument. Changed in version 3.7: Added support of splitting on a pattern that could match an empty string.", "score": "0.6819767"}, {"id": "24361", "text": "Function: python.library.stdtypes#str.isupper\nSnippet: str.isupper() Return True if all cased characters 4 in the string are uppercase and there is at least one cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False", "score": "0.68003744"}, {"id": "23304", "text": "Function: python.library.re\nSnippet: Similar to positive lookbehind assertions, the contained pattern must only match strings of some fixed length. Patterns which start with negative lookbehind assertions may match at the beginning of the string being searched. (?(id/name)yes-pattern|no-pattern) Will try to match with yes-pattern if the group with given id or name exists, and with no-pattern if it doesn’t. no-pattern is optional and can be omitted. For example, (<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$) is a poor email matching pattern, which will match with '<user@host.com>' as well as 'user@host.com', but not with '<user@host.com' nor 'user@host.com>'. The special sequences consist of '\\' and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, \\$ matches the character '$'. \\number Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, (.+) \\1 matches 'the the' or '55 55', but not 'thethe' (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the '[' and ']' of a character class, all numeric escapes are treated as characters. \\A Matches only at the start of the string. \\b Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of word characters. Note that formally, \\b is defined as the boundary between a \\w and a \\W character (or vice versa), or between \\w and the beginning/end of the string. This means that r'\\bfoo\\b' matches 'foo', 'foo.', '(foo)', 'bar foo baz' but not 'foobar' or 'foo3'. By default Unicode alphanumerics are the ones used in Unicode patterns, but this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. Inside a character range, \\b represents the backspace character, for compatibility with Python’s string literals. \\B Matches the empty string, but only when it is not at the beginning or end of a word. This means that r'py\\B' matches 'python', 'py3', 'py2', but not 'py', 'py.', or 'py!'. \\B is just the opposite of \\b, so word characters in Unicode patterns are Unicode alphanumerics or the underscore, although this can be changed by using the ASCII flag. Word boundaries are determined by the current locale if the LOCALE flag is used. \\d For Unicode (str) patterns: Matches any Unicode decimal digit (that is, any character in Unicode character category [Nd]). This includes [0-9], and also many other digit characters. If the ASCII flag is used only [0-9] is matched. For 8-bit (bytes) patterns: Matches any decimal digit; this is equivalent to [0-9]. \\D Matches any character which is not a decimal digit. This is the opposite of \\d. If the", "score": "0.675992"}, {"id": "16533", "text": "Function: pandas.reference.series\nSnippet: of strings in the Series/Index. Series.str.rpartition([sep, expand]) Split the string at the last occurrence of sep. Series.str.rstrip([to_strip]) Remove trailing characters. Series.str.slice([start, stop, step]) Slice substrings from each element in the Series or Index. Series.str.slice_replace([start, stop, repl]) Replace a positional slice of a string with another value. Series.str.split([pat, n, expand, regex]) Split strings around given separator/delimiter. Series.str.rsplit([pat, n, expand]) Split strings around given separator/delimiter. Series.str.startswith(pat[, na]) Test if the start of each string element matches a pattern. Series.str.strip([to_strip]) Remove leading and trailing characters. Series.str.swapcase() Convert strings in the Series/Index to be swapcased. Series.str.title() Convert strings in the Series/Index to titlecase. Series.str.translate(table) Map all characters in the string through the given mapping table. Series.str.upper() Convert strings in the Series/Index to uppercase. Series.str.wrap(width, **kwargs) Wrap strings in Series/Index at specified line width. Series.str.zfill(width) Pad strings in the Series/Index by prepending '0' characters. Series.str.isalnum() Check whether all characters in each string are alphanumeric. Series.str.isalpha() Check whether all characters in each string are alphabetic. Series.str.isdigit() Check whether all characters in each string are digits. Series.str.isspace() Check whether all characters in each string are whitespace. Series.str.islower() Check whether all characters in each string are lowercase. Series.str.isupper() Check whether all characters in each string are uppercase. Series.str.istitle() Check whether all characters in each string are titlecase. Series.str.isnumeric() Check whether all characters in each string are numeric. Series.str.isdecimal() Check whether all characters in each string are decimal. Series.str.get_dummies([sep]) Return DataFrame of dummy/indicator variables for Series. Categorical accessor Categorical-dtype specific methods and attributes are available under the Series.cat accessor. Series.cat.categories The categories of this categorical. Series.cat.ordered Whether the categories have an ordered relationship. Series.cat.codes Return Series of codes as well as the index. Series.cat.rename_categories(*args, **kwargs) Rename categories. Series.cat.reorder_categories(*args, **kwargs) Reorder categories as specified in new_categories. Series.cat.add_categories(*args, **kwargs) Add new categories. Series.cat.remove_categories(*args, **kwargs) Remove the specified categories. Series.cat.remove_unused_categories(*args, ...) Remove categories which are not used. Series.cat.set_categories(*args, **kwargs) Set the categories to the specified new_categories. Series.cat.as_ordered(*args, **kwargs) Set the Categorical to be ordered. Series.cat.as_unordered(*args, **kwargs) Set the Categorical to be unordered. Sparse accessor Sparse-dtype specific methods and attributes are provided under the Series.sparse accessor. Series.sparse.npoints The number of non- fill_value points. Series.sparse.density The percent of non- fill_value points, as decimal. Series.sparse.fill_value Elements in data that are fill_value are not stored. Series.sparse.sp_values An ndarray containing the non- fill_value values. Series.sparse.from_coo(A[, dense_index]) Create a Series with sparse values from a scipy.sparse.coo_matrix. Series.sparse.to_coo([row_levels, ...]) Create a scipy.sparse.coo_matrix from a Series with MultiIndex. Flags Flags refer to attributes of the pandas object. Properties of the dataset (like the date is was recorded, the URL it was accessed from, etc.) should be stored in Series.attrs. Flags(obj, *, allows_duplicate_labels) Flags that apply to pandas objects. Metadata Series.attrs is a dictionary for storing global metadata for this Series. Warning Series.attrs is considered experimental and may change without warning. Series.attrs Dictionary of global attributes of this dataset. Plotting Series.plot is both a callable method and a namespace attribute for specific plotting methods of the form Series.plot.<kind>. Series.plot([kind, ax, figsize, ....]) Series plotting accessor and method Series.plot.area([x, y]) Draw a", "score": "0.6699151"}]}
{"task_id": "humaneval_155", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "even_odd_count", "gold_generation": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n", "context": "Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)", "function_name": "def even_odd_count(num):", "ctxs": [{"id": "19597", "text": "Function: python.library.decimal#decimal.ROUND_HALF_EVEN\nSnippet: decimal.ROUND_HALF_EVEN Round to nearest with ties going to nearest even integer.", "score": "0.67963177"}, {"id": "24415", "text": "Function: python.library.string#string.octdigits\nSnippet: string.octdigits The string '01234567'.", "score": "0.6758902"}, {"id": "22291", "text": "Function: python.library.functions#oct\nSnippet: oct(x) Convert an integer number to an octal string prefixed with “0o”. The result is a valid Python expression. If x is not a Python int object, it has to define an __index__() method that returns an integer. For example: >>> oct(8) '0o10' >>> oct(-56) '-0o70' If you want to convert an integer number to octal string either with prefix “0o” or not, you can use either of the following ways. >>> '%#o' % 10, '%o' % 10 ('0o12', '12') >>> format(10, '#o'), format(10, 'o') ('0o12', '12') >>> f'{10:#o}', f'{10:o}' ('0o12', '12') See also format() for more information.", "score": "0.6735127"}, {"id": "25732", "text": "Function: python.library.stdtypes\nSnippet: there were an infinite number of sign bits. Additional Methods on Integer Types The int type implements the numbers.Integral abstract base class. In addition, it provides a few more methods: int.bit_length() Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 New in version 3.1. int.to_bytes(length, byteorder, *, signed=False) Return an array of bytes representing an integer. >>> (1024).to_bytes(2, byteorder='big') b'\\x04\\x00' >>> (1024).to_bytes(10, byteorder='big') b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00' >>> (-1024).to_bytes(10, byteorder='big', signed=True) b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00' >>> x = 1000 >>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little') b'\\xe8\\x03' The integer is represented using length bytes. An OverflowError is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument determines whether two’s complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. The default value for signed is False. New in version 3.2. classmethod int.from_bytes(bytes, byteorder, *, signed=False) Return the integer represented by the given array of bytes. >>> int.from_bytes(b'\\x00\\x10', byteorder='big') 16 >>> int.from_bytes(b'\\x00\\x10', byteorder='little') 4096 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True) -1024 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False) 64512 >>> int.from_bytes([255, 0, 0], byteorder='big') 16711680 The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. New in version 3.2. int.as_integer_ratio() Return a pair of integers whose ratio is exactly equal to the original integer and with a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. New in version 3.8. Additional Methods on Float The float type implements the numbers.Real abstract base class. float also has the following additional methods. float.as_integer_ratio() Return a pair of integers whose", "score": "0.6727129"}, {"id": "21297", "text": "Function: python.library.itertools\nSnippet: * (n - k + i) // i if index < 0: index += c if index < 0 or index >= c: raise IndexError result = [] while r: c, n, r = c*r//n, n-1, r-1 while index >= c: index -= c c, n = c*(n-r)//n, n-1 result.append(pool[-1-n]) return tuple(result)", "score": "0.6616911"}]}
{"task_id": "humaneval_156", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "int_to_mini_roman", "gold_generation": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "context": "Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'", "function_name": "def int_to_mini_roman(number):", "ctxs": [{"id": "20491", "text": "Function: python.library.functions#hex\nSnippet: hex(x) Convert an integer number to a lowercase hexadecimal string prefixed with “0x”. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> hex(255) '0xff' >>> hex(-42) '-0x2a' If you want to convert an integer number to an uppercase or lower hexadecimal string with prefix or not, you can use either of the following ways: >>> '%#x' % 255, '%x' % 255, '%X' % 255 ('0xff', 'ff', 'FF') >>> format(255, '#x'), format(255, 'x'), format(255, 'X') ('0xff', 'ff', 'FF') >>> f'{255:#x}', f'{255:x}', f'{255:X}' ('0xff', 'ff', 'FF') See also format() for more information. See also int() for converting a hexadecimal string to an integer using a base of 16. Note To obtain a hexadecimal string representation for a float, use the float.hex() method.", "score": "0.7209746"}, {"id": "41307", "text": "Function: django.ref.utils#django.utils.http.int_to_base36\nSnippet: int_to_base36(i) [source] Converts a positive integer to a base 36 string.", "score": "0.71275026"}, {"id": "42660", "text": "Function: numpy.reference.generated.numpy.base_repr\nSnippet: numpy.base_repr numpy.base_repr(number, base=2, padding=0)[source] Return a string representation of a number in the given base system. Parameters numberint The value to convert. Positive and negative values are handled. baseint, optional Convert number to the base number system. The valid range is 2-36, the default value is 2. paddingint, optional Number of zeros padded on the left. Default is 0 (no padding). Returns outstr String representation of number in base system. See also binary_repr Faster version of base_repr for base 2. Examples >>> np.base_repr(5) '101' >>> np.base_repr(6, 5) '11' >>> np.base_repr(7, base=5, padding=3) '00012' >>> np.base_repr(10, base=16) 'A' >>> np.base_repr(32, base=16) '20'", "score": "0.70833105"}, {"id": "21367", "text": "Function: python.library.locale#locale.atoi\nSnippet: locale.atoi(string) Converts a string to an integer, following the LC_NUMERIC conventions.", "score": "0.6964165"}, {"id": "25733", "text": "Function: python.library.stdtypes\nSnippet: ratio is exactly equal to the original float and with a positive denominator. Raises OverflowError on infinities and a ValueError on NaNs. float.is_integer() Return True if the float instance is finite with integral value, and False otherwise: >>> (-2.0).is_integer() True >>> (3.2).is_integer() False Two methods support conversion to and from hexadecimal strings. Since Python’s floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. float.hex() Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading 0x and a trailing p and exponent. classmethod float.fromhex(s) Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that float.hex() is an instance method, while float.fromhex() is a class method. A hexadecimal string takes the form: [sign] ['0x'] integer ['.' fraction] ['p' exponent] where the optional sign may by either + or -, integer and fraction are strings of hexadecimal digits, and exponent is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of float.hex() is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C’s %a format character or Java’s Double.toHexString are accepted by float.fromhex(). Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string 0x3.a7p10 represents the floating-point number (3 + 10./16 + 7./16**2) * 2.0**10, or 3740.0: >>> float.fromhex('0x3.a7p10') 3740.0 Applying the reverse conversion to 3740.0 gives a different hexadecimal string representing the same number: >>> float.hex(3740.0) '0x1.d380000000000p+11' Hashing of numeric types For numbers x and y, possibly of different types, it’s a requirement that hash(x) == hash(y) whenever x == y (see the __hash__() method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including int, float, decimal.Decimal and fractions.Fraction) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of int and fractions.Fraction, and all finite instances of float and decimal.Decimal. Essentially, this function is given by reduction modulo P for a fixed prime P. The value of P is made available to Python as the modulus attribute of sys.hash_info. CPython implementation detail: Currently, the prime used is P = 2**31 - 1 on machines with 32-bit C longs and P = 2**61 - 1 on machines with 64-bit C longs. Here are the rules", "score": "0.69176733"}]}
{"task_id": "humaneval_157", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "entry_point": "right_angle_triangle", "gold_generation": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "context": "", "function_name": "def right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''", "ctxs": [{"id": "17321", "text": "Function: skimage.api.skimage.util#skimage.util.pad\nSnippet: 100], [100, 100, 100, 100, 100, 100, 100]])", "score": "0.5015645"}, {"id": "29324", "text": "Function: matplotlib.collections_api\nSnippet: pattern to use in filled paths, if any. Valid strings are ['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See Hatch style reference for the meaning of each hatch type. pickradiusfloat, default: 5.0 If pickradius <= 0, then Collection.contains will return True whenever the test point is inside of one of the polygons formed by the control points of a Path in the Collection. On the other hand, if it is greater than 0, then we instead check if the test point is contained in a stroke of width 2*pickradius following any of the Paths in the Collection. urlslist of str, default: None A URL for each patch to link to once drawn. Currently only works for the SVG backend. See Hyperlinks for examples. zorderfloat, default: 1 The drawing order, shared by all Patches in the Collection. See Zorder Demo for all defaults and examples. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. staticconvert_mesh_to_paths(tri)[source] Convert a given mesh into a sequence of Path objects. This function is primarily of use to implementers of backends that do not directly support meshes. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of", "score": "0.49314862"}, {"id": "29271", "text": "Function: matplotlib.collections_api\nSnippet: When setting facecolors, each line is interpreted as a boundary for an area, implicitly closing the path from the last point to the first point. The enclosed area is filled with facecolor. In order to manually specify what should count as the \"interior\" of each line, please use PathCollection instead, where the \"interior\" can be specified by appropriate usage of CLOSEPOLY. **kwargs Forwarded to Collection. add_callback(func)[source] Add a callback function that will be called whenever one of the Artist's properties changes. Parameters funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return", "score": "0.4911952"}, {"id": "29256", "text": "Function: matplotlib.collections_api\nSnippet: funccallable The callback function. It must have the signature: def func(artist: Artist) -> Any where artist is the calling Artist. Return values may exist but are ignored. Returns int The observer id associated with the callback. This id can be used for removing the callback with remove_callback later. See also remove_callback autoscale()[source] Autoscale the scalar limits on the norm instance using the current array autoscale_None()[source] Autoscale the scalar limits on the norm instance using the current array, changing only limits that are None propertyaxes The Axes instance the artist resides in, or None. propertycallbacksSM[source] changed()[source] Call this whenever the mappable is changed to notify all the callbackSM listeners to the 'changed' signal. colorbar The last colorbar associated with this ScalarMappable. May be None. contains(mouseevent)[source] Test whether the mouse event occurred in the collection. Returns bool, dict(ind=itemlist), where every item in itemlist contains the event. convert_xunits(x)[source] Convert x using the unit type of the xaxis. If the artist is not in contained in an Axes or if the xaxis does not have units, x itself is returned. convert_yunits(y)[source] Convert y using the unit type of the yaxis. If the artist is not in contained in an Axes or if the yaxis does not have units, y itself is returned. draw(renderer)[source] Draw the Artist (and its children) using the given renderer. This has no effect if the artist is not visible (Artist.get_visible returns False). Parameters rendererRendererBase subclass. Notes This method is overridden in the Artist subclasses. findobj(match=None, include_self=True)[source] Find artist objects. Recursively find all Artist instances contained in the artist. Parameters match A filter criterion for the matches. This can be None: Return all objects contained in artist. A function with signature def match(artist: Artist) -> bool. The result will only contain artists for which the function returns True. A class instance: e.g., Line2D. The result will only contain artists of this class or its subclasses (isinstance check). include_selfbool Include self in the list to be checked for a match. Returns list of Artist format_cursor_data(data)[source] Return a string representation of data. Note This method is intended to be overridden by artist subclasses. As an end-user of Matplotlib you will most likely not call this method yourself. The default implementation converts ints and floats and arrays of ints and floats into a comma-separated string enclosed in square brackets, unless the artist has an associated colorbar, in which case scalar values are formatted using the colorbar's formatter. See also get_cursor_data get_agg_filter()[source] Return filter function to be used for agg filter. get_alpha()[source] Return the alpha value used for blending - not supported on all backends. get_animated()[source] Return whether the artist is animated. get_array()[source] Return the array of values, that are mapped to colors. The base class ScalarMappable does not make any assumptions on the dimensionality and shape of the array. get_capstyle()[source] get_children()[source] Return a list of the child Artists of this Artist. get_clim()[source] Return the values (min, max) that are mapped to the colormap limits. get_clip_box()[source] Return the clipbox. get_clip_on()[source] Return whether the artist uses", "score": "0.48990315"}, {"id": "32396", "text": "Function: matplotlib._as_gen.mpl_toolkits.mplot3d.art3d.pathpatch3d\nSnippet: mpl_toolkits.mplot3d.art3d.PathPatch3D classmpl_toolkits.mplot3d.art3d.PathPatch3D(path, *, zs=(), zdir='z', **kwargs)[source] Bases: mpl_toolkits.mplot3d.art3d.Patch3D 3D PathPatch object. The following kwarg properties are supported Property Description agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha unknown animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float do_3d_projection(renderer=<deprecated parameter>)[source] set(*, agg_filter=<UNSET>, alpha=<UNSET>, animated=<UNSET>, antialiased=<UNSET>, capstyle=<UNSET>, clip_box=<UNSET>, clip_on=<UNSET>, clip_path=<UNSET>, color=<UNSET>, edgecolor=<UNSET>, facecolor=<UNSET>, fill=<UNSET>, gid=<UNSET>, hatch=<UNSET>, in_layout=<UNSET>, joinstyle=<UNSET>, label=<UNSET>, linestyle=<UNSET>, linewidth=<UNSET>, path_effects=<UNSET>, picker=<UNSET>, rasterized=<UNSET>, sketch_params=<UNSET>, snap=<UNSET>, transform=<UNSET>, url=<UNSET>, visible=<UNSET>, zorder=<UNSET>)[source] Set multiple properties at once. Supported properties are Property Description 3d_properties unknown agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha scalar or None animated bool antialiased or aa bool or None capstyle CapStyle or {'butt', 'projecting', 'round'} clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color color edgecolor or ec color or None facecolor or fc color or None figure Figure fill bool gid str hatch {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} in_layout bool joinstyle JoinStyle or {'miter', 'round', 'bevel'} label object linestyle or ls {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw float or None path_effects AbstractPathEffect picker None or bool or float or callable rasterized bool sketch_params (scale: float, length: float, randomness: float) snap bool or None transform Transform url str visible bool zorder float set_3d_properties(path, zs=0, zdir='z')[source] Examples using mpl_toolkits.mplot3d.art3d.PathPatch3D Draw flat objects in 3D plot", "score": "0.4897412"}]}
{"task_id": "humaneval_158", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n", "entry_point": "find_max", "gold_generation": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n", "context": "Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"", "function_name": "def find_max(words):", "ctxs": [{"id": "21837", "text": "Function: python.library.functions#max\nSnippet: max(iterable, *[, key, default]) max(arg1, arg2, *args[, key]) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). New in version 3.4: The default keyword-only argument. Changed in version 3.8: The key can be None.", "score": "0.7570113"}, {"id": "42688", "text": "Function: numpy.reference.generated.numpy.char.chararray\nSnippet: same data with a new shape. resize(new_shape[, refcheck]) Change shape and size of array in-place. rfind(sub[, start, end]) For each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. rindex(sub[, start, end]) Like rfind, but raises ValueError when the substring sub is not found. rjust(width[, fillchar]) Return an array with the elements of self right-justified in a string of length width. rsplit([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. rstrip([chars]) For each element in self, return a copy with the trailing characters removed. searchsorted(v[, side, sorter]) Find indices where elements of v should be inserted in a to maintain order. setfield(val, dtype[, offset]) Put a value into a specified place in a field defined by a data-type. setflags([write, align, uic]) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. sort([axis, kind, order]) Sort an array in-place. split([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. splitlines([keepends]) For each element in self, return a list of the lines in the element, breaking at line boundaries. squeeze([axis]) Remove axes of length one from a. startswith(prefix[, start, end]) Returns a boolean array which is True where the string element in self starts with prefix, otherwise False. strip([chars]) For each element in self, return a copy with the leading and trailing characters removed. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. swapcase() For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. title() For each element in self, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. translate(table[, deletechars]) For each element in self, return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table. transpose(*axes) Returns a view of the array with axes transposed. upper() Return an array with the elements of self converted to uppercase. view([dtype][, type]) New view of array with the same data. zfill(width) Return the numeric string left-filled with zeros in a string of length width.", "score": "0.71850026"}, {"id": "42691", "text": "Function: numpy.reference.generated.numpy.chararray\nSnippet: same data with a new shape. resize(new_shape[, refcheck]) Change shape and size of array in-place. rfind(sub[, start, end]) For each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]. rindex(sub[, start, end]) Like rfind, but raises ValueError when the substring sub is not found. rjust(width[, fillchar]) Return an array with the elements of self right-justified in a string of length width. rsplit([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. rstrip([chars]) For each element in self, return a copy with the trailing characters removed. searchsorted(v[, side, sorter]) Find indices where elements of v should be inserted in a to maintain order. setfield(val, dtype[, offset]) Put a value into a specified place in a field defined by a data-type. setflags([write, align, uic]) Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively. sort([axis, kind, order]) Sort an array in-place. split([sep, maxsplit]) For each element in self, return a list of the words in the string, using sep as the delimiter string. splitlines([keepends]) For each element in self, return a list of the lines in the element, breaking at line boundaries. squeeze([axis]) Remove axes of length one from a. startswith(prefix[, start, end]) Returns a boolean array which is True where the string element in self starts with prefix, otherwise False. strip([chars]) For each element in self, return a copy with the leading and trailing characters removed. swapaxes(axis1, axis2) Return a view of the array with axis1 and axis2 interchanged. swapcase() For each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa. take(indices[, axis, out, mode]) Return an array formed from the elements of a at the given indices. title() For each element in self, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase. tofile(fid[, sep, format]) Write array to a file as text or binary (default). tolist() Return the array as an a.ndim-levels deep nested list of Python scalars. tostring([order]) A compatibility alias for tobytes, with exactly the same behavior. translate(table[, deletechars]) For each element in self, return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table. transpose(*axes) Returns a view of the array with axes transposed. upper() Return an array with the elements of self converted to uppercase. view([dtype][, type]) New view of array with the same data. zfill(width) Return the numeric string left-filled with zeros in a string of length width.", "score": "0.7161251"}, {"id": "41724", "text": "Function: numpy.reference.generated.numpy.char.find\nSnippet: numpy.char.find char.find(a, sub, start=0, end=None)[source] For each element, return the lowest index in the string where substring sub is found. Calls str.find element-wise. For each element, return the lowest index in the string where substring sub is found, such that sub is contained in the range [start, end]. Parameters aarray_like of str or unicode substr or unicode start, endint, optional Optional arguments start and end are interpreted as in slice notation. Returns outndarray or int Output array of ints. Returns -1 if sub is not found. See also str.find", "score": "0.71596783"}, {"id": "19634", "text": "Function: python.library.difflib#difflib.get_close_matches\nSnippet: difflib.get_close_matches(word, possibilities, n=3, cutoff=0.6) Return a list of the best “good enough” matches. word is a sequence for which close matches are desired (typically a string), and possibilities is a list of sequences against which to match word (typically a list of strings). Optional argument n (default 3) is the maximum number of close matches to return; n must be greater than 0. Optional argument cutoff (default 0.6) is a float in the range [0, 1]. Possibilities that don’t score at least that similar to word are ignored. The best (no more than n) matches among the possibilities are returned in a list, sorted by similarity score, most similar first. >>> get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy']) ['apple', 'ape'] >>> import keyword >>> get_close_matches('wheel', keyword.kwlist) ['while'] >>> get_close_matches('pineapple', keyword.kwlist) [] >>> get_close_matches('accept', keyword.kwlist) ['except']", "score": "0.71459156"}]}
{"task_id": "humaneval_159", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n", "entry_point": "eat", "gold_generation": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n", "context": "You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)", "function_name": "def eat(number, need, remaining):", "ctxs": [{"id": "21296", "text": "Function: python.library.itertools\nSnippet: D E B F C\" # Recipe credited to George Sakkis num_active = len(iterables) nexts = cycle(iter(it).__next__ for it in iterables) while num_active: try: for next in nexts: yield next() except StopIteration: # Remove the iterator we just exhausted from the cycle. num_active -= 1 nexts = cycle(islice(nexts, num_active)) def partition(pred, iterable): \"Use a predicate to partition entries into false entries and true entries\" # partition(is_odd, range(10)) --> 0 2 4 6 8 and 1 3 5 7 9 t1, t2 = tee(iterable) return filterfalse(pred, t1), filter(pred, t2) def powerset(iterable): \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\" s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s)+1)) def unique_everseen(iterable, key=None): \"List unique elements, preserving order. Remember all elements ever seen.\" # unique_everseen('AAAABBBCCDAABBB') --> A B C D # unique_everseen('ABBCcAD', str.lower) --> A B C D seen = set() seen_add = seen.add if key is None: for element in filterfalse(seen.__contains__, iterable): seen_add(element) yield element else: for element in iterable: k = key(element) if k not in seen: seen_add(k) yield element def unique_justseen(iterable, key=None): \"List unique elements, preserving order. Remember only the element just seen.\" # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B # unique_justseen('ABBCcAD', str.lower) --> A B C A D return map(next, map(operator.itemgetter(1), groupby(iterable, key))) def iter_except(func, exception, first=None): \"\"\" Call a function repeatedly until an exception is raised. Converts a call-until-exception interface to an iterator interface. Like builtins.iter(func, sentinel) but uses an exception instead of a sentinel to end the loop. Examples: iter_except(functools.partial(heappop, h), IndexError) # priority queue iterator iter_except(d.popitem, KeyError) # non-blocking dict iterator iter_except(d.popleft, IndexError) # non-blocking deque iterator iter_except(q.get_nowait, Queue.Empty) # loop over a producer Queue iter_except(s.pop, KeyError) # non-blocking set iterator \"\"\" try: if first is not None: yield first() # For database APIs needing an initial cast to db.first() while True: yield func() except exception: pass def first_true(iterable, default=False, pred=None): \"\"\"Returns the first true value in the iterable. If no true value is found, returns *default* If *pred* is not None, returns the first item for which pred(item) is true. \"\"\" # first_true([a,b,c], x) --> a or b or c or x # first_true([a,b], x, f) --> a if f(a) else b if f(b) else x return next(filter(pred, iterable), default) def random_product(*args, repeat=1): \"Random selection from itertools.product(*args, **kwds)\" pools = [tuple(pool) for pool in args] * repeat return tuple(map(random.choice, pools)) def random_permutation(iterable, r=None): \"Random selection from itertools.permutations(iterable, r)\" pool = tuple(iterable) r = len(pool) if r is None else r return tuple(random.sample(pool, r)) def random_combination(iterable, r): \"Random selection from itertools.combinations(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.sample(range(n), r)) return tuple(pool[i] for i in indices) def random_combination_with_replacement(iterable, r): \"Random selection from itertools.combinations_with_replacement(iterable, r)\" pool = tuple(iterable) n = len(pool) indices = sorted(random.choices(range(n), k=r)) return tuple(pool[i] for i in indices) def nth_combination(iterable, r, index): \"Equivalent to list(combinations(iterable, r))[index]\" pool = tuple(iterable) n = len(pool) if r < 0 or r > n: raise ValueError c = 1 k = min(r, n-r) for i in range(1, k+1): c = c", "score": "0.6347332"}, {"id": "25634", "text": "Function: python.library.turtle#turtle.filling\nSnippet: turtle.filling() Return fillstate (True if filling, False else). >>> turtle.begin_fill() >>> if turtle.filling(): ... turtle.pensize(5) ... else: ... turtle.pensize(3)", "score": "0.6331744"}, {"id": "41291", "text": "Function: django.ref.utils#django.utils.feedgenerator.SyndicationFeed.num_items\nSnippet: num_items()", "score": "0.63189375"}, {"id": "21823", "text": "Function: python.library.math#math.perm\nSnippet: math.perm(n, k=None) Return the number of ways to choose k items from n items without repetition and with order. Evaluates to n! / (n - k)! when k <= n and evaluates to zero when k > n. If k is not specified or is None, then k defaults to n and the function returns n!. Raises TypeError if either of the arguments are not integers. Raises ValueError if either of the arguments are negative. New in version 3.8.", "score": "0.6300484"}, {"id": "1558", "text": "Function: tensorflow.data.experimental.csvdataset\nSnippet: list(dataset.as_numpy_iterator()) # doctest: +SKIP [0, 1, 2, 3, 4] Note: cache will produce exactly the same elements during each iteration through the dataset. If you wish to randomize the iteration order, make sure to call shuffle after calling cache. Args filename A tf.string scalar tf.Tensor, representing the name of a directory on the filesystem to use for caching elements in this Dataset. If a filename is not provided, the dataset will be cached in memory. Returns Dataset A Dataset. cardinality View source cardinality() Returns the cardinality of the dataset, if known. cardinality may return tf.data.INFINITE_CARDINALITY if the dataset contains an infinite number of elements or tf.data.UNKNOWN_CARDINALITY if the analysis fails to determine the number of elements in the dataset (e.g. when the dataset source is a file). dataset = tf.data.Dataset.range(42) print(dataset.cardinality().numpy()) 42 dataset = dataset.repeat() cardinality = dataset.cardinality() print((cardinality == tf.data.INFINITE_CARDINALITY).numpy()) True dataset = dataset.filter(lambda x: True) cardinality = dataset.cardinality() print((cardinality == tf.data.UNKNOWN_CARDINALITY).numpy()) True Returns A scalar tf.int64 Tensor representing the cardinality of the dataset. If the cardinality is infinite or unknown, cardinality returns the named constants tf.data.INFINITE_CARDINALITY and tf.data.UNKNOWN_CARDINALITY respectively. concatenate View source concatenate( dataset ) Creates a Dataset by concatenating the given dataset with this dataset. a = tf.data.Dataset.range(1, 4) # ==> [ 1, 2, 3 ] b = tf.data.Dataset.range(4, 8) # ==> [ 4, 5, 6, 7 ] ds = a.concatenate(b) list(ds.as_numpy_iterator()) [1, 2, 3, 4, 5, 6, 7] # The input dataset and dataset to be concatenated should have the same # nested structures and output types. c = tf.data.Dataset.zip((a, b)) a.concatenate(c) Traceback (most recent call last): TypeError: Two datasets to concatenate have different types <dtype: 'int64'> and (tf.int64, tf.int64) d = tf.data.Dataset.from_tensor_slices([\"a\", \"b\", \"c\"]) a.concatenate(d) Traceback (most recent call last): TypeError: Two datasets to concatenate have different types <dtype: 'int64'> and <dtype: 'string'> Args dataset Dataset to be concatenated. Returns Dataset A Dataset. enumerate View source enumerate( start=0 ) Enumerates the elements of this dataset. It is similar to python's enumerate. dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3]) dataset = dataset.enumerate(start=5) for element in dataset.as_numpy_iterator(): print(element) (5, 1) (6, 2) (7, 3) # The nested structure of the input dataset determines the structure of # elements in the resulting dataset. dataset = tf.data.Dataset.from_tensor_slices([(7, 8), (9, 10)]) dataset = dataset.enumerate() for element in dataset.as_numpy_iterator(): print(element) (0, array([7, 8], dtype=int32)) (1, array([ 9, 10], dtype=int32)) Args start A tf.int64 scalar tf.Tensor, representing the start value for enumeration. Returns Dataset A Dataset. filter View source filter( predicate ) Filters this dataset according to predicate. dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3]) dataset = dataset.filter(lambda x: x < 3) list(dataset.as_numpy_iterator()) [1, 2] # `tf.math.equal(x, y)` is required for equality comparison def filter_fn(x): return tf.math.equal(x, 1) dataset = dataset.filter(filter_fn) list(dataset.as_numpy_iterator()) [1] Args predicate A function mapping a dataset element to a boolean. Returns Dataset The Dataset containing the elements of this dataset for which predicate is True. flat_map View source flat_map( map_func ) Maps map_func across this dataset and flattens the result. Use flat_map if you want to make sure that the order of", "score": "0.6296133"}]}
{"task_id": "humaneval_160", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "do_algebra", "gold_generation": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n", "context": "Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.", "function_name": "def do_algebra(operator, operand):", "ctxs": [{"id": "22301", "text": "Function: python.library.operator#operator.add\nSnippet: operator.add(a, b) operator.__add__(a, b) Return a + b, for a and b numbers.", "score": "0.7255285"}, {"id": "17687", "text": "Function: python.library.ast#ast.BinOp\nSnippet: class ast.BinOp(left, op, right) A binary operation (like addition or division). op is the operator, and left and right are any expression nodes. >>> print(ast.dump(ast.parse('x + y', mode='eval'), indent=4)) Expression( body=BinOp( left=Name(id='x', ctx=Load()), op=Add(), right=Name(id='y', ctx=Load())))", "score": "0.72109854"}, {"id": "22355", "text": "Function: python.library.operator#operator.__add__\nSnippet: operator.add(a, b) operator.__add__(a, b) Return a + b, for a and b numbers.", "score": "0.71986234"}, {"id": "22387", "text": "Function: python.library.operator#operator.__mul__\nSnippet: operator.mul(a, b) operator.__mul__(a, b) Return a * b, for a and b numbers.", "score": "0.7164191"}, {"id": "22299", "text": "Function: python.library.operator\nSnippet: 'l', 'd'] operator.iadd(a, b) operator.__iadd__(a, b) a = iadd(a, b) is equivalent to a += b. operator.iand(a, b) operator.__iand__(a, b) a = iand(a, b) is equivalent to a &= b. operator.iconcat(a, b) operator.__iconcat__(a, b) a = iconcat(a, b) is equivalent to a += b for a and b sequences. operator.ifloordiv(a, b) operator.__ifloordiv__(a, b) a = ifloordiv(a, b) is equivalent to a //= b. operator.ilshift(a, b) operator.__ilshift__(a, b) a = ilshift(a, b) is equivalent to a <<= b. operator.imod(a, b) operator.__imod__(a, b) a = imod(a, b) is equivalent to a %= b. operator.imul(a, b) operator.__imul__(a, b) a = imul(a, b) is equivalent to a *= b. operator.imatmul(a, b) operator.__imatmul__(a, b) a = imatmul(a, b) is equivalent to a @= b. New in version 3.5. operator.ior(a, b) operator.__ior__(a, b) a = ior(a, b) is equivalent to a |= b. operator.ipow(a, b) operator.__ipow__(a, b) a = ipow(a, b) is equivalent to a **= b. operator.irshift(a, b) operator.__irshift__(a, b) a = irshift(a, b) is equivalent to a >>= b. operator.isub(a, b) operator.__isub__(a, b) a = isub(a, b) is equivalent to a -= b. operator.itruediv(a, b) operator.__itruediv__(a, b) a = itruediv(a, b) is equivalent to a /= b. operator.ixor(a, b) operator.__ixor__(a, b) a = ixor(a, b) is equivalent to a ^= b.", "score": "0.71625435"}]}
{"task_id": "humaneval_161", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "entry_point": "solve", "gold_generation": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "context": "You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"", "function_name": "def solve(s):", "ctxs": [{"id": "24381", "text": "Function: python.library.stdtypes#str.swapcase\nSnippet: str.swapcase() Return a copy of the string with uppercase characters converted to lowercase and vice versa. Note that it is not necessarily true that s.swapcase().swapcase() == s.", "score": "0.74204576"}, {"id": "24340", "text": "Function: python.library.stdtypes#str.casefold\nSnippet: str.casefold() Return a casefolded copy of the string. Casefolded strings may be used for caseless matching. Casefolding is similar to lowercasing but more aggressive because it is intended to remove all case distinctions in a string. For example, the German lowercase letter 'ß' is equivalent to \"ss\". Since it is already lowercase, lower() would do nothing to 'ß'; casefold() converts it to \"ss\". The casefolding algorithm is described in section 3.13 of the Unicode Standard. New in version 3.3.", "score": "0.7355653"}, {"id": "24400", "text": "Function: python.library.string#string.ascii_lowercase\nSnippet: string.ascii_lowercase The lowercase letters 'abcdefghijklmnopqrstuvwxyz'. This value is not locale-dependent and will not change.", "score": "0.73458314"}, {"id": "15347", "text": "Function: pandas.reference.api.pandas.series.str.lower\nSnippet: pandas.Series.str.lower Series.str.lower()[source] Convert strings in the Series/Index to lowercase. Equivalent to str.lower(). Returns Series or Index of object See also Series.str.lower Converts all characters to lowercase. Series.str.upper Converts all characters to uppercase. Series.str.title Converts first character of each word to uppercase and remaining to lowercase. Series.str.capitalize Converts first character to uppercase and remaining to lowercase. Series.str.swapcase Converts uppercase to lowercase and lowercase to uppercase. Series.str.casefold Removes all case distinctions in the string. Examples >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe']) >>> s 0 lower 1 CAPITALS 2 this is a sentence 3 SwApCaSe dtype: object >>> s.str.lower() 0 lower 1 capitals 2 this is a sentence 3 swapcase dtype: object >>> s.str.upper() 0 LOWER 1 CAPITALS 2 THIS IS A SENTENCE 3 SWAPCASE dtype: object >>> s.str.title() 0 Lower 1 Capitals 2 This Is A Sentence 3 Swapcase dtype: object >>> s.str.capitalize() 0 Lower 1 Capitals 2 This is a sentence 3 Swapcase dtype: object >>> s.str.swapcase() 0 LOWER 1 capitals 2 THIS IS A SENTENCE 3 sWaPcAsE dtype: object", "score": "0.7307867"}, {"id": "24364", "text": "Function: python.library.stdtypes#str.lower\nSnippet: str.lower() Return a copy of the string with all the cased characters 4 converted to lowercase. The lowercasing algorithm used is described in section 3.13 of the Unicode Standard.", "score": "0.7277687"}]}
{"task_id": "humaneval_162", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "string_to_md5", "gold_generation": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "context": "Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'", "function_name": "def string_to_md5(text):", "ctxs": [{"id": "18869", "text": "Function: python.library.crypt#crypt.METHOD_MD5\nSnippet: crypt.METHOD_MD5 Another Modular Crypt Format method with 8 character salt and 22 character hash based on the MD5 hash function.", "score": "0.7073421"}, {"id": "3174", "text": "Function: tensorflow.keras.preprocessing.text.hashing_trick\nSnippet: tf.keras.preprocessing.text.hashing_trick View source on GitHub Converts a text to a sequence of indexes in a fixed-size hashing space. View aliases Compat aliases for migration See Migration guide for more details. tf.compat.v1.keras.preprocessing.text.hashing_trick tf.keras.preprocessing.text.hashing_trick( text, n, hash_function=None, filters='!\"#$%&()*+,-./:;<=>?@[\\\\]^_`{|}~\\t\\n', lower=True, split=' ' ) Arguments text Input text (string). n Dimension of the hashing space. hash_function defaults to python hash function, can be 'md5' or any function that takes in input a string and returns a int. Note that 'hash' is not a stable hashing function, so it is not consistent across different runs, while 'md5' is a stable hashing function. filters list (or concatenation) of characters to filter out, such as punctuation. Default: !\"#$%&()*+,-./:;<=>?@[\\]^_`{|}~\\t\\n, includes basic punctuation, tabs, and newlines. lower boolean. Whether to set the text to lowercase. split str. Separator for word splitting. Returns A list of integer word indices (unicity non-guaranteed). 0 is a reserved index that won't be assigned to any word. Two or more words may be assigned to the same index, due to possible collisions by the hashing function. The probability of a collision is in relation to the dimension of the hashing space and the number of distinct objects.", "score": "0.6815095"}, {"id": "1248", "text": "Function: tensorflow.compat.v1.string_to_hash_bucket\nSnippet: tf.compat.v1.string_to_hash_bucket Converts each string in the input Tensor to its hash mod by a number of buckets. View aliases Compat aliases for migration See Migration guide for more details. tf.compat.v1.strings.to_hash_bucket tf.compat.v1.string_to_hash_bucket( string_tensor=None, num_buckets=None, name=None, input=None ) The hash function is deterministic on the content of the string within the process. Note that the hash function may change from time to time. This functionality will be deprecated and it's recommended to use tf.string_to_hash_bucket_fast() or tf.string_to_hash_bucket_strong(). Args string_tensor A Tensor of type string. num_buckets An int that is >= 1. The number of buckets. name A name for the operation (optional). Returns A Tensor of type int64.", "score": "0.67676365"}, {"id": "26205", "text": "Function: python.library.urllib.parse#urllib.parse.unquote_to_bytes\nSnippet: urllib.parse.unquote_to_bytes(string) Replace %xx escapes with their single-octet equivalent, and return a bytes object. string may be either a str or a bytes object. If it is a str, unescaped non-ASCII characters in string are encoded into UTF-8 bytes. Example: unquote_to_bytes('a%26%EF') yields b'a&\\xef'.", "score": "0.6766442"}, {"id": "20469", "text": "Function: python.library.hashlib#hashlib.hash.hexdigest\nSnippet: hash.hexdigest() Like digest() except the digest is returned as a string object of double length, containing only hexadecimal digits. This may be used to exchange the value safely in email or other non-binary environments.", "score": "0.67212784"}]}
{"task_id": "humaneval_163", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "generate_integers", "gold_generation": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "context": "Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []", "function_name": "def generate_integers(a, b):", "ctxs": [{"id": "43669", "text": "Function: numpy.reference.random.generated.numpy.random.generator.integers\nSnippet: numpy.random.Generator.integers method random.Generator.integers(low, high=None, size=None, dtype=np.int64, endpoint=False) Return random integers from low (inclusive) to high (exclusive), or if endpoint=True, low (inclusive) to high (inclusive). Replaces RandomState.randint (with endpoint=False) and RandomState.random_integers (with endpoint=True) Return random integers from the “discrete uniform” distribution of the specified dtype. If high is None (the default), then results are from 0 to low. Parameters lowint or array-like of ints Lowest (signed) integers to be drawn from the distribution (unless high=None, in which case this parameter is 0 and this value is used for high). highint or array-like of ints, optional If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if high=None). If array-like, must contain integer values sizeint or tuple of ints, optional Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned. dtypedtype, optional Desired dtype of the result. Byteorder must be native. The default value is np.int64. endpointbool, optional If true, sample from the interval [low, high] instead of the default [low, high) Defaults to False Returns outint or ndarray of ints size-shaped array of random integers from the appropriate distribution, or a single such random int if size not provided. Notes When using broadcasting with uint64 dtypes, the maximum value (2**64) cannot be represented as a standard integer type. The high array (or low if high is None) must have object dtype, e.g., array([2**64]). References 1 Daniel Lemire., “Fast Random Integer Generation in an Interval”, ACM Transactions on Modeling and Computer Simulation 29 (1), 2019, http://arxiv.org/abs/1805.10941. Examples >>> rng = np.random.default_rng() >>> rng.integers(2, size=10) array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random >>> rng.integers(1, size=10) array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) Generate a 2 x 4 array of ints between 0 and 4, inclusive: >>> rng.integers(5, size=(2, 4)) array([[4, 0, 2, 1], [3, 2, 2, 0]]) # random Generate a 1 x 3 array with 3 different upper bounds >>> rng.integers(1, [3, 5, 10]) array([2, 2, 9]) # random Generate a 1 by 3 array with 3 different lower bounds >>> rng.integers([1, 5, 7], 10) array([9, 8, 7]) # random Generate a 2 by 4 array using broadcasting with dtype of uint8 >>> rng.integers([1, 3, 5, 7], [[10], [20]], dtype=np.uint8) array([[ 8, 6, 9, 7], [ 1, 16, 9, 12]], dtype=uint8) # random", "score": "0.68349135"}, {"id": "19597", "text": "Function: python.library.decimal#decimal.ROUND_HALF_EVEN\nSnippet: decimal.ROUND_HALF_EVEN Round to nearest with ties going to nearest even integer.", "score": "0.6786506"}, {"id": "13035", "text": "Function: sklearn.modules.generated.sklearn.utils.gen_even_slices#sklearn.utils.gen_even_slices\nSnippet: sklearn.utils.gen_even_slices(n, n_packs, *, n_samples=None) [source] Generator to create n_packs slices going up to n. Parameters nint n_packsint Number of slices to generate. n_samplesint, default=None Number of samples. Pass n_samples when the slices are to be used for sparse matrix indexing; slicing off-the-end raises an exception, while it works for NumPy arrays. Yields slice Examples >>> from sklearn.utils import gen_even_slices >>> list(gen_even_slices(10, 1)) [slice(0, 10, None)] >>> list(gen_even_slices(10, 10)) [slice(0, 1, None), slice(1, 2, None), ..., slice(9, 10, None)] >>> list(gen_even_slices(10, 5)) [slice(0, 2, None), slice(2, 4, None), ..., slice(8, 10, None)] >>> list(gen_even_slices(10, 3)) [slice(0, 4, None), slice(4, 7, None), slice(7, 10, None)]", "score": "0.67755085"}, {"id": "19488", "text": "Function: python.library.decimal#decimal.Context.logical_or\nSnippet: logical_or(x, y) Applies the logical operation or between each operand’s digits.", "score": "0.6765881"}, {"id": "19523", "text": "Function: python.library.decimal#decimal.Decimal.as_integer_ratio\nSnippet: as_integer_ratio() Return a pair (n, d) of integers that represent the given Decimal instance as a fraction, in lowest terms and with a positive denominator: >>> Decimal('-3.14').as_integer_ratio() (-157, 50) The conversion is exact. Raise OverflowError on infinities and ValueError on NaNs.", "score": "0.6749396"}]}
